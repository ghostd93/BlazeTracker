import * as __WEBPACK_EXTERNAL_MODULE__lib_dialog_polyfill_esm_js_9270c0ae__ from "../../../../../lib/dialog-polyfill.esm.js";
import * as __WEBPACK_EXTERNAL_MODULE__script_js_588e7203__ from "../../../../../script.js";
import * as __WEBPACK_EXTERNAL_MODULE__authors_note_js_59167e8d__ from "../../../../authors-note.js";
import * as __WEBPACK_EXTERNAL_MODULE__chats_js_c244506c__ from "../../../../chats.js";
import * as __WEBPACK_EXTERNAL_MODULE__group_chats_js_678c16bd__ from "../../../../group-chats.js";
import * as __WEBPACK_EXTERNAL_MODULE__instruct_mode_js_e7f3531a__ from "../../../../instruct-mode.js";
import * as __WEBPACK_EXTERNAL_MODULE__openai_js_bf183548__ from "../../../../openai.js";
import * as __WEBPACK_EXTERNAL_MODULE__personas_js_44397477__ from "../../../../personas.js";
import * as __WEBPACK_EXTERNAL_MODULE__popup_js_755810aa__ from "../../../../popup.js";
import * as __WEBPACK_EXTERNAL_MODULE__power_user_js_3c7cfb8b__ from "../../../../power-user.js";
import * as __WEBPACK_EXTERNAL_MODULE__slash_commands_js_f5742a84__ from "../../../../slash-commands.js";
import * as __WEBPACK_EXTERNAL_MODULE__slash_commands_SlashCommandCommonEnumsProvider_js_4453b111__ from "../../../../slash-commands/SlashCommandCommonEnumsProvider.js";
import * as __WEBPACK_EXTERNAL_MODULE__slash_commands_SlashCommandEnumValue_js_20f1c506__ from "../../../../slash-commands/SlashCommandEnumValue.js";
import * as __WEBPACK_EXTERNAL_MODULE__utils_js_d605cabe__ from "../../../../utils.js";
import * as __WEBPACK_EXTERNAL_MODULE__world_info_js_83198f57__ from "../../../../world-info.js";
import * as __WEBPACK_EXTERNAL_MODULE__regex_engine_js_683beba0__ from "../../../regex/engine.js";
/******/ var __webpack_modules__ = ({

/***/ "../../../../../lib/dialog-polyfill.esm.js"
/*!************************************************************!*\
  !*** external "../../../../../lib/dialog-polyfill.esm.js" ***!
  \************************************************************/
(module) {

module.exports = __WEBPACK_EXTERNAL_MODULE__lib_dialog_polyfill_esm_js_9270c0ae__;

/***/ },

/***/ "../../../../../script.js"
/*!*******************************************!*\
  !*** external "../../../../../script.js" ***!
  \*******************************************/
(module) {

module.exports = __WEBPACK_EXTERNAL_MODULE__script_js_588e7203__;

/***/ },

/***/ "../../../../authors-note.js"
/*!**********************************************!*\
  !*** external "../../../../authors-note.js" ***!
  \**********************************************/
(module) {

module.exports = __WEBPACK_EXTERNAL_MODULE__authors_note_js_59167e8d__;

/***/ },

/***/ "../../../../chats.js"
/*!***************************************!*\
  !*** external "../../../../chats.js" ***!
  \***************************************/
(module) {

module.exports = __WEBPACK_EXTERNAL_MODULE__chats_js_c244506c__;

/***/ },

/***/ "../../../../group-chats.js"
/*!*********************************************!*\
  !*** external "../../../../group-chats.js" ***!
  \*********************************************/
(module) {

module.exports = __WEBPACK_EXTERNAL_MODULE__group_chats_js_678c16bd__;

/***/ },

/***/ "../../../../instruct-mode.js"
/*!***********************************************!*\
  !*** external "../../../../instruct-mode.js" ***!
  \***********************************************/
(module) {

module.exports = __WEBPACK_EXTERNAL_MODULE__instruct_mode_js_e7f3531a__;

/***/ },

/***/ "../../../../openai.js"
/*!****************************************!*\
  !*** external "../../../../openai.js" ***!
  \****************************************/
(module) {

module.exports = __WEBPACK_EXTERNAL_MODULE__openai_js_bf183548__;

/***/ },

/***/ "../../../../personas.js"
/*!******************************************!*\
  !*** external "../../../../personas.js" ***!
  \******************************************/
(module) {

module.exports = __WEBPACK_EXTERNAL_MODULE__personas_js_44397477__;

/***/ },

/***/ "../../../../popup.js"
/*!***************************************!*\
  !*** external "../../../../popup.js" ***!
  \***************************************/
(module) {

module.exports = __WEBPACK_EXTERNAL_MODULE__popup_js_755810aa__;

/***/ },

/***/ "../../../../power-user.js"
/*!********************************************!*\
  !*** external "../../../../power-user.js" ***!
  \********************************************/
(module) {

module.exports = __WEBPACK_EXTERNAL_MODULE__power_user_js_3c7cfb8b__;

/***/ },

/***/ "../../../../slash-commands.js"
/*!************************************************!*\
  !*** external "../../../../slash-commands.js" ***!
  \************************************************/
(module) {

module.exports = __WEBPACK_EXTERNAL_MODULE__slash_commands_js_f5742a84__;

/***/ },

/***/ "../../../../slash-commands/SlashCommandCommonEnumsProvider.js"
/*!********************************************************************************!*\
  !*** external "../../../../slash-commands/SlashCommandCommonEnumsProvider.js" ***!
  \********************************************************************************/
(module) {

module.exports = __WEBPACK_EXTERNAL_MODULE__slash_commands_SlashCommandCommonEnumsProvider_js_4453b111__;

/***/ },

/***/ "../../../../slash-commands/SlashCommandEnumValue.js"
/*!**********************************************************************!*\
  !*** external "../../../../slash-commands/SlashCommandEnumValue.js" ***!
  \**********************************************************************/
(module) {

module.exports = __WEBPACK_EXTERNAL_MODULE__slash_commands_SlashCommandEnumValue_js_20f1c506__;

/***/ },

/***/ "../../../../utils.js"
/*!***************************************!*\
  !*** external "../../../../utils.js" ***!
  \***************************************/
(module) {

module.exports = __WEBPACK_EXTERNAL_MODULE__utils_js_d605cabe__;

/***/ },

/***/ "../../../../world-info.js"
/*!********************************************!*\
  !*** external "../../../../world-info.js" ***!
  \********************************************/
(module) {

module.exports = __WEBPACK_EXTERNAL_MODULE__world_info_js_83198f57__;

/***/ },

/***/ "../../../regex/engine.js"
/*!*******************************************!*\
  !*** external "../../../regex/engine.js" ***!
  \*******************************************/
(module) {

module.exports = __WEBPACK_EXTERNAL_MODULE__regex_engine_js_683beba0__;

/***/ },

/***/ "./node_modules/fuse.js/dist/fuse.mjs"
/*!********************************************!*\
  !*** ./node_modules/fuse.js/dist/fuse.mjs ***!
  \********************************************/
(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ Fuse)
/* harmony export */ });
/**
 * Fuse.js v7.1.0 - Lightweight fuzzy-search (http://fusejs.io)
 *
 * Copyright (c) 2025 Kiro Risk (http://kiro.me)
 * All Rights Reserved. Apache Software License 2.0
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 */

function isArray(value) {
  return !Array.isArray
    ? getTag(value) === '[object Array]'
    : Array.isArray(value)
}

// Adapted from: https://github.com/lodash/lodash/blob/master/.internal/baseToString.js
const INFINITY = 1 / 0;
function baseToString(value) {
  // Exit early for strings to avoid a performance hit in some environments.
  if (typeof value == 'string') {
    return value
  }
  let result = value + '';
  return result == '0' && 1 / value == -INFINITY ? '-0' : result
}

function toString(value) {
  return value == null ? '' : baseToString(value)
}

function isString(value) {
  return typeof value === 'string'
}

function isNumber(value) {
  return typeof value === 'number'
}

// Adapted from: https://github.com/lodash/lodash/blob/master/isBoolean.js
function isBoolean(value) {
  return (
    value === true ||
    value === false ||
    (isObjectLike(value) && getTag(value) == '[object Boolean]')
  )
}

function isObject(value) {
  return typeof value === 'object'
}

// Checks if `value` is object-like.
function isObjectLike(value) {
  return isObject(value) && value !== null
}

function isDefined(value) {
  return value !== undefined && value !== null
}

function isBlank(value) {
  return !value.trim().length
}

// Gets the `toStringTag` of `value`.
// Adapted from: https://github.com/lodash/lodash/blob/master/.internal/getTag.js
function getTag(value) {
  return value == null
    ? value === undefined
      ? '[object Undefined]'
      : '[object Null]'
    : Object.prototype.toString.call(value)
}

const EXTENDED_SEARCH_UNAVAILABLE = 'Extended search is not available';

const INCORRECT_INDEX_TYPE = "Incorrect 'index' type";

const LOGICAL_SEARCH_INVALID_QUERY_FOR_KEY = (key) =>
  `Invalid value for key ${key}`;

const PATTERN_LENGTH_TOO_LARGE = (max) =>
  `Pattern length exceeds max of ${max}.`;

const MISSING_KEY_PROPERTY = (name) => `Missing ${name} property in key`;

const INVALID_KEY_WEIGHT_VALUE = (key) =>
  `Property 'weight' in key '${key}' must be a positive integer`;

const hasOwn = Object.prototype.hasOwnProperty;

class KeyStore {
  constructor(keys) {
    this._keys = [];
    this._keyMap = {};

    let totalWeight = 0;

    keys.forEach((key) => {
      let obj = createKey(key);

      this._keys.push(obj);
      this._keyMap[obj.id] = obj;

      totalWeight += obj.weight;
    });

    // Normalize weights so that their sum is equal to 1
    this._keys.forEach((key) => {
      key.weight /= totalWeight;
    });
  }
  get(keyId) {
    return this._keyMap[keyId]
  }
  keys() {
    return this._keys
  }
  toJSON() {
    return JSON.stringify(this._keys)
  }
}

function createKey(key) {
  let path = null;
  let id = null;
  let src = null;
  let weight = 1;
  let getFn = null;

  if (isString(key) || isArray(key)) {
    src = key;
    path = createKeyPath(key);
    id = createKeyId(key);
  } else {
    if (!hasOwn.call(key, 'name')) {
      throw new Error(MISSING_KEY_PROPERTY('name'))
    }

    const name = key.name;
    src = name;

    if (hasOwn.call(key, 'weight')) {
      weight = key.weight;

      if (weight <= 0) {
        throw new Error(INVALID_KEY_WEIGHT_VALUE(name))
      }
    }

    path = createKeyPath(name);
    id = createKeyId(name);
    getFn = key.getFn;
  }

  return { path, id, weight, src, getFn }
}

function createKeyPath(key) {
  return isArray(key) ? key : key.split('.')
}

function createKeyId(key) {
  return isArray(key) ? key.join('.') : key
}

function get(obj, path) {
  let list = [];
  let arr = false;

  const deepGet = (obj, path, index) => {
    if (!isDefined(obj)) {
      return
    }
    if (!path[index]) {
      // If there's no path left, we've arrived at the object we care about.
      list.push(obj);
    } else {
      let key = path[index];

      const value = obj[key];

      if (!isDefined(value)) {
        return
      }

      // If we're at the last value in the path, and if it's a string/number/bool,
      // add it to the list
      if (
        index === path.length - 1 &&
        (isString(value) || isNumber(value) || isBoolean(value))
      ) {
        list.push(toString(value));
      } else if (isArray(value)) {
        arr = true;
        // Search each item in the array.
        for (let i = 0, len = value.length; i < len; i += 1) {
          deepGet(value[i], path, index + 1);
        }
      } else if (path.length) {
        // An object. Recurse further.
        deepGet(value, path, index + 1);
      }
    }
  };

  // Backwards compatibility (since path used to be a string)
  deepGet(obj, isString(path) ? path.split('.') : path, 0);

  return arr ? list : list[0]
}

const MatchOptions = {
  // Whether the matches should be included in the result set. When `true`, each record in the result
  // set will include the indices of the matched characters.
  // These can consequently be used for highlighting purposes.
  includeMatches: false,
  // When `true`, the matching function will continue to the end of a search pattern even if
  // a perfect match has already been located in the string.
  findAllMatches: false,
  // Minimum number of characters that must be matched before a result is considered a match
  minMatchCharLength: 1
};

const BasicOptions = {
  // When `true`, the algorithm continues searching to the end of the input even if a perfect
  // match is found before the end of the same input.
  isCaseSensitive: false,
  // When `true`, the algorithm will ignore diacritics (accents) in comparisons
  ignoreDiacritics: false,
  // When true, the matching function will continue to the end of a search pattern even if
  includeScore: false,
  // List of properties that will be searched. This also supports nested properties.
  keys: [],
  // Whether to sort the result list, by score
  shouldSort: true,
  // Default sort function: sort by ascending score, ascending index
  sortFn: (a, b) =>
    a.score === b.score ? (a.idx < b.idx ? -1 : 1) : a.score < b.score ? -1 : 1
};

const FuzzyOptions = {
  // Approximately where in the text is the pattern expected to be found?
  location: 0,
  // At what point does the match algorithm give up. A threshold of '0.0' requires a perfect match
  // (of both letters and location), a threshold of '1.0' would match anything.
  threshold: 0.6,
  // Determines how close the match must be to the fuzzy location (specified above).
  // An exact letter match which is 'distance' characters away from the fuzzy location
  // would score as a complete mismatch. A distance of '0' requires the match be at
  // the exact location specified, a threshold of '1000' would require a perfect match
  // to be within 800 characters of the fuzzy location to be found using a 0.8 threshold.
  distance: 100
};

const AdvancedOptions = {
  // When `true`, it enables the use of unix-like search commands
  useExtendedSearch: false,
  // The get function to use when fetching an object's properties.
  // The default will search nested paths *ie foo.bar.baz*
  getFn: get,
  // When `true`, search will ignore `location` and `distance`, so it won't matter
  // where in the string the pattern appears.
  // More info: https://fusejs.io/concepts/scoring-theory.html#fuzziness-score
  ignoreLocation: false,
  // When `true`, the calculation for the relevance score (used for sorting) will
  // ignore the field-length norm.
  // More info: https://fusejs.io/concepts/scoring-theory.html#field-length-norm
  ignoreFieldNorm: false,
  // The weight to determine how much field length norm effects scoring.
  fieldNormWeight: 1
};

var Config = {
  ...BasicOptions,
  ...MatchOptions,
  ...FuzzyOptions,
  ...AdvancedOptions
};

const SPACE = /[^ ]+/g;

// Field-length norm: the shorter the field, the higher the weight.
// Set to 3 decimals to reduce index size.
function norm(weight = 1, mantissa = 3) {
  const cache = new Map();
  const m = Math.pow(10, mantissa);

  return {
    get(value) {
      const numTokens = value.match(SPACE).length;

      if (cache.has(numTokens)) {
        return cache.get(numTokens)
      }

      // Default function is 1/sqrt(x), weight makes that variable
      const norm = 1 / Math.pow(numTokens, 0.5 * weight);

      // In place of `toFixed(mantissa)`, for faster computation
      const n = parseFloat(Math.round(norm * m) / m);

      cache.set(numTokens, n);

      return n
    },
    clear() {
      cache.clear();
    }
  }
}

class FuseIndex {
  constructor({
    getFn = Config.getFn,
    fieldNormWeight = Config.fieldNormWeight
  } = {}) {
    this.norm = norm(fieldNormWeight, 3);
    this.getFn = getFn;
    this.isCreated = false;

    this.setIndexRecords();
  }
  setSources(docs = []) {
    this.docs = docs;
  }
  setIndexRecords(records = []) {
    this.records = records;
  }
  setKeys(keys = []) {
    this.keys = keys;
    this._keysMap = {};
    keys.forEach((key, idx) => {
      this._keysMap[key.id] = idx;
    });
  }
  create() {
    if (this.isCreated || !this.docs.length) {
      return
    }

    this.isCreated = true;

    // List is Array<String>
    if (isString(this.docs[0])) {
      this.docs.forEach((doc, docIndex) => {
        this._addString(doc, docIndex);
      });
    } else {
      // List is Array<Object>
      this.docs.forEach((doc, docIndex) => {
        this._addObject(doc, docIndex);
      });
    }

    this.norm.clear();
  }
  // Adds a doc to the end of the index
  add(doc) {
    const idx = this.size();

    if (isString(doc)) {
      this._addString(doc, idx);
    } else {
      this._addObject(doc, idx);
    }
  }
  // Removes the doc at the specified index of the index
  removeAt(idx) {
    this.records.splice(idx, 1);

    // Change ref index of every subsquent doc
    for (let i = idx, len = this.size(); i < len; i += 1) {
      this.records[i].i -= 1;
    }
  }
  getValueForItemAtKeyId(item, keyId) {
    return item[this._keysMap[keyId]]
  }
  size() {
    return this.records.length
  }
  _addString(doc, docIndex) {
    if (!isDefined(doc) || isBlank(doc)) {
      return
    }

    let record = {
      v: doc,
      i: docIndex,
      n: this.norm.get(doc)
    };

    this.records.push(record);
  }
  _addObject(doc, docIndex) {
    let record = { i: docIndex, $: {} };

    // Iterate over every key (i.e, path), and fetch the value at that key
    this.keys.forEach((key, keyIndex) => {
      let value = key.getFn ? key.getFn(doc) : this.getFn(doc, key.path);

      if (!isDefined(value)) {
        return
      }

      if (isArray(value)) {
        let subRecords = [];
        const stack = [{ nestedArrIndex: -1, value }];

        while (stack.length) {
          const { nestedArrIndex, value } = stack.pop();

          if (!isDefined(value)) {
            continue
          }

          if (isString(value) && !isBlank(value)) {
            let subRecord = {
              v: value,
              i: nestedArrIndex,
              n: this.norm.get(value)
            };

            subRecords.push(subRecord);
          } else if (isArray(value)) {
            value.forEach((item, k) => {
              stack.push({
                nestedArrIndex: k,
                value: item
              });
            });
          } else ;
        }
        record.$[keyIndex] = subRecords;
      } else if (isString(value) && !isBlank(value)) {
        let subRecord = {
          v: value,
          n: this.norm.get(value)
        };

        record.$[keyIndex] = subRecord;
      }
    });

    this.records.push(record);
  }
  toJSON() {
    return {
      keys: this.keys,
      records: this.records
    }
  }
}

function createIndex(
  keys,
  docs,
  { getFn = Config.getFn, fieldNormWeight = Config.fieldNormWeight } = {}
) {
  const myIndex = new FuseIndex({ getFn, fieldNormWeight });
  myIndex.setKeys(keys.map(createKey));
  myIndex.setSources(docs);
  myIndex.create();
  return myIndex
}

function parseIndex(
  data,
  { getFn = Config.getFn, fieldNormWeight = Config.fieldNormWeight } = {}
) {
  const { keys, records } = data;
  const myIndex = new FuseIndex({ getFn, fieldNormWeight });
  myIndex.setKeys(keys);
  myIndex.setIndexRecords(records);
  return myIndex
}

function computeScore$1(
  pattern,
  {
    errors = 0,
    currentLocation = 0,
    expectedLocation = 0,
    distance = Config.distance,
    ignoreLocation = Config.ignoreLocation
  } = {}
) {
  const accuracy = errors / pattern.length;

  if (ignoreLocation) {
    return accuracy
  }

  const proximity = Math.abs(expectedLocation - currentLocation);

  if (!distance) {
    // Dodge divide by zero error.
    return proximity ? 1.0 : accuracy
  }

  return accuracy + proximity / distance
}

function convertMaskToIndices(
  matchmask = [],
  minMatchCharLength = Config.minMatchCharLength
) {
  let indices = [];
  let start = -1;
  let end = -1;
  let i = 0;

  for (let len = matchmask.length; i < len; i += 1) {
    let match = matchmask[i];
    if (match && start === -1) {
      start = i;
    } else if (!match && start !== -1) {
      end = i - 1;
      if (end - start + 1 >= minMatchCharLength) {
        indices.push([start, end]);
      }
      start = -1;
    }
  }

  // (i-1 - start) + 1 => i - start
  if (matchmask[i - 1] && i - start >= minMatchCharLength) {
    indices.push([start, i - 1]);
  }

  return indices
}

// Machine word size
const MAX_BITS = 32;

function search(
  text,
  pattern,
  patternAlphabet,
  {
    location = Config.location,
    distance = Config.distance,
    threshold = Config.threshold,
    findAllMatches = Config.findAllMatches,
    minMatchCharLength = Config.minMatchCharLength,
    includeMatches = Config.includeMatches,
    ignoreLocation = Config.ignoreLocation
  } = {}
) {
  if (pattern.length > MAX_BITS) {
    throw new Error(PATTERN_LENGTH_TOO_LARGE(MAX_BITS))
  }

  const patternLen = pattern.length;
  // Set starting location at beginning text and initialize the alphabet.
  const textLen = text.length;
  // Handle the case when location > text.length
  const expectedLocation = Math.max(0, Math.min(location, textLen));
  // Highest score beyond which we give up.
  let currentThreshold = threshold;
  // Is there a nearby exact match? (speedup)
  let bestLocation = expectedLocation;

  // Performance: only computer matches when the minMatchCharLength > 1
  // OR if `includeMatches` is true.
  const computeMatches = minMatchCharLength > 1 || includeMatches;
  // A mask of the matches, used for building the indices
  const matchMask = computeMatches ? Array(textLen) : [];

  let index;

  // Get all exact matches, here for speed up
  while ((index = text.indexOf(pattern, bestLocation)) > -1) {
    let score = computeScore$1(pattern, {
      currentLocation: index,
      expectedLocation,
      distance,
      ignoreLocation
    });

    currentThreshold = Math.min(score, currentThreshold);
    bestLocation = index + patternLen;

    if (computeMatches) {
      let i = 0;
      while (i < patternLen) {
        matchMask[index + i] = 1;
        i += 1;
      }
    }
  }

  // Reset the best location
  bestLocation = -1;

  let lastBitArr = [];
  let finalScore = 1;
  let binMax = patternLen + textLen;

  const mask = 1 << (patternLen - 1);

  for (let i = 0; i < patternLen; i += 1) {
    // Scan for the best match; each iteration allows for one more error.
    // Run a binary search to determine how far from the match location we can stray
    // at this error level.
    let binMin = 0;
    let binMid = binMax;

    while (binMin < binMid) {
      const score = computeScore$1(pattern, {
        errors: i,
        currentLocation: expectedLocation + binMid,
        expectedLocation,
        distance,
        ignoreLocation
      });

      if (score <= currentThreshold) {
        binMin = binMid;
      } else {
        binMax = binMid;
      }

      binMid = Math.floor((binMax - binMin) / 2 + binMin);
    }

    // Use the result from this iteration as the maximum for the next.
    binMax = binMid;

    let start = Math.max(1, expectedLocation - binMid + 1);
    let finish = findAllMatches
      ? textLen
      : Math.min(expectedLocation + binMid, textLen) + patternLen;

    // Initialize the bit array
    let bitArr = Array(finish + 2);

    bitArr[finish + 1] = (1 << i) - 1;

    for (let j = finish; j >= start; j -= 1) {
      let currentLocation = j - 1;
      let charMatch = patternAlphabet[text.charAt(currentLocation)];

      if (computeMatches) {
        // Speed up: quick bool to int conversion (i.e, `charMatch ? 1 : 0`)
        matchMask[currentLocation] = +!!charMatch;
      }

      // First pass: exact match
      bitArr[j] = ((bitArr[j + 1] << 1) | 1) & charMatch;

      // Subsequent passes: fuzzy match
      if (i) {
        bitArr[j] |=
          ((lastBitArr[j + 1] | lastBitArr[j]) << 1) | 1 | lastBitArr[j + 1];
      }

      if (bitArr[j] & mask) {
        finalScore = computeScore$1(pattern, {
          errors: i,
          currentLocation,
          expectedLocation,
          distance,
          ignoreLocation
        });

        // This match will almost certainly be better than any existing match.
        // But check anyway.
        if (finalScore <= currentThreshold) {
          // Indeed it is
          currentThreshold = finalScore;
          bestLocation = currentLocation;

          // Already passed `loc`, downhill from here on in.
          if (bestLocation <= expectedLocation) {
            break
          }

          // When passing `bestLocation`, don't exceed our current distance from `expectedLocation`.
          start = Math.max(1, 2 * expectedLocation - bestLocation);
        }
      }
    }

    // No hope for a (better) match at greater error levels.
    const score = computeScore$1(pattern, {
      errors: i + 1,
      currentLocation: expectedLocation,
      expectedLocation,
      distance,
      ignoreLocation
    });

    if (score > currentThreshold) {
      break
    }

    lastBitArr = bitArr;
  }

  const result = {
    isMatch: bestLocation >= 0,
    // Count exact matches (those with a score of 0) to be "almost" exact
    score: Math.max(0.001, finalScore)
  };

  if (computeMatches) {
    const indices = convertMaskToIndices(matchMask, minMatchCharLength);
    if (!indices.length) {
      result.isMatch = false;
    } else if (includeMatches) {
      result.indices = indices;
    }
  }

  return result
}

function createPatternAlphabet(pattern) {
  let mask = {};

  for (let i = 0, len = pattern.length; i < len; i += 1) {
    const char = pattern.charAt(i);
    mask[char] = (mask[char] || 0) | (1 << (len - i - 1));
  }

  return mask
}

const stripDiacritics = String.prototype.normalize
    ? ((str) => str.normalize('NFD').replace(/[\u0300-\u036F\u0483-\u0489\u0591-\u05BD\u05BF\u05C1\u05C2\u05C4\u05C5\u05C7\u0610-\u061A\u064B-\u065F\u0670\u06D6-\u06DC\u06DF-\u06E4\u06E7\u06E8\u06EA-\u06ED\u0711\u0730-\u074A\u07A6-\u07B0\u07EB-\u07F3\u07FD\u0816-\u0819\u081B-\u0823\u0825-\u0827\u0829-\u082D\u0859-\u085B\u08D3-\u08E1\u08E3-\u0903\u093A-\u093C\u093E-\u094F\u0951-\u0957\u0962\u0963\u0981-\u0983\u09BC\u09BE-\u09C4\u09C7\u09C8\u09CB-\u09CD\u09D7\u09E2\u09E3\u09FE\u0A01-\u0A03\u0A3C\u0A3E-\u0A42\u0A47\u0A48\u0A4B-\u0A4D\u0A51\u0A70\u0A71\u0A75\u0A81-\u0A83\u0ABC\u0ABE-\u0AC5\u0AC7-\u0AC9\u0ACB-\u0ACD\u0AE2\u0AE3\u0AFA-\u0AFF\u0B01-\u0B03\u0B3C\u0B3E-\u0B44\u0B47\u0B48\u0B4B-\u0B4D\u0B56\u0B57\u0B62\u0B63\u0B82\u0BBE-\u0BC2\u0BC6-\u0BC8\u0BCA-\u0BCD\u0BD7\u0C00-\u0C04\u0C3E-\u0C44\u0C46-\u0C48\u0C4A-\u0C4D\u0C55\u0C56\u0C62\u0C63\u0C81-\u0C83\u0CBC\u0CBE-\u0CC4\u0CC6-\u0CC8\u0CCA-\u0CCD\u0CD5\u0CD6\u0CE2\u0CE3\u0D00-\u0D03\u0D3B\u0D3C\u0D3E-\u0D44\u0D46-\u0D48\u0D4A-\u0D4D\u0D57\u0D62\u0D63\u0D82\u0D83\u0DCA\u0DCF-\u0DD4\u0DD6\u0DD8-\u0DDF\u0DF2\u0DF3\u0E31\u0E34-\u0E3A\u0E47-\u0E4E\u0EB1\u0EB4-\u0EB9\u0EBB\u0EBC\u0EC8-\u0ECD\u0F18\u0F19\u0F35\u0F37\u0F39\u0F3E\u0F3F\u0F71-\u0F84\u0F86\u0F87\u0F8D-\u0F97\u0F99-\u0FBC\u0FC6\u102B-\u103E\u1056-\u1059\u105E-\u1060\u1062-\u1064\u1067-\u106D\u1071-\u1074\u1082-\u108D\u108F\u109A-\u109D\u135D-\u135F\u1712-\u1714\u1732-\u1734\u1752\u1753\u1772\u1773\u17B4-\u17D3\u17DD\u180B-\u180D\u1885\u1886\u18A9\u1920-\u192B\u1930-\u193B\u1A17-\u1A1B\u1A55-\u1A5E\u1A60-\u1A7C\u1A7F\u1AB0-\u1ABE\u1B00-\u1B04\u1B34-\u1B44\u1B6B-\u1B73\u1B80-\u1B82\u1BA1-\u1BAD\u1BE6-\u1BF3\u1C24-\u1C37\u1CD0-\u1CD2\u1CD4-\u1CE8\u1CED\u1CF2-\u1CF4\u1CF7-\u1CF9\u1DC0-\u1DF9\u1DFB-\u1DFF\u20D0-\u20F0\u2CEF-\u2CF1\u2D7F\u2DE0-\u2DFF\u302A-\u302F\u3099\u309A\uA66F-\uA672\uA674-\uA67D\uA69E\uA69F\uA6F0\uA6F1\uA802\uA806\uA80B\uA823-\uA827\uA880\uA881\uA8B4-\uA8C5\uA8E0-\uA8F1\uA8FF\uA926-\uA92D\uA947-\uA953\uA980-\uA983\uA9B3-\uA9C0\uA9E5\uAA29-\uAA36\uAA43\uAA4C\uAA4D\uAA7B-\uAA7D\uAAB0\uAAB2-\uAAB4\uAAB7\uAAB8\uAABE\uAABF\uAAC1\uAAEB-\uAAEF\uAAF5\uAAF6\uABE3-\uABEA\uABEC\uABED\uFB1E\uFE00-\uFE0F\uFE20-\uFE2F]/g, ''))
    : ((str) => str);

class BitapSearch {
  constructor(
    pattern,
    {
      location = Config.location,
      threshold = Config.threshold,
      distance = Config.distance,
      includeMatches = Config.includeMatches,
      findAllMatches = Config.findAllMatches,
      minMatchCharLength = Config.minMatchCharLength,
      isCaseSensitive = Config.isCaseSensitive,
      ignoreDiacritics = Config.ignoreDiacritics,
      ignoreLocation = Config.ignoreLocation
    } = {}
  ) {
    this.options = {
      location,
      threshold,
      distance,
      includeMatches,
      findAllMatches,
      minMatchCharLength,
      isCaseSensitive,
      ignoreDiacritics,
      ignoreLocation
    };

    pattern = isCaseSensitive ? pattern : pattern.toLowerCase();
    pattern = ignoreDiacritics ? stripDiacritics(pattern) : pattern;
    this.pattern = pattern;

    this.chunks = [];

    if (!this.pattern.length) {
      return
    }

    const addChunk = (pattern, startIndex) => {
      this.chunks.push({
        pattern,
        alphabet: createPatternAlphabet(pattern),
        startIndex
      });
    };

    const len = this.pattern.length;

    if (len > MAX_BITS) {
      let i = 0;
      const remainder = len % MAX_BITS;
      const end = len - remainder;

      while (i < end) {
        addChunk(this.pattern.substr(i, MAX_BITS), i);
        i += MAX_BITS;
      }

      if (remainder) {
        const startIndex = len - MAX_BITS;
        addChunk(this.pattern.substr(startIndex), startIndex);
      }
    } else {
      addChunk(this.pattern, 0);
    }
  }

  searchIn(text) {
    const { isCaseSensitive, ignoreDiacritics, includeMatches } = this.options;

    text = isCaseSensitive ? text : text.toLowerCase();
    text = ignoreDiacritics ? stripDiacritics(text) : text;

    // Exact match
    if (this.pattern === text) {
      let result = {
        isMatch: true,
        score: 0
      };

      if (includeMatches) {
        result.indices = [[0, text.length - 1]];
      }

      return result
    }

    // Otherwise, use Bitap algorithm
    const {
      location,
      distance,
      threshold,
      findAllMatches,
      minMatchCharLength,
      ignoreLocation
    } = this.options;

    let allIndices = [];
    let totalScore = 0;
    let hasMatches = false;

    this.chunks.forEach(({ pattern, alphabet, startIndex }) => {
      const { isMatch, score, indices } = search(text, pattern, alphabet, {
        location: location + startIndex,
        distance,
        threshold,
        findAllMatches,
        minMatchCharLength,
        includeMatches,
        ignoreLocation
      });

      if (isMatch) {
        hasMatches = true;
      }

      totalScore += score;

      if (isMatch && indices) {
        allIndices = [...allIndices, ...indices];
      }
    });

    let result = {
      isMatch: hasMatches,
      score: hasMatches ? totalScore / this.chunks.length : 1
    };

    if (hasMatches && includeMatches) {
      result.indices = allIndices;
    }

    return result
  }
}

class BaseMatch {
  constructor(pattern) {
    this.pattern = pattern;
  }
  static isMultiMatch(pattern) {
    return getMatch(pattern, this.multiRegex)
  }
  static isSingleMatch(pattern) {
    return getMatch(pattern, this.singleRegex)
  }
  search(/*text*/) {}
}

function getMatch(pattern, exp) {
  const matches = pattern.match(exp);
  return matches ? matches[1] : null
}

// Token: 'file

class ExactMatch extends BaseMatch {
  constructor(pattern) {
    super(pattern);
  }
  static get type() {
    return 'exact'
  }
  static get multiRegex() {
    return /^="(.*)"$/
  }
  static get singleRegex() {
    return /^=(.*)$/
  }
  search(text) {
    const isMatch = text === this.pattern;

    return {
      isMatch,
      score: isMatch ? 0 : 1,
      indices: [0, this.pattern.length - 1]
    }
  }
}

// Token: !fire

class InverseExactMatch extends BaseMatch {
  constructor(pattern) {
    super(pattern);
  }
  static get type() {
    return 'inverse-exact'
  }
  static get multiRegex() {
    return /^!"(.*)"$/
  }
  static get singleRegex() {
    return /^!(.*)$/
  }
  search(text) {
    const index = text.indexOf(this.pattern);
    const isMatch = index === -1;

    return {
      isMatch,
      score: isMatch ? 0 : 1,
      indices: [0, text.length - 1]
    }
  }
}

// Token: ^file

class PrefixExactMatch extends BaseMatch {
  constructor(pattern) {
    super(pattern);
  }
  static get type() {
    return 'prefix-exact'
  }
  static get multiRegex() {
    return /^\^"(.*)"$/
  }
  static get singleRegex() {
    return /^\^(.*)$/
  }
  search(text) {
    const isMatch = text.startsWith(this.pattern);

    return {
      isMatch,
      score: isMatch ? 0 : 1,
      indices: [0, this.pattern.length - 1]
    }
  }
}

// Token: !^fire

class InversePrefixExactMatch extends BaseMatch {
  constructor(pattern) {
    super(pattern);
  }
  static get type() {
    return 'inverse-prefix-exact'
  }
  static get multiRegex() {
    return /^!\^"(.*)"$/
  }
  static get singleRegex() {
    return /^!\^(.*)$/
  }
  search(text) {
    const isMatch = !text.startsWith(this.pattern);

    return {
      isMatch,
      score: isMatch ? 0 : 1,
      indices: [0, text.length - 1]
    }
  }
}

// Token: .file$

class SuffixExactMatch extends BaseMatch {
  constructor(pattern) {
    super(pattern);
  }
  static get type() {
    return 'suffix-exact'
  }
  static get multiRegex() {
    return /^"(.*)"\$$/
  }
  static get singleRegex() {
    return /^(.*)\$$/
  }
  search(text) {
    const isMatch = text.endsWith(this.pattern);

    return {
      isMatch,
      score: isMatch ? 0 : 1,
      indices: [text.length - this.pattern.length, text.length - 1]
    }
  }
}

// Token: !.file$

class InverseSuffixExactMatch extends BaseMatch {
  constructor(pattern) {
    super(pattern);
  }
  static get type() {
    return 'inverse-suffix-exact'
  }
  static get multiRegex() {
    return /^!"(.*)"\$$/
  }
  static get singleRegex() {
    return /^!(.*)\$$/
  }
  search(text) {
    const isMatch = !text.endsWith(this.pattern);
    return {
      isMatch,
      score: isMatch ? 0 : 1,
      indices: [0, text.length - 1]
    }
  }
}

class FuzzyMatch extends BaseMatch {
  constructor(
    pattern,
    {
      location = Config.location,
      threshold = Config.threshold,
      distance = Config.distance,
      includeMatches = Config.includeMatches,
      findAllMatches = Config.findAllMatches,
      minMatchCharLength = Config.minMatchCharLength,
      isCaseSensitive = Config.isCaseSensitive,
      ignoreDiacritics = Config.ignoreDiacritics,
      ignoreLocation = Config.ignoreLocation
    } = {}
  ) {
    super(pattern);
    this._bitapSearch = new BitapSearch(pattern, {
      location,
      threshold,
      distance,
      includeMatches,
      findAllMatches,
      minMatchCharLength,
      isCaseSensitive,
      ignoreDiacritics,
      ignoreLocation
    });
  }
  static get type() {
    return 'fuzzy'
  }
  static get multiRegex() {
    return /^"(.*)"$/
  }
  static get singleRegex() {
    return /^(.*)$/
  }
  search(text) {
    return this._bitapSearch.searchIn(text)
  }
}

// Token: 'file

class IncludeMatch extends BaseMatch {
  constructor(pattern) {
    super(pattern);
  }
  static get type() {
    return 'include'
  }
  static get multiRegex() {
    return /^'"(.*)"$/
  }
  static get singleRegex() {
    return /^'(.*)$/
  }
  search(text) {
    let location = 0;
    let index;

    const indices = [];
    const patternLen = this.pattern.length;

    // Get all exact matches
    while ((index = text.indexOf(this.pattern, location)) > -1) {
      location = index + patternLen;
      indices.push([index, location - 1]);
    }

    const isMatch = !!indices.length;

    return {
      isMatch,
      score: isMatch ? 0 : 1,
      indices
    }
  }
}

// â—Order is important. DO NOT CHANGE.
const searchers = [
  ExactMatch,
  IncludeMatch,
  PrefixExactMatch,
  InversePrefixExactMatch,
  InverseSuffixExactMatch,
  SuffixExactMatch,
  InverseExactMatch,
  FuzzyMatch
];

const searchersLen = searchers.length;

// Regex to split by spaces, but keep anything in quotes together
const SPACE_RE = / +(?=(?:[^\"]*\"[^\"]*\")*[^\"]*$)/;
const OR_TOKEN = '|';

// Return a 2D array representation of the query, for simpler parsing.
// Example:
// "^core go$ | rb$ | py$ xy$" => [["^core", "go$"], ["rb$"], ["py$", "xy$"]]
function parseQuery(pattern, options = {}) {
  return pattern.split(OR_TOKEN).map((item) => {
    let query = item
      .trim()
      .split(SPACE_RE)
      .filter((item) => item && !!item.trim());

    let results = [];
    for (let i = 0, len = query.length; i < len; i += 1) {
      const queryItem = query[i];

      // 1. Handle multiple query match (i.e, once that are quoted, like `"hello world"`)
      let found = false;
      let idx = -1;
      while (!found && ++idx < searchersLen) {
        const searcher = searchers[idx];
        let token = searcher.isMultiMatch(queryItem);
        if (token) {
          results.push(new searcher(token, options));
          found = true;
        }
      }

      if (found) {
        continue
      }

      // 2. Handle single query matches (i.e, once that are *not* quoted)
      idx = -1;
      while (++idx < searchersLen) {
        const searcher = searchers[idx];
        let token = searcher.isSingleMatch(queryItem);
        if (token) {
          results.push(new searcher(token, options));
          break
        }
      }
    }

    return results
  })
}

// These extended matchers can return an array of matches, as opposed
// to a singl match
const MultiMatchSet = new Set([FuzzyMatch.type, IncludeMatch.type]);

/**
 * Command-like searching
 * ======================
 *
 * Given multiple search terms delimited by spaces.e.g. `^jscript .python$ ruby !java`,
 * search in a given text.
 *
 * Search syntax:
 *
 * | Token       | Match type                 | Description                            |
 * | ----------- | -------------------------- | -------------------------------------- |
 * | `jscript`   | fuzzy-match                | Items that fuzzy match `jscript`       |
 * | `=scheme`   | exact-match                | Items that are `scheme`                |
 * | `'python`   | include-match              | Items that include `python`            |
 * | `!ruby`     | inverse-exact-match        | Items that do not include `ruby`       |
 * | `^java`     | prefix-exact-match         | Items that start with `java`           |
 * | `!^earlang` | inverse-prefix-exact-match | Items that do not start with `earlang` |
 * | `.js$`      | suffix-exact-match         | Items that end with `.js`              |
 * | `!.go$`     | inverse-suffix-exact-match | Items that do not end with `.go`       |
 *
 * A single pipe character acts as an OR operator. For example, the following
 * query matches entries that start with `core` and end with either`go`, `rb`,
 * or`py`.
 *
 * ```
 * ^core go$ | rb$ | py$
 * ```
 */
class ExtendedSearch {
  constructor(
    pattern,
    {
      isCaseSensitive = Config.isCaseSensitive,
      ignoreDiacritics = Config.ignoreDiacritics,
      includeMatches = Config.includeMatches,
      minMatchCharLength = Config.minMatchCharLength,
      ignoreLocation = Config.ignoreLocation,
      findAllMatches = Config.findAllMatches,
      location = Config.location,
      threshold = Config.threshold,
      distance = Config.distance
    } = {}
  ) {
    this.query = null;
    this.options = {
      isCaseSensitive,
      ignoreDiacritics,
      includeMatches,
      minMatchCharLength,
      findAllMatches,
      ignoreLocation,
      location,
      threshold,
      distance
    };

    pattern = isCaseSensitive ? pattern : pattern.toLowerCase();
    pattern = ignoreDiacritics ? stripDiacritics(pattern) : pattern;
    this.pattern = pattern;
    this.query = parseQuery(this.pattern, this.options);
  }

  static condition(_, options) {
    return options.useExtendedSearch
  }

  searchIn(text) {
    const query = this.query;

    if (!query) {
      return {
        isMatch: false,
        score: 1
      }
    }

    const { includeMatches, isCaseSensitive, ignoreDiacritics } = this.options;

    text = isCaseSensitive ? text : text.toLowerCase();
    text = ignoreDiacritics ? stripDiacritics(text) : text;

    let numMatches = 0;
    let allIndices = [];
    let totalScore = 0;

    // ORs
    for (let i = 0, qLen = query.length; i < qLen; i += 1) {
      const searchers = query[i];

      // Reset indices
      allIndices.length = 0;
      numMatches = 0;

      // ANDs
      for (let j = 0, pLen = searchers.length; j < pLen; j += 1) {
        const searcher = searchers[j];
        const { isMatch, indices, score } = searcher.search(text);

        if (isMatch) {
          numMatches += 1;
          totalScore += score;
          if (includeMatches) {
            const type = searcher.constructor.type;
            if (MultiMatchSet.has(type)) {
              allIndices = [...allIndices, ...indices];
            } else {
              allIndices.push(indices);
            }
          }
        } else {
          totalScore = 0;
          numMatches = 0;
          allIndices.length = 0;
          break
        }
      }

      // OR condition, so if TRUE, return
      if (numMatches) {
        let result = {
          isMatch: true,
          score: totalScore / numMatches
        };

        if (includeMatches) {
          result.indices = allIndices;
        }

        return result
      }
    }

    // Nothing was matched
    return {
      isMatch: false,
      score: 1
    }
  }
}

const registeredSearchers = [];

function register(...args) {
  registeredSearchers.push(...args);
}

function createSearcher(pattern, options) {
  for (let i = 0, len = registeredSearchers.length; i < len; i += 1) {
    let searcherClass = registeredSearchers[i];
    if (searcherClass.condition(pattern, options)) {
      return new searcherClass(pattern, options)
    }
  }

  return new BitapSearch(pattern, options)
}

const LogicalOperator = {
  AND: '$and',
  OR: '$or'
};

const KeyType = {
  PATH: '$path',
  PATTERN: '$val'
};

const isExpression = (query) =>
  !!(query[LogicalOperator.AND] || query[LogicalOperator.OR]);

const isPath = (query) => !!query[KeyType.PATH];

const isLeaf = (query) =>
  !isArray(query) && isObject(query) && !isExpression(query);

const convertToExplicit = (query) => ({
  [LogicalOperator.AND]: Object.keys(query).map((key) => ({
    [key]: query[key]
  }))
});

// When `auto` is `true`, the parse function will infer and initialize and add
// the appropriate `Searcher` instance
function parse(query, options, { auto = true } = {}) {
  const next = (query) => {
    let keys = Object.keys(query);

    const isQueryPath = isPath(query);

    if (!isQueryPath && keys.length > 1 && !isExpression(query)) {
      return next(convertToExplicit(query))
    }

    if (isLeaf(query)) {
      const key = isQueryPath ? query[KeyType.PATH] : keys[0];

      const pattern = isQueryPath ? query[KeyType.PATTERN] : query[key];

      if (!isString(pattern)) {
        throw new Error(LOGICAL_SEARCH_INVALID_QUERY_FOR_KEY(key))
      }

      const obj = {
        keyId: createKeyId(key),
        pattern
      };

      if (auto) {
        obj.searcher = createSearcher(pattern, options);
      }

      return obj
    }

    let node = {
      children: [],
      operator: keys[0]
    };

    keys.forEach((key) => {
      const value = query[key];

      if (isArray(value)) {
        value.forEach((item) => {
          node.children.push(next(item));
        });
      }
    });

    return node
  };

  if (!isExpression(query)) {
    query = convertToExplicit(query);
  }

  return next(query)
}

// Practical scoring function
function computeScore(
  results,
  { ignoreFieldNorm = Config.ignoreFieldNorm }
) {
  results.forEach((result) => {
    let totalScore = 1;

    result.matches.forEach(({ key, norm, score }) => {
      const weight = key ? key.weight : null;

      totalScore *= Math.pow(
        score === 0 && weight ? Number.EPSILON : score,
        (weight || 1) * (ignoreFieldNorm ? 1 : norm)
      );
    });

    result.score = totalScore;
  });
}

function transformMatches(result, data) {
  const matches = result.matches;
  data.matches = [];

  if (!isDefined(matches)) {
    return
  }

  matches.forEach((match) => {
    if (!isDefined(match.indices) || !match.indices.length) {
      return
    }

    const { indices, value } = match;

    let obj = {
      indices,
      value
    };

    if (match.key) {
      obj.key = match.key.src;
    }

    if (match.idx > -1) {
      obj.refIndex = match.idx;
    }

    data.matches.push(obj);
  });
}

function transformScore(result, data) {
  data.score = result.score;
}

function format(
  results,
  docs,
  {
    includeMatches = Config.includeMatches,
    includeScore = Config.includeScore
  } = {}
) {
  const transformers = [];

  if (includeMatches) transformers.push(transformMatches);
  if (includeScore) transformers.push(transformScore);

  return results.map((result) => {
    const { idx } = result;

    const data = {
      item: docs[idx],
      refIndex: idx
    };

    if (transformers.length) {
      transformers.forEach((transformer) => {
        transformer(result, data);
      });
    }

    return data
  })
}

class Fuse {
  constructor(docs, options = {}, index) {
    this.options = { ...Config, ...options };

    if (
      this.options.useExtendedSearch &&
      !true
    ) // removed by dead control flow
{}

    this._keyStore = new KeyStore(this.options.keys);

    this.setCollection(docs, index);
  }

  setCollection(docs, index) {
    this._docs = docs;

    if (index && !(index instanceof FuseIndex)) {
      throw new Error(INCORRECT_INDEX_TYPE)
    }

    this._myIndex =
      index ||
      createIndex(this.options.keys, this._docs, {
        getFn: this.options.getFn,
        fieldNormWeight: this.options.fieldNormWeight
      });
  }

  add(doc) {
    if (!isDefined(doc)) {
      return
    }

    this._docs.push(doc);
    this._myIndex.add(doc);
  }

  remove(predicate = (/* doc, idx */) => false) {
    const results = [];

    for (let i = 0, len = this._docs.length; i < len; i += 1) {
      const doc = this._docs[i];
      if (predicate(doc, i)) {
        this.removeAt(i);
        i -= 1;
        len -= 1;

        results.push(doc);
      }
    }

    return results
  }

  removeAt(idx) {
    this._docs.splice(idx, 1);
    this._myIndex.removeAt(idx);
  }

  getIndex() {
    return this._myIndex
  }

  search(query, { limit = -1 } = {}) {
    const {
      includeMatches,
      includeScore,
      shouldSort,
      sortFn,
      ignoreFieldNorm
    } = this.options;

    let results = isString(query)
      ? isString(this._docs[0])
        ? this._searchStringList(query)
        : this._searchObjectList(query)
      : this._searchLogical(query);

    computeScore(results, { ignoreFieldNorm });

    if (shouldSort) {
      results.sort(sortFn);
    }

    if (isNumber(limit) && limit > -1) {
      results = results.slice(0, limit);
    }

    return format(results, this._docs, {
      includeMatches,
      includeScore
    })
  }

  _searchStringList(query) {
    const searcher = createSearcher(query, this.options);
    const { records } = this._myIndex;
    const results = [];

    // Iterate over every string in the index
    records.forEach(({ v: text, i: idx, n: norm }) => {
      if (!isDefined(text)) {
        return
      }

      const { isMatch, score, indices } = searcher.searchIn(text);

      if (isMatch) {
        results.push({
          item: text,
          idx,
          matches: [{ score, value: text, norm, indices }]
        });
      }
    });

    return results
  }

  _searchLogical(query) {

    const expression = parse(query, this.options);

    const evaluate = (node, item, idx) => {
      if (!node.children) {
        const { keyId, searcher } = node;

        const matches = this._findMatches({
          key: this._keyStore.get(keyId),
          value: this._myIndex.getValueForItemAtKeyId(item, keyId),
          searcher
        });

        if (matches && matches.length) {
          return [
            {
              idx,
              item,
              matches
            }
          ]
        }

        return []
      }

      const res = [];
      for (let i = 0, len = node.children.length; i < len; i += 1) {
        const child = node.children[i];
        const result = evaluate(child, item, idx);
        if (result.length) {
          res.push(...result);
        } else if (node.operator === LogicalOperator.AND) {
          return []
        }
      }
      return res
    };

    const records = this._myIndex.records;
    const resultMap = {};
    const results = [];

    records.forEach(({ $: item, i: idx }) => {
      if (isDefined(item)) {
        let expResults = evaluate(expression, item, idx);

        if (expResults.length) {
          // Dedupe when adding
          if (!resultMap[idx]) {
            resultMap[idx] = { idx, item, matches: [] };
            results.push(resultMap[idx]);
          }
          expResults.forEach(({ matches }) => {
            resultMap[idx].matches.push(...matches);
          });
        }
      }
    });

    return results
  }

  _searchObjectList(query) {
    const searcher = createSearcher(query, this.options);
    const { keys, records } = this._myIndex;
    const results = [];

    // List is Array<Object>
    records.forEach(({ $: item, i: idx }) => {
      if (!isDefined(item)) {
        return
      }

      let matches = [];

      // Iterate over every key (i.e, path), and fetch the value at that key
      keys.forEach((key, keyIndex) => {
        matches.push(
          ...this._findMatches({
            key,
            value: item[keyIndex],
            searcher
          })
        );
      });

      if (matches.length) {
        results.push({
          idx,
          item,
          matches
        });
      }
    });

    return results
  }
  _findMatches({ key, value, searcher }) {
    if (!isDefined(value)) {
      return []
    }

    let matches = [];

    if (isArray(value)) {
      value.forEach(({ v: text, i: idx, n: norm }) => {
        if (!isDefined(text)) {
          return
        }

        const { isMatch, score, indices } = searcher.searchIn(text);

        if (isMatch) {
          matches.push({
            score,
            key,
            value: text,
            idx,
            norm,
            indices
          });
        }
      });
    } else {
      const { v: text, n: norm } = value;

      const { isMatch, score, indices } = searcher.searchIn(text);

      if (isMatch) {
        matches.push({ score, key, value: text, norm, indices });
      }
    }

    return matches
  }
}

Fuse.version = '7.1.0';
Fuse.createIndex = createIndex;
Fuse.parseIndex = parseIndex;
Fuse.config = Config;

{
  Fuse.parseQuery = parse;
}

{
  register(ExtendedSearch);
}




/***/ },

/***/ "./node_modules/react-dom/cjs/react-dom-client.development.js"
/*!********************************************************************!*\
  !*** ./node_modules/react-dom/cjs/react-dom-client.development.js ***!
  \********************************************************************/
(__unused_webpack_module, exports, __webpack_require__) {

/**
 * @license React
 * react-dom-client.development.js
 *
 * Copyright (c) Meta Platforms, Inc. and affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */

/*
 Modernizr 3.0.0pre (Custom Build) | MIT
*/

 true &&
  (function () {
    function findHook(fiber, id) {
      for (fiber = fiber.memoizedState; null !== fiber && 0 < id; )
        (fiber = fiber.next), id--;
      return fiber;
    }
    function copyWithSetImpl(obj, path, index, value) {
      if (index >= path.length) return value;
      var key = path[index],
        updated = isArrayImpl(obj) ? obj.slice() : assign({}, obj);
      updated[key] = copyWithSetImpl(obj[key], path, index + 1, value);
      return updated;
    }
    function copyWithRename(obj, oldPath, newPath) {
      if (oldPath.length !== newPath.length)
        console.warn("copyWithRename() expects paths of the same length");
      else {
        for (var i = 0; i < newPath.length - 1; i++)
          if (oldPath[i] !== newPath[i]) {
            console.warn(
              "copyWithRename() expects paths to be the same except for the deepest key"
            );
            return;
          }
        return copyWithRenameImpl(obj, oldPath, newPath, 0);
      }
    }
    function copyWithRenameImpl(obj, oldPath, newPath, index) {
      var oldKey = oldPath[index],
        updated = isArrayImpl(obj) ? obj.slice() : assign({}, obj);
      index + 1 === oldPath.length
        ? ((updated[newPath[index]] = updated[oldKey]),
          isArrayImpl(updated)
            ? updated.splice(oldKey, 1)
            : delete updated[oldKey])
        : (updated[oldKey] = copyWithRenameImpl(
            obj[oldKey],
            oldPath,
            newPath,
            index + 1
          ));
      return updated;
    }
    function copyWithDeleteImpl(obj, path, index) {
      var key = path[index],
        updated = isArrayImpl(obj) ? obj.slice() : assign({}, obj);
      if (index + 1 === path.length)
        return (
          isArrayImpl(updated) ? updated.splice(key, 1) : delete updated[key],
          updated
        );
      updated[key] = copyWithDeleteImpl(obj[key], path, index + 1);
      return updated;
    }
    function shouldSuspendImpl() {
      return !1;
    }
    function shouldErrorImpl() {
      return null;
    }
    function warnInvalidHookAccess() {
      console.error(
        "Do not call Hooks inside useEffect(...), useMemo(...), or other built-in Hooks. You can only call Hooks at the top level of your React function. For more information, see https://react.dev/link/rules-of-hooks"
      );
    }
    function warnInvalidContextAccess() {
      console.error(
        "Context can only be read while React is rendering. In classes, you can read it in the render method or getDerivedStateFromProps. In function components, you can read it directly in the function body, but not inside Hooks like useReducer() or useMemo()."
      );
    }
    function noop() {}
    function warnForMissingKey() {}
    function setToSortedString(set) {
      var array = [];
      set.forEach(function (value) {
        array.push(value);
      });
      return array.sort().join(", ");
    }
    function createFiber(tag, pendingProps, key, mode) {
      return new FiberNode(tag, pendingProps, key, mode);
    }
    function scheduleRoot(root, element) {
      root.context === emptyContextObject &&
        (updateContainerImpl(root.current, 2, element, root, null, null),
        flushSyncWork$1());
    }
    function scheduleRefresh(root, update) {
      if (null !== resolveFamily) {
        var staleFamilies = update.staleFamilies;
        update = update.updatedFamilies;
        flushPendingEffects();
        scheduleFibersWithFamiliesRecursively(
          root.current,
          update,
          staleFamilies
        );
        flushSyncWork$1();
      }
    }
    function setRefreshHandler(handler) {
      resolveFamily = handler;
    }
    function isValidContainer(node) {
      return !(
        !node ||
        (1 !== node.nodeType && 9 !== node.nodeType && 11 !== node.nodeType)
      );
    }
    function getNearestMountedFiber(fiber) {
      var node = fiber,
        nearestMounted = fiber;
      if (fiber.alternate) for (; node.return; ) node = node.return;
      else {
        fiber = node;
        do
          (node = fiber),
            0 !== (node.flags & 4098) && (nearestMounted = node.return),
            (fiber = node.return);
        while (fiber);
      }
      return 3 === node.tag ? nearestMounted : null;
    }
    function getSuspenseInstanceFromFiber(fiber) {
      if (13 === fiber.tag) {
        var suspenseState = fiber.memoizedState;
        null === suspenseState &&
          ((fiber = fiber.alternate),
          null !== fiber && (suspenseState = fiber.memoizedState));
        if (null !== suspenseState) return suspenseState.dehydrated;
      }
      return null;
    }
    function getActivityInstanceFromFiber(fiber) {
      if (31 === fiber.tag) {
        var activityState = fiber.memoizedState;
        null === activityState &&
          ((fiber = fiber.alternate),
          null !== fiber && (activityState = fiber.memoizedState));
        if (null !== activityState) return activityState.dehydrated;
      }
      return null;
    }
    function assertIsMounted(fiber) {
      if (getNearestMountedFiber(fiber) !== fiber)
        throw Error("Unable to find node on an unmounted component.");
    }
    function findCurrentFiberUsingSlowPath(fiber) {
      var alternate = fiber.alternate;
      if (!alternate) {
        alternate = getNearestMountedFiber(fiber);
        if (null === alternate)
          throw Error("Unable to find node on an unmounted component.");
        return alternate !== fiber ? null : fiber;
      }
      for (var a = fiber, b = alternate; ; ) {
        var parentA = a.return;
        if (null === parentA) break;
        var parentB = parentA.alternate;
        if (null === parentB) {
          b = parentA.return;
          if (null !== b) {
            a = b;
            continue;
          }
          break;
        }
        if (parentA.child === parentB.child) {
          for (parentB = parentA.child; parentB; ) {
            if (parentB === a) return assertIsMounted(parentA), fiber;
            if (parentB === b) return assertIsMounted(parentA), alternate;
            parentB = parentB.sibling;
          }
          throw Error("Unable to find node on an unmounted component.");
        }
        if (a.return !== b.return) (a = parentA), (b = parentB);
        else {
          for (var didFindChild = !1, _child = parentA.child; _child; ) {
            if (_child === a) {
              didFindChild = !0;
              a = parentA;
              b = parentB;
              break;
            }
            if (_child === b) {
              didFindChild = !0;
              b = parentA;
              a = parentB;
              break;
            }
            _child = _child.sibling;
          }
          if (!didFindChild) {
            for (_child = parentB.child; _child; ) {
              if (_child === a) {
                didFindChild = !0;
                a = parentB;
                b = parentA;
                break;
              }
              if (_child === b) {
                didFindChild = !0;
                b = parentB;
                a = parentA;
                break;
              }
              _child = _child.sibling;
            }
            if (!didFindChild)
              throw Error(
                "Child was not found in either parent set. This indicates a bug in React related to the return pointer. Please file an issue."
              );
          }
        }
        if (a.alternate !== b)
          throw Error(
            "Return fibers should always be each others' alternates. This error is likely caused by a bug in React. Please file an issue."
          );
      }
      if (3 !== a.tag)
        throw Error("Unable to find node on an unmounted component.");
      return a.stateNode.current === a ? fiber : alternate;
    }
    function findCurrentHostFiberImpl(node) {
      var tag = node.tag;
      if (5 === tag || 26 === tag || 27 === tag || 6 === tag) return node;
      for (node = node.child; null !== node; ) {
        tag = findCurrentHostFiberImpl(node);
        if (null !== tag) return tag;
        node = node.sibling;
      }
      return null;
    }
    function getIteratorFn(maybeIterable) {
      if (null === maybeIterable || "object" !== typeof maybeIterable)
        return null;
      maybeIterable =
        (MAYBE_ITERATOR_SYMBOL && maybeIterable[MAYBE_ITERATOR_SYMBOL]) ||
        maybeIterable["@@iterator"];
      return "function" === typeof maybeIterable ? maybeIterable : null;
    }
    function getComponentNameFromType(type) {
      if (null == type) return null;
      if ("function" === typeof type)
        return type.$$typeof === REACT_CLIENT_REFERENCE
          ? null
          : type.displayName || type.name || null;
      if ("string" === typeof type) return type;
      switch (type) {
        case REACT_FRAGMENT_TYPE:
          return "Fragment";
        case REACT_PROFILER_TYPE:
          return "Profiler";
        case REACT_STRICT_MODE_TYPE:
          return "StrictMode";
        case REACT_SUSPENSE_TYPE:
          return "Suspense";
        case REACT_SUSPENSE_LIST_TYPE:
          return "SuspenseList";
        case REACT_ACTIVITY_TYPE:
          return "Activity";
      }
      if ("object" === typeof type)
        switch (
          ("number" === typeof type.tag &&
            console.error(
              "Received an unexpected object in getComponentNameFromType(). This is likely a bug in React. Please file an issue."
            ),
          type.$$typeof)
        ) {
          case REACT_PORTAL_TYPE:
            return "Portal";
          case REACT_CONTEXT_TYPE:
            return type.displayName || "Context";
          case REACT_CONSUMER_TYPE:
            return (type._context.displayName || "Context") + ".Consumer";
          case REACT_FORWARD_REF_TYPE:
            var innerType = type.render;
            type = type.displayName;
            type ||
              ((type = innerType.displayName || innerType.name || ""),
              (type = "" !== type ? "ForwardRef(" + type + ")" : "ForwardRef"));
            return type;
          case REACT_MEMO_TYPE:
            return (
              (innerType = type.displayName || null),
              null !== innerType
                ? innerType
                : getComponentNameFromType(type.type) || "Memo"
            );
          case REACT_LAZY_TYPE:
            innerType = type._payload;
            type = type._init;
            try {
              return getComponentNameFromType(type(innerType));
            } catch (x) {}
        }
      return null;
    }
    function getComponentNameFromOwner(owner) {
      return "number" === typeof owner.tag
        ? getComponentNameFromFiber(owner)
        : "string" === typeof owner.name
          ? owner.name
          : null;
    }
    function getComponentNameFromFiber(fiber) {
      var type = fiber.type;
      switch (fiber.tag) {
        case 31:
          return "Activity";
        case 24:
          return "Cache";
        case 9:
          return (type._context.displayName || "Context") + ".Consumer";
        case 10:
          return type.displayName || "Context";
        case 18:
          return "DehydratedFragment";
        case 11:
          return (
            (fiber = type.render),
            (fiber = fiber.displayName || fiber.name || ""),
            type.displayName ||
              ("" !== fiber ? "ForwardRef(" + fiber + ")" : "ForwardRef")
          );
        case 7:
          return "Fragment";
        case 26:
        case 27:
        case 5:
          return type;
        case 4:
          return "Portal";
        case 3:
          return "Root";
        case 6:
          return "Text";
        case 16:
          return getComponentNameFromType(type);
        case 8:
          return type === REACT_STRICT_MODE_TYPE ? "StrictMode" : "Mode";
        case 22:
          return "Offscreen";
        case 12:
          return "Profiler";
        case 21:
          return "Scope";
        case 13:
          return "Suspense";
        case 19:
          return "SuspenseList";
        case 25:
          return "TracingMarker";
        case 1:
        case 0:
        case 14:
        case 15:
          if ("function" === typeof type)
            return type.displayName || type.name || null;
          if ("string" === typeof type) return type;
          break;
        case 29:
          type = fiber._debugInfo;
          if (null != type)
            for (var i = type.length - 1; 0 <= i; i--)
              if ("string" === typeof type[i].name) return type[i].name;
          if (null !== fiber.return)
            return getComponentNameFromFiber(fiber.return);
      }
      return null;
    }
    function createCursor(defaultValue) {
      return { current: defaultValue };
    }
    function pop(cursor, fiber) {
      0 > index$jscomp$0
        ? console.error("Unexpected pop.")
        : (fiber !== fiberStack[index$jscomp$0] &&
            console.error("Unexpected Fiber popped."),
          (cursor.current = valueStack[index$jscomp$0]),
          (valueStack[index$jscomp$0] = null),
          (fiberStack[index$jscomp$0] = null),
          index$jscomp$0--);
    }
    function push(cursor, value, fiber) {
      index$jscomp$0++;
      valueStack[index$jscomp$0] = cursor.current;
      fiberStack[index$jscomp$0] = fiber;
      cursor.current = value;
    }
    function requiredContext(c) {
      null === c &&
        console.error(
          "Expected host context to exist. This error is likely caused by a bug in React. Please file an issue."
        );
      return c;
    }
    function pushHostContainer(fiber, nextRootInstance) {
      push(rootInstanceStackCursor, nextRootInstance, fiber);
      push(contextFiberStackCursor, fiber, fiber);
      push(contextStackCursor, null, fiber);
      var nextRootContext = nextRootInstance.nodeType;
      switch (nextRootContext) {
        case 9:
        case 11:
          nextRootContext = 9 === nextRootContext ? "#document" : "#fragment";
          nextRootInstance = (nextRootInstance =
            nextRootInstance.documentElement)
            ? (nextRootInstance = nextRootInstance.namespaceURI)
              ? getOwnHostContext(nextRootInstance)
              : HostContextNamespaceNone
            : HostContextNamespaceNone;
          break;
        default:
          if (
            ((nextRootContext = nextRootInstance.tagName),
            (nextRootInstance = nextRootInstance.namespaceURI))
          )
            (nextRootInstance = getOwnHostContext(nextRootInstance)),
              (nextRootInstance = getChildHostContextProd(
                nextRootInstance,
                nextRootContext
              ));
          else
            switch (nextRootContext) {
              case "svg":
                nextRootInstance = HostContextNamespaceSvg;
                break;
              case "math":
                nextRootInstance = HostContextNamespaceMath;
                break;
              default:
                nextRootInstance = HostContextNamespaceNone;
            }
      }
      nextRootContext = nextRootContext.toLowerCase();
      nextRootContext = updatedAncestorInfoDev(null, nextRootContext);
      nextRootContext = {
        context: nextRootInstance,
        ancestorInfo: nextRootContext
      };
      pop(contextStackCursor, fiber);
      push(contextStackCursor, nextRootContext, fiber);
    }
    function popHostContainer(fiber) {
      pop(contextStackCursor, fiber);
      pop(contextFiberStackCursor, fiber);
      pop(rootInstanceStackCursor, fiber);
    }
    function getHostContext() {
      return requiredContext(contextStackCursor.current);
    }
    function pushHostContext(fiber) {
      null !== fiber.memoizedState &&
        push(hostTransitionProviderCursor, fiber, fiber);
      var context = requiredContext(contextStackCursor.current);
      var type = fiber.type;
      var nextContext = getChildHostContextProd(context.context, type);
      type = updatedAncestorInfoDev(context.ancestorInfo, type);
      nextContext = { context: nextContext, ancestorInfo: type };
      context !== nextContext &&
        (push(contextFiberStackCursor, fiber, fiber),
        push(contextStackCursor, nextContext, fiber));
    }
    function popHostContext(fiber) {
      contextFiberStackCursor.current === fiber &&
        (pop(contextStackCursor, fiber), pop(contextFiberStackCursor, fiber));
      hostTransitionProviderCursor.current === fiber &&
        (pop(hostTransitionProviderCursor, fiber),
        (HostTransitionContext._currentValue = NotPendingTransition));
    }
    function disabledLog() {}
    function disableLogs() {
      if (0 === disabledDepth) {
        prevLog = console.log;
        prevInfo = console.info;
        prevWarn = console.warn;
        prevError = console.error;
        prevGroup = console.group;
        prevGroupCollapsed = console.groupCollapsed;
        prevGroupEnd = console.groupEnd;
        var props = {
          configurable: !0,
          enumerable: !0,
          value: disabledLog,
          writable: !0
        };
        Object.defineProperties(console, {
          info: props,
          log: props,
          warn: props,
          error: props,
          group: props,
          groupCollapsed: props,
          groupEnd: props
        });
      }
      disabledDepth++;
    }
    function reenableLogs() {
      disabledDepth--;
      if (0 === disabledDepth) {
        var props = { configurable: !0, enumerable: !0, writable: !0 };
        Object.defineProperties(console, {
          log: assign({}, props, { value: prevLog }),
          info: assign({}, props, { value: prevInfo }),
          warn: assign({}, props, { value: prevWarn }),
          error: assign({}, props, { value: prevError }),
          group: assign({}, props, { value: prevGroup }),
          groupCollapsed: assign({}, props, { value: prevGroupCollapsed }),
          groupEnd: assign({}, props, { value: prevGroupEnd })
        });
      }
      0 > disabledDepth &&
        console.error(
          "disabledDepth fell below zero. This is a bug in React. Please file an issue."
        );
    }
    function formatOwnerStack(error) {
      var prevPrepareStackTrace = Error.prepareStackTrace;
      Error.prepareStackTrace = void 0;
      error = error.stack;
      Error.prepareStackTrace = prevPrepareStackTrace;
      error.startsWith("Error: react-stack-top-frame\n") &&
        (error = error.slice(29));
      prevPrepareStackTrace = error.indexOf("\n");
      -1 !== prevPrepareStackTrace &&
        (error = error.slice(prevPrepareStackTrace + 1));
      prevPrepareStackTrace = error.indexOf("react_stack_bottom_frame");
      -1 !== prevPrepareStackTrace &&
        (prevPrepareStackTrace = error.lastIndexOf(
          "\n",
          prevPrepareStackTrace
        ));
      if (-1 !== prevPrepareStackTrace)
        error = error.slice(0, prevPrepareStackTrace);
      else return "";
      return error;
    }
    function describeBuiltInComponentFrame(name) {
      if (void 0 === prefix)
        try {
          throw Error();
        } catch (x) {
          var match = x.stack.trim().match(/\n( *(at )?)/);
          prefix = (match && match[1]) || "";
          suffix =
            -1 < x.stack.indexOf("\n    at")
              ? " (<anonymous>)"
              : -1 < x.stack.indexOf("@")
                ? "@unknown:0:0"
                : "";
        }
      return "\n" + prefix + name + suffix;
    }
    function describeNativeComponentFrame(fn, construct) {
      if (!fn || reentry) return "";
      var frame = componentFrameCache.get(fn);
      if (void 0 !== frame) return frame;
      reentry = !0;
      frame = Error.prepareStackTrace;
      Error.prepareStackTrace = void 0;
      var previousDispatcher = null;
      previousDispatcher = ReactSharedInternals.H;
      ReactSharedInternals.H = null;
      disableLogs();
      try {
        var RunInRootFrame = {
          DetermineComponentFrameRoot: function () {
            try {
              if (construct) {
                var Fake = function () {
                  throw Error();
                };
                Object.defineProperty(Fake.prototype, "props", {
                  set: function () {
                    throw Error();
                  }
                });
                if ("object" === typeof Reflect && Reflect.construct) {
                  try {
                    Reflect.construct(Fake, []);
                  } catch (x) {
                    var control = x;
                  }
                  Reflect.construct(fn, [], Fake);
                } else {
                  try {
                    Fake.call();
                  } catch (x$0) {
                    control = x$0;
                  }
                  fn.call(Fake.prototype);
                }
              } else {
                try {
                  throw Error();
                } catch (x$1) {
                  control = x$1;
                }
                (Fake = fn()) &&
                  "function" === typeof Fake.catch &&
                  Fake.catch(function () {});
              }
            } catch (sample) {
              if (sample && control && "string" === typeof sample.stack)
                return [sample.stack, control.stack];
            }
            return [null, null];
          }
        };
        RunInRootFrame.DetermineComponentFrameRoot.displayName =
          "DetermineComponentFrameRoot";
        var namePropDescriptor = Object.getOwnPropertyDescriptor(
          RunInRootFrame.DetermineComponentFrameRoot,
          "name"
        );
        namePropDescriptor &&
          namePropDescriptor.configurable &&
          Object.defineProperty(
            RunInRootFrame.DetermineComponentFrameRoot,
            "name",
            { value: "DetermineComponentFrameRoot" }
          );
        var _RunInRootFrame$Deter =
            RunInRootFrame.DetermineComponentFrameRoot(),
          sampleStack = _RunInRootFrame$Deter[0],
          controlStack = _RunInRootFrame$Deter[1];
        if (sampleStack && controlStack) {
          var sampleLines = sampleStack.split("\n"),
            controlLines = controlStack.split("\n");
          for (
            _RunInRootFrame$Deter = namePropDescriptor = 0;
            namePropDescriptor < sampleLines.length &&
            !sampleLines[namePropDescriptor].includes(
              "DetermineComponentFrameRoot"
            );

          )
            namePropDescriptor++;
          for (
            ;
            _RunInRootFrame$Deter < controlLines.length &&
            !controlLines[_RunInRootFrame$Deter].includes(
              "DetermineComponentFrameRoot"
            );

          )
            _RunInRootFrame$Deter++;
          if (
            namePropDescriptor === sampleLines.length ||
            _RunInRootFrame$Deter === controlLines.length
          )
            for (
              namePropDescriptor = sampleLines.length - 1,
                _RunInRootFrame$Deter = controlLines.length - 1;
              1 <= namePropDescriptor &&
              0 <= _RunInRootFrame$Deter &&
              sampleLines[namePropDescriptor] !==
                controlLines[_RunInRootFrame$Deter];

            )
              _RunInRootFrame$Deter--;
          for (
            ;
            1 <= namePropDescriptor && 0 <= _RunInRootFrame$Deter;
            namePropDescriptor--, _RunInRootFrame$Deter--
          )
            if (
              sampleLines[namePropDescriptor] !==
              controlLines[_RunInRootFrame$Deter]
            ) {
              if (1 !== namePropDescriptor || 1 !== _RunInRootFrame$Deter) {
                do
                  if (
                    (namePropDescriptor--,
                    _RunInRootFrame$Deter--,
                    0 > _RunInRootFrame$Deter ||
                      sampleLines[namePropDescriptor] !==
                        controlLines[_RunInRootFrame$Deter])
                  ) {
                    var _frame =
                      "\n" +
                      sampleLines[namePropDescriptor].replace(
                        " at new ",
                        " at "
                      );
                    fn.displayName &&
                      _frame.includes("<anonymous>") &&
                      (_frame = _frame.replace("<anonymous>", fn.displayName));
                    "function" === typeof fn &&
                      componentFrameCache.set(fn, _frame);
                    return _frame;
                  }
                while (1 <= namePropDescriptor && 0 <= _RunInRootFrame$Deter);
              }
              break;
            }
        }
      } finally {
        (reentry = !1),
          (ReactSharedInternals.H = previousDispatcher),
          reenableLogs(),
          (Error.prepareStackTrace = frame);
      }
      sampleLines = (sampleLines = fn ? fn.displayName || fn.name : "")
        ? describeBuiltInComponentFrame(sampleLines)
        : "";
      "function" === typeof fn && componentFrameCache.set(fn, sampleLines);
      return sampleLines;
    }
    function describeFiber(fiber, childFiber) {
      switch (fiber.tag) {
        case 26:
        case 27:
        case 5:
          return describeBuiltInComponentFrame(fiber.type);
        case 16:
          return describeBuiltInComponentFrame("Lazy");
        case 13:
          return fiber.child !== childFiber && null !== childFiber
            ? describeBuiltInComponentFrame("Suspense Fallback")
            : describeBuiltInComponentFrame("Suspense");
        case 19:
          return describeBuiltInComponentFrame("SuspenseList");
        case 0:
        case 15:
          return describeNativeComponentFrame(fiber.type, !1);
        case 11:
          return describeNativeComponentFrame(fiber.type.render, !1);
        case 1:
          return describeNativeComponentFrame(fiber.type, !0);
        case 31:
          return describeBuiltInComponentFrame("Activity");
        default:
          return "";
      }
    }
    function getStackByFiberInDevAndProd(workInProgress) {
      try {
        var info = "",
          previous = null;
        do {
          info += describeFiber(workInProgress, previous);
          var debugInfo = workInProgress._debugInfo;
          if (debugInfo)
            for (var i = debugInfo.length - 1; 0 <= i; i--) {
              var entry = debugInfo[i];
              if ("string" === typeof entry.name) {
                var JSCompiler_temp_const = info;
                a: {
                  var name = entry.name,
                    env = entry.env,
                    location = entry.debugLocation;
                  if (null != location) {
                    var childStack = formatOwnerStack(location),
                      idx = childStack.lastIndexOf("\n"),
                      lastLine =
                        -1 === idx ? childStack : childStack.slice(idx + 1);
                    if (-1 !== lastLine.indexOf(name)) {
                      var JSCompiler_inline_result = "\n" + lastLine;
                      break a;
                    }
                  }
                  JSCompiler_inline_result = describeBuiltInComponentFrame(
                    name + (env ? " [" + env + "]" : "")
                  );
                }
                info = JSCompiler_temp_const + JSCompiler_inline_result;
              }
            }
          previous = workInProgress;
          workInProgress = workInProgress.return;
        } while (workInProgress);
        return info;
      } catch (x) {
        return "\nError generating stack: " + x.message + "\n" + x.stack;
      }
    }
    function describeFunctionComponentFrameWithoutLineNumber(fn) {
      return (fn = fn ? fn.displayName || fn.name : "")
        ? describeBuiltInComponentFrame(fn)
        : "";
    }
    function getCurrentFiberOwnerNameInDevOrNull() {
      if (null === current) return null;
      var owner = current._debugOwner;
      return null != owner ? getComponentNameFromOwner(owner) : null;
    }
    function getCurrentFiberStackInDev() {
      if (null === current) return "";
      var workInProgress = current;
      try {
        var info = "";
        6 === workInProgress.tag && (workInProgress = workInProgress.return);
        switch (workInProgress.tag) {
          case 26:
          case 27:
          case 5:
            info += describeBuiltInComponentFrame(workInProgress.type);
            break;
          case 13:
            info += describeBuiltInComponentFrame("Suspense");
            break;
          case 19:
            info += describeBuiltInComponentFrame("SuspenseList");
            break;
          case 31:
            info += describeBuiltInComponentFrame("Activity");
            break;
          case 30:
          case 0:
          case 15:
          case 1:
            workInProgress._debugOwner ||
              "" !== info ||
              (info += describeFunctionComponentFrameWithoutLineNumber(
                workInProgress.type
              ));
            break;
          case 11:
            workInProgress._debugOwner ||
              "" !== info ||
              (info += describeFunctionComponentFrameWithoutLineNumber(
                workInProgress.type.render
              ));
        }
        for (; workInProgress; )
          if ("number" === typeof workInProgress.tag) {
            var fiber = workInProgress;
            workInProgress = fiber._debugOwner;
            var debugStack = fiber._debugStack;
            if (workInProgress && debugStack) {
              var formattedStack = formatOwnerStack(debugStack);
              "" !== formattedStack && (info += "\n" + formattedStack);
            }
          } else if (null != workInProgress.debugStack) {
            var ownerStack = workInProgress.debugStack;
            (workInProgress = workInProgress.owner) &&
              ownerStack &&
              (info += "\n" + formatOwnerStack(ownerStack));
          } else break;
        var JSCompiler_inline_result = info;
      } catch (x) {
        JSCompiler_inline_result =
          "\nError generating stack: " + x.message + "\n" + x.stack;
      }
      return JSCompiler_inline_result;
    }
    function runWithFiberInDEV(fiber, callback, arg0, arg1, arg2, arg3, arg4) {
      var previousFiber = current;
      setCurrentFiber(fiber);
      try {
        return null !== fiber && fiber._debugTask
          ? fiber._debugTask.run(
              callback.bind(null, arg0, arg1, arg2, arg3, arg4)
            )
          : callback(arg0, arg1, arg2, arg3, arg4);
      } finally {
        setCurrentFiber(previousFiber);
      }
      // removed by dead control flow

    }
    function setCurrentFiber(fiber) {
      ReactSharedInternals.getCurrentStack =
        null === fiber ? null : getCurrentFiberStackInDev;
      isRendering = !1;
      current = fiber;
    }
    function typeName(value) {
      return (
        ("function" === typeof Symbol &&
          Symbol.toStringTag &&
          value[Symbol.toStringTag]) ||
        value.constructor.name ||
        "Object"
      );
    }
    function willCoercionThrow(value) {
      try {
        return testStringCoercion(value), !1;
      } catch (e) {
        return !0;
      }
    }
    function testStringCoercion(value) {
      return "" + value;
    }
    function checkAttributeStringCoercion(value, attributeName) {
      if (willCoercionThrow(value))
        return (
          console.error(
            "The provided `%s` attribute is an unsupported type %s. This value must be coerced to a string before using it here.",
            attributeName,
            typeName(value)
          ),
          testStringCoercion(value)
        );
    }
    function checkCSSPropertyStringCoercion(value, propName) {
      if (willCoercionThrow(value))
        return (
          console.error(
            "The provided `%s` CSS property is an unsupported type %s. This value must be coerced to a string before using it here.",
            propName,
            typeName(value)
          ),
          testStringCoercion(value)
        );
    }
    function checkFormFieldValueStringCoercion(value) {
      if (willCoercionThrow(value))
        return (
          console.error(
            "Form field values (value, checked, defaultValue, or defaultChecked props) must be strings, not %s. This value must be coerced to a string before using it here.",
            typeName(value)
          ),
          testStringCoercion(value)
        );
    }
    function injectInternals(internals) {
      if ("undefined" === typeof __REACT_DEVTOOLS_GLOBAL_HOOK__) return !1;
      var hook = __REACT_DEVTOOLS_GLOBAL_HOOK__;
      if (hook.isDisabled) return !0;
      if (!hook.supportsFiber)
        return (
          console.error(
            "The installed version of React DevTools is too old and will not work with the current version of React. Please update React DevTools. https://react.dev/link/react-devtools"
          ),
          !0
        );
      try {
        (rendererID = hook.inject(internals)), (injectedHook = hook);
      } catch (err) {
        console.error("React instrumentation encountered an error: %o.", err);
      }
      return hook.checkDCE ? !0 : !1;
    }
    function setIsStrictModeForDevtools(newIsStrictMode) {
      "function" === typeof log$1 &&
        unstable_setDisableYieldValue(newIsStrictMode);
      if (injectedHook && "function" === typeof injectedHook.setStrictMode)
        try {
          injectedHook.setStrictMode(rendererID, newIsStrictMode);
        } catch (err) {
          hasLoggedError ||
            ((hasLoggedError = !0),
            console.error(
              "React instrumentation encountered an error: %o",
              err
            ));
        }
    }
    function clz32Fallback(x) {
      x >>>= 0;
      return 0 === x ? 32 : (31 - ((log(x) / LN2) | 0)) | 0;
    }
    function getHighestPriorityLanes(lanes) {
      var pendingSyncLanes = lanes & 42;
      if (0 !== pendingSyncLanes) return pendingSyncLanes;
      switch (lanes & -lanes) {
        case 1:
          return 1;
        case 2:
          return 2;
        case 4:
          return 4;
        case 8:
          return 8;
        case 16:
          return 16;
        case 32:
          return 32;
        case 64:
          return 64;
        case 128:
          return 128;
        case 256:
        case 512:
        case 1024:
        case 2048:
        case 4096:
        case 8192:
        case 16384:
        case 32768:
        case 65536:
        case 131072:
          return lanes & 261888;
        case 262144:
        case 524288:
        case 1048576:
        case 2097152:
          return lanes & 3932160;
        case 4194304:
        case 8388608:
        case 16777216:
        case 33554432:
          return lanes & 62914560;
        case 67108864:
          return 67108864;
        case 134217728:
          return 134217728;
        case 268435456:
          return 268435456;
        case 536870912:
          return 536870912;
        case 1073741824:
          return 0;
        default:
          return (
            console.error(
              "Should have found matching lanes. This is a bug in React."
            ),
            lanes
          );
      }
    }
    function getNextLanes(root, wipLanes, rootHasPendingCommit) {
      var pendingLanes = root.pendingLanes;
      if (0 === pendingLanes) return 0;
      var nextLanes = 0,
        suspendedLanes = root.suspendedLanes,
        pingedLanes = root.pingedLanes;
      root = root.warmLanes;
      var nonIdlePendingLanes = pendingLanes & 134217727;
      0 !== nonIdlePendingLanes
        ? ((pendingLanes = nonIdlePendingLanes & ~suspendedLanes),
          0 !== pendingLanes
            ? (nextLanes = getHighestPriorityLanes(pendingLanes))
            : ((pingedLanes &= nonIdlePendingLanes),
              0 !== pingedLanes
                ? (nextLanes = getHighestPriorityLanes(pingedLanes))
                : rootHasPendingCommit ||
                  ((rootHasPendingCommit = nonIdlePendingLanes & ~root),
                  0 !== rootHasPendingCommit &&
                    (nextLanes =
                      getHighestPriorityLanes(rootHasPendingCommit)))))
        : ((nonIdlePendingLanes = pendingLanes & ~suspendedLanes),
          0 !== nonIdlePendingLanes
            ? (nextLanes = getHighestPriorityLanes(nonIdlePendingLanes))
            : 0 !== pingedLanes
              ? (nextLanes = getHighestPriorityLanes(pingedLanes))
              : rootHasPendingCommit ||
                ((rootHasPendingCommit = pendingLanes & ~root),
                0 !== rootHasPendingCommit &&
                  (nextLanes = getHighestPriorityLanes(rootHasPendingCommit))));
      return 0 === nextLanes
        ? 0
        : 0 !== wipLanes &&
            wipLanes !== nextLanes &&
            0 === (wipLanes & suspendedLanes) &&
            ((suspendedLanes = nextLanes & -nextLanes),
            (rootHasPendingCommit = wipLanes & -wipLanes),
            suspendedLanes >= rootHasPendingCommit ||
              (32 === suspendedLanes && 0 !== (rootHasPendingCommit & 4194048)))
          ? wipLanes
          : nextLanes;
    }
    function checkIfRootIsPrerendering(root, renderLanes) {
      return (
        0 ===
        (root.pendingLanes &
          ~(root.suspendedLanes & ~root.pingedLanes) &
          renderLanes)
      );
    }
    function computeExpirationTime(lane, currentTime) {
      switch (lane) {
        case 1:
        case 2:
        case 4:
        case 8:
        case 64:
          return currentTime + 250;
        case 16:
        case 32:
        case 128:
        case 256:
        case 512:
        case 1024:
        case 2048:
        case 4096:
        case 8192:
        case 16384:
        case 32768:
        case 65536:
        case 131072:
        case 262144:
        case 524288:
        case 1048576:
        case 2097152:
          return currentTime + 5e3;
        case 4194304:
        case 8388608:
        case 16777216:
        case 33554432:
          return -1;
        case 67108864:
        case 134217728:
        case 268435456:
        case 536870912:
        case 1073741824:
          return -1;
        default:
          return (
            console.error(
              "Should have found matching lanes. This is a bug in React."
            ),
            -1
          );
      }
    }
    function claimNextRetryLane() {
      var lane = nextRetryLane;
      nextRetryLane <<= 1;
      0 === (nextRetryLane & 62914560) && (nextRetryLane = 4194304);
      return lane;
    }
    function createLaneMap(initial) {
      for (var laneMap = [], i = 0; 31 > i; i++) laneMap.push(initial);
      return laneMap;
    }
    function markRootUpdated$1(root, updateLane) {
      root.pendingLanes |= updateLane;
      268435456 !== updateLane &&
        ((root.suspendedLanes = 0),
        (root.pingedLanes = 0),
        (root.warmLanes = 0));
    }
    function markRootFinished(
      root,
      finishedLanes,
      remainingLanes,
      spawnedLane,
      updatedLanes,
      suspendedRetryLanes
    ) {
      var previouslyPendingLanes = root.pendingLanes;
      root.pendingLanes = remainingLanes;
      root.suspendedLanes = 0;
      root.pingedLanes = 0;
      root.warmLanes = 0;
      root.expiredLanes &= remainingLanes;
      root.entangledLanes &= remainingLanes;
      root.errorRecoveryDisabledLanes &= remainingLanes;
      root.shellSuspendCounter = 0;
      var entanglements = root.entanglements,
        expirationTimes = root.expirationTimes,
        hiddenUpdates = root.hiddenUpdates;
      for (
        remainingLanes = previouslyPendingLanes & ~remainingLanes;
        0 < remainingLanes;

      ) {
        var index = 31 - clz32(remainingLanes),
          lane = 1 << index;
        entanglements[index] = 0;
        expirationTimes[index] = -1;
        var hiddenUpdatesForLane = hiddenUpdates[index];
        if (null !== hiddenUpdatesForLane)
          for (
            hiddenUpdates[index] = null, index = 0;
            index < hiddenUpdatesForLane.length;
            index++
          ) {
            var update = hiddenUpdatesForLane[index];
            null !== update && (update.lane &= -536870913);
          }
        remainingLanes &= ~lane;
      }
      0 !== spawnedLane && markSpawnedDeferredLane(root, spawnedLane, 0);
      0 !== suspendedRetryLanes &&
        0 === updatedLanes &&
        0 !== root.tag &&
        (root.suspendedLanes |=
          suspendedRetryLanes & ~(previouslyPendingLanes & ~finishedLanes));
    }
    function markSpawnedDeferredLane(root, spawnedLane, entangledLanes) {
      root.pendingLanes |= spawnedLane;
      root.suspendedLanes &= ~spawnedLane;
      var spawnedLaneIndex = 31 - clz32(spawnedLane);
      root.entangledLanes |= spawnedLane;
      root.entanglements[spawnedLaneIndex] =
        root.entanglements[spawnedLaneIndex] |
        1073741824 |
        (entangledLanes & 261930);
    }
    function markRootEntangled(root, entangledLanes) {
      var rootEntangledLanes = (root.entangledLanes |= entangledLanes);
      for (root = root.entanglements; rootEntangledLanes; ) {
        var index = 31 - clz32(rootEntangledLanes),
          lane = 1 << index;
        (lane & entangledLanes) | (root[index] & entangledLanes) &&
          (root[index] |= entangledLanes);
        rootEntangledLanes &= ~lane;
      }
    }
    function getBumpedLaneForHydration(root, renderLanes) {
      var renderLane = renderLanes & -renderLanes;
      renderLane =
        0 !== (renderLane & 42)
          ? 1
          : getBumpedLaneForHydrationByLane(renderLane);
      return 0 !== (renderLane & (root.suspendedLanes | renderLanes))
        ? 0
        : renderLane;
    }
    function getBumpedLaneForHydrationByLane(lane) {
      switch (lane) {
        case 2:
          lane = 1;
          break;
        case 8:
          lane = 4;
          break;
        case 32:
          lane = 16;
          break;
        case 256:
        case 512:
        case 1024:
        case 2048:
        case 4096:
        case 8192:
        case 16384:
        case 32768:
        case 65536:
        case 131072:
        case 262144:
        case 524288:
        case 1048576:
        case 2097152:
        case 4194304:
        case 8388608:
        case 16777216:
        case 33554432:
          lane = 128;
          break;
        case 268435456:
          lane = 134217728;
          break;
        default:
          lane = 0;
      }
      return lane;
    }
    function addFiberToLanesMap(root, fiber, lanes) {
      if (isDevToolsPresent)
        for (root = root.pendingUpdatersLaneMap; 0 < lanes; ) {
          var index = 31 - clz32(lanes),
            lane = 1 << index;
          root[index].add(fiber);
          lanes &= ~lane;
        }
    }
    function movePendingFibersToMemoized(root, lanes) {
      if (isDevToolsPresent)
        for (
          var pendingUpdatersLaneMap = root.pendingUpdatersLaneMap,
            memoizedUpdaters = root.memoizedUpdaters;
          0 < lanes;

        ) {
          var index = 31 - clz32(lanes);
          root = 1 << index;
          index = pendingUpdatersLaneMap[index];
          0 < index.size &&
            (index.forEach(function (fiber) {
              var alternate = fiber.alternate;
              (null !== alternate && memoizedUpdaters.has(alternate)) ||
                memoizedUpdaters.add(fiber);
            }),
            index.clear());
          lanes &= ~root;
        }
    }
    function lanesToEventPriority(lanes) {
      lanes &= -lanes;
      return 0 !== DiscreteEventPriority && DiscreteEventPriority < lanes
        ? 0 !== ContinuousEventPriority && ContinuousEventPriority < lanes
          ? 0 !== (lanes & 134217727)
            ? DefaultEventPriority
            : IdleEventPriority
          : ContinuousEventPriority
        : DiscreteEventPriority;
    }
    function resolveUpdatePriority() {
      var updatePriority = ReactDOMSharedInternals.p;
      if (0 !== updatePriority) return updatePriority;
      updatePriority = window.event;
      return void 0 === updatePriority
        ? DefaultEventPriority
        : getEventPriority(updatePriority.type);
    }
    function runWithPriority(priority, fn) {
      var previousPriority = ReactDOMSharedInternals.p;
      try {
        return (ReactDOMSharedInternals.p = priority), fn();
      } finally {
        ReactDOMSharedInternals.p = previousPriority;
      }
    }
    function detachDeletedInstance(node) {
      delete node[internalInstanceKey];
      delete node[internalPropsKey];
      delete node[internalEventHandlersKey];
      delete node[internalEventHandlerListenersKey];
      delete node[internalEventHandlesSetKey];
    }
    function getClosestInstanceFromNode(targetNode) {
      var targetInst = targetNode[internalInstanceKey];
      if (targetInst) return targetInst;
      for (var parentNode = targetNode.parentNode; parentNode; ) {
        if (
          (targetInst =
            parentNode[internalContainerInstanceKey] ||
            parentNode[internalInstanceKey])
        ) {
          parentNode = targetInst.alternate;
          if (
            null !== targetInst.child ||
            (null !== parentNode && null !== parentNode.child)
          )
            for (
              targetNode = getParentHydrationBoundary(targetNode);
              null !== targetNode;

            ) {
              if ((parentNode = targetNode[internalInstanceKey]))
                return parentNode;
              targetNode = getParentHydrationBoundary(targetNode);
            }
          return targetInst;
        }
        targetNode = parentNode;
        parentNode = targetNode.parentNode;
      }
      return null;
    }
    function getInstanceFromNode(node) {
      if (
        (node = node[internalInstanceKey] || node[internalContainerInstanceKey])
      ) {
        var tag = node.tag;
        if (
          5 === tag ||
          6 === tag ||
          13 === tag ||
          31 === tag ||
          26 === tag ||
          27 === tag ||
          3 === tag
        )
          return node;
      }
      return null;
    }
    function getNodeFromInstance(inst) {
      var tag = inst.tag;
      if (5 === tag || 26 === tag || 27 === tag || 6 === tag)
        return inst.stateNode;
      throw Error("getNodeFromInstance: Invalid argument.");
    }
    function getResourcesFromRoot(root) {
      var resources = root[internalRootNodeResourcesKey];
      resources ||
        (resources = root[internalRootNodeResourcesKey] =
          { hoistableStyles: new Map(), hoistableScripts: new Map() });
      return resources;
    }
    function markNodeAsHoistable(node) {
      node[internalHoistableMarker] = !0;
    }
    function registerTwoPhaseEvent(registrationName, dependencies) {
      registerDirectEvent(registrationName, dependencies);
      registerDirectEvent(registrationName + "Capture", dependencies);
    }
    function registerDirectEvent(registrationName, dependencies) {
      registrationNameDependencies[registrationName] &&
        console.error(
          "EventRegistry: More than one plugin attempted to publish the same registration name, `%s`.",
          registrationName
        );
      registrationNameDependencies[registrationName] = dependencies;
      var lowerCasedName = registrationName.toLowerCase();
      possibleRegistrationNames[lowerCasedName] = registrationName;
      "onDoubleClick" === registrationName &&
        (possibleRegistrationNames.ondblclick = registrationName);
      for (
        registrationName = 0;
        registrationName < dependencies.length;
        registrationName++
      )
        allNativeEvents.add(dependencies[registrationName]);
    }
    function checkControlledValueProps(tagName, props) {
      hasReadOnlyValue[props.type] ||
        props.onChange ||
        props.onInput ||
        props.readOnly ||
        props.disabled ||
        null == props.value ||
        ("select" === tagName
          ? console.error(
              "You provided a `value` prop to a form field without an `onChange` handler. This will render a read-only field. If the field should be mutable use `defaultValue`. Otherwise, set `onChange`."
            )
          : console.error(
              "You provided a `value` prop to a form field without an `onChange` handler. This will render a read-only field. If the field should be mutable use `defaultValue`. Otherwise, set either `onChange` or `readOnly`."
            ));
      props.onChange ||
        props.readOnly ||
        props.disabled ||
        null == props.checked ||
        console.error(
          "You provided a `checked` prop to a form field without an `onChange` handler. This will render a read-only field. If the field should be mutable use `defaultChecked`. Otherwise, set either `onChange` or `readOnly`."
        );
    }
    function isAttributeNameSafe(attributeName) {
      if (hasOwnProperty.call(validatedAttributeNameCache, attributeName))
        return !0;
      if (hasOwnProperty.call(illegalAttributeNameCache, attributeName))
        return !1;
      if (VALID_ATTRIBUTE_NAME_REGEX.test(attributeName))
        return (validatedAttributeNameCache[attributeName] = !0);
      illegalAttributeNameCache[attributeName] = !0;
      console.error("Invalid attribute name: `%s`", attributeName);
      return !1;
    }
    function getValueForAttributeOnCustomComponent(node, name, expected) {
      if (isAttributeNameSafe(name)) {
        if (!node.hasAttribute(name)) {
          switch (typeof expected) {
            case "symbol":
            case "object":
              return expected;
            case "function":
              return expected;
            case "boolean":
              if (!1 === expected) return expected;
          }
          return void 0 === expected ? void 0 : null;
        }
        node = node.getAttribute(name);
        if ("" === node && !0 === expected) return !0;
        checkAttributeStringCoercion(expected, name);
        return node === "" + expected ? expected : node;
      }
    }
    function setValueForAttribute(node, name, value) {
      if (isAttributeNameSafe(name))
        if (null === value) node.removeAttribute(name);
        else {
          switch (typeof value) {
            case "undefined":
            case "function":
            case "symbol":
              node.removeAttribute(name);
              return;
            case "boolean":
              var prefix = name.toLowerCase().slice(0, 5);
              if ("data-" !== prefix && "aria-" !== prefix) {
                node.removeAttribute(name);
                return;
              }
          }
          checkAttributeStringCoercion(value, name);
          node.setAttribute(name, "" + value);
        }
    }
    function setValueForKnownAttribute(node, name, value) {
      if (null === value) node.removeAttribute(name);
      else {
        switch (typeof value) {
          case "undefined":
          case "function":
          case "symbol":
          case "boolean":
            node.removeAttribute(name);
            return;
        }
        checkAttributeStringCoercion(value, name);
        node.setAttribute(name, "" + value);
      }
    }
    function setValueForNamespacedAttribute(node, namespace, name, value) {
      if (null === value) node.removeAttribute(name);
      else {
        switch (typeof value) {
          case "undefined":
          case "function":
          case "symbol":
          case "boolean":
            node.removeAttribute(name);
            return;
        }
        checkAttributeStringCoercion(value, name);
        node.setAttributeNS(namespace, name, "" + value);
      }
    }
    function getToStringValue(value) {
      switch (typeof value) {
        case "bigint":
        case "boolean":
        case "number":
        case "string":
        case "undefined":
          return value;
        case "object":
          return checkFormFieldValueStringCoercion(value), value;
        default:
          return "";
      }
    }
    function isCheckable(elem) {
      var type = elem.type;
      return (
        (elem = elem.nodeName) &&
        "input" === elem.toLowerCase() &&
        ("checkbox" === type || "radio" === type)
      );
    }
    function trackValueOnNode(node, valueField, currentValue) {
      var descriptor = Object.getOwnPropertyDescriptor(
        node.constructor.prototype,
        valueField
      );
      if (
        !node.hasOwnProperty(valueField) &&
        "undefined" !== typeof descriptor &&
        "function" === typeof descriptor.get &&
        "function" === typeof descriptor.set
      ) {
        var get = descriptor.get,
          set = descriptor.set;
        Object.defineProperty(node, valueField, {
          configurable: !0,
          get: function () {
            return get.call(this);
          },
          set: function (value) {
            checkFormFieldValueStringCoercion(value);
            currentValue = "" + value;
            set.call(this, value);
          }
        });
        Object.defineProperty(node, valueField, {
          enumerable: descriptor.enumerable
        });
        return {
          getValue: function () {
            return currentValue;
          },
          setValue: function (value) {
            checkFormFieldValueStringCoercion(value);
            currentValue = "" + value;
          },
          stopTracking: function () {
            node._valueTracker = null;
            delete node[valueField];
          }
        };
      }
    }
    function track(node) {
      if (!node._valueTracker) {
        var valueField = isCheckable(node) ? "checked" : "value";
        node._valueTracker = trackValueOnNode(
          node,
          valueField,
          "" + node[valueField]
        );
      }
    }
    function updateValueIfChanged(node) {
      if (!node) return !1;
      var tracker = node._valueTracker;
      if (!tracker) return !0;
      var lastValue = tracker.getValue();
      var value = "";
      node &&
        (value = isCheckable(node)
          ? node.checked
            ? "true"
            : "false"
          : node.value);
      node = value;
      return node !== lastValue ? (tracker.setValue(node), !0) : !1;
    }
    function getActiveElement(doc) {
      doc = doc || ("undefined" !== typeof document ? document : void 0);
      if ("undefined" === typeof doc) return null;
      try {
        return doc.activeElement || doc.body;
      } catch (e) {
        return doc.body;
      }
    }
    function escapeSelectorAttributeValueInsideDoubleQuotes(value) {
      return value.replace(
        escapeSelectorAttributeValueInsideDoubleQuotesRegex,
        function (ch) {
          return "\\" + ch.charCodeAt(0).toString(16) + " ";
        }
      );
    }
    function validateInputProps(element, props) {
      void 0 === props.checked ||
        void 0 === props.defaultChecked ||
        didWarnCheckedDefaultChecked ||
        (console.error(
          "%s contains an input of type %s with both checked and defaultChecked props. Input elements must be either controlled or uncontrolled (specify either the checked prop, or the defaultChecked prop, but not both). Decide between using a controlled or uncontrolled input element and remove one of these props. More info: https://react.dev/link/controlled-components",
          getCurrentFiberOwnerNameInDevOrNull() || "A component",
          props.type
        ),
        (didWarnCheckedDefaultChecked = !0));
      void 0 === props.value ||
        void 0 === props.defaultValue ||
        didWarnValueDefaultValue$1 ||
        (console.error(
          "%s contains an input of type %s with both value and defaultValue props. Input elements must be either controlled or uncontrolled (specify either the value prop, or the defaultValue prop, but not both). Decide between using a controlled or uncontrolled input element and remove one of these props. More info: https://react.dev/link/controlled-components",
          getCurrentFiberOwnerNameInDevOrNull() || "A component",
          props.type
        ),
        (didWarnValueDefaultValue$1 = !0));
    }
    function updateInput(
      element,
      value,
      defaultValue,
      lastDefaultValue,
      checked,
      defaultChecked,
      type,
      name
    ) {
      element.name = "";
      null != type &&
      "function" !== typeof type &&
      "symbol" !== typeof type &&
      "boolean" !== typeof type
        ? (checkAttributeStringCoercion(type, "type"), (element.type = type))
        : element.removeAttribute("type");
      if (null != value)
        if ("number" === type) {
          if ((0 === value && "" === element.value) || element.value != value)
            element.value = "" + getToStringValue(value);
        } else
          element.value !== "" + getToStringValue(value) &&
            (element.value = "" + getToStringValue(value));
      else
        ("submit" !== type && "reset" !== type) ||
          element.removeAttribute("value");
      null != value
        ? setDefaultValue(element, type, getToStringValue(value))
        : null != defaultValue
          ? setDefaultValue(element, type, getToStringValue(defaultValue))
          : null != lastDefaultValue && element.removeAttribute("value");
      null == checked &&
        null != defaultChecked &&
        (element.defaultChecked = !!defaultChecked);
      null != checked &&
        (element.checked =
          checked &&
          "function" !== typeof checked &&
          "symbol" !== typeof checked);
      null != name &&
      "function" !== typeof name &&
      "symbol" !== typeof name &&
      "boolean" !== typeof name
        ? (checkAttributeStringCoercion(name, "name"),
          (element.name = "" + getToStringValue(name)))
        : element.removeAttribute("name");
    }
    function initInput(
      element,
      value,
      defaultValue,
      checked,
      defaultChecked,
      type,
      name,
      isHydrating
    ) {
      null != type &&
        "function" !== typeof type &&
        "symbol" !== typeof type &&
        "boolean" !== typeof type &&
        (checkAttributeStringCoercion(type, "type"), (element.type = type));
      if (null != value || null != defaultValue) {
        if (
          !(
            ("submit" !== type && "reset" !== type) ||
            (void 0 !== value && null !== value)
          )
        ) {
          track(element);
          return;
        }
        defaultValue =
          null != defaultValue ? "" + getToStringValue(defaultValue) : "";
        value = null != value ? "" + getToStringValue(value) : defaultValue;
        isHydrating || value === element.value || (element.value = value);
        element.defaultValue = value;
      }
      checked = null != checked ? checked : defaultChecked;
      checked =
        "function" !== typeof checked &&
        "symbol" !== typeof checked &&
        !!checked;
      element.checked = isHydrating ? element.checked : !!checked;
      element.defaultChecked = !!checked;
      null != name &&
        "function" !== typeof name &&
        "symbol" !== typeof name &&
        "boolean" !== typeof name &&
        (checkAttributeStringCoercion(name, "name"), (element.name = name));
      track(element);
    }
    function setDefaultValue(node, type, value) {
      ("number" === type && getActiveElement(node.ownerDocument) === node) ||
        node.defaultValue === "" + value ||
        (node.defaultValue = "" + value);
    }
    function validateOptionProps(element, props) {
      null == props.value &&
        ("object" === typeof props.children && null !== props.children
          ? React.Children.forEach(props.children, function (child) {
              null == child ||
                "string" === typeof child ||
                "number" === typeof child ||
                "bigint" === typeof child ||
                didWarnInvalidChild ||
                ((didWarnInvalidChild = !0),
                console.error(
                  "Cannot infer the option value of complex children. Pass a `value` prop or use a plain string as children to <option>."
                ));
            })
          : null == props.dangerouslySetInnerHTML ||
            didWarnInvalidInnerHTML ||
            ((didWarnInvalidInnerHTML = !0),
            console.error(
              "Pass a `value` prop if you set dangerouslyInnerHTML so React knows which value should be selected."
            )));
      null == props.selected ||
        didWarnSelectedSetOnOption ||
        (console.error(
          "Use the `defaultValue` or `value` props on <select> instead of setting `selected` on <option>."
        ),
        (didWarnSelectedSetOnOption = !0));
    }
    function getDeclarationErrorAddendum() {
      var ownerName = getCurrentFiberOwnerNameInDevOrNull();
      return ownerName
        ? "\n\nCheck the render method of `" + ownerName + "`."
        : "";
    }
    function updateOptions(node, multiple, propValue, setDefaultSelected) {
      node = node.options;
      if (multiple) {
        multiple = {};
        for (var i = 0; i < propValue.length; i++)
          multiple["$" + propValue[i]] = !0;
        for (propValue = 0; propValue < node.length; propValue++)
          (i = multiple.hasOwnProperty("$" + node[propValue].value)),
            node[propValue].selected !== i && (node[propValue].selected = i),
            i && setDefaultSelected && (node[propValue].defaultSelected = !0);
      } else {
        propValue = "" + getToStringValue(propValue);
        multiple = null;
        for (i = 0; i < node.length; i++) {
          if (node[i].value === propValue) {
            node[i].selected = !0;
            setDefaultSelected && (node[i].defaultSelected = !0);
            return;
          }
          null !== multiple || node[i].disabled || (multiple = node[i]);
        }
        null !== multiple && (multiple.selected = !0);
      }
    }
    function validateSelectProps(element, props) {
      for (element = 0; element < valuePropNames.length; element++) {
        var propName = valuePropNames[element];
        if (null != props[propName]) {
          var propNameIsArray = isArrayImpl(props[propName]);
          props.multiple && !propNameIsArray
            ? console.error(
                "The `%s` prop supplied to <select> must be an array if `multiple` is true.%s",
                propName,
                getDeclarationErrorAddendum()
              )
            : !props.multiple &&
              propNameIsArray &&
              console.error(
                "The `%s` prop supplied to <select> must be a scalar value if `multiple` is false.%s",
                propName,
                getDeclarationErrorAddendum()
              );
        }
      }
      void 0 === props.value ||
        void 0 === props.defaultValue ||
        didWarnValueDefaultValue ||
        (console.error(
          "Select elements must be either controlled or uncontrolled (specify either the value prop, or the defaultValue prop, but not both). Decide between using a controlled or uncontrolled select element and remove one of these props. More info: https://react.dev/link/controlled-components"
        ),
        (didWarnValueDefaultValue = !0));
    }
    function validateTextareaProps(element, props) {
      void 0 === props.value ||
        void 0 === props.defaultValue ||
        didWarnValDefaultVal ||
        (console.error(
          "%s contains a textarea with both value and defaultValue props. Textarea elements must be either controlled or uncontrolled (specify either the value prop, or the defaultValue prop, but not both). Decide between using a controlled or uncontrolled textarea and remove one of these props. More info: https://react.dev/link/controlled-components",
          getCurrentFiberOwnerNameInDevOrNull() || "A component"
        ),
        (didWarnValDefaultVal = !0));
      null != props.children &&
        null == props.value &&
        console.error(
          "Use the `defaultValue` or `value` props instead of setting children on <textarea>."
        );
    }
    function updateTextarea(element, value, defaultValue) {
      if (
        null != value &&
        ((value = "" + getToStringValue(value)),
        value !== element.value && (element.value = value),
        null == defaultValue)
      ) {
        element.defaultValue !== value && (element.defaultValue = value);
        return;
      }
      element.defaultValue =
        null != defaultValue ? "" + getToStringValue(defaultValue) : "";
    }
    function initTextarea(element, value, defaultValue, children) {
      if (null == value) {
        if (null != children) {
          if (null != defaultValue)
            throw Error(
              "If you supply `defaultValue` on a <textarea>, do not pass children."
            );
          if (isArrayImpl(children)) {
            if (1 < children.length)
              throw Error("<textarea> can only have at most one child.");
            children = children[0];
          }
          defaultValue = children;
        }
        null == defaultValue && (defaultValue = "");
        value = defaultValue;
      }
      defaultValue = getToStringValue(value);
      element.defaultValue = defaultValue;
      children = element.textContent;
      children === defaultValue &&
        "" !== children &&
        null !== children &&
        (element.value = children);
      track(element);
    }
    function findNotableNode(node, indent) {
      return void 0 === node.serverProps &&
        0 === node.serverTail.length &&
        1 === node.children.length &&
        3 < node.distanceFromLeaf &&
        node.distanceFromLeaf > 15 - indent
        ? findNotableNode(node.children[0], indent)
        : node;
    }
    function indentation(indent) {
      return "  " + "  ".repeat(indent);
    }
    function added(indent) {
      return "+ " + "  ".repeat(indent);
    }
    function removed(indent) {
      return "- " + "  ".repeat(indent);
    }
    function describeFiberType(fiber) {
      switch (fiber.tag) {
        case 26:
        case 27:
        case 5:
          return fiber.type;
        case 16:
          return "Lazy";
        case 31:
          return "Activity";
        case 13:
          return "Suspense";
        case 19:
          return "SuspenseList";
        case 0:
        case 15:
          return (fiber = fiber.type), fiber.displayName || fiber.name || null;
        case 11:
          return (
            (fiber = fiber.type.render), fiber.displayName || fiber.name || null
          );
        case 1:
          return (fiber = fiber.type), fiber.displayName || fiber.name || null;
        default:
          return null;
      }
    }
    function describeTextNode(content, maxLength) {
      return needsEscaping.test(content)
        ? ((content = JSON.stringify(content)),
          content.length > maxLength - 2
            ? 8 > maxLength
              ? '{"..."}'
              : "{" + content.slice(0, maxLength - 7) + '..."}'
            : "{" + content + "}")
        : content.length > maxLength
          ? 5 > maxLength
            ? '{"..."}'
            : content.slice(0, maxLength - 3) + "..."
          : content;
    }
    function describeTextDiff(clientText, serverProps, indent) {
      var maxLength = 120 - 2 * indent;
      if (null === serverProps)
        return added(indent) + describeTextNode(clientText, maxLength) + "\n";
      if ("string" === typeof serverProps) {
        for (
          var firstDiff = 0;
          firstDiff < serverProps.length &&
          firstDiff < clientText.length &&
          serverProps.charCodeAt(firstDiff) ===
            clientText.charCodeAt(firstDiff);
          firstDiff++
        );
        firstDiff > maxLength - 8 &&
          10 < firstDiff &&
          ((clientText = "..." + clientText.slice(firstDiff - 8)),
          (serverProps = "..." + serverProps.slice(firstDiff - 8)));
        return (
          added(indent) +
          describeTextNode(clientText, maxLength) +
          "\n" +
          removed(indent) +
          describeTextNode(serverProps, maxLength) +
          "\n"
        );
      }
      return (
        indentation(indent) + describeTextNode(clientText, maxLength) + "\n"
      );
    }
    function objectName(object) {
      return Object.prototype.toString
        .call(object)
        .replace(/^\[object (.*)\]$/, function (m, p0) {
          return p0;
        });
    }
    function describeValue(value, maxLength) {
      switch (typeof value) {
        case "string":
          return (
            (value = JSON.stringify(value)),
            value.length > maxLength
              ? 5 > maxLength
                ? '"..."'
                : value.slice(0, maxLength - 4) + '..."'
              : value
          );
        case "object":
          if (null === value) return "null";
          if (isArrayImpl(value)) return "[...]";
          if (value.$$typeof === REACT_ELEMENT_TYPE)
            return (maxLength = getComponentNameFromType(value.type))
              ? "<" + maxLength + ">"
              : "<...>";
          var name = objectName(value);
          if ("Object" === name) {
            name = "";
            maxLength -= 2;
            for (var propName in value)
              if (value.hasOwnProperty(propName)) {
                var jsonPropName = JSON.stringify(propName);
                jsonPropName !== '"' + propName + '"' &&
                  (propName = jsonPropName);
                maxLength -= propName.length - 2;
                jsonPropName = describeValue(
                  value[propName],
                  15 > maxLength ? maxLength : 15
                );
                maxLength -= jsonPropName.length;
                if (0 > maxLength) {
                  name += "" === name ? "..." : ", ...";
                  break;
                }
                name +=
                  ("" === name ? "" : ",") + propName + ":" + jsonPropName;
              }
            return "{" + name + "}";
          }
          return name;
        case "function":
          return (maxLength = value.displayName || value.name)
            ? "function " + maxLength
            : "function";
        default:
          return String(value);
      }
    }
    function describePropValue(value, maxLength) {
      return "string" !== typeof value || needsEscaping.test(value)
        ? "{" + describeValue(value, maxLength - 2) + "}"
        : value.length > maxLength - 2
          ? 5 > maxLength
            ? '"..."'
            : '"' + value.slice(0, maxLength - 5) + '..."'
          : '"' + value + '"';
    }
    function describeExpandedElement(type, props, rowPrefix) {
      var remainingRowLength = 120 - rowPrefix.length - type.length,
        properties = [],
        propName;
      for (propName in props)
        if (props.hasOwnProperty(propName) && "children" !== propName) {
          var propValue = describePropValue(
            props[propName],
            120 - rowPrefix.length - propName.length - 1
          );
          remainingRowLength -= propName.length + propValue.length + 2;
          properties.push(propName + "=" + propValue);
        }
      return 0 === properties.length
        ? rowPrefix + "<" + type + ">\n"
        : 0 < remainingRowLength
          ? rowPrefix + "<" + type + " " + properties.join(" ") + ">\n"
          : rowPrefix +
            "<" +
            type +
            "\n" +
            rowPrefix +
            "  " +
            properties.join("\n" + rowPrefix + "  ") +
            "\n" +
            rowPrefix +
            ">\n";
    }
    function describePropertiesDiff(clientObject, serverObject, indent) {
      var properties = "",
        remainingServerProperties = assign({}, serverObject),
        propName;
      for (propName in clientObject)
        if (clientObject.hasOwnProperty(propName)) {
          delete remainingServerProperties[propName];
          var maxLength = 120 - 2 * indent - propName.length - 2,
            clientPropValue = describeValue(clientObject[propName], maxLength);
          serverObject.hasOwnProperty(propName)
            ? ((maxLength = describeValue(serverObject[propName], maxLength)),
              (properties +=
                added(indent) + propName + ": " + clientPropValue + "\n"),
              (properties +=
                removed(indent) + propName + ": " + maxLength + "\n"))
            : (properties +=
                added(indent) + propName + ": " + clientPropValue + "\n");
        }
      for (var _propName in remainingServerProperties)
        remainingServerProperties.hasOwnProperty(_propName) &&
          ((clientObject = describeValue(
            remainingServerProperties[_propName],
            120 - 2 * indent - _propName.length - 2
          )),
          (properties +=
            removed(indent) + _propName + ": " + clientObject + "\n"));
      return properties;
    }
    function describeElementDiff(type, clientProps, serverProps, indent) {
      var content = "",
        serverPropNames = new Map();
      for (propName$jscomp$0 in serverProps)
        serverProps.hasOwnProperty(propName$jscomp$0) &&
          serverPropNames.set(
            propName$jscomp$0.toLowerCase(),
            propName$jscomp$0
          );
      if (1 === serverPropNames.size && serverPropNames.has("children"))
        content += describeExpandedElement(
          type,
          clientProps,
          indentation(indent)
        );
      else {
        for (var _propName2 in clientProps)
          if (
            clientProps.hasOwnProperty(_propName2) &&
            "children" !== _propName2
          ) {
            var maxLength$jscomp$0 =
                120 - 2 * (indent + 1) - _propName2.length - 1,
              serverPropName = serverPropNames.get(_propName2.toLowerCase());
            if (void 0 !== serverPropName) {
              serverPropNames.delete(_propName2.toLowerCase());
              var propName$jscomp$0 = clientProps[_propName2];
              serverPropName = serverProps[serverPropName];
              var clientPropValue = describePropValue(
                propName$jscomp$0,
                maxLength$jscomp$0
              );
              maxLength$jscomp$0 = describePropValue(
                serverPropName,
                maxLength$jscomp$0
              );
              "object" === typeof propName$jscomp$0 &&
              null !== propName$jscomp$0 &&
              "object" === typeof serverPropName &&
              null !== serverPropName &&
              "Object" === objectName(propName$jscomp$0) &&
              "Object" === objectName(serverPropName) &&
              (2 < Object.keys(propName$jscomp$0).length ||
                2 < Object.keys(serverPropName).length ||
                -1 < clientPropValue.indexOf("...") ||
                -1 < maxLength$jscomp$0.indexOf("..."))
                ? (content +=
                    indentation(indent + 1) +
                    _propName2 +
                    "={{\n" +
                    describePropertiesDiff(
                      propName$jscomp$0,
                      serverPropName,
                      indent + 2
                    ) +
                    indentation(indent + 1) +
                    "}}\n")
                : ((content +=
                    added(indent + 1) +
                    _propName2 +
                    "=" +
                    clientPropValue +
                    "\n"),
                  (content +=
                    removed(indent + 1) +
                    _propName2 +
                    "=" +
                    maxLength$jscomp$0 +
                    "\n"));
            } else
              content +=
                indentation(indent + 1) +
                _propName2 +
                "=" +
                describePropValue(clientProps[_propName2], maxLength$jscomp$0) +
                "\n";
          }
        serverPropNames.forEach(function (propName) {
          if ("children" !== propName) {
            var maxLength = 120 - 2 * (indent + 1) - propName.length - 1;
            content +=
              removed(indent + 1) +
              propName +
              "=" +
              describePropValue(serverProps[propName], maxLength) +
              "\n";
          }
        });
        content =
          "" === content
            ? indentation(indent) + "<" + type + ">\n"
            : indentation(indent) +
              "<" +
              type +
              "\n" +
              content +
              indentation(indent) +
              ">\n";
      }
      type = serverProps.children;
      clientProps = clientProps.children;
      if (
        "string" === typeof type ||
        "number" === typeof type ||
        "bigint" === typeof type
      ) {
        serverPropNames = "";
        if (
          "string" === typeof clientProps ||
          "number" === typeof clientProps ||
          "bigint" === typeof clientProps
        )
          serverPropNames = "" + clientProps;
        content += describeTextDiff(serverPropNames, "" + type, indent + 1);
      } else if (
        "string" === typeof clientProps ||
        "number" === typeof clientProps ||
        "bigint" === typeof clientProps
      )
        content =
          null == type
            ? content + describeTextDiff("" + clientProps, null, indent + 1)
            : content + describeTextDiff("" + clientProps, void 0, indent + 1);
      return content;
    }
    function describeSiblingFiber(fiber, indent) {
      var type = describeFiberType(fiber);
      if (null === type) {
        type = "";
        for (fiber = fiber.child; fiber; )
          (type += describeSiblingFiber(fiber, indent)),
            (fiber = fiber.sibling);
        return type;
      }
      return indentation(indent) + "<" + type + ">\n";
    }
    function describeNode(node, indent) {
      var skipToNode = findNotableNode(node, indent);
      if (
        skipToNode !== node &&
        (1 !== node.children.length || node.children[0] !== skipToNode)
      )
        return (
          indentation(indent) + "...\n" + describeNode(skipToNode, indent + 1)
        );
      skipToNode = "";
      var debugInfo = node.fiber._debugInfo;
      if (debugInfo)
        for (var i = 0; i < debugInfo.length; i++) {
          var serverComponentName = debugInfo[i].name;
          "string" === typeof serverComponentName &&
            ((skipToNode +=
              indentation(indent) + "<" + serverComponentName + ">\n"),
            indent++);
        }
      debugInfo = "";
      i = node.fiber.pendingProps;
      if (6 === node.fiber.tag)
        (debugInfo = describeTextDiff(i, node.serverProps, indent)), indent++;
      else if (
        ((serverComponentName = describeFiberType(node.fiber)),
        null !== serverComponentName)
      )
        if (void 0 === node.serverProps) {
          debugInfo = indent;
          var maxLength = 120 - 2 * debugInfo - serverComponentName.length - 2,
            content = "";
          for (propName in i)
            if (i.hasOwnProperty(propName) && "children" !== propName) {
              var propValue = describePropValue(i[propName], 15);
              maxLength -= propName.length + propValue.length + 2;
              if (0 > maxLength) {
                content += " ...";
                break;
              }
              content += " " + propName + "=" + propValue;
            }
          debugInfo =
            indentation(debugInfo) +
            "<" +
            serverComponentName +
            content +
            ">\n";
          indent++;
        } else
          null === node.serverProps
            ? ((debugInfo = describeExpandedElement(
                serverComponentName,
                i,
                added(indent)
              )),
              indent++)
            : "string" === typeof node.serverProps
              ? console.error(
                  "Should not have matched a non HostText fiber to a Text node. This is a bug in React."
                )
              : ((debugInfo = describeElementDiff(
                  serverComponentName,
                  i,
                  node.serverProps,
                  indent
                )),
                indent++);
      var propName = "";
      i = node.fiber.child;
      for (
        serverComponentName = 0;
        i && serverComponentName < node.children.length;

      )
        (maxLength = node.children[serverComponentName]),
          maxLength.fiber === i
            ? ((propName += describeNode(maxLength, indent)),
              serverComponentName++)
            : (propName += describeSiblingFiber(i, indent)),
          (i = i.sibling);
      i &&
        0 < node.children.length &&
        (propName += indentation(indent) + "...\n");
      i = node.serverTail;
      null === node.serverProps && indent--;
      for (node = 0; node < i.length; node++)
        (serverComponentName = i[node]),
          (propName =
            "string" === typeof serverComponentName
              ? propName +
                (removed(indent) +
                  describeTextNode(serverComponentName, 120 - 2 * indent) +
                  "\n")
              : propName +
                describeExpandedElement(
                  serverComponentName.type,
                  serverComponentName.props,
                  removed(indent)
                ));
      return skipToNode + debugInfo + propName;
    }
    function describeDiff(rootNode) {
      try {
        return "\n\n" + describeNode(rootNode, 0);
      } catch (x) {
        return "";
      }
    }
    function describeAncestors(ancestor, child, props) {
      for (var fiber = child, node = null, distanceFromLeaf = 0; fiber; )
        fiber === ancestor && (distanceFromLeaf = 0),
          (node = {
            fiber: fiber,
            children: null !== node ? [node] : [],
            serverProps:
              fiber === child ? props : fiber === ancestor ? null : void 0,
            serverTail: [],
            distanceFromLeaf: distanceFromLeaf
          }),
          distanceFromLeaf++,
          (fiber = fiber.return);
      return null !== node ? describeDiff(node).replaceAll(/^[+-]/gm, ">") : "";
    }
    function updatedAncestorInfoDev(oldInfo, tag) {
      var ancestorInfo = assign({}, oldInfo || emptyAncestorInfoDev),
        info = { tag: tag };
      -1 !== inScopeTags.indexOf(tag) &&
        ((ancestorInfo.aTagInScope = null),
        (ancestorInfo.buttonTagInScope = null),
        (ancestorInfo.nobrTagInScope = null));
      -1 !== buttonScopeTags.indexOf(tag) &&
        (ancestorInfo.pTagInButtonScope = null);
      -1 !== specialTags.indexOf(tag) &&
        "address" !== tag &&
        "div" !== tag &&
        "p" !== tag &&
        ((ancestorInfo.listItemTagAutoclosing = null),
        (ancestorInfo.dlItemTagAutoclosing = null));
      ancestorInfo.current = info;
      "form" === tag && (ancestorInfo.formTag = info);
      "a" === tag && (ancestorInfo.aTagInScope = info);
      "button" === tag && (ancestorInfo.buttonTagInScope = info);
      "nobr" === tag && (ancestorInfo.nobrTagInScope = info);
      "p" === tag && (ancestorInfo.pTagInButtonScope = info);
      "li" === tag && (ancestorInfo.listItemTagAutoclosing = info);
      if ("dd" === tag || "dt" === tag)
        ancestorInfo.dlItemTagAutoclosing = info;
      "#document" === tag || "html" === tag
        ? (ancestorInfo.containerTagInScope = null)
        : ancestorInfo.containerTagInScope ||
          (ancestorInfo.containerTagInScope = info);
      null !== oldInfo ||
      ("#document" !== tag && "html" !== tag && "body" !== tag)
        ? !0 === ancestorInfo.implicitRootScope &&
          (ancestorInfo.implicitRootScope = !1)
        : (ancestorInfo.implicitRootScope = !0);
      return ancestorInfo;
    }
    function isTagValidWithParent(tag, parentTag, implicitRootScope) {
      switch (parentTag) {
        case "select":
          return (
            "hr" === tag ||
            "option" === tag ||
            "optgroup" === tag ||
            "script" === tag ||
            "template" === tag ||
            "#text" === tag
          );
        case "optgroup":
          return "option" === tag || "#text" === tag;
        case "option":
          return "#text" === tag;
        case "tr":
          return (
            "th" === tag ||
            "td" === tag ||
            "style" === tag ||
            "script" === tag ||
            "template" === tag
          );
        case "tbody":
        case "thead":
        case "tfoot":
          return (
            "tr" === tag ||
            "style" === tag ||
            "script" === tag ||
            "template" === tag
          );
        case "colgroup":
          return "col" === tag || "template" === tag;
        case "table":
          return (
            "caption" === tag ||
            "colgroup" === tag ||
            "tbody" === tag ||
            "tfoot" === tag ||
            "thead" === tag ||
            "style" === tag ||
            "script" === tag ||
            "template" === tag
          );
        case "head":
          return (
            "base" === tag ||
            "basefont" === tag ||
            "bgsound" === tag ||
            "link" === tag ||
            "meta" === tag ||
            "title" === tag ||
            "noscript" === tag ||
            "noframes" === tag ||
            "style" === tag ||
            "script" === tag ||
            "template" === tag
          );
        case "html":
          if (implicitRootScope) break;
          return "head" === tag || "body" === tag || "frameset" === tag;
        case "frameset":
          return "frame" === tag;
        case "#document":
          if (!implicitRootScope) return "html" === tag;
      }
      switch (tag) {
        case "h1":
        case "h2":
        case "h3":
        case "h4":
        case "h5":
        case "h6":
          return (
            "h1" !== parentTag &&
            "h2" !== parentTag &&
            "h3" !== parentTag &&
            "h4" !== parentTag &&
            "h5" !== parentTag &&
            "h6" !== parentTag
          );
        case "rp":
        case "rt":
          return -1 === impliedEndTags.indexOf(parentTag);
        case "caption":
        case "col":
        case "colgroup":
        case "frameset":
        case "frame":
        case "tbody":
        case "td":
        case "tfoot":
        case "th":
        case "thead":
        case "tr":
          return null == parentTag;
        case "head":
          return implicitRootScope || null === parentTag;
        case "html":
          return (
            (implicitRootScope && "#document" === parentTag) ||
            null === parentTag
          );
        case "body":
          return (
            (implicitRootScope &&
              ("#document" === parentTag || "html" === parentTag)) ||
            null === parentTag
          );
      }
      return !0;
    }
    function findInvalidAncestorForTag(tag, ancestorInfo) {
      switch (tag) {
        case "address":
        case "article":
        case "aside":
        case "blockquote":
        case "center":
        case "details":
        case "dialog":
        case "dir":
        case "div":
        case "dl":
        case "fieldset":
        case "figcaption":
        case "figure":
        case "footer":
        case "header":
        case "hgroup":
        case "main":
        case "menu":
        case "nav":
        case "ol":
        case "p":
        case "section":
        case "summary":
        case "ul":
        case "pre":
        case "listing":
        case "table":
        case "hr":
        case "xmp":
        case "h1":
        case "h2":
        case "h3":
        case "h4":
        case "h5":
        case "h6":
          return ancestorInfo.pTagInButtonScope;
        case "form":
          return ancestorInfo.formTag || ancestorInfo.pTagInButtonScope;
        case "li":
          return ancestorInfo.listItemTagAutoclosing;
        case "dd":
        case "dt":
          return ancestorInfo.dlItemTagAutoclosing;
        case "button":
          return ancestorInfo.buttonTagInScope;
        case "a":
          return ancestorInfo.aTagInScope;
        case "nobr":
          return ancestorInfo.nobrTagInScope;
      }
      return null;
    }
    function findAncestor(parent, tagName) {
      for (; parent; ) {
        switch (parent.tag) {
          case 5:
          case 26:
          case 27:
            if (parent.type === tagName) return parent;
        }
        parent = parent.return;
      }
      return null;
    }
    function validateDOMNesting(childTag, ancestorInfo) {
      ancestorInfo = ancestorInfo || emptyAncestorInfoDev;
      var parentInfo = ancestorInfo.current;
      ancestorInfo = (parentInfo = isTagValidWithParent(
        childTag,
        parentInfo && parentInfo.tag,
        ancestorInfo.implicitRootScope
      )
        ? null
        : parentInfo)
        ? null
        : findInvalidAncestorForTag(childTag, ancestorInfo);
      ancestorInfo = parentInfo || ancestorInfo;
      if (!ancestorInfo) return !0;
      var ancestorTag = ancestorInfo.tag;
      ancestorInfo = String(!!parentInfo) + "|" + childTag + "|" + ancestorTag;
      if (didWarn[ancestorInfo]) return !1;
      didWarn[ancestorInfo] = !0;
      var ancestor = (ancestorInfo = current)
          ? findAncestor(ancestorInfo.return, ancestorTag)
          : null,
        ancestorDescription =
          null !== ancestorInfo && null !== ancestor
            ? describeAncestors(ancestor, ancestorInfo, null)
            : "",
        tagDisplayName = "<" + childTag + ">";
      parentInfo
        ? ((parentInfo = ""),
          "table" === ancestorTag &&
            "tr" === childTag &&
            (parentInfo +=
              " Add a <tbody>, <thead> or <tfoot> to your code to match the DOM tree generated by the browser."),
          console.error(
            "In HTML, %s cannot be a child of <%s>.%s\nThis will cause a hydration error.%s",
            tagDisplayName,
            ancestorTag,
            parentInfo,
            ancestorDescription
          ))
        : console.error(
            "In HTML, %s cannot be a descendant of <%s>.\nThis will cause a hydration error.%s",
            tagDisplayName,
            ancestorTag,
            ancestorDescription
          );
      ancestorInfo &&
        ((childTag = ancestorInfo.return),
        null === ancestor ||
          null === childTag ||
          (ancestor === childTag &&
            childTag._debugOwner === ancestorInfo._debugOwner) ||
          runWithFiberInDEV(ancestor, function () {
            console.error(
              "<%s> cannot contain a nested %s.\nSee this log for the ancestor stack trace.",
              ancestorTag,
              tagDisplayName
            );
          }));
      return !1;
    }
    function validateTextNesting(childText, parentTag, implicitRootScope) {
      if (implicitRootScope || isTagValidWithParent("#text", parentTag, !1))
        return !0;
      implicitRootScope = "#text|" + parentTag;
      if (didWarn[implicitRootScope]) return !1;
      didWarn[implicitRootScope] = !0;
      var ancestor = (implicitRootScope = current)
        ? findAncestor(implicitRootScope, parentTag)
        : null;
      implicitRootScope =
        null !== implicitRootScope && null !== ancestor
          ? describeAncestors(
              ancestor,
              implicitRootScope,
              6 !== implicitRootScope.tag ? { children: null } : null
            )
          : "";
      /\S/.test(childText)
        ? console.error(
            "In HTML, text nodes cannot be a child of <%s>.\nThis will cause a hydration error.%s",
            parentTag,
            implicitRootScope
          )
        : console.error(
            "In HTML, whitespace text nodes cannot be a child of <%s>. Make sure you don't have any extra whitespace between tags on each line of your source code.\nThis will cause a hydration error.%s",
            parentTag,
            implicitRootScope
          );
      return !1;
    }
    function setTextContent(node, text) {
      if (text) {
        var firstChild = node.firstChild;
        if (
          firstChild &&
          firstChild === node.lastChild &&
          3 === firstChild.nodeType
        ) {
          firstChild.nodeValue = text;
          return;
        }
      }
      node.textContent = text;
    }
    function camelize(string) {
      return string.replace(hyphenPattern, function (_, character) {
        return character.toUpperCase();
      });
    }
    function setValueForStyle(style, styleName, value) {
      var isCustomProperty = 0 === styleName.indexOf("--");
      isCustomProperty ||
        (-1 < styleName.indexOf("-")
          ? (warnedStyleNames.hasOwnProperty(styleName) &&
              warnedStyleNames[styleName]) ||
            ((warnedStyleNames[styleName] = !0),
            console.error(
              "Unsupported style property %s. Did you mean %s?",
              styleName,
              camelize(styleName.replace(msPattern, "ms-"))
            ))
          : badVendoredStyleNamePattern.test(styleName)
            ? (warnedStyleNames.hasOwnProperty(styleName) &&
                warnedStyleNames[styleName]) ||
              ((warnedStyleNames[styleName] = !0),
              console.error(
                "Unsupported vendor-prefixed style property %s. Did you mean %s?",
                styleName,
                styleName.charAt(0).toUpperCase() + styleName.slice(1)
              ))
            : !badStyleValueWithSemicolonPattern.test(value) ||
              (warnedStyleValues.hasOwnProperty(value) &&
                warnedStyleValues[value]) ||
              ((warnedStyleValues[value] = !0),
              console.error(
                'Style property values shouldn\'t contain a semicolon. Try "%s: %s" instead.',
                styleName,
                value.replace(badStyleValueWithSemicolonPattern, "")
              )),
        "number" === typeof value &&
          (isNaN(value)
            ? warnedForNaNValue ||
              ((warnedForNaNValue = !0),
              console.error(
                "`NaN` is an invalid value for the `%s` css style property.",
                styleName
              ))
            : isFinite(value) ||
              warnedForInfinityValue ||
              ((warnedForInfinityValue = !0),
              console.error(
                "`Infinity` is an invalid value for the `%s` css style property.",
                styleName
              ))));
      null == value || "boolean" === typeof value || "" === value
        ? isCustomProperty
          ? style.setProperty(styleName, "")
          : "float" === styleName
            ? (style.cssFloat = "")
            : (style[styleName] = "")
        : isCustomProperty
          ? style.setProperty(styleName, value)
          : "number" !== typeof value ||
              0 === value ||
              unitlessNumbers.has(styleName)
            ? "float" === styleName
              ? (style.cssFloat = value)
              : (checkCSSPropertyStringCoercion(value, styleName),
                (style[styleName] = ("" + value).trim()))
            : (style[styleName] = value + "px");
    }
    function setValueForStyles(node, styles, prevStyles) {
      if (null != styles && "object" !== typeof styles)
        throw Error(
          "The `style` prop expects a mapping from style properties to values, not a string. For example, style={{marginRight: spacing + 'em'}} when using JSX."
        );
      styles && Object.freeze(styles);
      node = node.style;
      if (null != prevStyles) {
        if (styles) {
          var expandedUpdates = {};
          if (prevStyles)
            for (var key in prevStyles)
              if (prevStyles.hasOwnProperty(key) && !styles.hasOwnProperty(key))
                for (
                  var longhands = shorthandToLonghand[key] || [key], i = 0;
                  i < longhands.length;
                  i++
                )
                  expandedUpdates[longhands[i]] = key;
          for (var _key in styles)
            if (
              styles.hasOwnProperty(_key) &&
              (!prevStyles || prevStyles[_key] !== styles[_key])
            )
              for (
                key = shorthandToLonghand[_key] || [_key], longhands = 0;
                longhands < key.length;
                longhands++
              )
                expandedUpdates[key[longhands]] = _key;
          _key = {};
          for (var key$jscomp$0 in styles)
            for (
              key = shorthandToLonghand[key$jscomp$0] || [key$jscomp$0],
                longhands = 0;
              longhands < key.length;
              longhands++
            )
              _key[key[longhands]] = key$jscomp$0;
          key$jscomp$0 = {};
          for (var _key2 in expandedUpdates)
            if (
              ((key = expandedUpdates[_key2]),
              (longhands = _key[_key2]) &&
                key !== longhands &&
                ((i = key + "," + longhands), !key$jscomp$0[i]))
            ) {
              key$jscomp$0[i] = !0;
              i = console;
              var value = styles[key];
              i.error.call(
                i,
                "%s a style property during rerender (%s) when a conflicting property is set (%s) can lead to styling bugs. To avoid this, don't mix shorthand and non-shorthand properties for the same value; instead, replace the shorthand with separate values.",
                null == value || "boolean" === typeof value || "" === value
                  ? "Removing"
                  : "Updating",
                key,
                longhands
              );
            }
        }
        for (var styleName in prevStyles)
          !prevStyles.hasOwnProperty(styleName) ||
            (null != styles && styles.hasOwnProperty(styleName)) ||
            (0 === styleName.indexOf("--")
              ? node.setProperty(styleName, "")
              : "float" === styleName
                ? (node.cssFloat = "")
                : (node[styleName] = ""));
        for (var _styleName in styles)
          (_key2 = styles[_styleName]),
            styles.hasOwnProperty(_styleName) &&
              prevStyles[_styleName] !== _key2 &&
              setValueForStyle(node, _styleName, _key2);
      } else
        for (expandedUpdates in styles)
          styles.hasOwnProperty(expandedUpdates) &&
            setValueForStyle(node, expandedUpdates, styles[expandedUpdates]);
    }
    function isCustomElement(tagName) {
      if (-1 === tagName.indexOf("-")) return !1;
      switch (tagName) {
        case "annotation-xml":
        case "color-profile":
        case "font-face":
        case "font-face-src":
        case "font-face-uri":
        case "font-face-format":
        case "font-face-name":
        case "missing-glyph":
          return !1;
        default:
          return !0;
      }
    }
    function getAttributeAlias(name) {
      return aliases.get(name) || name;
    }
    function validateProperty$1(tagName, name) {
      if (
        hasOwnProperty.call(warnedProperties$1, name) &&
        warnedProperties$1[name]
      )
        return !0;
      if (rARIACamel$1.test(name)) {
        tagName = "aria-" + name.slice(4).toLowerCase();
        tagName = ariaProperties.hasOwnProperty(tagName) ? tagName : null;
        if (null == tagName)
          return (
            console.error(
              "Invalid ARIA attribute `%s`. ARIA attributes follow the pattern aria-* and must be lowercase.",
              name
            ),
            (warnedProperties$1[name] = !0)
          );
        if (name !== tagName)
          return (
            console.error(
              "Invalid ARIA attribute `%s`. Did you mean `%s`?",
              name,
              tagName
            ),
            (warnedProperties$1[name] = !0)
          );
      }
      if (rARIA$1.test(name)) {
        tagName = name.toLowerCase();
        tagName = ariaProperties.hasOwnProperty(tagName) ? tagName : null;
        if (null == tagName) return (warnedProperties$1[name] = !0), !1;
        name !== tagName &&
          (console.error(
            "Unknown ARIA attribute `%s`. Did you mean `%s`?",
            name,
            tagName
          ),
          (warnedProperties$1[name] = !0));
      }
      return !0;
    }
    function validateProperties$2(type, props) {
      var invalidProps = [],
        key;
      for (key in props)
        validateProperty$1(type, key) || invalidProps.push(key);
      props = invalidProps
        .map(function (prop) {
          return "`" + prop + "`";
        })
        .join(", ");
      1 === invalidProps.length
        ? console.error(
            "Invalid aria prop %s on <%s> tag. For details, see https://react.dev/link/invalid-aria-props",
            props,
            type
          )
        : 1 < invalidProps.length &&
          console.error(
            "Invalid aria props %s on <%s> tag. For details, see https://react.dev/link/invalid-aria-props",
            props,
            type
          );
    }
    function validateProperty(tagName, name, value, eventRegistry) {
      if (hasOwnProperty.call(warnedProperties, name) && warnedProperties[name])
        return !0;
      var lowerCasedName = name.toLowerCase();
      if ("onfocusin" === lowerCasedName || "onfocusout" === lowerCasedName)
        return (
          console.error(
            "React uses onFocus and onBlur instead of onFocusIn and onFocusOut. All React events are normalized to bubble, so onFocusIn and onFocusOut are not needed/supported by React."
          ),
          (warnedProperties[name] = !0)
        );
      if (
        "function" === typeof value &&
        (("form" === tagName && "action" === name) ||
          ("input" === tagName && "formAction" === name) ||
          ("button" === tagName && "formAction" === name))
      )
        return !0;
      if (null != eventRegistry) {
        tagName = eventRegistry.possibleRegistrationNames;
        if (eventRegistry.registrationNameDependencies.hasOwnProperty(name))
          return !0;
        eventRegistry = tagName.hasOwnProperty(lowerCasedName)
          ? tagName[lowerCasedName]
          : null;
        if (null != eventRegistry)
          return (
            console.error(
              "Invalid event handler property `%s`. Did you mean `%s`?",
              name,
              eventRegistry
            ),
            (warnedProperties[name] = !0)
          );
        if (EVENT_NAME_REGEX.test(name))
          return (
            console.error(
              "Unknown event handler property `%s`. It will be ignored.",
              name
            ),
            (warnedProperties[name] = !0)
          );
      } else if (EVENT_NAME_REGEX.test(name))
        return (
          INVALID_EVENT_NAME_REGEX.test(name) &&
            console.error(
              "Invalid event handler property `%s`. React events use the camelCase naming convention, for example `onClick`.",
              name
            ),
          (warnedProperties[name] = !0)
        );
      if (rARIA.test(name) || rARIACamel.test(name)) return !0;
      if ("innerhtml" === lowerCasedName)
        return (
          console.error(
            "Directly setting property `innerHTML` is not permitted. For more information, lookup documentation on `dangerouslySetInnerHTML`."
          ),
          (warnedProperties[name] = !0)
        );
      if ("aria" === lowerCasedName)
        return (
          console.error(
            "The `aria` attribute is reserved for future use in React. Pass individual `aria-` attributes instead."
          ),
          (warnedProperties[name] = !0)
        );
      if (
        "is" === lowerCasedName &&
        null !== value &&
        void 0 !== value &&
        "string" !== typeof value
      )
        return (
          console.error(
            "Received a `%s` for a string attribute `is`. If this is expected, cast the value to a string.",
            typeof value
          ),
          (warnedProperties[name] = !0)
        );
      if ("number" === typeof value && isNaN(value))
        return (
          console.error(
            "Received NaN for the `%s` attribute. If this is expected, cast the value to a string.",
            name
          ),
          (warnedProperties[name] = !0)
        );
      if (possibleStandardNames.hasOwnProperty(lowerCasedName)) {
        if (
          ((lowerCasedName = possibleStandardNames[lowerCasedName]),
          lowerCasedName !== name)
        )
          return (
            console.error(
              "Invalid DOM property `%s`. Did you mean `%s`?",
              name,
              lowerCasedName
            ),
            (warnedProperties[name] = !0)
          );
      } else if (name !== lowerCasedName)
        return (
          console.error(
            "React does not recognize the `%s` prop on a DOM element. If you intentionally want it to appear in the DOM as a custom attribute, spell it as lowercase `%s` instead. If you accidentally passed it from a parent component, remove it from the DOM element.",
            name,
            lowerCasedName
          ),
          (warnedProperties[name] = !0)
        );
      switch (name) {
        case "dangerouslySetInnerHTML":
        case "children":
        case "style":
        case "suppressContentEditableWarning":
        case "suppressHydrationWarning":
        case "defaultValue":
        case "defaultChecked":
        case "innerHTML":
        case "ref":
          return !0;
        case "innerText":
        case "textContent":
          return !0;
      }
      switch (typeof value) {
        case "boolean":
          switch (name) {
            case "autoFocus":
            case "checked":
            case "multiple":
            case "muted":
            case "selected":
            case "contentEditable":
            case "spellCheck":
            case "draggable":
            case "value":
            case "autoReverse":
            case "externalResourcesRequired":
            case "focusable":
            case "preserveAlpha":
            case "allowFullScreen":
            case "async":
            case "autoPlay":
            case "controls":
            case "default":
            case "defer":
            case "disabled":
            case "disablePictureInPicture":
            case "disableRemotePlayback":
            case "formNoValidate":
            case "hidden":
            case "loop":
            case "noModule":
            case "noValidate":
            case "open":
            case "playsInline":
            case "readOnly":
            case "required":
            case "reversed":
            case "scoped":
            case "seamless":
            case "itemScope":
            case "capture":
            case "download":
            case "inert":
              return !0;
            default:
              lowerCasedName = name.toLowerCase().slice(0, 5);
              if ("data-" === lowerCasedName || "aria-" === lowerCasedName)
                return !0;
              value
                ? console.error(
                    'Received `%s` for a non-boolean attribute `%s`.\n\nIf you want to write it to the DOM, pass a string instead: %s="%s" or %s={value.toString()}.',
                    value,
                    name,
                    name,
                    value,
                    name
                  )
                : console.error(
                    'Received `%s` for a non-boolean attribute `%s`.\n\nIf you want to write it to the DOM, pass a string instead: %s="%s" or %s={value.toString()}.\n\nIf you used to conditionally omit it with %s={condition && value}, pass %s={condition ? value : undefined} instead.',
                    value,
                    name,
                    name,
                    value,
                    name,
                    name,
                    name
                  );
              return (warnedProperties[name] = !0);
          }
        case "function":
        case "symbol":
          return (warnedProperties[name] = !0), !1;
        case "string":
          if ("false" === value || "true" === value) {
            switch (name) {
              case "checked":
              case "selected":
              case "multiple":
              case "muted":
              case "allowFullScreen":
              case "async":
              case "autoPlay":
              case "controls":
              case "default":
              case "defer":
              case "disabled":
              case "disablePictureInPicture":
              case "disableRemotePlayback":
              case "formNoValidate":
              case "hidden":
              case "loop":
              case "noModule":
              case "noValidate":
              case "open":
              case "playsInline":
              case "readOnly":
              case "required":
              case "reversed":
              case "scoped":
              case "seamless":
              case "itemScope":
              case "inert":
                break;
              default:
                return !0;
            }
            console.error(
              "Received the string `%s` for the boolean attribute `%s`. %s Did you mean %s={%s}?",
              value,
              name,
              "false" === value
                ? "The browser will interpret it as a truthy value."
                : 'Although this works, it will not work as expected if you pass the string "false".',
              name,
              value
            );
            warnedProperties[name] = !0;
          }
      }
      return !0;
    }
    function warnUnknownProperties(type, props, eventRegistry) {
      var unknownProps = [],
        key;
      for (key in props)
        validateProperty(type, key, props[key], eventRegistry) ||
          unknownProps.push(key);
      props = unknownProps
        .map(function (prop) {
          return "`" + prop + "`";
        })
        .join(", ");
      1 === unknownProps.length
        ? console.error(
            "Invalid value for prop %s on <%s> tag. Either remove it from the element, or pass a string or number value to keep it in the DOM. For details, see https://react.dev/link/attribute-behavior ",
            props,
            type
          )
        : 1 < unknownProps.length &&
          console.error(
            "Invalid values for props %s on <%s> tag. Either remove them from the element, or pass a string or number value to keep them in the DOM. For details, see https://react.dev/link/attribute-behavior ",
            props,
            type
          );
    }
    function sanitizeURL(url) {
      return isJavaScriptProtocol.test("" + url)
        ? "javascript:throw new Error('React has blocked a javascript: URL as a security precaution.')"
        : url;
    }
    function noop$1() {}
    function getEventTarget(nativeEvent) {
      nativeEvent = nativeEvent.target || nativeEvent.srcElement || window;
      nativeEvent.correspondingUseElement &&
        (nativeEvent = nativeEvent.correspondingUseElement);
      return 3 === nativeEvent.nodeType ? nativeEvent.parentNode : nativeEvent;
    }
    function restoreStateOfTarget(target) {
      var internalInstance = getInstanceFromNode(target);
      if (internalInstance && (target = internalInstance.stateNode)) {
        var props = target[internalPropsKey] || null;
        a: switch (
          ((target = internalInstance.stateNode), internalInstance.type)
        ) {
          case "input":
            updateInput(
              target,
              props.value,
              props.defaultValue,
              props.defaultValue,
              props.checked,
              props.defaultChecked,
              props.type,
              props.name
            );
            internalInstance = props.name;
            if ("radio" === props.type && null != internalInstance) {
              for (props = target; props.parentNode; ) props = props.parentNode;
              checkAttributeStringCoercion(internalInstance, "name");
              props = props.querySelectorAll(
                'input[name="' +
                  escapeSelectorAttributeValueInsideDoubleQuotes(
                    "" + internalInstance
                  ) +
                  '"][type="radio"]'
              );
              for (
                internalInstance = 0;
                internalInstance < props.length;
                internalInstance++
              ) {
                var otherNode = props[internalInstance];
                if (otherNode !== target && otherNode.form === target.form) {
                  var otherProps = otherNode[internalPropsKey] || null;
                  if (!otherProps)
                    throw Error(
                      "ReactDOMInput: Mixing React and non-React radio inputs with the same `name` is not supported."
                    );
                  updateInput(
                    otherNode,
                    otherProps.value,
                    otherProps.defaultValue,
                    otherProps.defaultValue,
                    otherProps.checked,
                    otherProps.defaultChecked,
                    otherProps.type,
                    otherProps.name
                  );
                }
              }
              for (
                internalInstance = 0;
                internalInstance < props.length;
                internalInstance++
              )
                (otherNode = props[internalInstance]),
                  otherNode.form === target.form &&
                    updateValueIfChanged(otherNode);
            }
            break a;
          case "textarea":
            updateTextarea(target, props.value, props.defaultValue);
            break a;
          case "select":
            (internalInstance = props.value),
              null != internalInstance &&
                updateOptions(target, !!props.multiple, internalInstance, !1);
        }
      }
    }
    function batchedUpdates$1(fn, a, b) {
      if (isInsideEventHandler) return fn(a, b);
      isInsideEventHandler = !0;
      try {
        var JSCompiler_inline_result = fn(a);
        return JSCompiler_inline_result;
      } finally {
        if (
          ((isInsideEventHandler = !1),
          null !== restoreTarget || null !== restoreQueue)
        )
          if (
            (flushSyncWork$1(),
            restoreTarget &&
              ((a = restoreTarget),
              (fn = restoreQueue),
              (restoreQueue = restoreTarget = null),
              restoreStateOfTarget(a),
              fn))
          )
            for (a = 0; a < fn.length; a++) restoreStateOfTarget(fn[a]);
      }
    }
    function getListener(inst, registrationName) {
      var stateNode = inst.stateNode;
      if (null === stateNode) return null;
      var props = stateNode[internalPropsKey] || null;
      if (null === props) return null;
      stateNode = props[registrationName];
      a: switch (registrationName) {
        case "onClick":
        case "onClickCapture":
        case "onDoubleClick":
        case "onDoubleClickCapture":
        case "onMouseDown":
        case "onMouseDownCapture":
        case "onMouseMove":
        case "onMouseMoveCapture":
        case "onMouseUp":
        case "onMouseUpCapture":
        case "onMouseEnter":
          (props = !props.disabled) ||
            ((inst = inst.type),
            (props = !(
              "button" === inst ||
              "input" === inst ||
              "select" === inst ||
              "textarea" === inst
            )));
          inst = !props;
          break a;
        default:
          inst = !1;
      }
      if (inst) return null;
      if (stateNode && "function" !== typeof stateNode)
        throw Error(
          "Expected `" +
            registrationName +
            "` listener to be a function, instead got a value of `" +
            typeof stateNode +
            "` type."
        );
      return stateNode;
    }
    function getData() {
      if (fallbackText) return fallbackText;
      var start,
        startValue = startText,
        startLength = startValue.length,
        end,
        endValue = "value" in root ? root.value : root.textContent,
        endLength = endValue.length;
      for (
        start = 0;
        start < startLength && startValue[start] === endValue[start];
        start++
      );
      var minEnd = startLength - start;
      for (
        end = 1;
        end <= minEnd &&
        startValue[startLength - end] === endValue[endLength - end];
        end++
      );
      return (fallbackText = endValue.slice(start, 1 < end ? 1 - end : void 0));
    }
    function getEventCharCode(nativeEvent) {
      var keyCode = nativeEvent.keyCode;
      "charCode" in nativeEvent
        ? ((nativeEvent = nativeEvent.charCode),
          0 === nativeEvent && 13 === keyCode && (nativeEvent = 13))
        : (nativeEvent = keyCode);
      10 === nativeEvent && (nativeEvent = 13);
      return 32 <= nativeEvent || 13 === nativeEvent ? nativeEvent : 0;
    }
    function functionThatReturnsTrue() {
      return !0;
    }
    function functionThatReturnsFalse() {
      return !1;
    }
    function createSyntheticEvent(Interface) {
      function SyntheticBaseEvent(
        reactName,
        reactEventType,
        targetInst,
        nativeEvent,
        nativeEventTarget
      ) {
        this._reactName = reactName;
        this._targetInst = targetInst;
        this.type = reactEventType;
        this.nativeEvent = nativeEvent;
        this.target = nativeEventTarget;
        this.currentTarget = null;
        for (var propName in Interface)
          Interface.hasOwnProperty(propName) &&
            ((reactName = Interface[propName]),
            (this[propName] = reactName
              ? reactName(nativeEvent)
              : nativeEvent[propName]));
        this.isDefaultPrevented = (
          null != nativeEvent.defaultPrevented
            ? nativeEvent.defaultPrevented
            : !1 === nativeEvent.returnValue
        )
          ? functionThatReturnsTrue
          : functionThatReturnsFalse;
        this.isPropagationStopped = functionThatReturnsFalse;
        return this;
      }
      assign(SyntheticBaseEvent.prototype, {
        preventDefault: function () {
          this.defaultPrevented = !0;
          var event = this.nativeEvent;
          event &&
            (event.preventDefault
              ? event.preventDefault()
              : "unknown" !== typeof event.returnValue &&
                (event.returnValue = !1),
            (this.isDefaultPrevented = functionThatReturnsTrue));
        },
        stopPropagation: function () {
          var event = this.nativeEvent;
          event &&
            (event.stopPropagation
              ? event.stopPropagation()
              : "unknown" !== typeof event.cancelBubble &&
                (event.cancelBubble = !0),
            (this.isPropagationStopped = functionThatReturnsTrue));
        },
        persist: function () {},
        isPersistent: functionThatReturnsTrue
      });
      return SyntheticBaseEvent;
    }
    function modifierStateGetter(keyArg) {
      var nativeEvent = this.nativeEvent;
      return nativeEvent.getModifierState
        ? nativeEvent.getModifierState(keyArg)
        : (keyArg = modifierKeyToProp[keyArg])
          ? !!nativeEvent[keyArg]
          : !1;
    }
    function getEventModifierState() {
      return modifierStateGetter;
    }
    function isFallbackCompositionEnd(domEventName, nativeEvent) {
      switch (domEventName) {
        case "keyup":
          return -1 !== END_KEYCODES.indexOf(nativeEvent.keyCode);
        case "keydown":
          return nativeEvent.keyCode !== START_KEYCODE;
        case "keypress":
        case "mousedown":
        case "focusout":
          return !0;
        default:
          return !1;
      }
    }
    function getDataFromCustomEvent(nativeEvent) {
      nativeEvent = nativeEvent.detail;
      return "object" === typeof nativeEvent && "data" in nativeEvent
        ? nativeEvent.data
        : null;
    }
    function getNativeBeforeInputChars(domEventName, nativeEvent) {
      switch (domEventName) {
        case "compositionend":
          return getDataFromCustomEvent(nativeEvent);
        case "keypress":
          if (nativeEvent.which !== SPACEBAR_CODE) return null;
          hasSpaceKeypress = !0;
          return SPACEBAR_CHAR;
        case "textInput":
          return (
            (domEventName = nativeEvent.data),
            domEventName === SPACEBAR_CHAR && hasSpaceKeypress
              ? null
              : domEventName
          );
        default:
          return null;
      }
    }
    function getFallbackBeforeInputChars(domEventName, nativeEvent) {
      if (isComposing)
        return "compositionend" === domEventName ||
          (!canUseCompositionEvent &&
            isFallbackCompositionEnd(domEventName, nativeEvent))
          ? ((domEventName = getData()),
            (fallbackText = startText = root = null),
            (isComposing = !1),
            domEventName)
          : null;
      switch (domEventName) {
        case "paste":
          return null;
        case "keypress":
          if (
            !(
              nativeEvent.ctrlKey ||
              nativeEvent.altKey ||
              nativeEvent.metaKey
            ) ||
            (nativeEvent.ctrlKey && nativeEvent.altKey)
          ) {
            if (nativeEvent.char && 1 < nativeEvent.char.length)
              return nativeEvent.char;
            if (nativeEvent.which)
              return String.fromCharCode(nativeEvent.which);
          }
          return null;
        case "compositionend":
          return useFallbackCompositionData && "ko" !== nativeEvent.locale
            ? null
            : nativeEvent.data;
        default:
          return null;
      }
    }
    function isTextInputElement(elem) {
      var nodeName = elem && elem.nodeName && elem.nodeName.toLowerCase();
      return "input" === nodeName
        ? !!supportedInputTypes[elem.type]
        : "textarea" === nodeName
          ? !0
          : !1;
    }
    function isEventSupported(eventNameSuffix) {
      if (!canUseDOM) return !1;
      eventNameSuffix = "on" + eventNameSuffix;
      var isSupported = eventNameSuffix in document;
      isSupported ||
        ((isSupported = document.createElement("div")),
        isSupported.setAttribute(eventNameSuffix, "return;"),
        (isSupported = "function" === typeof isSupported[eventNameSuffix]));
      return isSupported;
    }
    function createAndAccumulateChangeEvent(
      dispatchQueue,
      inst,
      nativeEvent,
      target
    ) {
      restoreTarget
        ? restoreQueue
          ? restoreQueue.push(target)
          : (restoreQueue = [target])
        : (restoreTarget = target);
      inst = accumulateTwoPhaseListeners(inst, "onChange");
      0 < inst.length &&
        ((nativeEvent = new SyntheticEvent(
          "onChange",
          "change",
          null,
          nativeEvent,
          target
        )),
        dispatchQueue.push({ event: nativeEvent, listeners: inst }));
    }
    function runEventInBatch(dispatchQueue) {
      processDispatchQueue(dispatchQueue, 0);
    }
    function getInstIfValueChanged(targetInst) {
      var targetNode = getNodeFromInstance(targetInst);
      if (updateValueIfChanged(targetNode)) return targetInst;
    }
    function getTargetInstForChangeEvent(domEventName, targetInst) {
      if ("change" === domEventName) return targetInst;
    }
    function stopWatchingForValueChange() {
      activeElement$1 &&
        (activeElement$1.detachEvent("onpropertychange", handlePropertyChange),
        (activeElementInst$1 = activeElement$1 = null));
    }
    function handlePropertyChange(nativeEvent) {
      if (
        "value" === nativeEvent.propertyName &&
        getInstIfValueChanged(activeElementInst$1)
      ) {
        var dispatchQueue = [];
        createAndAccumulateChangeEvent(
          dispatchQueue,
          activeElementInst$1,
          nativeEvent,
          getEventTarget(nativeEvent)
        );
        batchedUpdates$1(runEventInBatch, dispatchQueue);
      }
    }
    function handleEventsForInputEventPolyfill(
      domEventName,
      target,
      targetInst
    ) {
      "focusin" === domEventName
        ? (stopWatchingForValueChange(),
          (activeElement$1 = target),
          (activeElementInst$1 = targetInst),
          activeElement$1.attachEvent("onpropertychange", handlePropertyChange))
        : "focusout" === domEventName && stopWatchingForValueChange();
    }
    function getTargetInstForInputEventPolyfill(domEventName) {
      if (
        "selectionchange" === domEventName ||
        "keyup" === domEventName ||
        "keydown" === domEventName
      )
        return getInstIfValueChanged(activeElementInst$1);
    }
    function getTargetInstForClickEvent(domEventName, targetInst) {
      if ("click" === domEventName) return getInstIfValueChanged(targetInst);
    }
    function getTargetInstForInputOrChangeEvent(domEventName, targetInst) {
      if ("input" === domEventName || "change" === domEventName)
        return getInstIfValueChanged(targetInst);
    }
    function is(x, y) {
      return (x === y && (0 !== x || 1 / x === 1 / y)) || (x !== x && y !== y);
    }
    function shallowEqual(objA, objB) {
      if (objectIs(objA, objB)) return !0;
      if (
        "object" !== typeof objA ||
        null === objA ||
        "object" !== typeof objB ||
        null === objB
      )
        return !1;
      var keysA = Object.keys(objA),
        keysB = Object.keys(objB);
      if (keysA.length !== keysB.length) return !1;
      for (keysB = 0; keysB < keysA.length; keysB++) {
        var currentKey = keysA[keysB];
        if (
          !hasOwnProperty.call(objB, currentKey) ||
          !objectIs(objA[currentKey], objB[currentKey])
        )
          return !1;
      }
      return !0;
    }
    function getLeafNode(node) {
      for (; node && node.firstChild; ) node = node.firstChild;
      return node;
    }
    function getNodeForCharacterOffset(root, offset) {
      var node = getLeafNode(root);
      root = 0;
      for (var nodeEnd; node; ) {
        if (3 === node.nodeType) {
          nodeEnd = root + node.textContent.length;
          if (root <= offset && nodeEnd >= offset)
            return { node: node, offset: offset - root };
          root = nodeEnd;
        }
        a: {
          for (; node; ) {
            if (node.nextSibling) {
              node = node.nextSibling;
              break a;
            }
            node = node.parentNode;
          }
          node = void 0;
        }
        node = getLeafNode(node);
      }
    }
    function containsNode(outerNode, innerNode) {
      return outerNode && innerNode
        ? outerNode === innerNode
          ? !0
          : outerNode && 3 === outerNode.nodeType
            ? !1
            : innerNode && 3 === innerNode.nodeType
              ? containsNode(outerNode, innerNode.parentNode)
              : "contains" in outerNode
                ? outerNode.contains(innerNode)
                : outerNode.compareDocumentPosition
                  ? !!(outerNode.compareDocumentPosition(innerNode) & 16)
                  : !1
        : !1;
    }
    function getActiveElementDeep(containerInfo) {
      containerInfo =
        null != containerInfo &&
        null != containerInfo.ownerDocument &&
        null != containerInfo.ownerDocument.defaultView
          ? containerInfo.ownerDocument.defaultView
          : window;
      for (
        var element = getActiveElement(containerInfo.document);
        element instanceof containerInfo.HTMLIFrameElement;

      ) {
        try {
          var JSCompiler_inline_result =
            "string" === typeof element.contentWindow.location.href;
        } catch (err) {
          JSCompiler_inline_result = !1;
        }
        if (JSCompiler_inline_result) containerInfo = element.contentWindow;
        else break;
        element = getActiveElement(containerInfo.document);
      }
      return element;
    }
    function hasSelectionCapabilities(elem) {
      var nodeName = elem && elem.nodeName && elem.nodeName.toLowerCase();
      return (
        nodeName &&
        (("input" === nodeName &&
          ("text" === elem.type ||
            "search" === elem.type ||
            "tel" === elem.type ||
            "url" === elem.type ||
            "password" === elem.type)) ||
          "textarea" === nodeName ||
          "true" === elem.contentEditable)
      );
    }
    function constructSelectEvent(
      dispatchQueue,
      nativeEvent,
      nativeEventTarget
    ) {
      var doc =
        nativeEventTarget.window === nativeEventTarget
          ? nativeEventTarget.document
          : 9 === nativeEventTarget.nodeType
            ? nativeEventTarget
            : nativeEventTarget.ownerDocument;
      mouseDown ||
        null == activeElement ||
        activeElement !== getActiveElement(doc) ||
        ((doc = activeElement),
        "selectionStart" in doc && hasSelectionCapabilities(doc)
          ? (doc = { start: doc.selectionStart, end: doc.selectionEnd })
          : ((doc = (
              (doc.ownerDocument && doc.ownerDocument.defaultView) ||
              window
            ).getSelection()),
            (doc = {
              anchorNode: doc.anchorNode,
              anchorOffset: doc.anchorOffset,
              focusNode: doc.focusNode,
              focusOffset: doc.focusOffset
            })),
        (lastSelection && shallowEqual(lastSelection, doc)) ||
          ((lastSelection = doc),
          (doc = accumulateTwoPhaseListeners(activeElementInst, "onSelect")),
          0 < doc.length &&
            ((nativeEvent = new SyntheticEvent(
              "onSelect",
              "select",
              null,
              nativeEvent,
              nativeEventTarget
            )),
            dispatchQueue.push({ event: nativeEvent, listeners: doc }),
            (nativeEvent.target = activeElement))));
    }
    function makePrefixMap(styleProp, eventName) {
      var prefixes = {};
      prefixes[styleProp.toLowerCase()] = eventName.toLowerCase();
      prefixes["Webkit" + styleProp] = "webkit" + eventName;
      prefixes["Moz" + styleProp] = "moz" + eventName;
      return prefixes;
    }
    function getVendorPrefixedEventName(eventName) {
      if (prefixedEventNames[eventName]) return prefixedEventNames[eventName];
      if (!vendorPrefixes[eventName]) return eventName;
      var prefixMap = vendorPrefixes[eventName],
        styleProp;
      for (styleProp in prefixMap)
        if (prefixMap.hasOwnProperty(styleProp) && styleProp in style)
          return (prefixedEventNames[eventName] = prefixMap[styleProp]);
      return eventName;
    }
    function registerSimpleEvent(domEventName, reactName) {
      topLevelEventsToReactNames.set(domEventName, reactName);
      registerTwoPhaseEvent(reactName, [domEventName]);
    }
    function getArrayKind(array) {
      for (var kind = EMPTY_ARRAY, i = 0; i < array.length; i++) {
        var value = array[i];
        if ("object" === typeof value && null !== value)
          if (
            isArrayImpl(value) &&
            2 === value.length &&
            "string" === typeof value[0]
          ) {
            if (kind !== EMPTY_ARRAY && kind !== ENTRIES_ARRAY)
              return COMPLEX_ARRAY;
            kind = ENTRIES_ARRAY;
          } else return COMPLEX_ARRAY;
        else {
          if (
            "function" === typeof value ||
            ("string" === typeof value && 50 < value.length) ||
            (kind !== EMPTY_ARRAY && kind !== PRIMITIVE_ARRAY)
          )
            return COMPLEX_ARRAY;
          kind = PRIMITIVE_ARRAY;
        }
      }
      return kind;
    }
    function addObjectToProperties(object, properties, indent, prefix) {
      for (var key in object)
        hasOwnProperty.call(object, key) &&
          "_" !== key[0] &&
          addValueToProperties(key, object[key], properties, indent, prefix);
    }
    function addValueToProperties(
      propertyName,
      value,
      properties,
      indent,
      prefix
    ) {
      switch (typeof value) {
        case "object":
          if (null === value) {
            value = "null";
            break;
          } else {
            if (value.$$typeof === REACT_ELEMENT_TYPE) {
              var typeName = getComponentNameFromType(value.type) || "\u2026",
                key = value.key;
              value = value.props;
              var propsKeys = Object.keys(value),
                propsLength = propsKeys.length;
              if (null == key && 0 === propsLength) {
                value = "<" + typeName + " />";
                break;
              }
              if (
                3 > indent ||
                (1 === propsLength &&
                  "children" === propsKeys[0] &&
                  null == key)
              ) {
                value = "<" + typeName + " \u2026 />";
                break;
              }
              properties.push([
                prefix + "\u00a0\u00a0".repeat(indent) + propertyName,
                "<" + typeName
              ]);
              null !== key &&
                addValueToProperties(
                  "key",
                  key,
                  properties,
                  indent + 1,
                  prefix
                );
              propertyName = !1;
              for (var propKey in value)
                "children" === propKey
                  ? null != value.children &&
                    (!isArrayImpl(value.children) ||
                      0 < value.children.length) &&
                    (propertyName = !0)
                  : hasOwnProperty.call(value, propKey) &&
                    "_" !== propKey[0] &&
                    addValueToProperties(
                      propKey,
                      value[propKey],
                      properties,
                      indent + 1,
                      prefix
                    );
              properties.push([
                "",
                propertyName ? ">\u2026</" + typeName + ">" : "/>"
              ]);
              return;
            }
            typeName = Object.prototype.toString.call(value);
            typeName = typeName.slice(8, typeName.length - 1);
            if ("Array" === typeName)
              if (
                ((propKey = getArrayKind(value)),
                propKey === PRIMITIVE_ARRAY || propKey === EMPTY_ARRAY)
              ) {
                value = JSON.stringify(value);
                break;
              } else if (propKey === ENTRIES_ARRAY) {
                properties.push([
                  prefix + "\u00a0\u00a0".repeat(indent) + propertyName,
                  ""
                ]);
                for (
                  propertyName = 0;
                  propertyName < value.length;
                  propertyName++
                )
                  (typeName = value[propertyName]),
                    addValueToProperties(
                      typeName[0],
                      typeName[1],
                      properties,
                      indent + 1,
                      prefix
                    );
                return;
              }
            if ("Promise" === typeName) {
              if ("fulfilled" === value.status) {
                if (
                  ((typeName = properties.length),
                  addValueToProperties(
                    propertyName,
                    value.value,
                    properties,
                    indent,
                    prefix
                  ),
                  properties.length > typeName)
                ) {
                  properties = properties[typeName];
                  properties[1] =
                    "Promise<" + (properties[1] || "Object") + ">";
                  return;
                }
              } else if (
                "rejected" === value.status &&
                ((typeName = properties.length),
                addValueToProperties(
                  propertyName,
                  value.reason,
                  properties,
                  indent,
                  prefix
                ),
                properties.length > typeName)
              ) {
                properties = properties[typeName];
                properties[1] = "Rejected Promise<" + properties[1] + ">";
                return;
              }
              properties.push([
                "\u00a0\u00a0".repeat(indent) + propertyName,
                "Promise"
              ]);
              return;
            }
            "Object" === typeName &&
              (propKey = Object.getPrototypeOf(value)) &&
              "function" === typeof propKey.constructor &&
              (typeName = propKey.constructor.name);
            properties.push([
              prefix + "\u00a0\u00a0".repeat(indent) + propertyName,
              "Object" === typeName ? (3 > indent ? "" : "\u2026") : typeName
            ]);
            3 > indent &&
              addObjectToProperties(value, properties, indent + 1, prefix);
            return;
          }
        case "function":
          value = "" === value.name ? "() => {}" : value.name + "() {}";
          break;
        case "string":
          value =
            value === OMITTED_PROP_ERROR ? "\u2026" : JSON.stringify(value);
          break;
        case "undefined":
          value = "undefined";
          break;
        case "boolean":
          value = value ? "true" : "false";
          break;
        default:
          value = String(value);
      }
      properties.push([
        prefix + "\u00a0\u00a0".repeat(indent) + propertyName,
        value
      ]);
    }
    function addObjectDiffToProperties(prev, next, properties, indent) {
      var isDeeplyEqual = !0;
      for (key in prev)
        key in next ||
          (properties.push([
            REMOVED + "\u00a0\u00a0".repeat(indent) + key,
            "\u2026"
          ]),
          (isDeeplyEqual = !1));
      for (var _key in next)
        if (_key in prev) {
          var key = prev[_key];
          var nextValue = next[_key];
          if (key !== nextValue) {
            if (0 === indent && "children" === _key)
              (isDeeplyEqual = "\u00a0\u00a0".repeat(indent) + _key),
                properties.push(
                  [REMOVED + isDeeplyEqual, "\u2026"],
                  [ADDED + isDeeplyEqual, "\u2026"]
                );
            else {
              if (!(3 <= indent))
                if (
                  "object" === typeof key &&
                  "object" === typeof nextValue &&
                  null !== key &&
                  null !== nextValue &&
                  key.$$typeof === nextValue.$$typeof
                )
                  if (nextValue.$$typeof === REACT_ELEMENT_TYPE) {
                    if (
                      key.type === nextValue.type &&
                      key.key === nextValue.key
                    ) {
                      key =
                        getComponentNameFromType(nextValue.type) || "\u2026";
                      isDeeplyEqual = "\u00a0\u00a0".repeat(indent) + _key;
                      key = "<" + key + " \u2026 />";
                      properties.push(
                        [REMOVED + isDeeplyEqual, key],
                        [ADDED + isDeeplyEqual, key]
                      );
                      isDeeplyEqual = !1;
                      continue;
                    }
                  } else {
                    var prevKind = Object.prototype.toString.call(key),
                      nextKind = Object.prototype.toString.call(nextValue);
                    if (
                      prevKind === nextKind &&
                      ("[object Object]" === nextKind ||
                        "[object Array]" === nextKind)
                    ) {
                      prevKind = [
                        UNCHANGED + "\u00a0\u00a0".repeat(indent) + _key,
                        "[object Array]" === nextKind ? "Array" : ""
                      ];
                      properties.push(prevKind);
                      nextKind = properties.length;
                      addObjectDiffToProperties(
                        key,
                        nextValue,
                        properties,
                        indent + 1
                      )
                        ? nextKind === properties.length &&
                          (prevKind[1] =
                            "Referentially unequal but deeply equal objects. Consider memoization.")
                        : (isDeeplyEqual = !1);
                      continue;
                    }
                  }
                else if (
                  "function" === typeof key &&
                  "function" === typeof nextValue &&
                  key.name === nextValue.name &&
                  key.length === nextValue.length &&
                  ((prevKind = Function.prototype.toString.call(key)),
                  (nextKind = Function.prototype.toString.call(nextValue)),
                  prevKind === nextKind)
                ) {
                  key =
                    "" === nextValue.name
                      ? "() => {}"
                      : nextValue.name + "() {}";
                  properties.push([
                    UNCHANGED + "\u00a0\u00a0".repeat(indent) + _key,
                    key +
                      " Referentially unequal function closure. Consider memoization."
                  ]);
                  continue;
                }
              addValueToProperties(_key, key, properties, indent, REMOVED);
              addValueToProperties(_key, nextValue, properties, indent, ADDED);
            }
            isDeeplyEqual = !1;
          }
        } else
          properties.push([
            ADDED + "\u00a0\u00a0".repeat(indent) + _key,
            "\u2026"
          ]),
            (isDeeplyEqual = !1);
      return isDeeplyEqual;
    }
    function setCurrentTrackFromLanes(lanes) {
      currentTrack =
        lanes & 63
          ? "Blocking"
          : lanes & 64
            ? "Gesture"
            : lanes & 4194176
              ? "Transition"
              : lanes & 62914560
                ? "Suspense"
                : lanes & 2080374784
                  ? "Idle"
                  : "Other";
    }
    function logComponentTrigger(fiber, startTime, endTime, trigger) {
      supportsUserTiming &&
        ((reusableComponentOptions.start = startTime),
        (reusableComponentOptions.end = endTime),
        (reusableComponentDevToolDetails.color = "warning"),
        (reusableComponentDevToolDetails.tooltipText = trigger),
        (reusableComponentDevToolDetails.properties = null),
        (fiber = fiber._debugTask)
          ? fiber.run(
              performance.measure.bind(
                performance,
                trigger,
                reusableComponentOptions
              )
            )
          : performance.measure(trigger, reusableComponentOptions));
    }
    function logComponentReappeared(fiber, startTime, endTime) {
      logComponentTrigger(fiber, startTime, endTime, "Reconnect");
    }
    function logComponentRender(
      fiber,
      startTime,
      endTime,
      wasHydrated,
      committedLanes
    ) {
      var name = getComponentNameFromFiber(fiber);
      if (null !== name && supportsUserTiming) {
        var alternate = fiber.alternate,
          selfTime = fiber.actualDuration;
        if (null === alternate || alternate.child !== fiber.child)
          for (var child = fiber.child; null !== child; child = child.sibling)
            selfTime -= child.actualDuration;
        wasHydrated =
          0.5 > selfTime
            ? wasHydrated
              ? "tertiary-light"
              : "primary-light"
            : 10 > selfTime
              ? wasHydrated
                ? "tertiary"
                : "primary"
              : 100 > selfTime
                ? wasHydrated
                  ? "tertiary-dark"
                  : "primary-dark"
                : "error";
        var props = fiber.memoizedProps;
        selfTime = fiber._debugTask;
        null !== props &&
        null !== alternate &&
        alternate.memoizedProps !== props
          ? ((child = [resuableChangedPropsEntry]),
            (props = addObjectDiffToProperties(
              alternate.memoizedProps,
              props,
              child,
              0
            )),
            1 < child.length &&
              (props &&
              !alreadyWarnedForDeepEquality &&
              0 === (alternate.lanes & committedLanes) &&
              100 < fiber.actualDuration
                ? ((alreadyWarnedForDeepEquality = !0),
                  (child[0] = reusableDeeplyEqualPropsEntry),
                  (reusableComponentDevToolDetails.color = "warning"),
                  (reusableComponentDevToolDetails.tooltipText =
                    DEEP_EQUALITY_WARNING))
                : ((reusableComponentDevToolDetails.color = wasHydrated),
                  (reusableComponentDevToolDetails.tooltipText = name)),
              (reusableComponentDevToolDetails.properties = child),
              (reusableComponentOptions.start = startTime),
              (reusableComponentOptions.end = endTime),
              null != selfTime
                ? selfTime.run(
                    performance.measure.bind(
                      performance,
                      "\u200b" + name,
                      reusableComponentOptions
                    )
                  )
                : performance.measure(
                    "\u200b" + name,
                    reusableComponentOptions
                  )))
          : null != selfTime
            ? selfTime.run(
                console.timeStamp.bind(
                  console,
                  name,
                  startTime,
                  endTime,
                  COMPONENTS_TRACK,
                  void 0,
                  wasHydrated
                )
              )
            : console.timeStamp(
                name,
                startTime,
                endTime,
                COMPONENTS_TRACK,
                void 0,
                wasHydrated
              );
      }
    }
    function logComponentErrored(fiber, startTime, endTime, errors) {
      if (supportsUserTiming) {
        var name = getComponentNameFromFiber(fiber);
        if (null !== name) {
          for (
            var debugTask = null, properties = [], i = 0;
            i < errors.length;
            i++
          ) {
            var capturedValue = errors[i];
            null == debugTask &&
              null !== capturedValue.source &&
              (debugTask = capturedValue.source._debugTask);
            capturedValue = capturedValue.value;
            properties.push([
              "Error",
              "object" === typeof capturedValue &&
              null !== capturedValue &&
              "string" === typeof capturedValue.message
                ? String(capturedValue.message)
                : String(capturedValue)
            ]);
          }
          null !== fiber.key &&
            addValueToProperties("key", fiber.key, properties, 0, "");
          null !== fiber.memoizedProps &&
            addObjectToProperties(fiber.memoizedProps, properties, 0, "");
          null == debugTask && (debugTask = fiber._debugTask);
          fiber = {
            start: startTime,
            end: endTime,
            detail: {
              devtools: {
                color: "error",
                track: COMPONENTS_TRACK,
                tooltipText:
                  13 === fiber.tag
                    ? "Hydration failed"
                    : "Error boundary caught an error",
                properties: properties
              }
            }
          };
          debugTask
            ? debugTask.run(
                performance.measure.bind(performance, "\u200b" + name, fiber)
              )
            : performance.measure("\u200b" + name, fiber);
        }
      }
    }
    function logComponentEffect(fiber, startTime, endTime, selfTime, errors) {
      if (null !== errors) {
        if (supportsUserTiming) {
          var name = getComponentNameFromFiber(fiber);
          if (null !== name) {
            selfTime = [];
            for (var i = 0; i < errors.length; i++) {
              var error = errors[i].value;
              selfTime.push([
                "Error",
                "object" === typeof error &&
                null !== error &&
                "string" === typeof error.message
                  ? String(error.message)
                  : String(error)
              ]);
            }
            null !== fiber.key &&
              addValueToProperties("key", fiber.key, selfTime, 0, "");
            null !== fiber.memoizedProps &&
              addObjectToProperties(fiber.memoizedProps, selfTime, 0, "");
            startTime = {
              start: startTime,
              end: endTime,
              detail: {
                devtools: {
                  color: "error",
                  track: COMPONENTS_TRACK,
                  tooltipText: "A lifecycle or effect errored",
                  properties: selfTime
                }
              }
            };
            (fiber = fiber._debugTask)
              ? fiber.run(
                  performance.measure.bind(
                    performance,
                    "\u200b" + name,
                    startTime
                  )
                )
              : performance.measure("\u200b" + name, startTime);
          }
        }
      } else
        (name = getComponentNameFromFiber(fiber)),
          null !== name &&
            supportsUserTiming &&
            ((errors =
              1 > selfTime
                ? "secondary-light"
                : 100 > selfTime
                  ? "secondary"
                  : 500 > selfTime
                    ? "secondary-dark"
                    : "error"),
            (fiber = fiber._debugTask)
              ? fiber.run(
                  console.timeStamp.bind(
                    console,
                    name,
                    startTime,
                    endTime,
                    COMPONENTS_TRACK,
                    void 0,
                    errors
                  )
                )
              : console.timeStamp(
                  name,
                  startTime,
                  endTime,
                  COMPONENTS_TRACK,
                  void 0,
                  errors
                ));
    }
    function logRenderPhase(startTime, endTime, lanes, debugTask) {
      if (supportsUserTiming && !(endTime <= startTime)) {
        var color =
          (lanes & 738197653) === lanes ? "tertiary-dark" : "primary-dark";
        lanes =
          (lanes & 536870912) === lanes
            ? "Prepared"
            : (lanes & 201326741) === lanes
              ? "Hydrated"
              : "Render";
        debugTask
          ? debugTask.run(
              console.timeStamp.bind(
                console,
                lanes,
                startTime,
                endTime,
                currentTrack,
                LANES_TRACK_GROUP,
                color
              )
            )
          : console.timeStamp(
              lanes,
              startTime,
              endTime,
              currentTrack,
              LANES_TRACK_GROUP,
              color
            );
      }
    }
    function logSuspendedRenderPhase(startTime, endTime, lanes, debugTask) {
      !supportsUserTiming ||
        endTime <= startTime ||
        ((lanes =
          (lanes & 738197653) === lanes ? "tertiary-dark" : "primary-dark"),
        debugTask
          ? debugTask.run(
              console.timeStamp.bind(
                console,
                "Prewarm",
                startTime,
                endTime,
                currentTrack,
                LANES_TRACK_GROUP,
                lanes
              )
            )
          : console.timeStamp(
              "Prewarm",
              startTime,
              endTime,
              currentTrack,
              LANES_TRACK_GROUP,
              lanes
            ));
    }
    function logSuspendedWithDelayPhase(startTime, endTime, lanes, debugTask) {
      !supportsUserTiming ||
        endTime <= startTime ||
        ((lanes =
          (lanes & 738197653) === lanes ? "tertiary-dark" : "primary-dark"),
        debugTask
          ? debugTask.run(
              console.timeStamp.bind(
                console,
                "Suspended",
                startTime,
                endTime,
                currentTrack,
                LANES_TRACK_GROUP,
                lanes
              )
            )
          : console.timeStamp(
              "Suspended",
              startTime,
              endTime,
              currentTrack,
              LANES_TRACK_GROUP,
              lanes
            ));
    }
    function logRecoveredRenderPhase(
      startTime,
      endTime,
      lanes,
      recoverableErrors,
      hydrationFailed,
      debugTask
    ) {
      if (supportsUserTiming && !(endTime <= startTime)) {
        lanes = [];
        for (var i = 0; i < recoverableErrors.length; i++) {
          var error = recoverableErrors[i].value;
          lanes.push([
            "Recoverable Error",
            "object" === typeof error &&
            null !== error &&
            "string" === typeof error.message
              ? String(error.message)
              : String(error)
          ]);
        }
        startTime = {
          start: startTime,
          end: endTime,
          detail: {
            devtools: {
              color: "primary-dark",
              track: currentTrack,
              trackGroup: LANES_TRACK_GROUP,
              tooltipText: hydrationFailed
                ? "Hydration Failed"
                : "Recovered after Error",
              properties: lanes
            }
          }
        };
        debugTask
          ? debugTask.run(
              performance.measure.bind(performance, "Recovered", startTime)
            )
          : performance.measure("Recovered", startTime);
      }
    }
    function logErroredRenderPhase(startTime, endTime, lanes, debugTask) {
      !supportsUserTiming ||
        endTime <= startTime ||
        (debugTask
          ? debugTask.run(
              console.timeStamp.bind(
                console,
                "Errored",
                startTime,
                endTime,
                currentTrack,
                LANES_TRACK_GROUP,
                "error"
              )
            )
          : console.timeStamp(
              "Errored",
              startTime,
              endTime,
              currentTrack,
              LANES_TRACK_GROUP,
              "error"
            ));
    }
    function logSuspendedCommitPhase(startTime, endTime, reason, debugTask) {
      !supportsUserTiming ||
        endTime <= startTime ||
        (debugTask
          ? debugTask.run(
              console.timeStamp.bind(
                console,
                reason,
                startTime,
                endTime,
                currentTrack,
                LANES_TRACK_GROUP,
                "secondary-light"
              )
            )
          : console.timeStamp(
              reason,
              startTime,
              endTime,
              currentTrack,
              LANES_TRACK_GROUP,
              "secondary-light"
            ));
    }
    function logCommitErrored(startTime, endTime, errors, passive, debugTask) {
      if (supportsUserTiming && !(endTime <= startTime)) {
        for (var properties = [], i = 0; i < errors.length; i++) {
          var error = errors[i].value;
          properties.push([
            "Error",
            "object" === typeof error &&
            null !== error &&
            "string" === typeof error.message
              ? String(error.message)
              : String(error)
          ]);
        }
        startTime = {
          start: startTime,
          end: endTime,
          detail: {
            devtools: {
              color: "error",
              track: currentTrack,
              trackGroup: LANES_TRACK_GROUP,
              tooltipText: passive
                ? "Remaining Effects Errored"
                : "Commit Errored",
              properties: properties
            }
          }
        };
        debugTask
          ? debugTask.run(
              performance.measure.bind(performance, "Errored", startTime)
            )
          : performance.measure("Errored", startTime);
      }
    }
    function logAnimatingPhase(startTime, endTime, debugTask) {
      !supportsUserTiming ||
        endTime <= startTime ||
        (debugTask
          ? debugTask.run(
              console.timeStamp.bind(
                console,
                "Animating",
                startTime,
                endTime,
                currentTrack,
                LANES_TRACK_GROUP,
                "secondary-dark"
              )
            )
          : console.timeStamp(
              "Animating",
              startTime,
              endTime,
              currentTrack,
              LANES_TRACK_GROUP,
              "secondary-dark"
            ));
    }
    function finishQueueingConcurrentUpdates() {
      for (
        var endIndex = concurrentQueuesIndex,
          i = (concurrentlyUpdatedLanes = concurrentQueuesIndex = 0);
        i < endIndex;

      ) {
        var fiber = concurrentQueues[i];
        concurrentQueues[i++] = null;
        var queue = concurrentQueues[i];
        concurrentQueues[i++] = null;
        var update = concurrentQueues[i];
        concurrentQueues[i++] = null;
        var lane = concurrentQueues[i];
        concurrentQueues[i++] = null;
        if (null !== queue && null !== update) {
          var pending = queue.pending;
          null === pending
            ? (update.next = update)
            : ((update.next = pending.next), (pending.next = update));
          queue.pending = update;
        }
        0 !== lane && markUpdateLaneFromFiberToRoot(fiber, update, lane);
      }
    }
    function enqueueUpdate$1(fiber, queue, update, lane) {
      concurrentQueues[concurrentQueuesIndex++] = fiber;
      concurrentQueues[concurrentQueuesIndex++] = queue;
      concurrentQueues[concurrentQueuesIndex++] = update;
      concurrentQueues[concurrentQueuesIndex++] = lane;
      concurrentlyUpdatedLanes |= lane;
      fiber.lanes |= lane;
      fiber = fiber.alternate;
      null !== fiber && (fiber.lanes |= lane);
    }
    function enqueueConcurrentHookUpdate(fiber, queue, update, lane) {
      enqueueUpdate$1(fiber, queue, update, lane);
      return getRootForUpdatedFiber(fiber);
    }
    function enqueueConcurrentRenderForLane(fiber, lane) {
      enqueueUpdate$1(fiber, null, null, lane);
      return getRootForUpdatedFiber(fiber);
    }
    function markUpdateLaneFromFiberToRoot(sourceFiber, update, lane) {
      sourceFiber.lanes |= lane;
      var alternate = sourceFiber.alternate;
      null !== alternate && (alternate.lanes |= lane);
      for (var isHidden = !1, parent = sourceFiber.return; null !== parent; )
        (parent.childLanes |= lane),
          (alternate = parent.alternate),
          null !== alternate && (alternate.childLanes |= lane),
          22 === parent.tag &&
            ((sourceFiber = parent.stateNode),
            null === sourceFiber ||
              sourceFiber._visibility & OffscreenVisible ||
              (isHidden = !0)),
          (sourceFiber = parent),
          (parent = parent.return);
      return 3 === sourceFiber.tag
        ? ((parent = sourceFiber.stateNode),
          isHidden &&
            null !== update &&
            ((isHidden = 31 - clz32(lane)),
            (sourceFiber = parent.hiddenUpdates),
            (alternate = sourceFiber[isHidden]),
            null === alternate
              ? (sourceFiber[isHidden] = [update])
              : alternate.push(update),
            (update.lane = lane | 536870912)),
          parent)
        : null;
    }
    function getRootForUpdatedFiber(sourceFiber) {
      if (nestedUpdateCount > NESTED_UPDATE_LIMIT)
        throw (
          ((nestedPassiveUpdateCount = nestedUpdateCount = 0),
          (rootWithPassiveNestedUpdates = rootWithNestedUpdates = null),
          Error(
            "Maximum update depth exceeded. This can happen when a component repeatedly calls setState inside componentWillUpdate or componentDidUpdate. React limits the number of nested updates to prevent infinite loops."
          ))
        );
      nestedPassiveUpdateCount > NESTED_PASSIVE_UPDATE_LIMIT &&
        ((nestedPassiveUpdateCount = 0),
        (rootWithPassiveNestedUpdates = null),
        console.error(
          "Maximum update depth exceeded. This can happen when a component calls setState inside useEffect, but useEffect either doesn't have a dependency array, or one of the dependencies changes on every render."
        ));
      null === sourceFiber.alternate &&
        0 !== (sourceFiber.flags & 4098) &&
        warnAboutUpdateOnNotYetMountedFiberInDEV(sourceFiber);
      for (var node = sourceFiber, parent = node.return; null !== parent; )
        null === node.alternate &&
          0 !== (node.flags & 4098) &&
          warnAboutUpdateOnNotYetMountedFiberInDEV(sourceFiber),
          (node = parent),
          (parent = node.return);
      return 3 === node.tag ? node.stateNode : null;
    }
    function resolveFunctionForHotReloading(type) {
      if (null === resolveFamily) return type;
      var family = resolveFamily(type);
      return void 0 === family ? type : family.current;
    }
    function resolveForwardRefForHotReloading(type) {
      if (null === resolveFamily) return type;
      var family = resolveFamily(type);
      return void 0 === family
        ? null !== type &&
          void 0 !== type &&
          "function" === typeof type.render &&
          ((family = resolveFunctionForHotReloading(type.render)),
          type.render !== family)
          ? ((family = { $$typeof: REACT_FORWARD_REF_TYPE, render: family }),
            void 0 !== type.displayName &&
              (family.displayName = type.displayName),
            family)
          : type
        : family.current;
    }
    function isCompatibleFamilyForHotReloading(fiber, element) {
      if (null === resolveFamily) return !1;
      var prevType = fiber.elementType;
      element = element.type;
      var needsCompareFamilies = !1,
        $$typeofNextType =
          "object" === typeof element && null !== element
            ? element.$$typeof
            : null;
      switch (fiber.tag) {
        case 1:
          "function" === typeof element && (needsCompareFamilies = !0);
          break;
        case 0:
          "function" === typeof element
            ? (needsCompareFamilies = !0)
            : $$typeofNextType === REACT_LAZY_TYPE &&
              (needsCompareFamilies = !0);
          break;
        case 11:
          $$typeofNextType === REACT_FORWARD_REF_TYPE
            ? (needsCompareFamilies = !0)
            : $$typeofNextType === REACT_LAZY_TYPE &&
              (needsCompareFamilies = !0);
          break;
        case 14:
        case 15:
          $$typeofNextType === REACT_MEMO_TYPE
            ? (needsCompareFamilies = !0)
            : $$typeofNextType === REACT_LAZY_TYPE &&
              (needsCompareFamilies = !0);
          break;
        default:
          return !1;
      }
      return needsCompareFamilies &&
        ((fiber = resolveFamily(prevType)),
        void 0 !== fiber && fiber === resolveFamily(element))
        ? !0
        : !1;
    }
    function markFailedErrorBoundaryForHotReloading(fiber) {
      null !== resolveFamily &&
        "function" === typeof WeakSet &&
        (null === failedBoundaries && (failedBoundaries = new WeakSet()),
        failedBoundaries.add(fiber));
    }
    function scheduleFibersWithFamiliesRecursively(
      fiber,
      updatedFamilies,
      staleFamilies
    ) {
      do {
        var _fiber = fiber,
          alternate = _fiber.alternate,
          child = _fiber.child,
          sibling = _fiber.sibling,
          tag = _fiber.tag;
        _fiber = _fiber.type;
        var candidateType = null;
        switch (tag) {
          case 0:
          case 15:
          case 1:
            candidateType = _fiber;
            break;
          case 11:
            candidateType = _fiber.render;
        }
        if (null === resolveFamily)
          throw Error("Expected resolveFamily to be set during hot reload.");
        var needsRender = !1;
        _fiber = !1;
        null !== candidateType &&
          ((candidateType = resolveFamily(candidateType)),
          void 0 !== candidateType &&
            (staleFamilies.has(candidateType)
              ? (_fiber = !0)
              : updatedFamilies.has(candidateType) &&
                (1 === tag ? (_fiber = !0) : (needsRender = !0))));
        null !== failedBoundaries &&
          (failedBoundaries.has(fiber) ||
            (null !== alternate && failedBoundaries.has(alternate))) &&
          (_fiber = !0);
        _fiber && (fiber._debugNeedsRemount = !0);
        if (_fiber || needsRender)
          (alternate = enqueueConcurrentRenderForLane(fiber, 2)),
            null !== alternate && scheduleUpdateOnFiber(alternate, fiber, 2);
        null === child ||
          _fiber ||
          scheduleFibersWithFamiliesRecursively(
            child,
            updatedFamilies,
            staleFamilies
          );
        if (null === sibling) break;
        fiber = sibling;
      } while (1);
    }
    function FiberNode(tag, pendingProps, key, mode) {
      this.tag = tag;
      this.key = key;
      this.sibling =
        this.child =
        this.return =
        this.stateNode =
        this.type =
        this.elementType =
          null;
      this.index = 0;
      this.refCleanup = this.ref = null;
      this.pendingProps = pendingProps;
      this.dependencies =
        this.memoizedState =
        this.updateQueue =
        this.memoizedProps =
          null;
      this.mode = mode;
      this.subtreeFlags = this.flags = 0;
      this.deletions = null;
      this.childLanes = this.lanes = 0;
      this.alternate = null;
      this.actualDuration = -0;
      this.actualStartTime = -1.1;
      this.treeBaseDuration = this.selfBaseDuration = -0;
      this._debugTask =
        this._debugStack =
        this._debugOwner =
        this._debugInfo =
          null;
      this._debugNeedsRemount = !1;
      this._debugHookTypes = null;
      hasBadMapPolyfill ||
        "function" !== typeof Object.preventExtensions ||
        Object.preventExtensions(this);
    }
    function shouldConstruct(Component) {
      Component = Component.prototype;
      return !(!Component || !Component.isReactComponent);
    }
    function createWorkInProgress(current, pendingProps) {
      var workInProgress = current.alternate;
      null === workInProgress
        ? ((workInProgress = createFiber(
            current.tag,
            pendingProps,
            current.key,
            current.mode
          )),
          (workInProgress.elementType = current.elementType),
          (workInProgress.type = current.type),
          (workInProgress.stateNode = current.stateNode),
          (workInProgress._debugOwner = current._debugOwner),
          (workInProgress._debugStack = current._debugStack),
          (workInProgress._debugTask = current._debugTask),
          (workInProgress._debugHookTypes = current._debugHookTypes),
          (workInProgress.alternate = current),
          (current.alternate = workInProgress))
        : ((workInProgress.pendingProps = pendingProps),
          (workInProgress.type = current.type),
          (workInProgress.flags = 0),
          (workInProgress.subtreeFlags = 0),
          (workInProgress.deletions = null),
          (workInProgress.actualDuration = -0),
          (workInProgress.actualStartTime = -1.1));
      workInProgress.flags = current.flags & 65011712;
      workInProgress.childLanes = current.childLanes;
      workInProgress.lanes = current.lanes;
      workInProgress.child = current.child;
      workInProgress.memoizedProps = current.memoizedProps;
      workInProgress.memoizedState = current.memoizedState;
      workInProgress.updateQueue = current.updateQueue;
      pendingProps = current.dependencies;
      workInProgress.dependencies =
        null === pendingProps
          ? null
          : {
              lanes: pendingProps.lanes,
              firstContext: pendingProps.firstContext,
              _debugThenableState: pendingProps._debugThenableState
            };
      workInProgress.sibling = current.sibling;
      workInProgress.index = current.index;
      workInProgress.ref = current.ref;
      workInProgress.refCleanup = current.refCleanup;
      workInProgress.selfBaseDuration = current.selfBaseDuration;
      workInProgress.treeBaseDuration = current.treeBaseDuration;
      workInProgress._debugInfo = current._debugInfo;
      workInProgress._debugNeedsRemount = current._debugNeedsRemount;
      switch (workInProgress.tag) {
        case 0:
        case 15:
          workInProgress.type = resolveFunctionForHotReloading(current.type);
          break;
        case 1:
          workInProgress.type = resolveFunctionForHotReloading(current.type);
          break;
        case 11:
          workInProgress.type = resolveForwardRefForHotReloading(current.type);
      }
      return workInProgress;
    }
    function resetWorkInProgress(workInProgress, renderLanes) {
      workInProgress.flags &= 65011714;
      var current = workInProgress.alternate;
      null === current
        ? ((workInProgress.childLanes = 0),
          (workInProgress.lanes = renderLanes),
          (workInProgress.child = null),
          (workInProgress.subtreeFlags = 0),
          (workInProgress.memoizedProps = null),
          (workInProgress.memoizedState = null),
          (workInProgress.updateQueue = null),
          (workInProgress.dependencies = null),
          (workInProgress.stateNode = null),
          (workInProgress.selfBaseDuration = 0),
          (workInProgress.treeBaseDuration = 0))
        : ((workInProgress.childLanes = current.childLanes),
          (workInProgress.lanes = current.lanes),
          (workInProgress.child = current.child),
          (workInProgress.subtreeFlags = 0),
          (workInProgress.deletions = null),
          (workInProgress.memoizedProps = current.memoizedProps),
          (workInProgress.memoizedState = current.memoizedState),
          (workInProgress.updateQueue = current.updateQueue),
          (workInProgress.type = current.type),
          (renderLanes = current.dependencies),
          (workInProgress.dependencies =
            null === renderLanes
              ? null
              : {
                  lanes: renderLanes.lanes,
                  firstContext: renderLanes.firstContext,
                  _debugThenableState: renderLanes._debugThenableState
                }),
          (workInProgress.selfBaseDuration = current.selfBaseDuration),
          (workInProgress.treeBaseDuration = current.treeBaseDuration));
      return workInProgress;
    }
    function createFiberFromTypeAndProps(
      type,
      key,
      pendingProps,
      owner,
      mode,
      lanes
    ) {
      var fiberTag = 0,
        resolvedType = type;
      if ("function" === typeof type)
        shouldConstruct(type) && (fiberTag = 1),
          (resolvedType = resolveFunctionForHotReloading(resolvedType));
      else if ("string" === typeof type)
        (fiberTag = getHostContext()),
          (fiberTag = isHostHoistableType(type, pendingProps, fiberTag)
            ? 26
            : "html" === type || "head" === type || "body" === type
              ? 27
              : 5);
      else
        a: switch (type) {
          case REACT_ACTIVITY_TYPE:
            return (
              (key = createFiber(31, pendingProps, key, mode)),
              (key.elementType = REACT_ACTIVITY_TYPE),
              (key.lanes = lanes),
              key
            );
          case REACT_FRAGMENT_TYPE:
            return createFiberFromFragment(
              pendingProps.children,
              mode,
              lanes,
              key
            );
          case REACT_STRICT_MODE_TYPE:
            fiberTag = 8;
            mode |= StrictLegacyMode;
            mode |= StrictEffectsMode;
            break;
          case REACT_PROFILER_TYPE:
            return (
              (type = pendingProps),
              (owner = mode),
              "string" !== typeof type.id &&
                console.error(
                  'Profiler must specify an "id" of type `string` as a prop. Received the type `%s` instead.',
                  typeof type.id
                ),
              (key = createFiber(12, type, key, owner | ProfileMode)),
              (key.elementType = REACT_PROFILER_TYPE),
              (key.lanes = lanes),
              (key.stateNode = { effectDuration: 0, passiveEffectDuration: 0 }),
              key
            );
          case REACT_SUSPENSE_TYPE:
            return (
              (key = createFiber(13, pendingProps, key, mode)),
              (key.elementType = REACT_SUSPENSE_TYPE),
              (key.lanes = lanes),
              key
            );
          case REACT_SUSPENSE_LIST_TYPE:
            return (
              (key = createFiber(19, pendingProps, key, mode)),
              (key.elementType = REACT_SUSPENSE_LIST_TYPE),
              (key.lanes = lanes),
              key
            );
          default:
            if ("object" === typeof type && null !== type)
              switch (type.$$typeof) {
                case REACT_CONTEXT_TYPE:
                  fiberTag = 10;
                  break a;
                case REACT_CONSUMER_TYPE:
                  fiberTag = 9;
                  break a;
                case REACT_FORWARD_REF_TYPE:
                  fiberTag = 11;
                  resolvedType = resolveForwardRefForHotReloading(resolvedType);
                  break a;
                case REACT_MEMO_TYPE:
                  fiberTag = 14;
                  break a;
                case REACT_LAZY_TYPE:
                  fiberTag = 16;
                  resolvedType = null;
                  break a;
              }
            resolvedType = "";
            if (
              void 0 === type ||
              ("object" === typeof type &&
                null !== type &&
                0 === Object.keys(type).length)
            )
              resolvedType +=
                " You likely forgot to export your component from the file it's defined in, or you might have mixed up default and named imports.";
            null === type
              ? (pendingProps = "null")
              : isArrayImpl(type)
                ? (pendingProps = "array")
                : void 0 !== type && type.$$typeof === REACT_ELEMENT_TYPE
                  ? ((pendingProps =
                      "<" +
                      (getComponentNameFromType(type.type) || "Unknown") +
                      " />"),
                    (resolvedType =
                      " Did you accidentally export a JSX literal instead of a component?"))
                  : (pendingProps = typeof type);
            (fiberTag = owner ? getComponentNameFromOwner(owner) : null) &&
              (resolvedType +=
                "\n\nCheck the render method of `" + fiberTag + "`.");
            fiberTag = 29;
            pendingProps = Error(
              "Element type is invalid: expected a string (for built-in components) or a class/function (for composite components) but got: " +
                (pendingProps + "." + resolvedType)
            );
            resolvedType = null;
        }
      key = createFiber(fiberTag, pendingProps, key, mode);
      key.elementType = type;
      key.type = resolvedType;
      key.lanes = lanes;
      key._debugOwner = owner;
      return key;
    }
    function createFiberFromElement(element, mode, lanes) {
      mode = createFiberFromTypeAndProps(
        element.type,
        element.key,
        element.props,
        element._owner,
        mode,
        lanes
      );
      mode._debugOwner = element._owner;
      mode._debugStack = element._debugStack;
      mode._debugTask = element._debugTask;
      return mode;
    }
    function createFiberFromFragment(elements, mode, lanes, key) {
      elements = createFiber(7, elements, key, mode);
      elements.lanes = lanes;
      return elements;
    }
    function createFiberFromText(content, mode, lanes) {
      content = createFiber(6, content, null, mode);
      content.lanes = lanes;
      return content;
    }
    function createFiberFromDehydratedFragment(dehydratedNode) {
      var fiber = createFiber(18, null, null, NoMode);
      fiber.stateNode = dehydratedNode;
      return fiber;
    }
    function createFiberFromPortal(portal, mode, lanes) {
      mode = createFiber(
        4,
        null !== portal.children ? portal.children : [],
        portal.key,
        mode
      );
      mode.lanes = lanes;
      mode.stateNode = {
        containerInfo: portal.containerInfo,
        pendingChildren: null,
        implementation: portal.implementation
      };
      return mode;
    }
    function createCapturedValueAtFiber(value, source) {
      if ("object" === typeof value && null !== value) {
        var existing = CapturedStacks.get(value);
        if (void 0 !== existing) return existing;
        source = {
          value: value,
          source: source,
          stack: getStackByFiberInDevAndProd(source)
        };
        CapturedStacks.set(value, source);
        return source;
      }
      return {
        value: value,
        source: source,
        stack: getStackByFiberInDevAndProd(source)
      };
    }
    function pushTreeFork(workInProgress, totalChildren) {
      warnIfNotHydrating();
      forkStack[forkStackIndex++] = treeForkCount;
      forkStack[forkStackIndex++] = treeForkProvider;
      treeForkProvider = workInProgress;
      treeForkCount = totalChildren;
    }
    function pushTreeId(workInProgress, totalChildren, index) {
      warnIfNotHydrating();
      idStack[idStackIndex++] = treeContextId;
      idStack[idStackIndex++] = treeContextOverflow;
      idStack[idStackIndex++] = treeContextProvider;
      treeContextProvider = workInProgress;
      var baseIdWithLeadingBit = treeContextId;
      workInProgress = treeContextOverflow;
      var baseLength = 32 - clz32(baseIdWithLeadingBit) - 1;
      baseIdWithLeadingBit &= ~(1 << baseLength);
      index += 1;
      var length = 32 - clz32(totalChildren) + baseLength;
      if (30 < length) {
        var numberOfOverflowBits = baseLength - (baseLength % 5);
        length = (
          baseIdWithLeadingBit &
          ((1 << numberOfOverflowBits) - 1)
        ).toString(32);
        baseIdWithLeadingBit >>= numberOfOverflowBits;
        baseLength -= numberOfOverflowBits;
        treeContextId =
          (1 << (32 - clz32(totalChildren) + baseLength)) |
          (index << baseLength) |
          baseIdWithLeadingBit;
        treeContextOverflow = length + workInProgress;
      } else
        (treeContextId =
          (1 << length) | (index << baseLength) | baseIdWithLeadingBit),
          (treeContextOverflow = workInProgress);
    }
    function pushMaterializedTreeId(workInProgress) {
      warnIfNotHydrating();
      null !== workInProgress.return &&
        (pushTreeFork(workInProgress, 1), pushTreeId(workInProgress, 1, 0));
    }
    function popTreeContext(workInProgress) {
      for (; workInProgress === treeForkProvider; )
        (treeForkProvider = forkStack[--forkStackIndex]),
          (forkStack[forkStackIndex] = null),
          (treeForkCount = forkStack[--forkStackIndex]),
          (forkStack[forkStackIndex] = null);
      for (; workInProgress === treeContextProvider; )
        (treeContextProvider = idStack[--idStackIndex]),
          (idStack[idStackIndex] = null),
          (treeContextOverflow = idStack[--idStackIndex]),
          (idStack[idStackIndex] = null),
          (treeContextId = idStack[--idStackIndex]),
          (idStack[idStackIndex] = null);
    }
    function getSuspendedTreeContext() {
      warnIfNotHydrating();
      return null !== treeContextProvider
        ? { id: treeContextId, overflow: treeContextOverflow }
        : null;
    }
    function restoreSuspendedTreeContext(workInProgress, suspendedContext) {
      warnIfNotHydrating();
      idStack[idStackIndex++] = treeContextId;
      idStack[idStackIndex++] = treeContextOverflow;
      idStack[idStackIndex++] = treeContextProvider;
      treeContextId = suspendedContext.id;
      treeContextOverflow = suspendedContext.overflow;
      treeContextProvider = workInProgress;
    }
    function warnIfNotHydrating() {
      isHydrating ||
        console.error(
          "Expected to be hydrating. This is a bug in React. Please file an issue."
        );
    }
    function buildHydrationDiffNode(fiber, distanceFromLeaf) {
      if (null === fiber.return) {
        if (null === hydrationDiffRootDEV)
          hydrationDiffRootDEV = {
            fiber: fiber,
            children: [],
            serverProps: void 0,
            serverTail: [],
            distanceFromLeaf: distanceFromLeaf
          };
        else {
          if (hydrationDiffRootDEV.fiber !== fiber)
            throw Error(
              "Saw multiple hydration diff roots in a pass. This is a bug in React."
            );
          hydrationDiffRootDEV.distanceFromLeaf > distanceFromLeaf &&
            (hydrationDiffRootDEV.distanceFromLeaf = distanceFromLeaf);
        }
        return hydrationDiffRootDEV;
      }
      var siblings = buildHydrationDiffNode(
        fiber.return,
        distanceFromLeaf + 1
      ).children;
      if (0 < siblings.length && siblings[siblings.length - 1].fiber === fiber)
        return (
          (siblings = siblings[siblings.length - 1]),
          siblings.distanceFromLeaf > distanceFromLeaf &&
            (siblings.distanceFromLeaf = distanceFromLeaf),
          siblings
        );
      distanceFromLeaf = {
        fiber: fiber,
        children: [],
        serverProps: void 0,
        serverTail: [],
        distanceFromLeaf: distanceFromLeaf
      };
      siblings.push(distanceFromLeaf);
      return distanceFromLeaf;
    }
    function warnIfHydrating() {
      isHydrating &&
        console.error(
          "We should not be hydrating here. This is a bug in React. Please file a bug."
        );
    }
    function warnNonHydratedInstance(fiber, rejectedCandidate) {
      didSuspendOrErrorDEV ||
        ((fiber = buildHydrationDiffNode(fiber, 0)),
        (fiber.serverProps = null),
        null !== rejectedCandidate &&
          ((rejectedCandidate =
            describeHydratableInstanceForDevWarnings(rejectedCandidate)),
          fiber.serverTail.push(rejectedCandidate)));
    }
    function throwOnHydrationMismatch(fiber) {
      var fromText =
          1 < arguments.length && void 0 !== arguments[1] ? arguments[1] : !1,
        diff = "",
        diffRoot = hydrationDiffRootDEV;
      null !== diffRoot &&
        ((hydrationDiffRootDEV = null), (diff = describeDiff(diffRoot)));
      queueHydrationError(
        createCapturedValueAtFiber(
          Error(
            "Hydration failed because the server rendered " +
              (fromText ? "text" : "HTML") +
              " didn't match the client. As a result this tree will be regenerated on the client. This can happen if a SSR-ed Client Component used:\n\n- A server/client branch `if (typeof window !== 'undefined')`.\n- Variable input such as `Date.now()` or `Math.random()` which changes each time it's called.\n- Date formatting in a user's locale which doesn't match the server.\n- External changing data without sending a snapshot of it along with the HTML.\n- Invalid HTML tag nesting.\n\nIt can also happen if the client has a browser extension installed which messes with the HTML before React loaded.\n\nhttps://react.dev/link/hydration-mismatch" +
              diff
          ),
          fiber
        )
      );
      throw HydrationMismatchException;
    }
    function prepareToHydrateHostInstance(fiber) {
      var didHydrate = fiber.stateNode;
      var type = fiber.type,
        props = fiber.memoizedProps;
      didHydrate[internalInstanceKey] = fiber;
      didHydrate[internalPropsKey] = props;
      validatePropertiesInDevelopment(type, props);
      switch (type) {
        case "dialog":
          listenToNonDelegatedEvent("cancel", didHydrate);
          listenToNonDelegatedEvent("close", didHydrate);
          break;
        case "iframe":
        case "object":
        case "embed":
          listenToNonDelegatedEvent("load", didHydrate);
          break;
        case "video":
        case "audio":
          for (type = 0; type < mediaEventTypes.length; type++)
            listenToNonDelegatedEvent(mediaEventTypes[type], didHydrate);
          break;
        case "source":
          listenToNonDelegatedEvent("error", didHydrate);
          break;
        case "img":
        case "image":
        case "link":
          listenToNonDelegatedEvent("error", didHydrate);
          listenToNonDelegatedEvent("load", didHydrate);
          break;
        case "details":
          listenToNonDelegatedEvent("toggle", didHydrate);
          break;
        case "input":
          checkControlledValueProps("input", props);
          listenToNonDelegatedEvent("invalid", didHydrate);
          validateInputProps(didHydrate, props);
          initInput(
            didHydrate,
            props.value,
            props.defaultValue,
            props.checked,
            props.defaultChecked,
            props.type,
            props.name,
            !0
          );
          break;
        case "option":
          validateOptionProps(didHydrate, props);
          break;
        case "select":
          checkControlledValueProps("select", props);
          listenToNonDelegatedEvent("invalid", didHydrate);
          validateSelectProps(didHydrate, props);
          break;
        case "textarea":
          checkControlledValueProps("textarea", props),
            listenToNonDelegatedEvent("invalid", didHydrate),
            validateTextareaProps(didHydrate, props),
            initTextarea(
              didHydrate,
              props.value,
              props.defaultValue,
              props.children
            );
      }
      type = props.children;
      ("string" !== typeof type &&
        "number" !== typeof type &&
        "bigint" !== typeof type) ||
      didHydrate.textContent === "" + type ||
      !0 === props.suppressHydrationWarning ||
      checkForUnmatchedText(didHydrate.textContent, type)
        ? (null != props.popover &&
            (listenToNonDelegatedEvent("beforetoggle", didHydrate),
            listenToNonDelegatedEvent("toggle", didHydrate)),
          null != props.onScroll &&
            listenToNonDelegatedEvent("scroll", didHydrate),
          null != props.onScrollEnd &&
            listenToNonDelegatedEvent("scrollend", didHydrate),
          null != props.onClick && (didHydrate.onclick = noop$1),
          (didHydrate = !0))
        : (didHydrate = !1);
      didHydrate || throwOnHydrationMismatch(fiber, !0);
    }
    function popToNextHostParent(fiber) {
      for (hydrationParentFiber = fiber.return; hydrationParentFiber; )
        switch (hydrationParentFiber.tag) {
          case 5:
          case 31:
          case 13:
            rootOrSingletonContext = !1;
            return;
          case 27:
          case 3:
            rootOrSingletonContext = !0;
            return;
          default:
            hydrationParentFiber = hydrationParentFiber.return;
        }
    }
    function popHydrationState(fiber) {
      if (fiber !== hydrationParentFiber) return !1;
      if (!isHydrating)
        return popToNextHostParent(fiber), (isHydrating = !0), !1;
      var tag = fiber.tag,
        JSCompiler_temp;
      if ((JSCompiler_temp = 3 !== tag && 27 !== tag)) {
        if ((JSCompiler_temp = 5 === tag))
          (JSCompiler_temp = fiber.type),
            (JSCompiler_temp =
              !("form" !== JSCompiler_temp && "button" !== JSCompiler_temp) ||
              shouldSetTextContent(fiber.type, fiber.memoizedProps));
        JSCompiler_temp = !JSCompiler_temp;
      }
      if (JSCompiler_temp && nextHydratableInstance) {
        for (JSCompiler_temp = nextHydratableInstance; JSCompiler_temp; ) {
          var diffNode = buildHydrationDiffNode(fiber, 0),
            description =
              describeHydratableInstanceForDevWarnings(JSCompiler_temp);
          diffNode.serverTail.push(description);
          JSCompiler_temp =
            "Suspense" === description.type
              ? getNextHydratableInstanceAfterHydrationBoundary(JSCompiler_temp)
              : getNextHydratable(JSCompiler_temp.nextSibling);
        }
        throwOnHydrationMismatch(fiber);
      }
      popToNextHostParent(fiber);
      if (13 === tag) {
        fiber = fiber.memoizedState;
        fiber = null !== fiber ? fiber.dehydrated : null;
        if (!fiber)
          throw Error(
            "Expected to have a hydrated suspense instance. This error is likely caused by a bug in React. Please file an issue."
          );
        nextHydratableInstance =
          getNextHydratableInstanceAfterHydrationBoundary(fiber);
      } else if (31 === tag) {
        fiber = fiber.memoizedState;
        fiber = null !== fiber ? fiber.dehydrated : null;
        if (!fiber)
          throw Error(
            "Expected to have a hydrated suspense instance. This error is likely caused by a bug in React. Please file an issue."
          );
        nextHydratableInstance =
          getNextHydratableInstanceAfterHydrationBoundary(fiber);
      } else
        27 === tag
          ? ((tag = nextHydratableInstance),
            isSingletonScope(fiber.type)
              ? ((fiber = previousHydratableOnEnteringScopedSingleton),
                (previousHydratableOnEnteringScopedSingleton = null),
                (nextHydratableInstance = fiber))
              : (nextHydratableInstance = tag))
          : (nextHydratableInstance = hydrationParentFiber
              ? getNextHydratable(fiber.stateNode.nextSibling)
              : null);
      return !0;
    }
    function resetHydrationState() {
      nextHydratableInstance = hydrationParentFiber = null;
      didSuspendOrErrorDEV = isHydrating = !1;
    }
    function upgradeHydrationErrorsToRecoverable() {
      var queuedErrors = hydrationErrors;
      null !== queuedErrors &&
        (null === workInProgressRootRecoverableErrors
          ? (workInProgressRootRecoverableErrors = queuedErrors)
          : workInProgressRootRecoverableErrors.push.apply(
              workInProgressRootRecoverableErrors,
              queuedErrors
            ),
        (hydrationErrors = null));
      return queuedErrors;
    }
    function queueHydrationError(error) {
      null === hydrationErrors
        ? (hydrationErrors = [error])
        : hydrationErrors.push(error);
    }
    function emitPendingHydrationWarnings() {
      var diffRoot = hydrationDiffRootDEV;
      if (null !== diffRoot) {
        hydrationDiffRootDEV = null;
        for (var diff = describeDiff(diffRoot); 0 < diffRoot.children.length; )
          diffRoot = diffRoot.children[0];
        runWithFiberInDEV(diffRoot.fiber, function () {
          console.error(
            "A tree hydrated but some attributes of the server rendered HTML didn't match the client properties. This won't be patched up. This can happen if a SSR-ed Client Component used:\n\n- A server/client branch `if (typeof window !== 'undefined')`.\n- Variable input such as `Date.now()` or `Math.random()` which changes each time it's called.\n- Date formatting in a user's locale which doesn't match the server.\n- External changing data without sending a snapshot of it along with the HTML.\n- Invalid HTML tag nesting.\n\nIt can also happen if the client has a browser extension installed which messes with the HTML before React loaded.\n\n%s%s",
            "https://react.dev/link/hydration-mismatch",
            diff
          );
        });
      }
    }
    function resetContextDependencies() {
      lastContextDependency = currentlyRenderingFiber$1 = null;
      isDisallowedContextReadInDEV = !1;
    }
    function pushProvider(providerFiber, context, nextValue) {
      push(valueCursor, context._currentValue, providerFiber);
      context._currentValue = nextValue;
      push(rendererCursorDEV, context._currentRenderer, providerFiber);
      void 0 !== context._currentRenderer &&
        null !== context._currentRenderer &&
        context._currentRenderer !== rendererSigil &&
        console.error(
          "Detected multiple renderers concurrently rendering the same context provider. This is currently unsupported."
        );
      context._currentRenderer = rendererSigil;
    }
    function popProvider(context, providerFiber) {
      context._currentValue = valueCursor.current;
      var currentRenderer = rendererCursorDEV.current;
      pop(rendererCursorDEV, providerFiber);
      context._currentRenderer = currentRenderer;
      pop(valueCursor, providerFiber);
    }
    function scheduleContextWorkOnParentPath(
      parent,
      renderLanes,
      propagationRoot
    ) {
      for (; null !== parent; ) {
        var alternate = parent.alternate;
        (parent.childLanes & renderLanes) !== renderLanes
          ? ((parent.childLanes |= renderLanes),
            null !== alternate && (alternate.childLanes |= renderLanes))
          : null !== alternate &&
            (alternate.childLanes & renderLanes) !== renderLanes &&
            (alternate.childLanes |= renderLanes);
        if (parent === propagationRoot) break;
        parent = parent.return;
      }
      parent !== propagationRoot &&
        console.error(
          "Expected to find the propagation root when scheduling context work. This error is likely caused by a bug in React. Please file an issue."
        );
    }
    function propagateContextChanges(
      workInProgress,
      contexts,
      renderLanes,
      forcePropagateEntireTree
    ) {
      var fiber = workInProgress.child;
      null !== fiber && (fiber.return = workInProgress);
      for (; null !== fiber; ) {
        var list = fiber.dependencies;
        if (null !== list) {
          var nextFiber = fiber.child;
          list = list.firstContext;
          a: for (; null !== list; ) {
            var dependency = list;
            list = fiber;
            for (var i = 0; i < contexts.length; i++)
              if (dependency.context === contexts[i]) {
                list.lanes |= renderLanes;
                dependency = list.alternate;
                null !== dependency && (dependency.lanes |= renderLanes);
                scheduleContextWorkOnParentPath(
                  list.return,
                  renderLanes,
                  workInProgress
                );
                forcePropagateEntireTree || (nextFiber = null);
                break a;
              }
            list = dependency.next;
          }
        } else if (18 === fiber.tag) {
          nextFiber = fiber.return;
          if (null === nextFiber)
            throw Error(
              "We just came from a parent so we must have had a parent. This is a bug in React."
            );
          nextFiber.lanes |= renderLanes;
          list = nextFiber.alternate;
          null !== list && (list.lanes |= renderLanes);
          scheduleContextWorkOnParentPath(
            nextFiber,
            renderLanes,
            workInProgress
          );
          nextFiber = null;
        } else nextFiber = fiber.child;
        if (null !== nextFiber) nextFiber.return = fiber;
        else
          for (nextFiber = fiber; null !== nextFiber; ) {
            if (nextFiber === workInProgress) {
              nextFiber = null;
              break;
            }
            fiber = nextFiber.sibling;
            if (null !== fiber) {
              fiber.return = nextFiber.return;
              nextFiber = fiber;
              break;
            }
            nextFiber = nextFiber.return;
          }
        fiber = nextFiber;
      }
    }
    function propagateParentContextChanges(
      current,
      workInProgress,
      renderLanes,
      forcePropagateEntireTree
    ) {
      current = null;
      for (
        var parent = workInProgress, isInsidePropagationBailout = !1;
        null !== parent;

      ) {
        if (!isInsidePropagationBailout)
          if (0 !== (parent.flags & 524288)) isInsidePropagationBailout = !0;
          else if (0 !== (parent.flags & 262144)) break;
        if (10 === parent.tag) {
          var currentParent = parent.alternate;
          if (null === currentParent)
            throw Error("Should have a current fiber. This is a bug in React.");
          currentParent = currentParent.memoizedProps;
          if (null !== currentParent) {
            var context = parent.type;
            objectIs(parent.pendingProps.value, currentParent.value) ||
              (null !== current
                ? current.push(context)
                : (current = [context]));
          }
        } else if (parent === hostTransitionProviderCursor.current) {
          currentParent = parent.alternate;
          if (null === currentParent)
            throw Error("Should have a current fiber. This is a bug in React.");
          currentParent.memoizedState.memoizedState !==
            parent.memoizedState.memoizedState &&
            (null !== current
              ? current.push(HostTransitionContext)
              : (current = [HostTransitionContext]));
        }
        parent = parent.return;
      }
      null !== current &&
        propagateContextChanges(
          workInProgress,
          current,
          renderLanes,
          forcePropagateEntireTree
        );
      workInProgress.flags |= 262144;
    }
    function checkIfContextChanged(currentDependencies) {
      for (
        currentDependencies = currentDependencies.firstContext;
        null !== currentDependencies;

      ) {
        if (
          !objectIs(
            currentDependencies.context._currentValue,
            currentDependencies.memoizedValue
          )
        )
          return !0;
        currentDependencies = currentDependencies.next;
      }
      return !1;
    }
    function prepareToReadContext(workInProgress) {
      currentlyRenderingFiber$1 = workInProgress;
      lastContextDependency = null;
      workInProgress = workInProgress.dependencies;
      null !== workInProgress && (workInProgress.firstContext = null);
    }
    function readContext(context) {
      isDisallowedContextReadInDEV &&
        console.error(
          "Context can only be read while React is rendering. In classes, you can read it in the render method or getDerivedStateFromProps. In function components, you can read it directly in the function body, but not inside Hooks like useReducer() or useMemo()."
        );
      return readContextForConsumer(currentlyRenderingFiber$1, context);
    }
    function readContextDuringReconciliation(consumer, context) {
      null === currentlyRenderingFiber$1 && prepareToReadContext(consumer);
      return readContextForConsumer(consumer, context);
    }
    function readContextForConsumer(consumer, context) {
      var value = context._currentValue;
      context = { context: context, memoizedValue: value, next: null };
      if (null === lastContextDependency) {
        if (null === consumer)
          throw Error(
            "Context can only be read while React is rendering. In classes, you can read it in the render method or getDerivedStateFromProps. In function components, you can read it directly in the function body, but not inside Hooks like useReducer() or useMemo()."
          );
        lastContextDependency = context;
        consumer.dependencies = {
          lanes: 0,
          firstContext: context,
          _debugThenableState: null
        };
        consumer.flags |= 524288;
      } else lastContextDependency = lastContextDependency.next = context;
      return value;
    }
    function createCache() {
      return {
        controller: new AbortControllerLocal(),
        data: new Map(),
        refCount: 0
      };
    }
    function retainCache(cache) {
      cache.controller.signal.aborted &&
        console.warn(
          "A cache instance was retained after it was already freed. This likely indicates a bug in React."
        );
      cache.refCount++;
    }
    function releaseCache(cache) {
      cache.refCount--;
      0 > cache.refCount &&
        console.warn(
          "A cache instance was released after it was already freed. This likely indicates a bug in React."
        );
      0 === cache.refCount &&
        scheduleCallback$2(NormalPriority, function () {
          cache.controller.abort();
        });
    }
    function startUpdateTimerByLane(lane, method, fiber) {
      if (0 !== (lane & 127))
        0 > blockingUpdateTime &&
          ((blockingUpdateTime = now()),
          (blockingUpdateTask = createTask(method)),
          (blockingUpdateMethodName = method),
          null != fiber &&
            (blockingUpdateComponentName = getComponentNameFromFiber(fiber)),
          (executionContext & (RenderContext | CommitContext)) !== NoContext &&
            ((componentEffectSpawnedUpdate = !0),
            (blockingUpdateType = SPAWNED_UPDATE)),
          (lane = resolveEventTimeStamp()),
          (method = resolveEventType()),
          lane !== blockingEventRepeatTime || method !== blockingEventType
            ? (blockingEventRepeatTime = -1.1)
            : null !== method && (blockingUpdateType = SPAWNED_UPDATE),
          (blockingEventTime = lane),
          (blockingEventType = method));
      else if (
        0 !== (lane & 4194048) &&
        0 > transitionUpdateTime &&
        ((transitionUpdateTime = now()),
        (transitionUpdateTask = createTask(method)),
        (transitionUpdateMethodName = method),
        null != fiber &&
          (transitionUpdateComponentName = getComponentNameFromFiber(fiber)),
        0 > transitionStartTime)
      ) {
        lane = resolveEventTimeStamp();
        method = resolveEventType();
        if (
          lane !== transitionEventRepeatTime ||
          method !== transitionEventType
        )
          transitionEventRepeatTime = -1.1;
        transitionEventTime = lane;
        transitionEventType = method;
      }
    }
    function startHostActionTimer(fiber) {
      if (0 > blockingUpdateTime) {
        blockingUpdateTime = now();
        blockingUpdateTask = null != fiber._debugTask ? fiber._debugTask : null;
        (executionContext & (RenderContext | CommitContext)) !== NoContext &&
          (blockingUpdateType = SPAWNED_UPDATE);
        var newEventTime = resolveEventTimeStamp(),
          newEventType = resolveEventType();
        newEventTime !== blockingEventRepeatTime ||
        newEventType !== blockingEventType
          ? (blockingEventRepeatTime = -1.1)
          : null !== newEventType && (blockingUpdateType = SPAWNED_UPDATE);
        blockingEventTime = newEventTime;
        blockingEventType = newEventType;
      }
      if (
        0 > transitionUpdateTime &&
        ((transitionUpdateTime = now()),
        (transitionUpdateTask =
          null != fiber._debugTask ? fiber._debugTask : null),
        0 > transitionStartTime)
      ) {
        fiber = resolveEventTimeStamp();
        newEventTime = resolveEventType();
        if (
          fiber !== transitionEventRepeatTime ||
          newEventTime !== transitionEventType
        )
          transitionEventRepeatTime = -1.1;
        transitionEventTime = fiber;
        transitionEventType = newEventTime;
      }
    }
    function pushNestedEffectDurations() {
      var prevEffectDuration = profilerEffectDuration;
      profilerEffectDuration = 0;
      return prevEffectDuration;
    }
    function popNestedEffectDurations(prevEffectDuration) {
      var elapsedTime = profilerEffectDuration;
      profilerEffectDuration = prevEffectDuration;
      return elapsedTime;
    }
    function bubbleNestedEffectDurations(prevEffectDuration) {
      var elapsedTime = profilerEffectDuration;
      profilerEffectDuration += prevEffectDuration;
      return elapsedTime;
    }
    function resetComponentEffectTimers() {
      componentEffectEndTime = componentEffectStartTime = -1.1;
    }
    function pushComponentEffectStart() {
      var prevEffectStart = componentEffectStartTime;
      componentEffectStartTime = -1.1;
      return prevEffectStart;
    }
    function popComponentEffectStart(prevEffectStart) {
      0 <= prevEffectStart && (componentEffectStartTime = prevEffectStart);
    }
    function pushComponentEffectDuration() {
      var prevEffectDuration = componentEffectDuration;
      componentEffectDuration = -0;
      return prevEffectDuration;
    }
    function popComponentEffectDuration(prevEffectDuration) {
      0 <= prevEffectDuration && (componentEffectDuration = prevEffectDuration);
    }
    function pushComponentEffectErrors() {
      var prevErrors = componentEffectErrors;
      componentEffectErrors = null;
      return prevErrors;
    }
    function pushComponentEffectDidSpawnUpdate() {
      var prev = componentEffectSpawnedUpdate;
      componentEffectSpawnedUpdate = !1;
      return prev;
    }
    function startProfilerTimer(fiber) {
      profilerStartTime = now();
      0 > fiber.actualStartTime && (fiber.actualStartTime = profilerStartTime);
    }
    function stopProfilerTimerIfRunningAndRecordDuration(fiber) {
      if (0 <= profilerStartTime) {
        var elapsedTime = now() - profilerStartTime;
        fiber.actualDuration += elapsedTime;
        fiber.selfBaseDuration = elapsedTime;
        profilerStartTime = -1;
      }
    }
    function stopProfilerTimerIfRunningAndRecordIncompleteDuration(fiber) {
      if (0 <= profilerStartTime) {
        var elapsedTime = now() - profilerStartTime;
        fiber.actualDuration += elapsedTime;
        profilerStartTime = -1;
      }
    }
    function recordEffectDuration() {
      if (0 <= profilerStartTime) {
        var endTime = now(),
          elapsedTime = endTime - profilerStartTime;
        profilerStartTime = -1;
        profilerEffectDuration += elapsedTime;
        componentEffectDuration += elapsedTime;
        componentEffectEndTime = endTime;
      }
    }
    function recordEffectError(errorInfo) {
      null === componentEffectErrors && (componentEffectErrors = []);
      componentEffectErrors.push(errorInfo);
      null === commitErrors && (commitErrors = []);
      commitErrors.push(errorInfo);
    }
    function startEffectTimer() {
      profilerStartTime = now();
      0 > componentEffectStartTime &&
        (componentEffectStartTime = profilerStartTime);
    }
    function transferActualDuration(fiber) {
      for (var child = fiber.child; child; )
        (fiber.actualDuration += child.actualDuration), (child = child.sibling);
    }
    function entangleAsyncAction(transition, thenable) {
      if (null === currentEntangledListeners) {
        var entangledListeners = (currentEntangledListeners = []);
        currentEntangledPendingCount = 0;
        currentEntangledLane = requestTransitionLane();
        currentEntangledActionThenable = {
          status: "pending",
          value: void 0,
          then: function (resolve) {
            entangledListeners.push(resolve);
          }
        };
      }
      currentEntangledPendingCount++;
      thenable.then(pingEngtangledActionScope, pingEngtangledActionScope);
      return thenable;
    }
    function pingEngtangledActionScope() {
      if (
        0 === --currentEntangledPendingCount &&
        (-1 < transitionUpdateTime || (transitionStartTime = -1.1),
        null !== currentEntangledListeners)
      ) {
        null !== currentEntangledActionThenable &&
          (currentEntangledActionThenable.status = "fulfilled");
        var listeners = currentEntangledListeners;
        currentEntangledListeners = null;
        currentEntangledLane = 0;
        currentEntangledActionThenable = null;
        for (var i = 0; i < listeners.length; i++) (0, listeners[i])();
      }
    }
    function chainThenableValue(thenable, result) {
      var listeners = [],
        thenableWithOverride = {
          status: "pending",
          value: null,
          reason: null,
          then: function (resolve) {
            listeners.push(resolve);
          }
        };
      thenable.then(
        function () {
          thenableWithOverride.status = "fulfilled";
          thenableWithOverride.value = result;
          for (var i = 0; i < listeners.length; i++) (0, listeners[i])(result);
        },
        function (error) {
          thenableWithOverride.status = "rejected";
          thenableWithOverride.reason = error;
          for (error = 0; error < listeners.length; error++)
            (0, listeners[error])(void 0);
        }
      );
      return thenableWithOverride;
    }
    function peekCacheFromPool() {
      var cacheResumedFromPreviousRender = resumedCache.current;
      return null !== cacheResumedFromPreviousRender
        ? cacheResumedFromPreviousRender
        : workInProgressRoot.pooledCache;
    }
    function pushTransition(offscreenWorkInProgress, prevCachePool) {
      null === prevCachePool
        ? push(resumedCache, resumedCache.current, offscreenWorkInProgress)
        : push(resumedCache, prevCachePool.pool, offscreenWorkInProgress);
    }
    function getSuspendedCache() {
      var cacheFromPool = peekCacheFromPool();
      return null === cacheFromPool
        ? null
        : { parent: CacheContext._currentValue, pool: cacheFromPool };
    }
    function createThenableState() {
      return { didWarnAboutUncachedPromise: !1, thenables: [] };
    }
    function isThenableResolved(thenable) {
      thenable = thenable.status;
      return "fulfilled" === thenable || "rejected" === thenable;
    }
    function trackUsedThenable(thenableState, thenable, index) {
      null !== ReactSharedInternals.actQueue &&
        (ReactSharedInternals.didUsePromise = !0);
      var trackedThenables = thenableState.thenables;
      index = trackedThenables[index];
      void 0 === index
        ? trackedThenables.push(thenable)
        : index !== thenable &&
          (thenableState.didWarnAboutUncachedPromise ||
            ((thenableState.didWarnAboutUncachedPromise = !0),
            console.error(
              "A component was suspended by an uncached promise. Creating promises inside a Client Component or hook is not yet supported, except via a Suspense-compatible library or framework."
            )),
          thenable.then(noop$1, noop$1),
          (thenable = index));
      if (void 0 === thenable._debugInfo) {
        thenableState = performance.now();
        trackedThenables = thenable.displayName;
        var ioInfo = {
          name:
            "string" === typeof trackedThenables ? trackedThenables : "Promise",
          start: thenableState,
          end: thenableState,
          value: thenable
        };
        thenable._debugInfo = [{ awaited: ioInfo }];
        "fulfilled" !== thenable.status &&
          "rejected" !== thenable.status &&
          ((thenableState = function () {
            ioInfo.end = performance.now();
          }),
          thenable.then(thenableState, thenableState));
      }
      switch (thenable.status) {
        case "fulfilled":
          return thenable.value;
        case "rejected":
          throw (
            ((thenableState = thenable.reason),
            checkIfUseWrappedInAsyncCatch(thenableState),
            thenableState)
          );
        default:
          if ("string" === typeof thenable.status)
            thenable.then(noop$1, noop$1);
          else {
            thenableState = workInProgressRoot;
            if (
              null !== thenableState &&
              100 < thenableState.shellSuspendCounter
            )
              throw Error(
                "An unknown Component is an async Client Component. Only Server Components can be async at the moment. This error is often caused by accidentally adding `'use client'` to a module that was originally written for the server."
              );
            thenableState = thenable;
            thenableState.status = "pending";
            thenableState.then(
              function (fulfilledValue) {
                if ("pending" === thenable.status) {
                  var fulfilledThenable = thenable;
                  fulfilledThenable.status = "fulfilled";
                  fulfilledThenable.value = fulfilledValue;
                }
              },
              function (error) {
                if ("pending" === thenable.status) {
                  var rejectedThenable = thenable;
                  rejectedThenable.status = "rejected";
                  rejectedThenable.reason = error;
                }
              }
            );
          }
          switch (thenable.status) {
            case "fulfilled":
              return thenable.value;
            case "rejected":
              throw (
                ((thenableState = thenable.reason),
                checkIfUseWrappedInAsyncCatch(thenableState),
                thenableState)
              );
          }
          suspendedThenable = thenable;
          needsToResetSuspendedThenableDEV = !0;
          throw SuspenseException;
      }
    }
    function resolveLazy(lazyType) {
      try {
        return callLazyInitInDEV(lazyType);
      } catch (x) {
        if (null !== x && "object" === typeof x && "function" === typeof x.then)
          throw (
            ((suspendedThenable = x),
            (needsToResetSuspendedThenableDEV = !0),
            SuspenseException)
          );
        throw x;
      }
    }
    function getSuspendedThenable() {
      if (null === suspendedThenable)
        throw Error(
          "Expected a suspended thenable. This is a bug in React. Please file an issue."
        );
      var thenable = suspendedThenable;
      suspendedThenable = null;
      needsToResetSuspendedThenableDEV = !1;
      return thenable;
    }
    function checkIfUseWrappedInAsyncCatch(rejectedReason) {
      if (
        rejectedReason === SuspenseException ||
        rejectedReason === SuspenseActionException
      )
        throw Error(
          "Hooks are not supported inside an async component. This error is often caused by accidentally adding `'use client'` to a module that was originally written for the server."
        );
    }
    function pushDebugInfo(debugInfo) {
      var previousDebugInfo = currentDebugInfo;
      null != debugInfo &&
        (currentDebugInfo =
          null === previousDebugInfo
            ? debugInfo
            : previousDebugInfo.concat(debugInfo));
      return previousDebugInfo;
    }
    function getCurrentDebugTask() {
      var debugInfo = currentDebugInfo;
      if (null != debugInfo)
        for (var i = debugInfo.length - 1; 0 <= i; i--)
          if (null != debugInfo[i].name) {
            var debugTask = debugInfo[i].debugTask;
            if (null != debugTask) return debugTask;
          }
      return null;
    }
    function validateFragmentProps(element, fiber, returnFiber) {
      for (var keys = Object.keys(element.props), i = 0; i < keys.length; i++) {
        var key = keys[i];
        if ("children" !== key && "key" !== key) {
          null === fiber &&
            ((fiber = createFiberFromElement(element, returnFiber.mode, 0)),
            (fiber._debugInfo = currentDebugInfo),
            (fiber.return = returnFiber));
          runWithFiberInDEV(
            fiber,
            function (erroredKey) {
              console.error(
                "Invalid prop `%s` supplied to `React.Fragment`. React.Fragment can only have `key` and `children` props.",
                erroredKey
              );
            },
            key
          );
          break;
        }
      }
    }
    function unwrapThenable(thenable) {
      var index = thenableIndexCounter$1;
      thenableIndexCounter$1 += 1;
      null === thenableState$1 && (thenableState$1 = createThenableState());
      return trackUsedThenable(thenableState$1, thenable, index);
    }
    function coerceRef(workInProgress, element) {
      element = element.props.ref;
      workInProgress.ref = void 0 !== element ? element : null;
    }
    function throwOnInvalidObjectTypeImpl(returnFiber, newChild) {
      if (newChild.$$typeof === REACT_LEGACY_ELEMENT_TYPE)
        throw Error(
          'A React Element from an older version of React was rendered. This is not supported. It can happen if:\n- Multiple copies of the "react" package is used.\n- A library pre-bundled an old copy of "react" or "react/jsx-runtime".\n- A compiler tries to "inline" JSX instead of using the runtime.'
        );
      returnFiber = Object.prototype.toString.call(newChild);
      throw Error(
        "Objects are not valid as a React child (found: " +
          ("[object Object]" === returnFiber
            ? "object with keys {" + Object.keys(newChild).join(", ") + "}"
            : returnFiber) +
          "). If you meant to render a collection of children, use an array instead."
      );
    }
    function throwOnInvalidObjectType(returnFiber, newChild) {
      var debugTask = getCurrentDebugTask();
      null !== debugTask
        ? debugTask.run(
            throwOnInvalidObjectTypeImpl.bind(null, returnFiber, newChild)
          )
        : throwOnInvalidObjectTypeImpl(returnFiber, newChild);
    }
    function warnOnFunctionTypeImpl(returnFiber, invalidChild) {
      var parentName = getComponentNameFromFiber(returnFiber) || "Component";
      ownerHasFunctionTypeWarning[parentName] ||
        ((ownerHasFunctionTypeWarning[parentName] = !0),
        (invalidChild =
          invalidChild.displayName || invalidChild.name || "Component"),
        3 === returnFiber.tag
          ? console.error(
              "Functions are not valid as a React child. This may happen if you return %s instead of <%s /> from render. Or maybe you meant to call this function rather than return it.\n  root.render(%s)",
              invalidChild,
              invalidChild,
              invalidChild
            )
          : console.error(
              "Functions are not valid as a React child. This may happen if you return %s instead of <%s /> from render. Or maybe you meant to call this function rather than return it.\n  <%s>{%s}</%s>",
              invalidChild,
              invalidChild,
              parentName,
              invalidChild,
              parentName
            ));
    }
    function warnOnFunctionType(returnFiber, invalidChild) {
      var debugTask = getCurrentDebugTask();
      null !== debugTask
        ? debugTask.run(
            warnOnFunctionTypeImpl.bind(null, returnFiber, invalidChild)
          )
        : warnOnFunctionTypeImpl(returnFiber, invalidChild);
    }
    function warnOnSymbolTypeImpl(returnFiber, invalidChild) {
      var parentName = getComponentNameFromFiber(returnFiber) || "Component";
      ownerHasSymbolTypeWarning[parentName] ||
        ((ownerHasSymbolTypeWarning[parentName] = !0),
        (invalidChild = String(invalidChild)),
        3 === returnFiber.tag
          ? console.error(
              "Symbols are not valid as a React child.\n  root.render(%s)",
              invalidChild
            )
          : console.error(
              "Symbols are not valid as a React child.\n  <%s>%s</%s>",
              parentName,
              invalidChild,
              parentName
            ));
    }
    function warnOnSymbolType(returnFiber, invalidChild) {
      var debugTask = getCurrentDebugTask();
      null !== debugTask
        ? debugTask.run(
            warnOnSymbolTypeImpl.bind(null, returnFiber, invalidChild)
          )
        : warnOnSymbolTypeImpl(returnFiber, invalidChild);
    }
    function createChildReconciler(shouldTrackSideEffects) {
      function deleteChild(returnFiber, childToDelete) {
        if (shouldTrackSideEffects) {
          var deletions = returnFiber.deletions;
          null === deletions
            ? ((returnFiber.deletions = [childToDelete]),
              (returnFiber.flags |= 16))
            : deletions.push(childToDelete);
        }
      }
      function deleteRemainingChildren(returnFiber, currentFirstChild) {
        if (!shouldTrackSideEffects) return null;
        for (; null !== currentFirstChild; )
          deleteChild(returnFiber, currentFirstChild),
            (currentFirstChild = currentFirstChild.sibling);
        return null;
      }
      function mapRemainingChildren(currentFirstChild) {
        for (var existingChildren = new Map(); null !== currentFirstChild; )
          null !== currentFirstChild.key
            ? existingChildren.set(currentFirstChild.key, currentFirstChild)
            : existingChildren.set(currentFirstChild.index, currentFirstChild),
            (currentFirstChild = currentFirstChild.sibling);
        return existingChildren;
      }
      function useFiber(fiber, pendingProps) {
        fiber = createWorkInProgress(fiber, pendingProps);
        fiber.index = 0;
        fiber.sibling = null;
        return fiber;
      }
      function placeChild(newFiber, lastPlacedIndex, newIndex) {
        newFiber.index = newIndex;
        if (!shouldTrackSideEffects)
          return (newFiber.flags |= 1048576), lastPlacedIndex;
        newIndex = newFiber.alternate;
        if (null !== newIndex)
          return (
            (newIndex = newIndex.index),
            newIndex < lastPlacedIndex
              ? ((newFiber.flags |= 67108866), lastPlacedIndex)
              : newIndex
          );
        newFiber.flags |= 67108866;
        return lastPlacedIndex;
      }
      function placeSingleChild(newFiber) {
        shouldTrackSideEffects &&
          null === newFiber.alternate &&
          (newFiber.flags |= 67108866);
        return newFiber;
      }
      function updateTextNode(returnFiber, current, textContent, lanes) {
        if (null === current || 6 !== current.tag)
          return (
            (current = createFiberFromText(
              textContent,
              returnFiber.mode,
              lanes
            )),
            (current.return = returnFiber),
            (current._debugOwner = returnFiber),
            (current._debugTask = returnFiber._debugTask),
            (current._debugInfo = currentDebugInfo),
            current
          );
        current = useFiber(current, textContent);
        current.return = returnFiber;
        current._debugInfo = currentDebugInfo;
        return current;
      }
      function updateElement(returnFiber, current, element, lanes) {
        var elementType = element.type;
        if (elementType === REACT_FRAGMENT_TYPE)
          return (
            (current = updateFragment(
              returnFiber,
              current,
              element.props.children,
              lanes,
              element.key
            )),
            validateFragmentProps(element, current, returnFiber),
            current
          );
        if (
          null !== current &&
          (current.elementType === elementType ||
            isCompatibleFamilyForHotReloading(current, element) ||
            ("object" === typeof elementType &&
              null !== elementType &&
              elementType.$$typeof === REACT_LAZY_TYPE &&
              resolveLazy(elementType) === current.type))
        )
          return (
            (current = useFiber(current, element.props)),
            coerceRef(current, element),
            (current.return = returnFiber),
            (current._debugOwner = element._owner),
            (current._debugInfo = currentDebugInfo),
            current
          );
        current = createFiberFromElement(element, returnFiber.mode, lanes);
        coerceRef(current, element);
        current.return = returnFiber;
        current._debugInfo = currentDebugInfo;
        return current;
      }
      function updatePortal(returnFiber, current, portal, lanes) {
        if (
          null === current ||
          4 !== current.tag ||
          current.stateNode.containerInfo !== portal.containerInfo ||
          current.stateNode.implementation !== portal.implementation
        )
          return (
            (current = createFiberFromPortal(portal, returnFiber.mode, lanes)),
            (current.return = returnFiber),
            (current._debugInfo = currentDebugInfo),
            current
          );
        current = useFiber(current, portal.children || []);
        current.return = returnFiber;
        current._debugInfo = currentDebugInfo;
        return current;
      }
      function updateFragment(returnFiber, current, fragment, lanes, key) {
        if (null === current || 7 !== current.tag)
          return (
            (current = createFiberFromFragment(
              fragment,
              returnFiber.mode,
              lanes,
              key
            )),
            (current.return = returnFiber),
            (current._debugOwner = returnFiber),
            (current._debugTask = returnFiber._debugTask),
            (current._debugInfo = currentDebugInfo),
            current
          );
        current = useFiber(current, fragment);
        current.return = returnFiber;
        current._debugInfo = currentDebugInfo;
        return current;
      }
      function createChild(returnFiber, newChild, lanes) {
        if (
          ("string" === typeof newChild && "" !== newChild) ||
          "number" === typeof newChild ||
          "bigint" === typeof newChild
        )
          return (
            (newChild = createFiberFromText(
              "" + newChild,
              returnFiber.mode,
              lanes
            )),
            (newChild.return = returnFiber),
            (newChild._debugOwner = returnFiber),
            (newChild._debugTask = returnFiber._debugTask),
            (newChild._debugInfo = currentDebugInfo),
            newChild
          );
        if ("object" === typeof newChild && null !== newChild) {
          switch (newChild.$$typeof) {
            case REACT_ELEMENT_TYPE:
              return (
                (lanes = createFiberFromElement(
                  newChild,
                  returnFiber.mode,
                  lanes
                )),
                coerceRef(lanes, newChild),
                (lanes.return = returnFiber),
                (returnFiber = pushDebugInfo(newChild._debugInfo)),
                (lanes._debugInfo = currentDebugInfo),
                (currentDebugInfo = returnFiber),
                lanes
              );
            case REACT_PORTAL_TYPE:
              return (
                (newChild = createFiberFromPortal(
                  newChild,
                  returnFiber.mode,
                  lanes
                )),
                (newChild.return = returnFiber),
                (newChild._debugInfo = currentDebugInfo),
                newChild
              );
            case REACT_LAZY_TYPE:
              var _prevDebugInfo = pushDebugInfo(newChild._debugInfo);
              newChild = resolveLazy(newChild);
              returnFiber = createChild(returnFiber, newChild, lanes);
              currentDebugInfo = _prevDebugInfo;
              return returnFiber;
          }
          if (isArrayImpl(newChild) || getIteratorFn(newChild))
            return (
              (lanes = createFiberFromFragment(
                newChild,
                returnFiber.mode,
                lanes,
                null
              )),
              (lanes.return = returnFiber),
              (lanes._debugOwner = returnFiber),
              (lanes._debugTask = returnFiber._debugTask),
              (returnFiber = pushDebugInfo(newChild._debugInfo)),
              (lanes._debugInfo = currentDebugInfo),
              (currentDebugInfo = returnFiber),
              lanes
            );
          if ("function" === typeof newChild.then)
            return (
              (_prevDebugInfo = pushDebugInfo(newChild._debugInfo)),
              (returnFiber = createChild(
                returnFiber,
                unwrapThenable(newChild),
                lanes
              )),
              (currentDebugInfo = _prevDebugInfo),
              returnFiber
            );
          if (newChild.$$typeof === REACT_CONTEXT_TYPE)
            return createChild(
              returnFiber,
              readContextDuringReconciliation(returnFiber, newChild),
              lanes
            );
          throwOnInvalidObjectType(returnFiber, newChild);
        }
        "function" === typeof newChild &&
          warnOnFunctionType(returnFiber, newChild);
        "symbol" === typeof newChild && warnOnSymbolType(returnFiber, newChild);
        return null;
      }
      function updateSlot(returnFiber, oldFiber, newChild, lanes) {
        var key = null !== oldFiber ? oldFiber.key : null;
        if (
          ("string" === typeof newChild && "" !== newChild) ||
          "number" === typeof newChild ||
          "bigint" === typeof newChild
        )
          return null !== key
            ? null
            : updateTextNode(returnFiber, oldFiber, "" + newChild, lanes);
        if ("object" === typeof newChild && null !== newChild) {
          switch (newChild.$$typeof) {
            case REACT_ELEMENT_TYPE:
              return newChild.key === key
                ? ((key = pushDebugInfo(newChild._debugInfo)),
                  (returnFiber = updateElement(
                    returnFiber,
                    oldFiber,
                    newChild,
                    lanes
                  )),
                  (currentDebugInfo = key),
                  returnFiber)
                : null;
            case REACT_PORTAL_TYPE:
              return newChild.key === key
                ? updatePortal(returnFiber, oldFiber, newChild, lanes)
                : null;
            case REACT_LAZY_TYPE:
              return (
                (key = pushDebugInfo(newChild._debugInfo)),
                (newChild = resolveLazy(newChild)),
                (returnFiber = updateSlot(
                  returnFiber,
                  oldFiber,
                  newChild,
                  lanes
                )),
                (currentDebugInfo = key),
                returnFiber
              );
          }
          if (isArrayImpl(newChild) || getIteratorFn(newChild)) {
            if (null !== key) return null;
            key = pushDebugInfo(newChild._debugInfo);
            returnFiber = updateFragment(
              returnFiber,
              oldFiber,
              newChild,
              lanes,
              null
            );
            currentDebugInfo = key;
            return returnFiber;
          }
          if ("function" === typeof newChild.then)
            return (
              (key = pushDebugInfo(newChild._debugInfo)),
              (returnFiber = updateSlot(
                returnFiber,
                oldFiber,
                unwrapThenable(newChild),
                lanes
              )),
              (currentDebugInfo = key),
              returnFiber
            );
          if (newChild.$$typeof === REACT_CONTEXT_TYPE)
            return updateSlot(
              returnFiber,
              oldFiber,
              readContextDuringReconciliation(returnFiber, newChild),
              lanes
            );
          throwOnInvalidObjectType(returnFiber, newChild);
        }
        "function" === typeof newChild &&
          warnOnFunctionType(returnFiber, newChild);
        "symbol" === typeof newChild && warnOnSymbolType(returnFiber, newChild);
        return null;
      }
      function updateFromMap(
        existingChildren,
        returnFiber,
        newIdx,
        newChild,
        lanes
      ) {
        if (
          ("string" === typeof newChild && "" !== newChild) ||
          "number" === typeof newChild ||
          "bigint" === typeof newChild
        )
          return (
            (existingChildren = existingChildren.get(newIdx) || null),
            updateTextNode(returnFiber, existingChildren, "" + newChild, lanes)
          );
        if ("object" === typeof newChild && null !== newChild) {
          switch (newChild.$$typeof) {
            case REACT_ELEMENT_TYPE:
              return (
                (newIdx =
                  existingChildren.get(
                    null === newChild.key ? newIdx : newChild.key
                  ) || null),
                (existingChildren = pushDebugInfo(newChild._debugInfo)),
                (returnFiber = updateElement(
                  returnFiber,
                  newIdx,
                  newChild,
                  lanes
                )),
                (currentDebugInfo = existingChildren),
                returnFiber
              );
            case REACT_PORTAL_TYPE:
              return (
                (existingChildren =
                  existingChildren.get(
                    null === newChild.key ? newIdx : newChild.key
                  ) || null),
                updatePortal(returnFiber, existingChildren, newChild, lanes)
              );
            case REACT_LAZY_TYPE:
              var _prevDebugInfo7 = pushDebugInfo(newChild._debugInfo);
              newChild = resolveLazy(newChild);
              returnFiber = updateFromMap(
                existingChildren,
                returnFiber,
                newIdx,
                newChild,
                lanes
              );
              currentDebugInfo = _prevDebugInfo7;
              return returnFiber;
          }
          if (isArrayImpl(newChild) || getIteratorFn(newChild))
            return (
              (newIdx = existingChildren.get(newIdx) || null),
              (existingChildren = pushDebugInfo(newChild._debugInfo)),
              (returnFiber = updateFragment(
                returnFiber,
                newIdx,
                newChild,
                lanes,
                null
              )),
              (currentDebugInfo = existingChildren),
              returnFiber
            );
          if ("function" === typeof newChild.then)
            return (
              (_prevDebugInfo7 = pushDebugInfo(newChild._debugInfo)),
              (returnFiber = updateFromMap(
                existingChildren,
                returnFiber,
                newIdx,
                unwrapThenable(newChild),
                lanes
              )),
              (currentDebugInfo = _prevDebugInfo7),
              returnFiber
            );
          if (newChild.$$typeof === REACT_CONTEXT_TYPE)
            return updateFromMap(
              existingChildren,
              returnFiber,
              newIdx,
              readContextDuringReconciliation(returnFiber, newChild),
              lanes
            );
          throwOnInvalidObjectType(returnFiber, newChild);
        }
        "function" === typeof newChild &&
          warnOnFunctionType(returnFiber, newChild);
        "symbol" === typeof newChild && warnOnSymbolType(returnFiber, newChild);
        return null;
      }
      function warnOnInvalidKey(returnFiber, workInProgress, child, knownKeys) {
        if ("object" !== typeof child || null === child) return knownKeys;
        switch (child.$$typeof) {
          case REACT_ELEMENT_TYPE:
          case REACT_PORTAL_TYPE:
            warnForMissingKey(returnFiber, workInProgress, child);
            var key = child.key;
            if ("string" !== typeof key) break;
            if (null === knownKeys) {
              knownKeys = new Set();
              knownKeys.add(key);
              break;
            }
            if (!knownKeys.has(key)) {
              knownKeys.add(key);
              break;
            }
            runWithFiberInDEV(workInProgress, function () {
              console.error(
                "Encountered two children with the same key, `%s`. Keys should be unique so that components maintain their identity across updates. Non-unique keys may cause children to be duplicated and/or omitted \u2014 the behavior is unsupported and could change in a future version.",
                key
              );
            });
            break;
          case REACT_LAZY_TYPE:
            (child = resolveLazy(child)),
              warnOnInvalidKey(returnFiber, workInProgress, child, knownKeys);
        }
        return knownKeys;
      }
      function reconcileChildrenArray(
        returnFiber,
        currentFirstChild,
        newChildren,
        lanes
      ) {
        for (
          var knownKeys = null,
            resultingFirstChild = null,
            previousNewFiber = null,
            oldFiber = currentFirstChild,
            newIdx = (currentFirstChild = 0),
            nextOldFiber = null;
          null !== oldFiber && newIdx < newChildren.length;
          newIdx++
        ) {
          oldFiber.index > newIdx
            ? ((nextOldFiber = oldFiber), (oldFiber = null))
            : (nextOldFiber = oldFiber.sibling);
          var newFiber = updateSlot(
            returnFiber,
            oldFiber,
            newChildren[newIdx],
            lanes
          );
          if (null === newFiber) {
            null === oldFiber && (oldFiber = nextOldFiber);
            break;
          }
          knownKeys = warnOnInvalidKey(
            returnFiber,
            newFiber,
            newChildren[newIdx],
            knownKeys
          );
          shouldTrackSideEffects &&
            oldFiber &&
            null === newFiber.alternate &&
            deleteChild(returnFiber, oldFiber);
          currentFirstChild = placeChild(newFiber, currentFirstChild, newIdx);
          null === previousNewFiber
            ? (resultingFirstChild = newFiber)
            : (previousNewFiber.sibling = newFiber);
          previousNewFiber = newFiber;
          oldFiber = nextOldFiber;
        }
        if (newIdx === newChildren.length)
          return (
            deleteRemainingChildren(returnFiber, oldFiber),
            isHydrating && pushTreeFork(returnFiber, newIdx),
            resultingFirstChild
          );
        if (null === oldFiber) {
          for (; newIdx < newChildren.length; newIdx++)
            (oldFiber = createChild(returnFiber, newChildren[newIdx], lanes)),
              null !== oldFiber &&
                ((knownKeys = warnOnInvalidKey(
                  returnFiber,
                  oldFiber,
                  newChildren[newIdx],
                  knownKeys
                )),
                (currentFirstChild = placeChild(
                  oldFiber,
                  currentFirstChild,
                  newIdx
                )),
                null === previousNewFiber
                  ? (resultingFirstChild = oldFiber)
                  : (previousNewFiber.sibling = oldFiber),
                (previousNewFiber = oldFiber));
          isHydrating && pushTreeFork(returnFiber, newIdx);
          return resultingFirstChild;
        }
        for (
          oldFiber = mapRemainingChildren(oldFiber);
          newIdx < newChildren.length;
          newIdx++
        )
          (nextOldFiber = updateFromMap(
            oldFiber,
            returnFiber,
            newIdx,
            newChildren[newIdx],
            lanes
          )),
            null !== nextOldFiber &&
              ((knownKeys = warnOnInvalidKey(
                returnFiber,
                nextOldFiber,
                newChildren[newIdx],
                knownKeys
              )),
              shouldTrackSideEffects &&
                null !== nextOldFiber.alternate &&
                oldFiber.delete(
                  null === nextOldFiber.key ? newIdx : nextOldFiber.key
                ),
              (currentFirstChild = placeChild(
                nextOldFiber,
                currentFirstChild,
                newIdx
              )),
              null === previousNewFiber
                ? (resultingFirstChild = nextOldFiber)
                : (previousNewFiber.sibling = nextOldFiber),
              (previousNewFiber = nextOldFiber));
        shouldTrackSideEffects &&
          oldFiber.forEach(function (child) {
            return deleteChild(returnFiber, child);
          });
        isHydrating && pushTreeFork(returnFiber, newIdx);
        return resultingFirstChild;
      }
      function reconcileChildrenIterator(
        returnFiber,
        currentFirstChild,
        newChildren,
        lanes
      ) {
        if (null == newChildren)
          throw Error("An iterable object provided no iterator.");
        for (
          var resultingFirstChild = null,
            previousNewFiber = null,
            oldFiber = currentFirstChild,
            newIdx = (currentFirstChild = 0),
            nextOldFiber = null,
            knownKeys = null,
            step = newChildren.next();
          null !== oldFiber && !step.done;
          newIdx++, step = newChildren.next()
        ) {
          oldFiber.index > newIdx
            ? ((nextOldFiber = oldFiber), (oldFiber = null))
            : (nextOldFiber = oldFiber.sibling);
          var newFiber = updateSlot(returnFiber, oldFiber, step.value, lanes);
          if (null === newFiber) {
            null === oldFiber && (oldFiber = nextOldFiber);
            break;
          }
          knownKeys = warnOnInvalidKey(
            returnFiber,
            newFiber,
            step.value,
            knownKeys
          );
          shouldTrackSideEffects &&
            oldFiber &&
            null === newFiber.alternate &&
            deleteChild(returnFiber, oldFiber);
          currentFirstChild = placeChild(newFiber, currentFirstChild, newIdx);
          null === previousNewFiber
            ? (resultingFirstChild = newFiber)
            : (previousNewFiber.sibling = newFiber);
          previousNewFiber = newFiber;
          oldFiber = nextOldFiber;
        }
        if (step.done)
          return (
            deleteRemainingChildren(returnFiber, oldFiber),
            isHydrating && pushTreeFork(returnFiber, newIdx),
            resultingFirstChild
          );
        if (null === oldFiber) {
          for (; !step.done; newIdx++, step = newChildren.next())
            (oldFiber = createChild(returnFiber, step.value, lanes)),
              null !== oldFiber &&
                ((knownKeys = warnOnInvalidKey(
                  returnFiber,
                  oldFiber,
                  step.value,
                  knownKeys
                )),
                (currentFirstChild = placeChild(
                  oldFiber,
                  currentFirstChild,
                  newIdx
                )),
                null === previousNewFiber
                  ? (resultingFirstChild = oldFiber)
                  : (previousNewFiber.sibling = oldFiber),
                (previousNewFiber = oldFiber));
          isHydrating && pushTreeFork(returnFiber, newIdx);
          return resultingFirstChild;
        }
        for (
          oldFiber = mapRemainingChildren(oldFiber);
          !step.done;
          newIdx++, step = newChildren.next()
        )
          (nextOldFiber = updateFromMap(
            oldFiber,
            returnFiber,
            newIdx,
            step.value,
            lanes
          )),
            null !== nextOldFiber &&
              ((knownKeys = warnOnInvalidKey(
                returnFiber,
                nextOldFiber,
                step.value,
                knownKeys
              )),
              shouldTrackSideEffects &&
                null !== nextOldFiber.alternate &&
                oldFiber.delete(
                  null === nextOldFiber.key ? newIdx : nextOldFiber.key
                ),
              (currentFirstChild = placeChild(
                nextOldFiber,
                currentFirstChild,
                newIdx
              )),
              null === previousNewFiber
                ? (resultingFirstChild = nextOldFiber)
                : (previousNewFiber.sibling = nextOldFiber),
              (previousNewFiber = nextOldFiber));
        shouldTrackSideEffects &&
          oldFiber.forEach(function (child) {
            return deleteChild(returnFiber, child);
          });
        isHydrating && pushTreeFork(returnFiber, newIdx);
        return resultingFirstChild;
      }
      function reconcileChildFibersImpl(
        returnFiber,
        currentFirstChild,
        newChild,
        lanes
      ) {
        "object" === typeof newChild &&
          null !== newChild &&
          newChild.type === REACT_FRAGMENT_TYPE &&
          null === newChild.key &&
          (validateFragmentProps(newChild, null, returnFiber),
          (newChild = newChild.props.children));
        if ("object" === typeof newChild && null !== newChild) {
          switch (newChild.$$typeof) {
            case REACT_ELEMENT_TYPE:
              var prevDebugInfo = pushDebugInfo(newChild._debugInfo);
              a: {
                for (var key = newChild.key; null !== currentFirstChild; ) {
                  if (currentFirstChild.key === key) {
                    key = newChild.type;
                    if (key === REACT_FRAGMENT_TYPE) {
                      if (7 === currentFirstChild.tag) {
                        deleteRemainingChildren(
                          returnFiber,
                          currentFirstChild.sibling
                        );
                        lanes = useFiber(
                          currentFirstChild,
                          newChild.props.children
                        );
                        lanes.return = returnFiber;
                        lanes._debugOwner = newChild._owner;
                        lanes._debugInfo = currentDebugInfo;
                        validateFragmentProps(newChild, lanes, returnFiber);
                        returnFiber = lanes;
                        break a;
                      }
                    } else if (
                      currentFirstChild.elementType === key ||
                      isCompatibleFamilyForHotReloading(
                        currentFirstChild,
                        newChild
                      ) ||
                      ("object" === typeof key &&
                        null !== key &&
                        key.$$typeof === REACT_LAZY_TYPE &&
                        resolveLazy(key) === currentFirstChild.type)
                    ) {
                      deleteRemainingChildren(
                        returnFiber,
                        currentFirstChild.sibling
                      );
                      lanes = useFiber(currentFirstChild, newChild.props);
                      coerceRef(lanes, newChild);
                      lanes.return = returnFiber;
                      lanes._debugOwner = newChild._owner;
                      lanes._debugInfo = currentDebugInfo;
                      returnFiber = lanes;
                      break a;
                    }
                    deleteRemainingChildren(returnFiber, currentFirstChild);
                    break;
                  } else deleteChild(returnFiber, currentFirstChild);
                  currentFirstChild = currentFirstChild.sibling;
                }
                newChild.type === REACT_FRAGMENT_TYPE
                  ? ((lanes = createFiberFromFragment(
                      newChild.props.children,
                      returnFiber.mode,
                      lanes,
                      newChild.key
                    )),
                    (lanes.return = returnFiber),
                    (lanes._debugOwner = returnFiber),
                    (lanes._debugTask = returnFiber._debugTask),
                    (lanes._debugInfo = currentDebugInfo),
                    validateFragmentProps(newChild, lanes, returnFiber),
                    (returnFiber = lanes))
                  : ((lanes = createFiberFromElement(
                      newChild,
                      returnFiber.mode,
                      lanes
                    )),
                    coerceRef(lanes, newChild),
                    (lanes.return = returnFiber),
                    (lanes._debugInfo = currentDebugInfo),
                    (returnFiber = lanes));
              }
              returnFiber = placeSingleChild(returnFiber);
              currentDebugInfo = prevDebugInfo;
              return returnFiber;
            case REACT_PORTAL_TYPE:
              a: {
                prevDebugInfo = newChild;
                for (
                  newChild = prevDebugInfo.key;
                  null !== currentFirstChild;

                ) {
                  if (currentFirstChild.key === newChild)
                    if (
                      4 === currentFirstChild.tag &&
                      currentFirstChild.stateNode.containerInfo ===
                        prevDebugInfo.containerInfo &&
                      currentFirstChild.stateNode.implementation ===
                        prevDebugInfo.implementation
                    ) {
                      deleteRemainingChildren(
                        returnFiber,
                        currentFirstChild.sibling
                      );
                      lanes = useFiber(
                        currentFirstChild,
                        prevDebugInfo.children || []
                      );
                      lanes.return = returnFiber;
                      returnFiber = lanes;
                      break a;
                    } else {
                      deleteRemainingChildren(returnFiber, currentFirstChild);
                      break;
                    }
                  else deleteChild(returnFiber, currentFirstChild);
                  currentFirstChild = currentFirstChild.sibling;
                }
                lanes = createFiberFromPortal(
                  prevDebugInfo,
                  returnFiber.mode,
                  lanes
                );
                lanes.return = returnFiber;
                returnFiber = lanes;
              }
              return placeSingleChild(returnFiber);
            case REACT_LAZY_TYPE:
              return (
                (prevDebugInfo = pushDebugInfo(newChild._debugInfo)),
                (newChild = resolveLazy(newChild)),
                (returnFiber = reconcileChildFibersImpl(
                  returnFiber,
                  currentFirstChild,
                  newChild,
                  lanes
                )),
                (currentDebugInfo = prevDebugInfo),
                returnFiber
              );
          }
          if (isArrayImpl(newChild))
            return (
              (prevDebugInfo = pushDebugInfo(newChild._debugInfo)),
              (returnFiber = reconcileChildrenArray(
                returnFiber,
                currentFirstChild,
                newChild,
                lanes
              )),
              (currentDebugInfo = prevDebugInfo),
              returnFiber
            );
          if (getIteratorFn(newChild)) {
            prevDebugInfo = pushDebugInfo(newChild._debugInfo);
            key = getIteratorFn(newChild);
            if ("function" !== typeof key)
              throw Error(
                "An object is not an iterable. This error is likely caused by a bug in React. Please file an issue."
              );
            var newChildren = key.call(newChild);
            if (newChildren === newChild) {
              if (
                0 !== returnFiber.tag ||
                "[object GeneratorFunction]" !==
                  Object.prototype.toString.call(returnFiber.type) ||
                "[object Generator]" !==
                  Object.prototype.toString.call(newChildren)
              )
                didWarnAboutGenerators ||
                  console.error(
                    "Using Iterators as children is unsupported and will likely yield unexpected results because enumerating a generator mutates it. You may convert it to an array with `Array.from()` or the `[...spread]` operator before rendering. You can also use an Iterable that can iterate multiple times over the same items."
                  ),
                  (didWarnAboutGenerators = !0);
            } else
              newChild.entries !== key ||
                didWarnAboutMaps ||
                (console.error(
                  "Using Maps as children is not supported. Use an array of keyed ReactElements instead."
                ),
                (didWarnAboutMaps = !0));
            returnFiber = reconcileChildrenIterator(
              returnFiber,
              currentFirstChild,
              newChildren,
              lanes
            );
            currentDebugInfo = prevDebugInfo;
            return returnFiber;
          }
          if ("function" === typeof newChild.then)
            return (
              (prevDebugInfo = pushDebugInfo(newChild._debugInfo)),
              (returnFiber = reconcileChildFibersImpl(
                returnFiber,
                currentFirstChild,
                unwrapThenable(newChild),
                lanes
              )),
              (currentDebugInfo = prevDebugInfo),
              returnFiber
            );
          if (newChild.$$typeof === REACT_CONTEXT_TYPE)
            return reconcileChildFibersImpl(
              returnFiber,
              currentFirstChild,
              readContextDuringReconciliation(returnFiber, newChild),
              lanes
            );
          throwOnInvalidObjectType(returnFiber, newChild);
        }
        if (
          ("string" === typeof newChild && "" !== newChild) ||
          "number" === typeof newChild ||
          "bigint" === typeof newChild
        )
          return (
            (prevDebugInfo = "" + newChild),
            null !== currentFirstChild && 6 === currentFirstChild.tag
              ? (deleteRemainingChildren(
                  returnFiber,
                  currentFirstChild.sibling
                ),
                (lanes = useFiber(currentFirstChild, prevDebugInfo)),
                (lanes.return = returnFiber),
                (returnFiber = lanes))
              : (deleteRemainingChildren(returnFiber, currentFirstChild),
                (lanes = createFiberFromText(
                  prevDebugInfo,
                  returnFiber.mode,
                  lanes
                )),
                (lanes.return = returnFiber),
                (lanes._debugOwner = returnFiber),
                (lanes._debugTask = returnFiber._debugTask),
                (lanes._debugInfo = currentDebugInfo),
                (returnFiber = lanes)),
            placeSingleChild(returnFiber)
          );
        "function" === typeof newChild &&
          warnOnFunctionType(returnFiber, newChild);
        "symbol" === typeof newChild && warnOnSymbolType(returnFiber, newChild);
        return deleteRemainingChildren(returnFiber, currentFirstChild);
      }
      return function (returnFiber, currentFirstChild, newChild, lanes) {
        var prevDebugInfo = currentDebugInfo;
        currentDebugInfo = null;
        try {
          thenableIndexCounter$1 = 0;
          var firstChildFiber = reconcileChildFibersImpl(
            returnFiber,
            currentFirstChild,
            newChild,
            lanes
          );
          thenableState$1 = null;
          return firstChildFiber;
        } catch (x) {
          if (x === SuspenseException || x === SuspenseActionException) throw x;
          var fiber = createFiber(29, x, null, returnFiber.mode);
          fiber.lanes = lanes;
          fiber.return = returnFiber;
          var debugInfo = (fiber._debugInfo = currentDebugInfo);
          fiber._debugOwner = returnFiber._debugOwner;
          fiber._debugTask = returnFiber._debugTask;
          if (null != debugInfo)
            for (var i = debugInfo.length - 1; 0 <= i; i--)
              if ("string" === typeof debugInfo[i].stack) {
                fiber._debugOwner = debugInfo[i];
                fiber._debugTask = debugInfo[i].debugTask;
                break;
              }
          return fiber;
        } finally {
          currentDebugInfo = prevDebugInfo;
        }
      };
    }
    function validateSuspenseListNestedChild(childSlot, index) {
      var isAnArray = isArrayImpl(childSlot);
      childSlot = !isAnArray && "function" === typeof getIteratorFn(childSlot);
      return isAnArray || childSlot
        ? ((isAnArray = isAnArray ? "array" : "iterable"),
          console.error(
            "A nested %s was passed to row #%s in <SuspenseList />. Wrap it in an additional SuspenseList to configure its revealOrder: <SuspenseList revealOrder=...> ... <SuspenseList revealOrder=...>{%s}</SuspenseList> ... </SuspenseList>",
            isAnArray,
            index,
            isAnArray
          ),
          !1)
        : !0;
    }
    function initializeUpdateQueue(fiber) {
      fiber.updateQueue = {
        baseState: fiber.memoizedState,
        firstBaseUpdate: null,
        lastBaseUpdate: null,
        shared: { pending: null, lanes: 0, hiddenCallbacks: null },
        callbacks: null
      };
    }
    function cloneUpdateQueue(current, workInProgress) {
      current = current.updateQueue;
      workInProgress.updateQueue === current &&
        (workInProgress.updateQueue = {
          baseState: current.baseState,
          firstBaseUpdate: current.firstBaseUpdate,
          lastBaseUpdate: current.lastBaseUpdate,
          shared: current.shared,
          callbacks: null
        });
    }
    function createUpdate(lane) {
      return {
        lane: lane,
        tag: UpdateState,
        payload: null,
        callback: null,
        next: null
      };
    }
    function enqueueUpdate(fiber, update, lane) {
      var updateQueue = fiber.updateQueue;
      if (null === updateQueue) return null;
      updateQueue = updateQueue.shared;
      if (
        currentlyProcessingQueue === updateQueue &&
        !didWarnUpdateInsideUpdate
      ) {
        var componentName = getComponentNameFromFiber(fiber);
        console.error(
          "An update (setState, replaceState, or forceUpdate) was scheduled from inside an update function. Update functions should be pure, with zero side-effects. Consider using componentDidUpdate or a callback.\n\nPlease update the following component: %s",
          componentName
        );
        didWarnUpdateInsideUpdate = !0;
      }
      if ((executionContext & RenderContext) !== NoContext)
        return (
          (componentName = updateQueue.pending),
          null === componentName
            ? (update.next = update)
            : ((update.next = componentName.next),
              (componentName.next = update)),
          (updateQueue.pending = update),
          (update = getRootForUpdatedFiber(fiber)),
          markUpdateLaneFromFiberToRoot(fiber, null, lane),
          update
        );
      enqueueUpdate$1(fiber, updateQueue, update, lane);
      return getRootForUpdatedFiber(fiber);
    }
    function entangleTransitions(root, fiber, lane) {
      fiber = fiber.updateQueue;
      if (null !== fiber && ((fiber = fiber.shared), 0 !== (lane & 4194048))) {
        var queueLanes = fiber.lanes;
        queueLanes &= root.pendingLanes;
        lane |= queueLanes;
        fiber.lanes = lane;
        markRootEntangled(root, lane);
      }
    }
    function enqueueCapturedUpdate(workInProgress, capturedUpdate) {
      var queue = workInProgress.updateQueue,
        current = workInProgress.alternate;
      if (
        null !== current &&
        ((current = current.updateQueue), queue === current)
      ) {
        var newFirst = null,
          newLast = null;
        queue = queue.firstBaseUpdate;
        if (null !== queue) {
          do {
            var clone = {
              lane: queue.lane,
              tag: queue.tag,
              payload: queue.payload,
              callback: null,
              next: null
            };
            null === newLast
              ? (newFirst = newLast = clone)
              : (newLast = newLast.next = clone);
            queue = queue.next;
          } while (null !== queue);
          null === newLast
            ? (newFirst = newLast = capturedUpdate)
            : (newLast = newLast.next = capturedUpdate);
        } else newFirst = newLast = capturedUpdate;
        queue = {
          baseState: current.baseState,
          firstBaseUpdate: newFirst,
          lastBaseUpdate: newLast,
          shared: current.shared,
          callbacks: current.callbacks
        };
        workInProgress.updateQueue = queue;
        return;
      }
      workInProgress = queue.lastBaseUpdate;
      null === workInProgress
        ? (queue.firstBaseUpdate = capturedUpdate)
        : (workInProgress.next = capturedUpdate);
      queue.lastBaseUpdate = capturedUpdate;
    }
    function suspendIfUpdateReadFromEntangledAsyncAction() {
      if (didReadFromEntangledAsyncAction) {
        var entangledActionThenable = currentEntangledActionThenable;
        if (null !== entangledActionThenable) throw entangledActionThenable;
      }
    }
    function processUpdateQueue(
      workInProgress,
      props,
      instance$jscomp$0,
      renderLanes
    ) {
      didReadFromEntangledAsyncAction = !1;
      var queue = workInProgress.updateQueue;
      hasForceUpdate = !1;
      currentlyProcessingQueue = queue.shared;
      var firstBaseUpdate = queue.firstBaseUpdate,
        lastBaseUpdate = queue.lastBaseUpdate,
        pendingQueue = queue.shared.pending;
      if (null !== pendingQueue) {
        queue.shared.pending = null;
        var lastPendingUpdate = pendingQueue,
          firstPendingUpdate = lastPendingUpdate.next;
        lastPendingUpdate.next = null;
        null === lastBaseUpdate
          ? (firstBaseUpdate = firstPendingUpdate)
          : (lastBaseUpdate.next = firstPendingUpdate);
        lastBaseUpdate = lastPendingUpdate;
        var current = workInProgress.alternate;
        null !== current &&
          ((current = current.updateQueue),
          (pendingQueue = current.lastBaseUpdate),
          pendingQueue !== lastBaseUpdate &&
            (null === pendingQueue
              ? (current.firstBaseUpdate = firstPendingUpdate)
              : (pendingQueue.next = firstPendingUpdate),
            (current.lastBaseUpdate = lastPendingUpdate)));
      }
      if (null !== firstBaseUpdate) {
        var newState = queue.baseState;
        lastBaseUpdate = 0;
        current = firstPendingUpdate = lastPendingUpdate = null;
        pendingQueue = firstBaseUpdate;
        do {
          var updateLane = pendingQueue.lane & -536870913,
            isHiddenUpdate = updateLane !== pendingQueue.lane;
          if (
            isHiddenUpdate
              ? (workInProgressRootRenderLanes & updateLane) === updateLane
              : (renderLanes & updateLane) === updateLane
          ) {
            0 !== updateLane &&
              updateLane === currentEntangledLane &&
              (didReadFromEntangledAsyncAction = !0);
            null !== current &&
              (current = current.next =
                {
                  lane: 0,
                  tag: pendingQueue.tag,
                  payload: pendingQueue.payload,
                  callback: null,
                  next: null
                });
            a: {
              updateLane = workInProgress;
              var partialState = pendingQueue;
              var nextProps = props,
                instance = instance$jscomp$0;
              switch (partialState.tag) {
                case ReplaceState:
                  partialState = partialState.payload;
                  if ("function" === typeof partialState) {
                    isDisallowedContextReadInDEV = !0;
                    var nextState = partialState.call(
                      instance,
                      newState,
                      nextProps
                    );
                    if (updateLane.mode & StrictLegacyMode) {
                      setIsStrictModeForDevtools(!0);
                      try {
                        partialState.call(instance, newState, nextProps);
                      } finally {
                        setIsStrictModeForDevtools(!1);
                      }
                    }
                    isDisallowedContextReadInDEV = !1;
                    newState = nextState;
                    break a;
                  }
                  newState = partialState;
                  break a;
                case CaptureUpdate:
                  updateLane.flags = (updateLane.flags & -65537) | 128;
                case UpdateState:
                  nextState = partialState.payload;
                  if ("function" === typeof nextState) {
                    isDisallowedContextReadInDEV = !0;
                    partialState = nextState.call(
                      instance,
                      newState,
                      nextProps
                    );
                    if (updateLane.mode & StrictLegacyMode) {
                      setIsStrictModeForDevtools(!0);
                      try {
                        nextState.call(instance, newState, nextProps);
                      } finally {
                        setIsStrictModeForDevtools(!1);
                      }
                    }
                    isDisallowedContextReadInDEV = !1;
                  } else partialState = nextState;
                  if (null === partialState || void 0 === partialState) break a;
                  newState = assign({}, newState, partialState);
                  break a;
                case ForceUpdate:
                  hasForceUpdate = !0;
              }
            }
            updateLane = pendingQueue.callback;
            null !== updateLane &&
              ((workInProgress.flags |= 64),
              isHiddenUpdate && (workInProgress.flags |= 8192),
              (isHiddenUpdate = queue.callbacks),
              null === isHiddenUpdate
                ? (queue.callbacks = [updateLane])
                : isHiddenUpdate.push(updateLane));
          } else
            (isHiddenUpdate = {
              lane: updateLane,
              tag: pendingQueue.tag,
              payload: pendingQueue.payload,
              callback: pendingQueue.callback,
              next: null
            }),
              null === current
                ? ((firstPendingUpdate = current = isHiddenUpdate),
                  (lastPendingUpdate = newState))
                : (current = current.next = isHiddenUpdate),
              (lastBaseUpdate |= updateLane);
          pendingQueue = pendingQueue.next;
          if (null === pendingQueue)
            if (((pendingQueue = queue.shared.pending), null === pendingQueue))
              break;
            else
              (isHiddenUpdate = pendingQueue),
                (pendingQueue = isHiddenUpdate.next),
                (isHiddenUpdate.next = null),
                (queue.lastBaseUpdate = isHiddenUpdate),
                (queue.shared.pending = null);
        } while (1);
        null === current && (lastPendingUpdate = newState);
        queue.baseState = lastPendingUpdate;
        queue.firstBaseUpdate = firstPendingUpdate;
        queue.lastBaseUpdate = current;
        null === firstBaseUpdate && (queue.shared.lanes = 0);
        workInProgressRootSkippedLanes |= lastBaseUpdate;
        workInProgress.lanes = lastBaseUpdate;
        workInProgress.memoizedState = newState;
      }
      currentlyProcessingQueue = null;
    }
    function callCallback(callback, context) {
      if ("function" !== typeof callback)
        throw Error(
          "Invalid argument passed as callback. Expected a function. Instead received: " +
            callback
        );
      callback.call(context);
    }
    function commitHiddenCallbacks(updateQueue, context) {
      var hiddenCallbacks = updateQueue.shared.hiddenCallbacks;
      if (null !== hiddenCallbacks)
        for (
          updateQueue.shared.hiddenCallbacks = null, updateQueue = 0;
          updateQueue < hiddenCallbacks.length;
          updateQueue++
        )
          callCallback(hiddenCallbacks[updateQueue], context);
    }
    function commitCallbacks(updateQueue, context) {
      var callbacks = updateQueue.callbacks;
      if (null !== callbacks)
        for (
          updateQueue.callbacks = null, updateQueue = 0;
          updateQueue < callbacks.length;
          updateQueue++
        )
          callCallback(callbacks[updateQueue], context);
    }
    function pushHiddenContext(fiber, context) {
      var prevEntangledRenderLanes = entangledRenderLanes;
      push(prevEntangledRenderLanesCursor, prevEntangledRenderLanes, fiber);
      push(currentTreeHiddenStackCursor, context, fiber);
      entangledRenderLanes = prevEntangledRenderLanes | context.baseLanes;
    }
    function reuseHiddenContextOnStack(fiber) {
      push(prevEntangledRenderLanesCursor, entangledRenderLanes, fiber);
      push(
        currentTreeHiddenStackCursor,
        currentTreeHiddenStackCursor.current,
        fiber
      );
    }
    function popHiddenContext(fiber) {
      entangledRenderLanes = prevEntangledRenderLanesCursor.current;
      pop(currentTreeHiddenStackCursor, fiber);
      pop(prevEntangledRenderLanesCursor, fiber);
    }
    function pushPrimaryTreeSuspenseHandler(handler) {
      var current = handler.alternate;
      push(
        suspenseStackCursor,
        suspenseStackCursor.current & SubtreeSuspenseContextMask,
        handler
      );
      push(suspenseHandlerStackCursor, handler, handler);
      null === shellBoundary &&
        (null === current || null !== currentTreeHiddenStackCursor.current
          ? (shellBoundary = handler)
          : null !== current.memoizedState && (shellBoundary = handler));
    }
    function pushDehydratedActivitySuspenseHandler(fiber) {
      push(suspenseStackCursor, suspenseStackCursor.current, fiber);
      push(suspenseHandlerStackCursor, fiber, fiber);
      null === shellBoundary && (shellBoundary = fiber);
    }
    function pushOffscreenSuspenseHandler(fiber) {
      22 === fiber.tag
        ? (push(suspenseStackCursor, suspenseStackCursor.current, fiber),
          push(suspenseHandlerStackCursor, fiber, fiber),
          null === shellBoundary && (shellBoundary = fiber))
        : reuseSuspenseHandlerOnStack(fiber);
    }
    function reuseSuspenseHandlerOnStack(fiber) {
      push(suspenseStackCursor, suspenseStackCursor.current, fiber);
      push(
        suspenseHandlerStackCursor,
        suspenseHandlerStackCursor.current,
        fiber
      );
    }
    function popSuspenseHandler(fiber) {
      pop(suspenseHandlerStackCursor, fiber);
      shellBoundary === fiber && (shellBoundary = null);
      pop(suspenseStackCursor, fiber);
    }
    function findFirstSuspended(row) {
      for (var node = row; null !== node; ) {
        if (13 === node.tag) {
          var state = node.memoizedState;
          if (
            null !== state &&
            ((state = state.dehydrated),
            null === state ||
              isSuspenseInstancePending(state) ||
              isSuspenseInstanceFallback(state))
          )
            return node;
        } else if (
          19 === node.tag &&
          ("forwards" === node.memoizedProps.revealOrder ||
            "backwards" === node.memoizedProps.revealOrder ||
            "unstable_legacy-backwards" === node.memoizedProps.revealOrder ||
            "together" === node.memoizedProps.revealOrder)
        ) {
          if (0 !== (node.flags & 128)) return node;
        } else if (null !== node.child) {
          node.child.return = node;
          node = node.child;
          continue;
        }
        if (node === row) break;
        for (; null === node.sibling; ) {
          if (null === node.return || node.return === row) return null;
          node = node.return;
        }
        node.sibling.return = node.return;
        node = node.sibling;
      }
      return null;
    }
    function mountHookTypesDev() {
      var hookName = currentHookNameInDev;
      null === hookTypesDev
        ? (hookTypesDev = [hookName])
        : hookTypesDev.push(hookName);
    }
    function updateHookTypesDev() {
      var hookName = currentHookNameInDev;
      if (
        null !== hookTypesDev &&
        (hookTypesUpdateIndexDev++,
        hookTypesDev[hookTypesUpdateIndexDev] !== hookName)
      ) {
        var componentName = getComponentNameFromFiber(currentlyRenderingFiber);
        if (
          !didWarnAboutMismatchedHooksForComponent.has(componentName) &&
          (didWarnAboutMismatchedHooksForComponent.add(componentName),
          null !== hookTypesDev)
        ) {
          for (var table = "", i = 0; i <= hookTypesUpdateIndexDev; i++) {
            var oldHookName = hookTypesDev[i],
              newHookName =
                i === hookTypesUpdateIndexDev ? hookName : oldHookName;
            for (
              oldHookName = i + 1 + ". " + oldHookName;
              30 > oldHookName.length;

            )
              oldHookName += " ";
            oldHookName += newHookName + "\n";
            table += oldHookName;
          }
          console.error(
            "React has detected a change in the order of Hooks called by %s. This will lead to bugs and errors if not fixed. For more information, read the Rules of Hooks: https://react.dev/link/rules-of-hooks\n\n   Previous render            Next render\n   ------------------------------------------------------\n%s   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n",
            componentName,
            table
          );
        }
      }
    }
    function checkDepsAreArrayDev(deps) {
      void 0 === deps ||
        null === deps ||
        isArrayImpl(deps) ||
        console.error(
          "%s received a final argument that is not an array (instead, received `%s`). When specified, the final argument must be an array.",
          currentHookNameInDev,
          typeof deps
        );
    }
    function warnOnUseFormStateInDev() {
      var componentName = getComponentNameFromFiber(currentlyRenderingFiber);
      didWarnAboutUseFormState.has(componentName) ||
        (didWarnAboutUseFormState.add(componentName),
        console.error(
          "ReactDOM.useFormState has been renamed to React.useActionState. Please update %s to use React.useActionState.",
          componentName
        ));
    }
    function throwInvalidHookError() {
      throw Error(
        "Invalid hook call. Hooks can only be called inside of the body of a function component. This could happen for one of the following reasons:\n1. You might have mismatching versions of React and the renderer (such as React DOM)\n2. You might be breaking the Rules of Hooks\n3. You might have more than one copy of React in the same app\nSee https://react.dev/link/invalid-hook-call for tips about how to debug and fix this problem."
      );
    }
    function areHookInputsEqual(nextDeps, prevDeps) {
      if (ignorePreviousDependencies) return !1;
      if (null === prevDeps)
        return (
          console.error(
            "%s received a final argument during this render, but not during the previous render. Even though the final argument is optional, its type cannot change between renders.",
            currentHookNameInDev
          ),
          !1
        );
      nextDeps.length !== prevDeps.length &&
        console.error(
          "The final argument passed to %s changed size between renders. The order and size of this array must remain constant.\n\nPrevious: %s\nIncoming: %s",
          currentHookNameInDev,
          "[" + prevDeps.join(", ") + "]",
          "[" + nextDeps.join(", ") + "]"
        );
      for (var i = 0; i < prevDeps.length && i < nextDeps.length; i++)
        if (!objectIs(nextDeps[i], prevDeps[i])) return !1;
      return !0;
    }
    function renderWithHooks(
      current,
      workInProgress,
      Component,
      props,
      secondArg,
      nextRenderLanes
    ) {
      renderLanes = nextRenderLanes;
      currentlyRenderingFiber = workInProgress;
      hookTypesDev = null !== current ? current._debugHookTypes : null;
      hookTypesUpdateIndexDev = -1;
      ignorePreviousDependencies =
        null !== current && current.type !== workInProgress.type;
      if (
        "[object AsyncFunction]" ===
          Object.prototype.toString.call(Component) ||
        "[object AsyncGeneratorFunction]" ===
          Object.prototype.toString.call(Component)
      )
        (nextRenderLanes = getComponentNameFromFiber(currentlyRenderingFiber)),
          didWarnAboutAsyncClientComponent.has(nextRenderLanes) ||
            (didWarnAboutAsyncClientComponent.add(nextRenderLanes),
            console.error(
              "%s is an async Client Component. Only Server Components can be async at the moment. This error is often caused by accidentally adding `'use client'` to a module that was originally written for the server.",
              null === nextRenderLanes
                ? "An unknown Component"
                : "<" + nextRenderLanes + ">"
            ));
      workInProgress.memoizedState = null;
      workInProgress.updateQueue = null;
      workInProgress.lanes = 0;
      ReactSharedInternals.H =
        null !== current && null !== current.memoizedState
          ? HooksDispatcherOnUpdateInDEV
          : null !== hookTypesDev
            ? HooksDispatcherOnMountWithHookTypesInDEV
            : HooksDispatcherOnMountInDEV;
      shouldDoubleInvokeUserFnsInHooksDEV = nextRenderLanes =
        (workInProgress.mode & StrictLegacyMode) !== NoMode;
      var children = callComponentInDEV(Component, props, secondArg);
      shouldDoubleInvokeUserFnsInHooksDEV = !1;
      didScheduleRenderPhaseUpdateDuringThisPass &&
        (children = renderWithHooksAgain(
          workInProgress,
          Component,
          props,
          secondArg
        ));
      if (nextRenderLanes) {
        setIsStrictModeForDevtools(!0);
        try {
          children = renderWithHooksAgain(
            workInProgress,
            Component,
            props,
            secondArg
          );
        } finally {
          setIsStrictModeForDevtools(!1);
        }
      }
      finishRenderingHooks(current, workInProgress);
      return children;
    }
    function finishRenderingHooks(current, workInProgress) {
      workInProgress._debugHookTypes = hookTypesDev;
      null === workInProgress.dependencies
        ? null !== thenableState &&
          (workInProgress.dependencies = {
            lanes: 0,
            firstContext: null,
            _debugThenableState: thenableState
          })
        : (workInProgress.dependencies._debugThenableState = thenableState);
      ReactSharedInternals.H = ContextOnlyDispatcher;
      var didRenderTooFewHooks =
        null !== currentHook && null !== currentHook.next;
      renderLanes = 0;
      hookTypesDev =
        currentHookNameInDev =
        workInProgressHook =
        currentHook =
        currentlyRenderingFiber =
          null;
      hookTypesUpdateIndexDev = -1;
      null !== current &&
        (current.flags & 65011712) !== (workInProgress.flags & 65011712) &&
        console.error(
          "Internal React error: Expected static flag was missing. Please notify the React team."
        );
      didScheduleRenderPhaseUpdate = !1;
      thenableIndexCounter = 0;
      thenableState = null;
      if (didRenderTooFewHooks)
        throw Error(
          "Rendered fewer hooks than expected. This may be caused by an accidental early return statement."
        );
      null === current ||
        didReceiveUpdate ||
        ((current = current.dependencies),
        null !== current &&
          checkIfContextChanged(current) &&
          (didReceiveUpdate = !0));
      needsToResetSuspendedThenableDEV
        ? ((needsToResetSuspendedThenableDEV = !1), (current = !0))
        : (current = !1);
      current &&
        ((workInProgress =
          getComponentNameFromFiber(workInProgress) || "Unknown"),
        didWarnAboutUseWrappedInTryCatch.has(workInProgress) ||
          didWarnAboutAsyncClientComponent.has(workInProgress) ||
          (didWarnAboutUseWrappedInTryCatch.add(workInProgress),
          console.error(
            "`use` was called from inside a try/catch block. This is not allowed and can lead to unexpected behavior. To handle errors triggered by `use`, wrap your component in a error boundary."
          )));
    }
    function renderWithHooksAgain(workInProgress, Component, props, secondArg) {
      currentlyRenderingFiber = workInProgress;
      var numberOfReRenders = 0;
      do {
        didScheduleRenderPhaseUpdateDuringThisPass && (thenableState = null);
        thenableIndexCounter = 0;
        didScheduleRenderPhaseUpdateDuringThisPass = !1;
        if (numberOfReRenders >= RE_RENDER_LIMIT)
          throw Error(
            "Too many re-renders. React limits the number of renders to prevent an infinite loop."
          );
        numberOfReRenders += 1;
        ignorePreviousDependencies = !1;
        workInProgressHook = currentHook = null;
        if (null != workInProgress.updateQueue) {
          var children = workInProgress.updateQueue;
          children.lastEffect = null;
          children.events = null;
          children.stores = null;
          null != children.memoCache && (children.memoCache.index = 0);
        }
        hookTypesUpdateIndexDev = -1;
        ReactSharedInternals.H = HooksDispatcherOnRerenderInDEV;
        children = callComponentInDEV(Component, props, secondArg);
      } while (didScheduleRenderPhaseUpdateDuringThisPass);
      return children;
    }
    function TransitionAwareHostComponent() {
      var dispatcher = ReactSharedInternals.H,
        maybeThenable = dispatcher.useState()[0];
      maybeThenable =
        "function" === typeof maybeThenable.then
          ? useThenable(maybeThenable)
          : maybeThenable;
      dispatcher = dispatcher.useState()[0];
      (null !== currentHook ? currentHook.memoizedState : null) !==
        dispatcher && (currentlyRenderingFiber.flags |= 1024);
      return maybeThenable;
    }
    function checkDidRenderIdHook() {
      var didRenderIdHook = 0 !== localIdCounter;
      localIdCounter = 0;
      return didRenderIdHook;
    }
    function bailoutHooks(current, workInProgress, lanes) {
      workInProgress.updateQueue = current.updateQueue;
      workInProgress.flags =
        (workInProgress.mode & StrictEffectsMode) !== NoMode
          ? workInProgress.flags & -402655237
          : workInProgress.flags & -2053;
      current.lanes &= ~lanes;
    }
    function resetHooksOnUnwind(workInProgress) {
      if (didScheduleRenderPhaseUpdate) {
        for (
          workInProgress = workInProgress.memoizedState;
          null !== workInProgress;

        ) {
          var queue = workInProgress.queue;
          null !== queue && (queue.pending = null);
          workInProgress = workInProgress.next;
        }
        didScheduleRenderPhaseUpdate = !1;
      }
      renderLanes = 0;
      hookTypesDev =
        workInProgressHook =
        currentHook =
        currentlyRenderingFiber =
          null;
      hookTypesUpdateIndexDev = -1;
      currentHookNameInDev = null;
      didScheduleRenderPhaseUpdateDuringThisPass = !1;
      thenableIndexCounter = localIdCounter = 0;
      thenableState = null;
    }
    function mountWorkInProgressHook() {
      var hook = {
        memoizedState: null,
        baseState: null,
        baseQueue: null,
        queue: null,
        next: null
      };
      null === workInProgressHook
        ? (currentlyRenderingFiber.memoizedState = workInProgressHook = hook)
        : (workInProgressHook = workInProgressHook.next = hook);
      return workInProgressHook;
    }
    function updateWorkInProgressHook() {
      if (null === currentHook) {
        var nextCurrentHook = currentlyRenderingFiber.alternate;
        nextCurrentHook =
          null !== nextCurrentHook ? nextCurrentHook.memoizedState : null;
      } else nextCurrentHook = currentHook.next;
      var nextWorkInProgressHook =
        null === workInProgressHook
          ? currentlyRenderingFiber.memoizedState
          : workInProgressHook.next;
      if (null !== nextWorkInProgressHook)
        (workInProgressHook = nextWorkInProgressHook),
          (currentHook = nextCurrentHook);
      else {
        if (null === nextCurrentHook) {
          if (null === currentlyRenderingFiber.alternate)
            throw Error(
              "Update hook called on initial render. This is likely a bug in React. Please file an issue."
            );
          throw Error("Rendered more hooks than during the previous render.");
        }
        currentHook = nextCurrentHook;
        nextCurrentHook = {
          memoizedState: currentHook.memoizedState,
          baseState: currentHook.baseState,
          baseQueue: currentHook.baseQueue,
          queue: currentHook.queue,
          next: null
        };
        null === workInProgressHook
          ? (currentlyRenderingFiber.memoizedState = workInProgressHook =
              nextCurrentHook)
          : (workInProgressHook = workInProgressHook.next = nextCurrentHook);
      }
      return workInProgressHook;
    }
    function createFunctionComponentUpdateQueue() {
      return { lastEffect: null, events: null, stores: null, memoCache: null };
    }
    function useThenable(thenable) {
      var index = thenableIndexCounter;
      thenableIndexCounter += 1;
      null === thenableState && (thenableState = createThenableState());
      thenable = trackUsedThenable(thenableState, thenable, index);
      index = currentlyRenderingFiber;
      null ===
        (null === workInProgressHook
          ? index.memoizedState
          : workInProgressHook.next) &&
        ((index = index.alternate),
        (ReactSharedInternals.H =
          null !== index && null !== index.memoizedState
            ? HooksDispatcherOnUpdateInDEV
            : HooksDispatcherOnMountInDEV));
      return thenable;
    }
    function use(usable) {
      if (null !== usable && "object" === typeof usable) {
        if ("function" === typeof usable.then) return useThenable(usable);
        if (usable.$$typeof === REACT_CONTEXT_TYPE) return readContext(usable);
      }
      throw Error("An unsupported type was passed to use(): " + String(usable));
    }
    function useMemoCache(size) {
      var memoCache = null,
        updateQueue = currentlyRenderingFiber.updateQueue;
      null !== updateQueue && (memoCache = updateQueue.memoCache);
      if (null == memoCache) {
        var current = currentlyRenderingFiber.alternate;
        null !== current &&
          ((current = current.updateQueue),
          null !== current &&
            ((current = current.memoCache),
            null != current &&
              (memoCache = {
                data: current.data.map(function (array) {
                  return array.slice();
                }),
                index: 0
              })));
      }
      null == memoCache && (memoCache = { data: [], index: 0 });
      null === updateQueue &&
        ((updateQueue = createFunctionComponentUpdateQueue()),
        (currentlyRenderingFiber.updateQueue = updateQueue));
      updateQueue.memoCache = memoCache;
      updateQueue = memoCache.data[memoCache.index];
      if (void 0 === updateQueue || ignorePreviousDependencies)
        for (
          updateQueue = memoCache.data[memoCache.index] = Array(size),
            current = 0;
          current < size;
          current++
        )
          updateQueue[current] = REACT_MEMO_CACHE_SENTINEL;
      else
        updateQueue.length !== size &&
          console.error(
            "Expected a constant size argument for each invocation of useMemoCache. The previous cache was allocated with size %s but size %s was requested.",
            updateQueue.length,
            size
          );
      memoCache.index++;
      return updateQueue;
    }
    function basicStateReducer(state, action) {
      return "function" === typeof action ? action(state) : action;
    }
    function mountReducer(reducer, initialArg, init) {
      var hook = mountWorkInProgressHook();
      if (void 0 !== init) {
        var initialState = init(initialArg);
        if (shouldDoubleInvokeUserFnsInHooksDEV) {
          setIsStrictModeForDevtools(!0);
          try {
            init(initialArg);
          } finally {
            setIsStrictModeForDevtools(!1);
          }
        }
      } else initialState = initialArg;
      hook.memoizedState = hook.baseState = initialState;
      reducer = {
        pending: null,
        lanes: 0,
        dispatch: null,
        lastRenderedReducer: reducer,
        lastRenderedState: initialState
      };
      hook.queue = reducer;
      reducer = reducer.dispatch = dispatchReducerAction.bind(
        null,
        currentlyRenderingFiber,
        reducer
      );
      return [hook.memoizedState, reducer];
    }
    function updateReducer(reducer) {
      var hook = updateWorkInProgressHook();
      return updateReducerImpl(hook, currentHook, reducer);
    }
    function updateReducerImpl(hook, current, reducer) {
      var queue = hook.queue;
      if (null === queue)
        throw Error(
          "Should have a queue. You are likely calling Hooks conditionally, which is not allowed. (https://react.dev/link/invalid-hook-call)"
        );
      queue.lastRenderedReducer = reducer;
      var baseQueue = hook.baseQueue,
        pendingQueue = queue.pending;
      if (null !== pendingQueue) {
        if (null !== baseQueue) {
          var baseFirst = baseQueue.next;
          baseQueue.next = pendingQueue.next;
          pendingQueue.next = baseFirst;
        }
        current.baseQueue !== baseQueue &&
          console.error(
            "Internal error: Expected work-in-progress queue to be a clone. This is a bug in React."
          );
        current.baseQueue = baseQueue = pendingQueue;
        queue.pending = null;
      }
      pendingQueue = hook.baseState;
      if (null === baseQueue) hook.memoizedState = pendingQueue;
      else {
        current = baseQueue.next;
        var newBaseQueueFirst = (baseFirst = null),
          newBaseQueueLast = null,
          update = current,
          didReadFromEntangledAsyncAction = !1;
        do {
          var updateLane = update.lane & -536870913;
          if (
            updateLane !== update.lane
              ? (workInProgressRootRenderLanes & updateLane) === updateLane
              : (renderLanes & updateLane) === updateLane
          ) {
            var revertLane = update.revertLane;
            if (0 === revertLane)
              null !== newBaseQueueLast &&
                (newBaseQueueLast = newBaseQueueLast.next =
                  {
                    lane: 0,
                    revertLane: 0,
                    gesture: null,
                    action: update.action,
                    hasEagerState: update.hasEagerState,
                    eagerState: update.eagerState,
                    next: null
                  }),
                updateLane === currentEntangledLane &&
                  (didReadFromEntangledAsyncAction = !0);
            else if ((renderLanes & revertLane) === revertLane) {
              update = update.next;
              revertLane === currentEntangledLane &&
                (didReadFromEntangledAsyncAction = !0);
              continue;
            } else
              (updateLane = {
                lane: 0,
                revertLane: update.revertLane,
                gesture: null,
                action: update.action,
                hasEagerState: update.hasEagerState,
                eagerState: update.eagerState,
                next: null
              }),
                null === newBaseQueueLast
                  ? ((newBaseQueueFirst = newBaseQueueLast = updateLane),
                    (baseFirst = pendingQueue))
                  : (newBaseQueueLast = newBaseQueueLast.next = updateLane),
                (currentlyRenderingFiber.lanes |= revertLane),
                (workInProgressRootSkippedLanes |= revertLane);
            updateLane = update.action;
            shouldDoubleInvokeUserFnsInHooksDEV &&
              reducer(pendingQueue, updateLane);
            pendingQueue = update.hasEagerState
              ? update.eagerState
              : reducer(pendingQueue, updateLane);
          } else
            (revertLane = {
              lane: updateLane,
              revertLane: update.revertLane,
              gesture: update.gesture,
              action: update.action,
              hasEagerState: update.hasEagerState,
              eagerState: update.eagerState,
              next: null
            }),
              null === newBaseQueueLast
                ? ((newBaseQueueFirst = newBaseQueueLast = revertLane),
                  (baseFirst = pendingQueue))
                : (newBaseQueueLast = newBaseQueueLast.next = revertLane),
              (currentlyRenderingFiber.lanes |= updateLane),
              (workInProgressRootSkippedLanes |= updateLane);
          update = update.next;
        } while (null !== update && update !== current);
        null === newBaseQueueLast
          ? (baseFirst = pendingQueue)
          : (newBaseQueueLast.next = newBaseQueueFirst);
        if (
          !objectIs(pendingQueue, hook.memoizedState) &&
          ((didReceiveUpdate = !0),
          didReadFromEntangledAsyncAction &&
            ((reducer = currentEntangledActionThenable), null !== reducer))
        )
          throw reducer;
        hook.memoizedState = pendingQueue;
        hook.baseState = baseFirst;
        hook.baseQueue = newBaseQueueLast;
        queue.lastRenderedState = pendingQueue;
      }
      null === baseQueue && (queue.lanes = 0);
      return [hook.memoizedState, queue.dispatch];
    }
    function rerenderReducer(reducer) {
      var hook = updateWorkInProgressHook(),
        queue = hook.queue;
      if (null === queue)
        throw Error(
          "Should have a queue. You are likely calling Hooks conditionally, which is not allowed. (https://react.dev/link/invalid-hook-call)"
        );
      queue.lastRenderedReducer = reducer;
      var dispatch = queue.dispatch,
        lastRenderPhaseUpdate = queue.pending,
        newState = hook.memoizedState;
      if (null !== lastRenderPhaseUpdate) {
        queue.pending = null;
        var update = (lastRenderPhaseUpdate = lastRenderPhaseUpdate.next);
        do
          (newState = reducer(newState, update.action)), (update = update.next);
        while (update !== lastRenderPhaseUpdate);
        objectIs(newState, hook.memoizedState) || (didReceiveUpdate = !0);
        hook.memoizedState = newState;
        null === hook.baseQueue && (hook.baseState = newState);
        queue.lastRenderedState = newState;
      }
      return [newState, dispatch];
    }
    function mountSyncExternalStore(subscribe, getSnapshot, getServerSnapshot) {
      var fiber = currentlyRenderingFiber,
        hook = mountWorkInProgressHook();
      if (isHydrating) {
        if (void 0 === getServerSnapshot)
          throw Error(
            "Missing getServerSnapshot, which is required for server-rendered content. Will revert to client rendering."
          );
        var nextSnapshot = getServerSnapshot();
        didWarnUncachedGetSnapshot ||
          nextSnapshot === getServerSnapshot() ||
          (console.error(
            "The result of getServerSnapshot should be cached to avoid an infinite loop"
          ),
          (didWarnUncachedGetSnapshot = !0));
      } else {
        nextSnapshot = getSnapshot();
        didWarnUncachedGetSnapshot ||
          ((getServerSnapshot = getSnapshot()),
          objectIs(nextSnapshot, getServerSnapshot) ||
            (console.error(
              "The result of getSnapshot should be cached to avoid an infinite loop"
            ),
            (didWarnUncachedGetSnapshot = !0)));
        if (null === workInProgressRoot)
          throw Error(
            "Expected a work-in-progress root. This is a bug in React. Please file an issue."
          );
        0 !== (workInProgressRootRenderLanes & 127) ||
          pushStoreConsistencyCheck(fiber, getSnapshot, nextSnapshot);
      }
      hook.memoizedState = nextSnapshot;
      getServerSnapshot = { value: nextSnapshot, getSnapshot: getSnapshot };
      hook.queue = getServerSnapshot;
      mountEffect(
        subscribeToStore.bind(null, fiber, getServerSnapshot, subscribe),
        [subscribe]
      );
      fiber.flags |= 2048;
      pushSimpleEffect(
        HasEffect | Passive,
        { destroy: void 0 },
        updateStoreInstance.bind(
          null,
          fiber,
          getServerSnapshot,
          nextSnapshot,
          getSnapshot
        ),
        null
      );
      return nextSnapshot;
    }
    function updateSyncExternalStore(
      subscribe,
      getSnapshot,
      getServerSnapshot
    ) {
      var fiber = currentlyRenderingFiber,
        hook = updateWorkInProgressHook(),
        isHydrating$jscomp$0 = isHydrating;
      if (isHydrating$jscomp$0) {
        if (void 0 === getServerSnapshot)
          throw Error(
            "Missing getServerSnapshot, which is required for server-rendered content. Will revert to client rendering."
          );
        getServerSnapshot = getServerSnapshot();
      } else if (
        ((getServerSnapshot = getSnapshot()), !didWarnUncachedGetSnapshot)
      ) {
        var cachedSnapshot = getSnapshot();
        objectIs(getServerSnapshot, cachedSnapshot) ||
          (console.error(
            "The result of getSnapshot should be cached to avoid an infinite loop"
          ),
          (didWarnUncachedGetSnapshot = !0));
      }
      if (
        (cachedSnapshot = !objectIs(
          (currentHook || hook).memoizedState,
          getServerSnapshot
        ))
      )
        (hook.memoizedState = getServerSnapshot), (didReceiveUpdate = !0);
      hook = hook.queue;
      var create = subscribeToStore.bind(null, fiber, hook, subscribe);
      updateEffectImpl(2048, Passive, create, [subscribe]);
      if (
        hook.getSnapshot !== getSnapshot ||
        cachedSnapshot ||
        (null !== workInProgressHook &&
          workInProgressHook.memoizedState.tag & HasEffect)
      ) {
        fiber.flags |= 2048;
        pushSimpleEffect(
          HasEffect | Passive,
          { destroy: void 0 },
          updateStoreInstance.bind(
            null,
            fiber,
            hook,
            getServerSnapshot,
            getSnapshot
          ),
          null
        );
        if (null === workInProgressRoot)
          throw Error(
            "Expected a work-in-progress root. This is a bug in React. Please file an issue."
          );
        isHydrating$jscomp$0 ||
          0 !== (renderLanes & 127) ||
          pushStoreConsistencyCheck(fiber, getSnapshot, getServerSnapshot);
      }
      return getServerSnapshot;
    }
    function pushStoreConsistencyCheck(fiber, getSnapshot, renderedSnapshot) {
      fiber.flags |= 16384;
      fiber = { getSnapshot: getSnapshot, value: renderedSnapshot };
      getSnapshot = currentlyRenderingFiber.updateQueue;
      null === getSnapshot
        ? ((getSnapshot = createFunctionComponentUpdateQueue()),
          (currentlyRenderingFiber.updateQueue = getSnapshot),
          (getSnapshot.stores = [fiber]))
        : ((renderedSnapshot = getSnapshot.stores),
          null === renderedSnapshot
            ? (getSnapshot.stores = [fiber])
            : renderedSnapshot.push(fiber));
    }
    function updateStoreInstance(fiber, inst, nextSnapshot, getSnapshot) {
      inst.value = nextSnapshot;
      inst.getSnapshot = getSnapshot;
      checkIfSnapshotChanged(inst) && forceStoreRerender(fiber);
    }
    function subscribeToStore(fiber, inst, subscribe) {
      return subscribe(function () {
        checkIfSnapshotChanged(inst) &&
          (startUpdateTimerByLane(2, "updateSyncExternalStore()", fiber),
          forceStoreRerender(fiber));
      });
    }
    function checkIfSnapshotChanged(inst) {
      var latestGetSnapshot = inst.getSnapshot;
      inst = inst.value;
      try {
        var nextValue = latestGetSnapshot();
        return !objectIs(inst, nextValue);
      } catch (error) {
        return !0;
      }
    }
    function forceStoreRerender(fiber) {
      var root = enqueueConcurrentRenderForLane(fiber, 2);
      null !== root && scheduleUpdateOnFiber(root, fiber, 2);
    }
    function mountStateImpl(initialState) {
      var hook = mountWorkInProgressHook();
      if ("function" === typeof initialState) {
        var initialStateInitializer = initialState;
        initialState = initialStateInitializer();
        if (shouldDoubleInvokeUserFnsInHooksDEV) {
          setIsStrictModeForDevtools(!0);
          try {
            initialStateInitializer();
          } finally {
            setIsStrictModeForDevtools(!1);
          }
        }
      }
      hook.memoizedState = hook.baseState = initialState;
      hook.queue = {
        pending: null,
        lanes: 0,
        dispatch: null,
        lastRenderedReducer: basicStateReducer,
        lastRenderedState: initialState
      };
      return hook;
    }
    function mountState(initialState) {
      initialState = mountStateImpl(initialState);
      var queue = initialState.queue,
        dispatch = dispatchSetState.bind(null, currentlyRenderingFiber, queue);
      queue.dispatch = dispatch;
      return [initialState.memoizedState, dispatch];
    }
    function mountOptimistic(passthrough) {
      var hook = mountWorkInProgressHook();
      hook.memoizedState = hook.baseState = passthrough;
      var queue = {
        pending: null,
        lanes: 0,
        dispatch: null,
        lastRenderedReducer: null,
        lastRenderedState: null
      };
      hook.queue = queue;
      hook = dispatchOptimisticSetState.bind(
        null,
        currentlyRenderingFiber,
        !0,
        queue
      );
      queue.dispatch = hook;
      return [passthrough, hook];
    }
    function updateOptimistic(passthrough, reducer) {
      var hook = updateWorkInProgressHook();
      return updateOptimisticImpl(hook, currentHook, passthrough, reducer);
    }
    function updateOptimisticImpl(hook, current, passthrough, reducer) {
      hook.baseState = passthrough;
      return updateReducerImpl(
        hook,
        currentHook,
        "function" === typeof reducer ? reducer : basicStateReducer
      );
    }
    function rerenderOptimistic(passthrough, reducer) {
      var hook = updateWorkInProgressHook();
      if (null !== currentHook)
        return updateOptimisticImpl(hook, currentHook, passthrough, reducer);
      hook.baseState = passthrough;
      return [passthrough, hook.queue.dispatch];
    }
    function dispatchActionState(
      fiber,
      actionQueue,
      setPendingState,
      setState,
      payload
    ) {
      if (isRenderPhaseUpdate(fiber))
        throw Error("Cannot update form state while rendering.");
      fiber = actionQueue.action;
      if (null !== fiber) {
        var actionNode = {
          payload: payload,
          action: fiber,
          next: null,
          isTransition: !0,
          status: "pending",
          value: null,
          reason: null,
          listeners: [],
          then: function (listener) {
            actionNode.listeners.push(listener);
          }
        };
        null !== ReactSharedInternals.T
          ? setPendingState(!0)
          : (actionNode.isTransition = !1);
        setState(actionNode);
        setPendingState = actionQueue.pending;
        null === setPendingState
          ? ((actionNode.next = actionQueue.pending = actionNode),
            runActionStateAction(actionQueue, actionNode))
          : ((actionNode.next = setPendingState.next),
            (actionQueue.pending = setPendingState.next = actionNode));
      }
    }
    function runActionStateAction(actionQueue, node) {
      var action = node.action,
        payload = node.payload,
        prevState = actionQueue.state;
      if (node.isTransition) {
        var prevTransition = ReactSharedInternals.T,
          currentTransition = {};
        currentTransition._updatedFibers = new Set();
        ReactSharedInternals.T = currentTransition;
        try {
          var returnValue = action(prevState, payload),
            onStartTransitionFinish = ReactSharedInternals.S;
          null !== onStartTransitionFinish &&
            onStartTransitionFinish(currentTransition, returnValue);
          handleActionReturnValue(actionQueue, node, returnValue);
        } catch (error) {
          onActionError(actionQueue, node, error);
        } finally {
          null !== prevTransition &&
            null !== currentTransition.types &&
            (null !== prevTransition.types &&
              prevTransition.types !== currentTransition.types &&
              console.error(
                "We expected inner Transitions to have transferred the outer types set and that you cannot add to the outer Transition while inside the inner.This is a bug in React."
              ),
            (prevTransition.types = currentTransition.types)),
            (ReactSharedInternals.T = prevTransition),
            null === prevTransition &&
              currentTransition._updatedFibers &&
              ((actionQueue = currentTransition._updatedFibers.size),
              currentTransition._updatedFibers.clear(),
              10 < actionQueue &&
                console.warn(
                  "Detected a large number of updates inside startTransition. If this is due to a subscription please re-write it to use React provided hooks. Otherwise concurrent mode guarantees are off the table."
                ));
        }
      } else
        try {
          (currentTransition = action(prevState, payload)),
            handleActionReturnValue(actionQueue, node, currentTransition);
        } catch (error$4) {
          onActionError(actionQueue, node, error$4);
        }
    }
    function handleActionReturnValue(actionQueue, node, returnValue) {
      null !== returnValue &&
      "object" === typeof returnValue &&
      "function" === typeof returnValue.then
        ? (ReactSharedInternals.asyncTransitions++,
          returnValue.then(releaseAsyncTransition, releaseAsyncTransition),
          returnValue.then(
            function (nextState) {
              onActionSuccess(actionQueue, node, nextState);
            },
            function (error) {
              return onActionError(actionQueue, node, error);
            }
          ),
          node.isTransition ||
            console.error(
              "An async function with useActionState was called outside of a transition. This is likely not what you intended (for example, isPending will not update correctly). Either call the returned function inside startTransition, or pass it to an `action` or `formAction` prop."
            ))
        : onActionSuccess(actionQueue, node, returnValue);
    }
    function onActionSuccess(actionQueue, actionNode, nextState) {
      actionNode.status = "fulfilled";
      actionNode.value = nextState;
      notifyActionListeners(actionNode);
      actionQueue.state = nextState;
      actionNode = actionQueue.pending;
      null !== actionNode &&
        ((nextState = actionNode.next),
        nextState === actionNode
          ? (actionQueue.pending = null)
          : ((nextState = nextState.next),
            (actionNode.next = nextState),
            runActionStateAction(actionQueue, nextState)));
    }
    function onActionError(actionQueue, actionNode, error) {
      var last = actionQueue.pending;
      actionQueue.pending = null;
      if (null !== last) {
        last = last.next;
        do
          (actionNode.status = "rejected"),
            (actionNode.reason = error),
            notifyActionListeners(actionNode),
            (actionNode = actionNode.next);
        while (actionNode !== last);
      }
      actionQueue.action = null;
    }
    function notifyActionListeners(actionNode) {
      actionNode = actionNode.listeners;
      for (var i = 0; i < actionNode.length; i++) (0, actionNode[i])();
    }
    function actionStateReducer(oldState, newState) {
      return newState;
    }
    function mountActionState(action, initialStateProp) {
      if (isHydrating) {
        var ssrFormState = workInProgressRoot.formState;
        if (null !== ssrFormState) {
          a: {
            var isMatching = currentlyRenderingFiber;
            if (isHydrating) {
              if (nextHydratableInstance) {
                b: {
                  var markerInstance = nextHydratableInstance;
                  for (
                    var inRootOrSingleton = rootOrSingletonContext;
                    8 !== markerInstance.nodeType;

                  ) {
                    if (!inRootOrSingleton) {
                      markerInstance = null;
                      break b;
                    }
                    markerInstance = getNextHydratable(
                      markerInstance.nextSibling
                    );
                    if (null === markerInstance) {
                      markerInstance = null;
                      break b;
                    }
                  }
                  inRootOrSingleton = markerInstance.data;
                  markerInstance =
                    inRootOrSingleton === FORM_STATE_IS_MATCHING ||
                    inRootOrSingleton === FORM_STATE_IS_NOT_MATCHING
                      ? markerInstance
                      : null;
                }
                if (markerInstance) {
                  nextHydratableInstance = getNextHydratable(
                    markerInstance.nextSibling
                  );
                  isMatching = markerInstance.data === FORM_STATE_IS_MATCHING;
                  break a;
                }
              }
              throwOnHydrationMismatch(isMatching);
            }
            isMatching = !1;
          }
          isMatching && (initialStateProp = ssrFormState[0]);
        }
      }
      ssrFormState = mountWorkInProgressHook();
      ssrFormState.memoizedState = ssrFormState.baseState = initialStateProp;
      isMatching = {
        pending: null,
        lanes: 0,
        dispatch: null,
        lastRenderedReducer: actionStateReducer,
        lastRenderedState: initialStateProp
      };
      ssrFormState.queue = isMatching;
      ssrFormState = dispatchSetState.bind(
        null,
        currentlyRenderingFiber,
        isMatching
      );
      isMatching.dispatch = ssrFormState;
      isMatching = mountStateImpl(!1);
      inRootOrSingleton = dispatchOptimisticSetState.bind(
        null,
        currentlyRenderingFiber,
        !1,
        isMatching.queue
      );
      isMatching = mountWorkInProgressHook();
      markerInstance = {
        state: initialStateProp,
        dispatch: null,
        action: action,
        pending: null
      };
      isMatching.queue = markerInstance;
      ssrFormState = dispatchActionState.bind(
        null,
        currentlyRenderingFiber,
        markerInstance,
        inRootOrSingleton,
        ssrFormState
      );
      markerInstance.dispatch = ssrFormState;
      isMatching.memoizedState = action;
      return [initialStateProp, ssrFormState, !1];
    }
    function updateActionState(action) {
      var stateHook = updateWorkInProgressHook();
      return updateActionStateImpl(stateHook, currentHook, action);
    }
    function updateActionStateImpl(stateHook, currentStateHook, action) {
      currentStateHook = updateReducerImpl(
        stateHook,
        currentStateHook,
        actionStateReducer
      )[0];
      stateHook = updateReducer(basicStateReducer)[0];
      if (
        "object" === typeof currentStateHook &&
        null !== currentStateHook &&
        "function" === typeof currentStateHook.then
      )
        try {
          var state = useThenable(currentStateHook);
        } catch (x) {
          if (x === SuspenseException) throw SuspenseActionException;
          throw x;
        }
      else state = currentStateHook;
      currentStateHook = updateWorkInProgressHook();
      var actionQueue = currentStateHook.queue,
        dispatch = actionQueue.dispatch;
      action !== currentStateHook.memoizedState &&
        ((currentlyRenderingFiber.flags |= 2048),
        pushSimpleEffect(
          HasEffect | Passive,
          { destroy: void 0 },
          actionStateActionEffect.bind(null, actionQueue, action),
          null
        ));
      return [state, dispatch, stateHook];
    }
    function actionStateActionEffect(actionQueue, action) {
      actionQueue.action = action;
    }
    function rerenderActionState(action) {
      var stateHook = updateWorkInProgressHook(),
        currentStateHook = currentHook;
      if (null !== currentStateHook)
        return updateActionStateImpl(stateHook, currentStateHook, action);
      updateWorkInProgressHook();
      stateHook = stateHook.memoizedState;
      currentStateHook = updateWorkInProgressHook();
      var dispatch = currentStateHook.queue.dispatch;
      currentStateHook.memoizedState = action;
      return [stateHook, dispatch, !1];
    }
    function pushSimpleEffect(tag, inst, create, deps) {
      tag = { tag: tag, create: create, deps: deps, inst: inst, next: null };
      inst = currentlyRenderingFiber.updateQueue;
      null === inst &&
        ((inst = createFunctionComponentUpdateQueue()),
        (currentlyRenderingFiber.updateQueue = inst));
      create = inst.lastEffect;
      null === create
        ? (inst.lastEffect = tag.next = tag)
        : ((deps = create.next),
          (create.next = tag),
          (tag.next = deps),
          (inst.lastEffect = tag));
      return tag;
    }
    function mountRef(initialValue) {
      var hook = mountWorkInProgressHook();
      initialValue = { current: initialValue };
      return (hook.memoizedState = initialValue);
    }
    function mountEffectImpl(fiberFlags, hookFlags, create, deps) {
      var hook = mountWorkInProgressHook();
      currentlyRenderingFiber.flags |= fiberFlags;
      hook.memoizedState = pushSimpleEffect(
        HasEffect | hookFlags,
        { destroy: void 0 },
        create,
        void 0 === deps ? null : deps
      );
    }
    function updateEffectImpl(fiberFlags, hookFlags, create, deps) {
      var hook = updateWorkInProgressHook();
      deps = void 0 === deps ? null : deps;
      var inst = hook.memoizedState.inst;
      null !== currentHook &&
      null !== deps &&
      areHookInputsEqual(deps, currentHook.memoizedState.deps)
        ? (hook.memoizedState = pushSimpleEffect(hookFlags, inst, create, deps))
        : ((currentlyRenderingFiber.flags |= fiberFlags),
          (hook.memoizedState = pushSimpleEffect(
            HasEffect | hookFlags,
            inst,
            create,
            deps
          )));
    }
    function mountEffect(create, deps) {
      (currentlyRenderingFiber.mode & StrictEffectsMode) !== NoMode
        ? mountEffectImpl(276826112, Passive, create, deps)
        : mountEffectImpl(8390656, Passive, create, deps);
    }
    function useEffectEventImpl(payload) {
      currentlyRenderingFiber.flags |= 4;
      var componentUpdateQueue = currentlyRenderingFiber.updateQueue;
      if (null === componentUpdateQueue)
        (componentUpdateQueue = createFunctionComponentUpdateQueue()),
          (currentlyRenderingFiber.updateQueue = componentUpdateQueue),
          (componentUpdateQueue.events = [payload]);
      else {
        var events = componentUpdateQueue.events;
        null === events
          ? (componentUpdateQueue.events = [payload])
          : events.push(payload);
      }
    }
    function mountEvent(callback) {
      var hook = mountWorkInProgressHook(),
        ref = { impl: callback };
      hook.memoizedState = ref;
      return function () {
        if ((executionContext & RenderContext) !== NoContext)
          throw Error(
            "A function wrapped in useEffectEvent can't be called during rendering."
          );
        return ref.impl.apply(void 0, arguments);
      };
    }
    function updateEvent(callback) {
      var ref = updateWorkInProgressHook().memoizedState;
      useEffectEventImpl({ ref: ref, nextImpl: callback });
      return function () {
        if ((executionContext & RenderContext) !== NoContext)
          throw Error(
            "A function wrapped in useEffectEvent can't be called during rendering."
          );
        return ref.impl.apply(void 0, arguments);
      };
    }
    function mountLayoutEffect(create, deps) {
      var fiberFlags = 4194308;
      (currentlyRenderingFiber.mode & StrictEffectsMode) !== NoMode &&
        (fiberFlags |= 134217728);
      return mountEffectImpl(fiberFlags, Layout, create, deps);
    }
    function imperativeHandleEffect(create, ref) {
      if ("function" === typeof ref) {
        create = create();
        var refCleanup = ref(create);
        return function () {
          "function" === typeof refCleanup ? refCleanup() : ref(null);
        };
      }
      if (null !== ref && void 0 !== ref)
        return (
          ref.hasOwnProperty("current") ||
            console.error(
              "Expected useImperativeHandle() first argument to either be a ref callback or React.createRef() object. Instead received: %s.",
              "an object with keys {" + Object.keys(ref).join(", ") + "}"
            ),
          (create = create()),
          (ref.current = create),
          function () {
            ref.current = null;
          }
        );
    }
    function mountImperativeHandle(ref, create, deps) {
      "function" !== typeof create &&
        console.error(
          "Expected useImperativeHandle() second argument to be a function that creates a handle. Instead received: %s.",
          null !== create ? typeof create : "null"
        );
      deps = null !== deps && void 0 !== deps ? deps.concat([ref]) : null;
      var fiberFlags = 4194308;
      (currentlyRenderingFiber.mode & StrictEffectsMode) !== NoMode &&
        (fiberFlags |= 134217728);
      mountEffectImpl(
        fiberFlags,
        Layout,
        imperativeHandleEffect.bind(null, create, ref),
        deps
      );
    }
    function updateImperativeHandle(ref, create, deps) {
      "function" !== typeof create &&
        console.error(
          "Expected useImperativeHandle() second argument to be a function that creates a handle. Instead received: %s.",
          null !== create ? typeof create : "null"
        );
      deps = null !== deps && void 0 !== deps ? deps.concat([ref]) : null;
      updateEffectImpl(
        4,
        Layout,
        imperativeHandleEffect.bind(null, create, ref),
        deps
      );
    }
    function mountCallback(callback, deps) {
      mountWorkInProgressHook().memoizedState = [
        callback,
        void 0 === deps ? null : deps
      ];
      return callback;
    }
    function updateCallback(callback, deps) {
      var hook = updateWorkInProgressHook();
      deps = void 0 === deps ? null : deps;
      var prevState = hook.memoizedState;
      if (null !== deps && areHookInputsEqual(deps, prevState[1]))
        return prevState[0];
      hook.memoizedState = [callback, deps];
      return callback;
    }
    function mountMemo(nextCreate, deps) {
      var hook = mountWorkInProgressHook();
      deps = void 0 === deps ? null : deps;
      var nextValue = nextCreate();
      if (shouldDoubleInvokeUserFnsInHooksDEV) {
        setIsStrictModeForDevtools(!0);
        try {
          nextCreate();
        } finally {
          setIsStrictModeForDevtools(!1);
        }
      }
      hook.memoizedState = [nextValue, deps];
      return nextValue;
    }
    function updateMemo(nextCreate, deps) {
      var hook = updateWorkInProgressHook();
      deps = void 0 === deps ? null : deps;
      var prevState = hook.memoizedState;
      if (null !== deps && areHookInputsEqual(deps, prevState[1]))
        return prevState[0];
      prevState = nextCreate();
      if (shouldDoubleInvokeUserFnsInHooksDEV) {
        setIsStrictModeForDevtools(!0);
        try {
          nextCreate();
        } finally {
          setIsStrictModeForDevtools(!1);
        }
      }
      hook.memoizedState = [prevState, deps];
      return prevState;
    }
    function mountDeferredValue(value, initialValue) {
      var hook = mountWorkInProgressHook();
      return mountDeferredValueImpl(hook, value, initialValue);
    }
    function updateDeferredValue(value, initialValue) {
      var hook = updateWorkInProgressHook();
      return updateDeferredValueImpl(
        hook,
        currentHook.memoizedState,
        value,
        initialValue
      );
    }
    function rerenderDeferredValue(value, initialValue) {
      var hook = updateWorkInProgressHook();
      return null === currentHook
        ? mountDeferredValueImpl(hook, value, initialValue)
        : updateDeferredValueImpl(
            hook,
            currentHook.memoizedState,
            value,
            initialValue
          );
    }
    function mountDeferredValueImpl(hook, value, initialValue) {
      if (
        void 0 === initialValue ||
        (0 !== (renderLanes & 1073741824) &&
          0 === (workInProgressRootRenderLanes & 261930))
      )
        return (hook.memoizedState = value);
      hook.memoizedState = initialValue;
      hook = requestDeferredLane();
      currentlyRenderingFiber.lanes |= hook;
      workInProgressRootSkippedLanes |= hook;
      return initialValue;
    }
    function updateDeferredValueImpl(hook, prevValue, value, initialValue) {
      if (objectIs(value, prevValue)) return value;
      if (null !== currentTreeHiddenStackCursor.current)
        return (
          (hook = mountDeferredValueImpl(hook, value, initialValue)),
          objectIs(hook, prevValue) || (didReceiveUpdate = !0),
          hook
        );
      if (
        0 === (renderLanes & 42) ||
        (0 !== (renderLanes & 1073741824) &&
          0 === (workInProgressRootRenderLanes & 261930))
      )
        return (didReceiveUpdate = !0), (hook.memoizedState = value);
      hook = requestDeferredLane();
      currentlyRenderingFiber.lanes |= hook;
      workInProgressRootSkippedLanes |= hook;
      return prevValue;
    }
    function releaseAsyncTransition() {
      ReactSharedInternals.asyncTransitions--;
    }
    function startTransition(
      fiber,
      queue,
      pendingState,
      finishedState,
      callback
    ) {
      var previousPriority = ReactDOMSharedInternals.p;
      ReactDOMSharedInternals.p =
        0 !== previousPriority && previousPriority < ContinuousEventPriority
          ? previousPriority
          : ContinuousEventPriority;
      var prevTransition = ReactSharedInternals.T,
        currentTransition = {};
      currentTransition._updatedFibers = new Set();
      ReactSharedInternals.T = currentTransition;
      dispatchOptimisticSetState(fiber, !1, queue, pendingState);
      try {
        var returnValue = callback(),
          onStartTransitionFinish = ReactSharedInternals.S;
        null !== onStartTransitionFinish &&
          onStartTransitionFinish(currentTransition, returnValue);
        if (
          null !== returnValue &&
          "object" === typeof returnValue &&
          "function" === typeof returnValue.then
        ) {
          ReactSharedInternals.asyncTransitions++;
          returnValue.then(releaseAsyncTransition, releaseAsyncTransition);
          var thenableForFinishedState = chainThenableValue(
            returnValue,
            finishedState
          );
          dispatchSetStateInternal(
            fiber,
            queue,
            thenableForFinishedState,
            requestUpdateLane(fiber)
          );
        } else
          dispatchSetStateInternal(
            fiber,
            queue,
            finishedState,
            requestUpdateLane(fiber)
          );
      } catch (error) {
        dispatchSetStateInternal(
          fiber,
          queue,
          { then: function () {}, status: "rejected", reason: error },
          requestUpdateLane(fiber)
        );
      } finally {
        (ReactDOMSharedInternals.p = previousPriority),
          null !== prevTransition &&
            null !== currentTransition.types &&
            (null !== prevTransition.types &&
              prevTransition.types !== currentTransition.types &&
              console.error(
                "We expected inner Transitions to have transferred the outer types set and that you cannot add to the outer Transition while inside the inner.This is a bug in React."
              ),
            (prevTransition.types = currentTransition.types)),
          (ReactSharedInternals.T = prevTransition),
          null === prevTransition &&
            currentTransition._updatedFibers &&
            ((fiber = currentTransition._updatedFibers.size),
            currentTransition._updatedFibers.clear(),
            10 < fiber &&
              console.warn(
                "Detected a large number of updates inside startTransition. If this is due to a subscription please re-write it to use React provided hooks. Otherwise concurrent mode guarantees are off the table."
              ));
      }
    }
    function startHostTransition(formFiber, pendingState, action, formData) {
      if (5 !== formFiber.tag)
        throw Error(
          "Expected the form instance to be a HostComponent. This is a bug in React."
        );
      var queue = ensureFormComponentIsStateful(formFiber).queue;
      startHostActionTimer(formFiber);
      startTransition(
        formFiber,
        queue,
        pendingState,
        NotPendingTransition,
        null === action
          ? noop
          : function () {
              requestFormReset$1(formFiber);
              return action(formData);
            }
      );
    }
    function ensureFormComponentIsStateful(formFiber) {
      var existingStateHook = formFiber.memoizedState;
      if (null !== existingStateHook) return existingStateHook;
      existingStateHook = {
        memoizedState: NotPendingTransition,
        baseState: NotPendingTransition,
        baseQueue: null,
        queue: {
          pending: null,
          lanes: 0,
          dispatch: null,
          lastRenderedReducer: basicStateReducer,
          lastRenderedState: NotPendingTransition
        },
        next: null
      };
      var initialResetState = {};
      existingStateHook.next = {
        memoizedState: initialResetState,
        baseState: initialResetState,
        baseQueue: null,
        queue: {
          pending: null,
          lanes: 0,
          dispatch: null,
          lastRenderedReducer: basicStateReducer,
          lastRenderedState: initialResetState
        },
        next: null
      };
      formFiber.memoizedState = existingStateHook;
      formFiber = formFiber.alternate;
      null !== formFiber && (formFiber.memoizedState = existingStateHook);
      return existingStateHook;
    }
    function requestFormReset$1(formFiber) {
      null === ReactSharedInternals.T &&
        console.error(
          "requestFormReset was called outside a transition or action. To fix, move to an action, or wrap with startTransition."
        );
      var stateHook = ensureFormComponentIsStateful(formFiber);
      null === stateHook.next &&
        (stateHook = formFiber.alternate.memoizedState);
      dispatchSetStateInternal(
        formFiber,
        stateHook.next.queue,
        {},
        requestUpdateLane(formFiber)
      );
    }
    function mountTransition() {
      var stateHook = mountStateImpl(!1);
      stateHook = startTransition.bind(
        null,
        currentlyRenderingFiber,
        stateHook.queue,
        !0,
        !1
      );
      mountWorkInProgressHook().memoizedState = stateHook;
      return [!1, stateHook];
    }
    function updateTransition() {
      var booleanOrThenable = updateReducer(basicStateReducer)[0],
        start = updateWorkInProgressHook().memoizedState;
      return [
        "boolean" === typeof booleanOrThenable
          ? booleanOrThenable
          : useThenable(booleanOrThenable),
        start
      ];
    }
    function rerenderTransition() {
      var booleanOrThenable = rerenderReducer(basicStateReducer)[0],
        start = updateWorkInProgressHook().memoizedState;
      return [
        "boolean" === typeof booleanOrThenable
          ? booleanOrThenable
          : useThenable(booleanOrThenable),
        start
      ];
    }
    function useHostTransitionStatus() {
      return readContext(HostTransitionContext);
    }
    function mountId() {
      var hook = mountWorkInProgressHook(),
        identifierPrefix = workInProgressRoot.identifierPrefix;
      if (isHydrating) {
        var treeId = treeContextOverflow;
        var idWithLeadingBit = treeContextId;
        treeId =
          (
            idWithLeadingBit & ~(1 << (32 - clz32(idWithLeadingBit) - 1))
          ).toString(32) + treeId;
        identifierPrefix = "_" + identifierPrefix + "R_" + treeId;
        treeId = localIdCounter++;
        0 < treeId && (identifierPrefix += "H" + treeId.toString(32));
        identifierPrefix += "_";
      } else
        (treeId = globalClientIdCounter++),
          (identifierPrefix =
            "_" + identifierPrefix + "r_" + treeId.toString(32) + "_");
      return (hook.memoizedState = identifierPrefix);
    }
    function mountRefresh() {
      return (mountWorkInProgressHook().memoizedState = refreshCache.bind(
        null,
        currentlyRenderingFiber
      ));
    }
    function refreshCache(fiber, seedKey) {
      for (var provider = fiber.return; null !== provider; ) {
        switch (provider.tag) {
          case 24:
          case 3:
            var lane = requestUpdateLane(provider),
              refreshUpdate = createUpdate(lane),
              root = enqueueUpdate(provider, refreshUpdate, lane);
            null !== root &&
              (startUpdateTimerByLane(lane, "refresh()", fiber),
              scheduleUpdateOnFiber(root, provider, lane),
              entangleTransitions(root, provider, lane));
            fiber = createCache();
            null !== seedKey &&
              void 0 !== seedKey &&
              null !== root &&
              console.error(
                "The seed argument is not enabled outside experimental channels."
              );
            refreshUpdate.payload = { cache: fiber };
            return;
        }
        provider = provider.return;
      }
    }
    function dispatchReducerAction(fiber, queue, action) {
      var args = arguments;
      "function" === typeof args[3] &&
        console.error(
          "State updates from the useState() and useReducer() Hooks don't support the second callback argument. To execute a side effect after rendering, declare it in the component body with useEffect()."
        );
      args = requestUpdateLane(fiber);
      var update = {
        lane: args,
        revertLane: 0,
        gesture: null,
        action: action,
        hasEagerState: !1,
        eagerState: null,
        next: null
      };
      isRenderPhaseUpdate(fiber)
        ? enqueueRenderPhaseUpdate(queue, update)
        : ((update = enqueueConcurrentHookUpdate(fiber, queue, update, args)),
          null !== update &&
            (startUpdateTimerByLane(args, "dispatch()", fiber),
            scheduleUpdateOnFiber(update, fiber, args),
            entangleTransitionUpdate(update, queue, args)));
    }
    function dispatchSetState(fiber, queue, action) {
      var args = arguments;
      "function" === typeof args[3] &&
        console.error(
          "State updates from the useState() and useReducer() Hooks don't support the second callback argument. To execute a side effect after rendering, declare it in the component body with useEffect()."
        );
      args = requestUpdateLane(fiber);
      dispatchSetStateInternal(fiber, queue, action, args) &&
        startUpdateTimerByLane(args, "setState()", fiber);
    }
    function dispatchSetStateInternal(fiber, queue, action, lane) {
      var update = {
        lane: lane,
        revertLane: 0,
        gesture: null,
        action: action,
        hasEagerState: !1,
        eagerState: null,
        next: null
      };
      if (isRenderPhaseUpdate(fiber)) enqueueRenderPhaseUpdate(queue, update);
      else {
        var alternate = fiber.alternate;
        if (
          0 === fiber.lanes &&
          (null === alternate || 0 === alternate.lanes) &&
          ((alternate = queue.lastRenderedReducer), null !== alternate)
        ) {
          var prevDispatcher = ReactSharedInternals.H;
          ReactSharedInternals.H = InvalidNestedHooksDispatcherOnUpdateInDEV;
          try {
            var currentState = queue.lastRenderedState,
              eagerState = alternate(currentState, action);
            update.hasEagerState = !0;
            update.eagerState = eagerState;
            if (objectIs(eagerState, currentState))
              return (
                enqueueUpdate$1(fiber, queue, update, 0),
                null === workInProgressRoot &&
                  finishQueueingConcurrentUpdates(),
                !1
              );
          } catch (error) {
          } finally {
            ReactSharedInternals.H = prevDispatcher;
          }
        }
        action = enqueueConcurrentHookUpdate(fiber, queue, update, lane);
        if (null !== action)
          return (
            scheduleUpdateOnFiber(action, fiber, lane),
            entangleTransitionUpdate(action, queue, lane),
            !0
          );
      }
      return !1;
    }
    function dispatchOptimisticSetState(
      fiber,
      throwIfDuringRender,
      queue,
      action
    ) {
      null === ReactSharedInternals.T &&
        0 === currentEntangledLane &&
        console.error(
          "An optimistic state update occurred outside a transition or action. To fix, move the update to an action, or wrap with startTransition."
        );
      action = {
        lane: 2,
        revertLane: requestTransitionLane(),
        gesture: null,
        action: action,
        hasEagerState: !1,
        eagerState: null,
        next: null
      };
      if (isRenderPhaseUpdate(fiber)) {
        if (throwIfDuringRender)
          throw Error("Cannot update optimistic state while rendering.");
        console.error("Cannot call startTransition while rendering.");
      } else
        (throwIfDuringRender = enqueueConcurrentHookUpdate(
          fiber,
          queue,
          action,
          2
        )),
          null !== throwIfDuringRender &&
            (startUpdateTimerByLane(2, "setOptimistic()", fiber),
            scheduleUpdateOnFiber(throwIfDuringRender, fiber, 2));
    }
    function isRenderPhaseUpdate(fiber) {
      var alternate = fiber.alternate;
      return (
        fiber === currentlyRenderingFiber ||
        (null !== alternate && alternate === currentlyRenderingFiber)
      );
    }
    function enqueueRenderPhaseUpdate(queue, update) {
      didScheduleRenderPhaseUpdateDuringThisPass =
        didScheduleRenderPhaseUpdate = !0;
      var pending = queue.pending;
      null === pending
        ? (update.next = update)
        : ((update.next = pending.next), (pending.next = update));
      queue.pending = update;
    }
    function entangleTransitionUpdate(root, queue, lane) {
      if (0 !== (lane & 4194048)) {
        var queueLanes = queue.lanes;
        queueLanes &= root.pendingLanes;
        lane |= queueLanes;
        queue.lanes = lane;
        markRootEntangled(root, lane);
      }
    }
    function warnOnInvalidCallback(callback) {
      if (null !== callback && "function" !== typeof callback) {
        var key = String(callback);
        didWarnOnInvalidCallback.has(key) ||
          (didWarnOnInvalidCallback.add(key),
          console.error(
            "Expected the last optional `callback` argument to be a function. Instead received: %s.",
            callback
          ));
      }
    }
    function applyDerivedStateFromProps(
      workInProgress,
      ctor,
      getDerivedStateFromProps,
      nextProps
    ) {
      var prevState = workInProgress.memoizedState,
        partialState = getDerivedStateFromProps(nextProps, prevState);
      if (workInProgress.mode & StrictLegacyMode) {
        setIsStrictModeForDevtools(!0);
        try {
          partialState = getDerivedStateFromProps(nextProps, prevState);
        } finally {
          setIsStrictModeForDevtools(!1);
        }
      }
      void 0 === partialState &&
        ((ctor = getComponentNameFromType(ctor) || "Component"),
        didWarnAboutUndefinedDerivedState.has(ctor) ||
          (didWarnAboutUndefinedDerivedState.add(ctor),
          console.error(
            "%s.getDerivedStateFromProps(): A valid state object (or null) must be returned. You have returned undefined.",
            ctor
          )));
      prevState =
        null === partialState || void 0 === partialState
          ? prevState
          : assign({}, prevState, partialState);
      workInProgress.memoizedState = prevState;
      0 === workInProgress.lanes &&
        (workInProgress.updateQueue.baseState = prevState);
    }
    function checkShouldComponentUpdate(
      workInProgress,
      ctor,
      oldProps,
      newProps,
      oldState,
      newState,
      nextContext
    ) {
      var instance = workInProgress.stateNode;
      if ("function" === typeof instance.shouldComponentUpdate) {
        oldProps = instance.shouldComponentUpdate(
          newProps,
          newState,
          nextContext
        );
        if (workInProgress.mode & StrictLegacyMode) {
          setIsStrictModeForDevtools(!0);
          try {
            oldProps = instance.shouldComponentUpdate(
              newProps,
              newState,
              nextContext
            );
          } finally {
            setIsStrictModeForDevtools(!1);
          }
        }
        void 0 === oldProps &&
          console.error(
            "%s.shouldComponentUpdate(): Returned undefined instead of a boolean value. Make sure to return true or false.",
            getComponentNameFromType(ctor) || "Component"
          );
        return oldProps;
      }
      return ctor.prototype && ctor.prototype.isPureReactComponent
        ? !shallowEqual(oldProps, newProps) || !shallowEqual(oldState, newState)
        : !0;
    }
    function callComponentWillReceiveProps(
      workInProgress,
      instance,
      newProps,
      nextContext
    ) {
      var oldState = instance.state;
      "function" === typeof instance.componentWillReceiveProps &&
        instance.componentWillReceiveProps(newProps, nextContext);
      "function" === typeof instance.UNSAFE_componentWillReceiveProps &&
        instance.UNSAFE_componentWillReceiveProps(newProps, nextContext);
      instance.state !== oldState &&
        ((workInProgress =
          getComponentNameFromFiber(workInProgress) || "Component"),
        didWarnAboutStateAssignmentForComponent.has(workInProgress) ||
          (didWarnAboutStateAssignmentForComponent.add(workInProgress),
          console.error(
            "%s.componentWillReceiveProps(): Assigning directly to this.state is deprecated (except inside a component's constructor). Use setState instead.",
            workInProgress
          )),
        classComponentUpdater.enqueueReplaceState(
          instance,
          instance.state,
          null
        ));
    }
    function resolveClassComponentProps(Component, baseProps) {
      var newProps = baseProps;
      if ("ref" in baseProps) {
        newProps = {};
        for (var propName in baseProps)
          "ref" !== propName && (newProps[propName] = baseProps[propName]);
      }
      if ((Component = Component.defaultProps)) {
        newProps === baseProps && (newProps = assign({}, newProps));
        for (var _propName in Component)
          void 0 === newProps[_propName] &&
            (newProps[_propName] = Component[_propName]);
      }
      return newProps;
    }
    function defaultOnUncaughtError(error) {
      reportGlobalError(error);
      console.warn(
        "%s\n\n%s\n",
        componentName
          ? "An error occurred in the <" + componentName + "> component."
          : "An error occurred in one of your React components.",
        "Consider adding an error boundary to your tree to customize error handling behavior.\nVisit https://react.dev/link/error-boundaries to learn more about error boundaries."
      );
    }
    function defaultOnCaughtError(error) {
      var componentNameMessage = componentName
          ? "The above error occurred in the <" + componentName + "> component."
          : "The above error occurred in one of your React components.",
        recreateMessage =
          "React will try to recreate this component tree from scratch using the error boundary you provided, " +
          ((errorBoundaryName || "Anonymous") + ".");
      if (
        "object" === typeof error &&
        null !== error &&
        "string" === typeof error.environmentName
      ) {
        var JSCompiler_inline_result = error.environmentName;
        error = [
          "%o\n\n%s\n\n%s\n",
          error,
          componentNameMessage,
          recreateMessage
        ].slice(0);
        "string" === typeof error[0]
          ? error.splice(
              0,
              1,
              badgeFormat + " " + error[0],
              badgeStyle,
              pad + JSCompiler_inline_result + pad,
              resetStyle
            )
          : error.splice(
              0,
              0,
              badgeFormat,
              badgeStyle,
              pad + JSCompiler_inline_result + pad,
              resetStyle
            );
        error.unshift(console);
        JSCompiler_inline_result = bind.apply(console.error, error);
        JSCompiler_inline_result();
      } else
        console.error(
          "%o\n\n%s\n\n%s\n",
          error,
          componentNameMessage,
          recreateMessage
        );
    }
    function defaultOnRecoverableError(error) {
      reportGlobalError(error);
    }
    function logUncaughtError(root, errorInfo) {
      try {
        componentName = errorInfo.source
          ? getComponentNameFromFiber(errorInfo.source)
          : null;
        errorBoundaryName = null;
        var error = errorInfo.value;
        if (null !== ReactSharedInternals.actQueue)
          ReactSharedInternals.thrownErrors.push(error);
        else {
          var onUncaughtError = root.onUncaughtError;
          onUncaughtError(error, { componentStack: errorInfo.stack });
        }
      } catch (e$5) {
        setTimeout(function () {
          throw e$5;
        });
      }
    }
    function logCaughtError(root, boundary, errorInfo) {
      try {
        componentName = errorInfo.source
          ? getComponentNameFromFiber(errorInfo.source)
          : null;
        errorBoundaryName = getComponentNameFromFiber(boundary);
        var onCaughtError = root.onCaughtError;
        onCaughtError(errorInfo.value, {
          componentStack: errorInfo.stack,
          errorBoundary: 1 === boundary.tag ? boundary.stateNode : null
        });
      } catch (e$6) {
        setTimeout(function () {
          throw e$6;
        });
      }
    }
    function createRootErrorUpdate(root, errorInfo, lane) {
      lane = createUpdate(lane);
      lane.tag = CaptureUpdate;
      lane.payload = { element: null };
      lane.callback = function () {
        runWithFiberInDEV(errorInfo.source, logUncaughtError, root, errorInfo);
      };
      return lane;
    }
    function createClassErrorUpdate(lane) {
      lane = createUpdate(lane);
      lane.tag = CaptureUpdate;
      return lane;
    }
    function initializeClassErrorUpdate(update, root, fiber, errorInfo) {
      var getDerivedStateFromError = fiber.type.getDerivedStateFromError;
      if ("function" === typeof getDerivedStateFromError) {
        var error = errorInfo.value;
        update.payload = function () {
          return getDerivedStateFromError(error);
        };
        update.callback = function () {
          markFailedErrorBoundaryForHotReloading(fiber);
          runWithFiberInDEV(
            errorInfo.source,
            logCaughtError,
            root,
            fiber,
            errorInfo
          );
        };
      }
      var inst = fiber.stateNode;
      null !== inst &&
        "function" === typeof inst.componentDidCatch &&
        (update.callback = function () {
          markFailedErrorBoundaryForHotReloading(fiber);
          runWithFiberInDEV(
            errorInfo.source,
            logCaughtError,
            root,
            fiber,
            errorInfo
          );
          "function" !== typeof getDerivedStateFromError &&
            (null === legacyErrorBoundariesThatAlreadyFailed
              ? (legacyErrorBoundariesThatAlreadyFailed = new Set([this]))
              : legacyErrorBoundariesThatAlreadyFailed.add(this));
          callComponentDidCatchInDEV(this, errorInfo);
          "function" === typeof getDerivedStateFromError ||
            (0 === (fiber.lanes & 2) &&
              console.error(
                "%s: Error boundaries should implement getDerivedStateFromError(). In that method, return a state update to display an error message or fallback UI.",
                getComponentNameFromFiber(fiber) || "Unknown"
              ));
        });
    }
    function throwException(
      root,
      returnFiber,
      sourceFiber,
      value,
      rootRenderLanes
    ) {
      sourceFiber.flags |= 32768;
      isDevToolsPresent && restorePendingUpdaters(root, rootRenderLanes);
      if (
        null !== value &&
        "object" === typeof value &&
        "function" === typeof value.then
      ) {
        returnFiber = sourceFiber.alternate;
        null !== returnFiber &&
          propagateParentContextChanges(
            returnFiber,
            sourceFiber,
            rootRenderLanes,
            !0
          );
        isHydrating && (didSuspendOrErrorDEV = !0);
        sourceFiber = suspenseHandlerStackCursor.current;
        if (null !== sourceFiber) {
          switch (sourceFiber.tag) {
            case 31:
            case 13:
              return (
                null === shellBoundary
                  ? renderDidSuspendDelayIfPossible()
                  : null === sourceFiber.alternate &&
                    workInProgressRootExitStatus === RootInProgress &&
                    (workInProgressRootExitStatus = RootSuspended),
                (sourceFiber.flags &= -257),
                (sourceFiber.flags |= 65536),
                (sourceFiber.lanes = rootRenderLanes),
                value === noopSuspenseyCommitThenable
                  ? (sourceFiber.flags |= 16384)
                  : ((returnFiber = sourceFiber.updateQueue),
                    null === returnFiber
                      ? (sourceFiber.updateQueue = new Set([value]))
                      : returnFiber.add(value),
                    attachPingListener(root, value, rootRenderLanes)),
                !1
              );
            case 22:
              return (
                (sourceFiber.flags |= 65536),
                value === noopSuspenseyCommitThenable
                  ? (sourceFiber.flags |= 16384)
                  : ((returnFiber = sourceFiber.updateQueue),
                    null === returnFiber
                      ? ((returnFiber = {
                          transitions: null,
                          markerInstances: null,
                          retryQueue: new Set([value])
                        }),
                        (sourceFiber.updateQueue = returnFiber))
                      : ((sourceFiber = returnFiber.retryQueue),
                        null === sourceFiber
                          ? (returnFiber.retryQueue = new Set([value]))
                          : sourceFiber.add(value)),
                    attachPingListener(root, value, rootRenderLanes)),
                !1
              );
          }
          throw Error(
            "Unexpected Suspense handler tag (" +
              sourceFiber.tag +
              "). This is a bug in React."
          );
        }
        attachPingListener(root, value, rootRenderLanes);
        renderDidSuspendDelayIfPossible();
        return !1;
      }
      if (isHydrating)
        return (
          (didSuspendOrErrorDEV = !0),
          (returnFiber = suspenseHandlerStackCursor.current),
          null !== returnFiber
            ? (0 === (returnFiber.flags & 65536) && (returnFiber.flags |= 256),
              (returnFiber.flags |= 65536),
              (returnFiber.lanes = rootRenderLanes),
              value !== HydrationMismatchException &&
                queueHydrationError(
                  createCapturedValueAtFiber(
                    Error(
                      "There was an error while hydrating but React was able to recover by instead client rendering from the nearest Suspense boundary.",
                      { cause: value }
                    ),
                    sourceFiber
                  )
                ))
            : (value !== HydrationMismatchException &&
                queueHydrationError(
                  createCapturedValueAtFiber(
                    Error(
                      "There was an error while hydrating but React was able to recover by instead client rendering the entire root.",
                      { cause: value }
                    ),
                    sourceFiber
                  )
                ),
              (root = root.current.alternate),
              (root.flags |= 65536),
              (rootRenderLanes &= -rootRenderLanes),
              (root.lanes |= rootRenderLanes),
              (value = createCapturedValueAtFiber(value, sourceFiber)),
              (rootRenderLanes = createRootErrorUpdate(
                root.stateNode,
                value,
                rootRenderLanes
              )),
              enqueueCapturedUpdate(root, rootRenderLanes),
              workInProgressRootExitStatus !== RootSuspendedWithDelay &&
                (workInProgressRootExitStatus = RootErrored)),
          !1
        );
      var error = createCapturedValueAtFiber(
        Error(
          "There was an error during concurrent rendering but React was able to recover by instead synchronously rendering the entire root.",
          { cause: value }
        ),
        sourceFiber
      );
      null === workInProgressRootConcurrentErrors
        ? (workInProgressRootConcurrentErrors = [error])
        : workInProgressRootConcurrentErrors.push(error);
      workInProgressRootExitStatus !== RootSuspendedWithDelay &&
        (workInProgressRootExitStatus = RootErrored);
      if (null === returnFiber) return !0;
      value = createCapturedValueAtFiber(value, sourceFiber);
      sourceFiber = returnFiber;
      do {
        switch (sourceFiber.tag) {
          case 3:
            return (
              (sourceFiber.flags |= 65536),
              (root = rootRenderLanes & -rootRenderLanes),
              (sourceFiber.lanes |= root),
              (root = createRootErrorUpdate(
                sourceFiber.stateNode,
                value,
                root
              )),
              enqueueCapturedUpdate(sourceFiber, root),
              !1
            );
          case 1:
            if (
              ((returnFiber = sourceFiber.type),
              (error = sourceFiber.stateNode),
              0 === (sourceFiber.flags & 128) &&
                ("function" === typeof returnFiber.getDerivedStateFromError ||
                  (null !== error &&
                    "function" === typeof error.componentDidCatch &&
                    (null === legacyErrorBoundariesThatAlreadyFailed ||
                      !legacyErrorBoundariesThatAlreadyFailed.has(error)))))
            )
              return (
                (sourceFiber.flags |= 65536),
                (rootRenderLanes &= -rootRenderLanes),
                (sourceFiber.lanes |= rootRenderLanes),
                (rootRenderLanes = createClassErrorUpdate(rootRenderLanes)),
                initializeClassErrorUpdate(
                  rootRenderLanes,
                  root,
                  sourceFiber,
                  value
                ),
                enqueueCapturedUpdate(sourceFiber, rootRenderLanes),
                !1
              );
        }
        sourceFiber = sourceFiber.return;
      } while (null !== sourceFiber);
      return !1;
    }
    function reconcileChildren(
      current,
      workInProgress,
      nextChildren,
      renderLanes
    ) {
      workInProgress.child =
        null === current
          ? mountChildFibers(workInProgress, null, nextChildren, renderLanes)
          : reconcileChildFibers(
              workInProgress,
              current.child,
              nextChildren,
              renderLanes
            );
    }
    function updateForwardRef(
      current,
      workInProgress,
      Component,
      nextProps,
      renderLanes
    ) {
      Component = Component.render;
      var ref = workInProgress.ref;
      if ("ref" in nextProps) {
        var propsWithoutRef = {};
        for (var key in nextProps)
          "ref" !== key && (propsWithoutRef[key] = nextProps[key]);
      } else propsWithoutRef = nextProps;
      prepareToReadContext(workInProgress);
      nextProps = renderWithHooks(
        current,
        workInProgress,
        Component,
        propsWithoutRef,
        ref,
        renderLanes
      );
      key = checkDidRenderIdHook();
      if (null !== current && !didReceiveUpdate)
        return (
          bailoutHooks(current, workInProgress, renderLanes),
          bailoutOnAlreadyFinishedWork(current, workInProgress, renderLanes)
        );
      isHydrating && key && pushMaterializedTreeId(workInProgress);
      workInProgress.flags |= 1;
      reconcileChildren(current, workInProgress, nextProps, renderLanes);
      return workInProgress.child;
    }
    function updateMemoComponent(
      current,
      workInProgress,
      Component,
      nextProps,
      renderLanes
    ) {
      if (null === current) {
        var type = Component.type;
        if (
          "function" === typeof type &&
          !shouldConstruct(type) &&
          void 0 === type.defaultProps &&
          null === Component.compare
        )
          return (
            (Component = resolveFunctionForHotReloading(type)),
            (workInProgress.tag = 15),
            (workInProgress.type = Component),
            validateFunctionComponentInDev(workInProgress, type),
            updateSimpleMemoComponent(
              current,
              workInProgress,
              Component,
              nextProps,
              renderLanes
            )
          );
        current = createFiberFromTypeAndProps(
          Component.type,
          null,
          nextProps,
          workInProgress,
          workInProgress.mode,
          renderLanes
        );
        current.ref = workInProgress.ref;
        current.return = workInProgress;
        return (workInProgress.child = current);
      }
      type = current.child;
      if (!checkScheduledUpdateOrContext(current, renderLanes)) {
        var prevProps = type.memoizedProps;
        Component = Component.compare;
        Component = null !== Component ? Component : shallowEqual;
        if (
          Component(prevProps, nextProps) &&
          current.ref === workInProgress.ref
        )
          return bailoutOnAlreadyFinishedWork(
            current,
            workInProgress,
            renderLanes
          );
      }
      workInProgress.flags |= 1;
      current = createWorkInProgress(type, nextProps);
      current.ref = workInProgress.ref;
      current.return = workInProgress;
      return (workInProgress.child = current);
    }
    function updateSimpleMemoComponent(
      current,
      workInProgress,
      Component,
      nextProps,
      renderLanes
    ) {
      if (null !== current) {
        var prevProps = current.memoizedProps;
        if (
          shallowEqual(prevProps, nextProps) &&
          current.ref === workInProgress.ref &&
          workInProgress.type === current.type
        )
          if (
            ((didReceiveUpdate = !1),
            (workInProgress.pendingProps = nextProps = prevProps),
            checkScheduledUpdateOrContext(current, renderLanes))
          )
            0 !== (current.flags & 131072) && (didReceiveUpdate = !0);
          else
            return (
              (workInProgress.lanes = current.lanes),
              bailoutOnAlreadyFinishedWork(current, workInProgress, renderLanes)
            );
      }
      return updateFunctionComponent(
        current,
        workInProgress,
        Component,
        nextProps,
        renderLanes
      );
    }
    function updateOffscreenComponent(
      current,
      workInProgress,
      renderLanes,
      nextProps
    ) {
      var nextChildren = nextProps.children,
        prevState = null !== current ? current.memoizedState : null;
      null === current &&
        null === workInProgress.stateNode &&
        (workInProgress.stateNode = {
          _visibility: OffscreenVisible,
          _pendingMarkers: null,
          _retryCache: null,
          _transitions: null
        });
      if ("hidden" === nextProps.mode) {
        if (0 !== (workInProgress.flags & 128)) {
          prevState =
            null !== prevState
              ? prevState.baseLanes | renderLanes
              : renderLanes;
          if (null !== current) {
            nextProps = workInProgress.child = current.child;
            for (nextChildren = 0; null !== nextProps; )
              (nextChildren =
                nextChildren | nextProps.lanes | nextProps.childLanes),
                (nextProps = nextProps.sibling);
            nextProps = nextChildren & ~prevState;
          } else (nextProps = 0), (workInProgress.child = null);
          return deferHiddenOffscreenComponent(
            current,
            workInProgress,
            prevState,
            renderLanes,
            nextProps
          );
        }
        if (0 !== (renderLanes & 536870912))
          (workInProgress.memoizedState = { baseLanes: 0, cachePool: null }),
            null !== current &&
              pushTransition(
                workInProgress,
                null !== prevState ? prevState.cachePool : null
              ),
            null !== prevState
              ? pushHiddenContext(workInProgress, prevState)
              : reuseHiddenContextOnStack(workInProgress),
            pushOffscreenSuspenseHandler(workInProgress);
        else
          return (
            (nextProps = workInProgress.lanes = 536870912),
            deferHiddenOffscreenComponent(
              current,
              workInProgress,
              null !== prevState
                ? prevState.baseLanes | renderLanes
                : renderLanes,
              renderLanes,
              nextProps
            )
          );
      } else
        null !== prevState
          ? (pushTransition(workInProgress, prevState.cachePool),
            pushHiddenContext(workInProgress, prevState),
            reuseSuspenseHandlerOnStack(workInProgress),
            (workInProgress.memoizedState = null))
          : (null !== current && pushTransition(workInProgress, null),
            reuseHiddenContextOnStack(workInProgress),
            reuseSuspenseHandlerOnStack(workInProgress));
      reconcileChildren(current, workInProgress, nextChildren, renderLanes);
      return workInProgress.child;
    }
    function bailoutOffscreenComponent(current, workInProgress) {
      (null !== current && 22 === current.tag) ||
        null !== workInProgress.stateNode ||
        (workInProgress.stateNode = {
          _visibility: OffscreenVisible,
          _pendingMarkers: null,
          _retryCache: null,
          _transitions: null
        });
      return workInProgress.sibling;
    }
    function deferHiddenOffscreenComponent(
      current,
      workInProgress,
      nextBaseLanes,
      renderLanes,
      remainingChildLanes
    ) {
      var JSCompiler_inline_result = peekCacheFromPool();
      JSCompiler_inline_result =
        null === JSCompiler_inline_result
          ? null
          : {
              parent: CacheContext._currentValue,
              pool: JSCompiler_inline_result
            };
      workInProgress.memoizedState = {
        baseLanes: nextBaseLanes,
        cachePool: JSCompiler_inline_result
      };
      null !== current && pushTransition(workInProgress, null);
      reuseHiddenContextOnStack(workInProgress);
      pushOffscreenSuspenseHandler(workInProgress);
      null !== current &&
        propagateParentContextChanges(current, workInProgress, renderLanes, !0);
      workInProgress.childLanes = remainingChildLanes;
      return null;
    }
    function mountActivityChildren(workInProgress, nextProps) {
      var hiddenProp = nextProps.hidden;
      void 0 !== hiddenProp &&
        console.error(
          '<Activity> doesn\'t accept a hidden prop. Use mode="hidden" instead.\n- <Activity %s>\n+ <Activity %s>',
          !0 === hiddenProp
            ? "hidden"
            : !1 === hiddenProp
              ? "hidden={false}"
              : "hidden={...}",
          hiddenProp ? 'mode="hidden"' : 'mode="visible"'
        );
      nextProps = mountWorkInProgressOffscreenFiber(
        { mode: nextProps.mode, children: nextProps.children },
        workInProgress.mode
      );
      nextProps.ref = workInProgress.ref;
      workInProgress.child = nextProps;
      nextProps.return = workInProgress;
      return nextProps;
    }
    function retryActivityComponentWithoutHydrating(
      current,
      workInProgress,
      renderLanes
    ) {
      reconcileChildFibers(workInProgress, current.child, null, renderLanes);
      current = mountActivityChildren(
        workInProgress,
        workInProgress.pendingProps
      );
      current.flags |= 2;
      popSuspenseHandler(workInProgress);
      workInProgress.memoizedState = null;
      return current;
    }
    function updateActivityComponent(current, workInProgress, renderLanes) {
      var nextProps = workInProgress.pendingProps,
        didSuspend = 0 !== (workInProgress.flags & 128);
      workInProgress.flags &= -129;
      if (null === current) {
        if (isHydrating) {
          if ("hidden" === nextProps.mode)
            return (
              (current = mountActivityChildren(workInProgress, nextProps)),
              (workInProgress.lanes = 536870912),
              bailoutOffscreenComponent(null, current)
            );
          pushDehydratedActivitySuspenseHandler(workInProgress);
          (current = nextHydratableInstance)
            ? ((renderLanes = canHydrateHydrationBoundary(
                current,
                rootOrSingletonContext
              )),
              (renderLanes =
                null !== renderLanes && renderLanes.data === ACTIVITY_START_DATA
                  ? renderLanes
                  : null),
              null !== renderLanes &&
                ((nextProps = {
                  dehydrated: renderLanes,
                  treeContext: getSuspendedTreeContext(),
                  retryLane: 536870912,
                  hydrationErrors: null
                }),
                (workInProgress.memoizedState = nextProps),
                (nextProps = createFiberFromDehydratedFragment(renderLanes)),
                (nextProps.return = workInProgress),
                (workInProgress.child = nextProps),
                (hydrationParentFiber = workInProgress),
                (nextHydratableInstance = null)))
            : (renderLanes = null);
          if (null === renderLanes)
            throw (
              (warnNonHydratedInstance(workInProgress, current),
              throwOnHydrationMismatch(workInProgress))
            );
          workInProgress.lanes = 536870912;
          return null;
        }
        return mountActivityChildren(workInProgress, nextProps);
      }
      var prevState = current.memoizedState;
      if (null !== prevState) {
        var activityInstance = prevState.dehydrated;
        pushDehydratedActivitySuspenseHandler(workInProgress);
        if (didSuspend)
          if (workInProgress.flags & 256)
            (workInProgress.flags &= -257),
              (workInProgress = retryActivityComponentWithoutHydrating(
                current,
                workInProgress,
                renderLanes
              ));
          else if (null !== workInProgress.memoizedState)
            (workInProgress.child = current.child),
              (workInProgress.flags |= 128),
              (workInProgress = null);
          else
            throw Error(
              "Client rendering an Activity suspended it again. This is a bug in React."
            );
        else if (
          (warnIfHydrating(),
          0 !== (renderLanes & 536870912) &&
            markRenderDerivedCause(workInProgress),
          didReceiveUpdate ||
            propagateParentContextChanges(
              current,
              workInProgress,
              renderLanes,
              !1
            ),
          (didSuspend = 0 !== (renderLanes & current.childLanes)),
          didReceiveUpdate || didSuspend)
        ) {
          nextProps = workInProgressRoot;
          if (
            null !== nextProps &&
            ((activityInstance = getBumpedLaneForHydration(
              nextProps,
              renderLanes
            )),
            0 !== activityInstance && activityInstance !== prevState.retryLane)
          )
            throw (
              ((prevState.retryLane = activityInstance),
              enqueueConcurrentRenderForLane(current, activityInstance),
              scheduleUpdateOnFiber(nextProps, current, activityInstance),
              SelectiveHydrationException)
            );
          renderDidSuspendDelayIfPossible();
          workInProgress = retryActivityComponentWithoutHydrating(
            current,
            workInProgress,
            renderLanes
          );
        } else
          (current = prevState.treeContext),
            (nextHydratableInstance = getNextHydratable(
              activityInstance.nextSibling
            )),
            (hydrationParentFiber = workInProgress),
            (isHydrating = !0),
            (hydrationErrors = null),
            (didSuspendOrErrorDEV = !1),
            (hydrationDiffRootDEV = null),
            (rootOrSingletonContext = !1),
            null !== current &&
              restoreSuspendedTreeContext(workInProgress, current),
            (workInProgress = mountActivityChildren(workInProgress, nextProps)),
            (workInProgress.flags |= 4096);
        return workInProgress;
      }
      prevState = current.child;
      nextProps = { mode: nextProps.mode, children: nextProps.children };
      0 !== (renderLanes & 536870912) &&
        0 !== (renderLanes & current.lanes) &&
        markRenderDerivedCause(workInProgress);
      current = createWorkInProgress(prevState, nextProps);
      current.ref = workInProgress.ref;
      workInProgress.child = current;
      current.return = workInProgress;
      return current;
    }
    function markRef(current, workInProgress) {
      var ref = workInProgress.ref;
      if (null === ref)
        null !== current &&
          null !== current.ref &&
          (workInProgress.flags |= 4194816);
      else {
        if ("function" !== typeof ref && "object" !== typeof ref)
          throw Error(
            "Expected ref to be a function, an object returned by React.createRef(), or undefined/null."
          );
        if (null === current || current.ref !== ref)
          workInProgress.flags |= 4194816;
      }
    }
    function updateFunctionComponent(
      current,
      workInProgress,
      Component,
      nextProps,
      renderLanes
    ) {
      if (
        Component.prototype &&
        "function" === typeof Component.prototype.render
      ) {
        var componentName = getComponentNameFromType(Component) || "Unknown";
        didWarnAboutBadClass[componentName] ||
          (console.error(
            "The <%s /> component appears to have a render method, but doesn't extend React.Component. This is likely to cause errors. Change %s to extend React.Component instead.",
            componentName,
            componentName
          ),
          (didWarnAboutBadClass[componentName] = !0));
      }
      workInProgress.mode & StrictLegacyMode &&
        ReactStrictModeWarnings.recordLegacyContextWarning(
          workInProgress,
          null
        );
      null === current &&
        (validateFunctionComponentInDev(workInProgress, workInProgress.type),
        Component.contextTypes &&
          ((componentName = getComponentNameFromType(Component) || "Unknown"),
          didWarnAboutContextTypes[componentName] ||
            ((didWarnAboutContextTypes[componentName] = !0),
            console.error(
              "%s uses the legacy contextTypes API which was removed in React 19. Use React.createContext() with React.useContext() instead. (https://react.dev/link/legacy-context)",
              componentName
            ))));
      prepareToReadContext(workInProgress);
      Component = renderWithHooks(
        current,
        workInProgress,
        Component,
        nextProps,
        void 0,
        renderLanes
      );
      nextProps = checkDidRenderIdHook();
      if (null !== current && !didReceiveUpdate)
        return (
          bailoutHooks(current, workInProgress, renderLanes),
          bailoutOnAlreadyFinishedWork(current, workInProgress, renderLanes)
        );
      isHydrating && nextProps && pushMaterializedTreeId(workInProgress);
      workInProgress.flags |= 1;
      reconcileChildren(current, workInProgress, Component, renderLanes);
      return workInProgress.child;
    }
    function replayFunctionComponent(
      current,
      workInProgress,
      nextProps,
      Component,
      secondArg,
      renderLanes
    ) {
      prepareToReadContext(workInProgress);
      hookTypesUpdateIndexDev = -1;
      ignorePreviousDependencies =
        null !== current && current.type !== workInProgress.type;
      workInProgress.updateQueue = null;
      nextProps = renderWithHooksAgain(
        workInProgress,
        Component,
        nextProps,
        secondArg
      );
      finishRenderingHooks(current, workInProgress);
      Component = checkDidRenderIdHook();
      if (null !== current && !didReceiveUpdate)
        return (
          bailoutHooks(current, workInProgress, renderLanes),
          bailoutOnAlreadyFinishedWork(current, workInProgress, renderLanes)
        );
      isHydrating && Component && pushMaterializedTreeId(workInProgress);
      workInProgress.flags |= 1;
      reconcileChildren(current, workInProgress, nextProps, renderLanes);
      return workInProgress.child;
    }
    function updateClassComponent(
      current,
      workInProgress,
      Component,
      nextProps,
      renderLanes
    ) {
      switch (shouldErrorImpl(workInProgress)) {
        case !1:
          var _instance = workInProgress.stateNode,
            state = new workInProgress.type(
              workInProgress.memoizedProps,
              _instance.context
            ).state;
          _instance.updater.enqueueSetState(_instance, state, null);
          break;
        case !0:
          workInProgress.flags |= 128;
          workInProgress.flags |= 65536;
          _instance = Error("Simulated error coming from DevTools");
          var lane = renderLanes & -renderLanes;
          workInProgress.lanes |= lane;
          state = workInProgressRoot;
          if (null === state)
            throw Error(
              "Expected a work-in-progress root. This is a bug in React. Please file an issue."
            );
          lane = createClassErrorUpdate(lane);
          initializeClassErrorUpdate(
            lane,
            state,
            workInProgress,
            createCapturedValueAtFiber(_instance, workInProgress)
          );
          enqueueCapturedUpdate(workInProgress, lane);
      }
      prepareToReadContext(workInProgress);
      if (null === workInProgress.stateNode) {
        state = emptyContextObject;
        _instance = Component.contextType;
        "contextType" in Component &&
          null !== _instance &&
          (void 0 === _instance || _instance.$$typeof !== REACT_CONTEXT_TYPE) &&
          !didWarnAboutInvalidateContextType.has(Component) &&
          (didWarnAboutInvalidateContextType.add(Component),
          (lane =
            void 0 === _instance
              ? " However, it is set to undefined. This can be caused by a typo or by mixing up named and default imports. This can also happen due to a circular dependency, so try moving the createContext() call to a separate file."
              : "object" !== typeof _instance
                ? " However, it is set to a " + typeof _instance + "."
                : _instance.$$typeof === REACT_CONSUMER_TYPE
                  ? " Did you accidentally pass the Context.Consumer instead?"
                  : " However, it is set to an object with keys {" +
                    Object.keys(_instance).join(", ") +
                    "}."),
          console.error(
            "%s defines an invalid contextType. contextType should point to the Context object returned by React.createContext().%s",
            getComponentNameFromType(Component) || "Component",
            lane
          ));
        "object" === typeof _instance &&
          null !== _instance &&
          (state = readContext(_instance));
        _instance = new Component(nextProps, state);
        if (workInProgress.mode & StrictLegacyMode) {
          setIsStrictModeForDevtools(!0);
          try {
            _instance = new Component(nextProps, state);
          } finally {
            setIsStrictModeForDevtools(!1);
          }
        }
        state = workInProgress.memoizedState =
          null !== _instance.state && void 0 !== _instance.state
            ? _instance.state
            : null;
        _instance.updater = classComponentUpdater;
        workInProgress.stateNode = _instance;
        _instance._reactInternals = workInProgress;
        _instance._reactInternalInstance = fakeInternalInstance;
        "function" === typeof Component.getDerivedStateFromProps &&
          null === state &&
          ((state = getComponentNameFromType(Component) || "Component"),
          didWarnAboutUninitializedState.has(state) ||
            (didWarnAboutUninitializedState.add(state),
            console.error(
              "`%s` uses `getDerivedStateFromProps` but its initial state is %s. This is not recommended. Instead, define the initial state by assigning an object to `this.state` in the constructor of `%s`. This ensures that `getDerivedStateFromProps` arguments have a consistent shape.",
              state,
              null === _instance.state ? "null" : "undefined",
              state
            )));
        if (
          "function" === typeof Component.getDerivedStateFromProps ||
          "function" === typeof _instance.getSnapshotBeforeUpdate
        ) {
          var foundWillUpdateName = (lane = state = null);
          "function" === typeof _instance.componentWillMount &&
          !0 !== _instance.componentWillMount.__suppressDeprecationWarning
            ? (state = "componentWillMount")
            : "function" === typeof _instance.UNSAFE_componentWillMount &&
              (state = "UNSAFE_componentWillMount");
          "function" === typeof _instance.componentWillReceiveProps &&
          !0 !==
            _instance.componentWillReceiveProps.__suppressDeprecationWarning
            ? (lane = "componentWillReceiveProps")
            : "function" ===
                typeof _instance.UNSAFE_componentWillReceiveProps &&
              (lane = "UNSAFE_componentWillReceiveProps");
          "function" === typeof _instance.componentWillUpdate &&
          !0 !== _instance.componentWillUpdate.__suppressDeprecationWarning
            ? (foundWillUpdateName = "componentWillUpdate")
            : "function" === typeof _instance.UNSAFE_componentWillUpdate &&
              (foundWillUpdateName = "UNSAFE_componentWillUpdate");
          if (null !== state || null !== lane || null !== foundWillUpdateName) {
            _instance = getComponentNameFromType(Component) || "Component";
            var newApiName =
              "function" === typeof Component.getDerivedStateFromProps
                ? "getDerivedStateFromProps()"
                : "getSnapshotBeforeUpdate()";
            didWarnAboutLegacyLifecyclesAndDerivedState.has(_instance) ||
              (didWarnAboutLegacyLifecyclesAndDerivedState.add(_instance),
              console.error(
                "Unsafe legacy lifecycles will not be called for components using new component APIs.\n\n%s uses %s but also contains the following legacy lifecycles:%s%s%s\n\nThe above lifecycles should be removed. Learn more about this warning here:\nhttps://react.dev/link/unsafe-component-lifecycles",
                _instance,
                newApiName,
                null !== state ? "\n  " + state : "",
                null !== lane ? "\n  " + lane : "",
                null !== foundWillUpdateName ? "\n  " + foundWillUpdateName : ""
              ));
          }
        }
        _instance = workInProgress.stateNode;
        state = getComponentNameFromType(Component) || "Component";
        _instance.render ||
          (Component.prototype &&
          "function" === typeof Component.prototype.render
            ? console.error(
                "No `render` method found on the %s instance: did you accidentally return an object from the constructor?",
                state
              )
            : console.error(
                "No `render` method found on the %s instance: you may have forgotten to define `render`.",
                state
              ));
        !_instance.getInitialState ||
          _instance.getInitialState.isReactClassApproved ||
          _instance.state ||
          console.error(
            "getInitialState was defined on %s, a plain JavaScript class. This is only supported for classes created using React.createClass. Did you mean to define a state property instead?",
            state
          );
        _instance.getDefaultProps &&
          !_instance.getDefaultProps.isReactClassApproved &&
          console.error(
            "getDefaultProps was defined on %s, a plain JavaScript class. This is only supported for classes created using React.createClass. Use a static property to define defaultProps instead.",
            state
          );
        _instance.contextType &&
          console.error(
            "contextType was defined as an instance property on %s. Use a static property to define contextType instead.",
            state
          );
        Component.childContextTypes &&
          !didWarnAboutChildContextTypes.has(Component) &&
          (didWarnAboutChildContextTypes.add(Component),
          console.error(
            "%s uses the legacy childContextTypes API which was removed in React 19. Use React.createContext() instead. (https://react.dev/link/legacy-context)",
            state
          ));
        Component.contextTypes &&
          !didWarnAboutContextTypes$1.has(Component) &&
          (didWarnAboutContextTypes$1.add(Component),
          console.error(
            "%s uses the legacy contextTypes API which was removed in React 19. Use React.createContext() with static contextType instead. (https://react.dev/link/legacy-context)",
            state
          ));
        "function" === typeof _instance.componentShouldUpdate &&
          console.error(
            "%s has a method called componentShouldUpdate(). Did you mean shouldComponentUpdate()? The name is phrased as a question because the function is expected to return a value.",
            state
          );
        Component.prototype &&
          Component.prototype.isPureReactComponent &&
          "undefined" !== typeof _instance.shouldComponentUpdate &&
          console.error(
            "%s has a method called shouldComponentUpdate(). shouldComponentUpdate should not be used when extending React.PureComponent. Please extend React.Component if shouldComponentUpdate is used.",
            getComponentNameFromType(Component) || "A pure component"
          );
        "function" === typeof _instance.componentDidUnmount &&
          console.error(
            "%s has a method called componentDidUnmount(). But there is no such lifecycle method. Did you mean componentWillUnmount()?",
            state
          );
        "function" === typeof _instance.componentDidReceiveProps &&
          console.error(
            "%s has a method called componentDidReceiveProps(). But there is no such lifecycle method. If you meant to update the state in response to changing props, use componentWillReceiveProps(). If you meant to fetch data or run side-effects or mutations after React has updated the UI, use componentDidUpdate().",
            state
          );
        "function" === typeof _instance.componentWillRecieveProps &&
          console.error(
            "%s has a method called componentWillRecieveProps(). Did you mean componentWillReceiveProps()?",
            state
          );
        "function" === typeof _instance.UNSAFE_componentWillRecieveProps &&
          console.error(
            "%s has a method called UNSAFE_componentWillRecieveProps(). Did you mean UNSAFE_componentWillReceiveProps()?",
            state
          );
        lane = _instance.props !== nextProps;
        void 0 !== _instance.props &&
          lane &&
          console.error(
            "When calling super() in `%s`, make sure to pass up the same props that your component's constructor was passed.",
            state
          );
        _instance.defaultProps &&
          console.error(
            "Setting defaultProps as an instance property on %s is not supported and will be ignored. Instead, define defaultProps as a static property on %s.",
            state,
            state
          );
        "function" !== typeof _instance.getSnapshotBeforeUpdate ||
          "function" === typeof _instance.componentDidUpdate ||
          didWarnAboutGetSnapshotBeforeUpdateWithoutDidUpdate.has(Component) ||
          (didWarnAboutGetSnapshotBeforeUpdateWithoutDidUpdate.add(Component),
          console.error(
            "%s: getSnapshotBeforeUpdate() should be used with componentDidUpdate(). This component defines getSnapshotBeforeUpdate() only.",
            getComponentNameFromType(Component)
          ));
        "function" === typeof _instance.getDerivedStateFromProps &&
          console.error(
            "%s: getDerivedStateFromProps() is defined as an instance method and will be ignored. Instead, declare it as a static method.",
            state
          );
        "function" === typeof _instance.getDerivedStateFromError &&
          console.error(
            "%s: getDerivedStateFromError() is defined as an instance method and will be ignored. Instead, declare it as a static method.",
            state
          );
        "function" === typeof Component.getSnapshotBeforeUpdate &&
          console.error(
            "%s: getSnapshotBeforeUpdate() is defined as a static method and will be ignored. Instead, declare it as an instance method.",
            state
          );
        (lane = _instance.state) &&
          ("object" !== typeof lane || isArrayImpl(lane)) &&
          console.error("%s.state: must be set to an object or null", state);
        "function" === typeof _instance.getChildContext &&
          "object" !== typeof Component.childContextTypes &&
          console.error(
            "%s.getChildContext(): childContextTypes must be defined in order to use getChildContext().",
            state
          );
        _instance = workInProgress.stateNode;
        _instance.props = nextProps;
        _instance.state = workInProgress.memoizedState;
        _instance.refs = {};
        initializeUpdateQueue(workInProgress);
        state = Component.contextType;
        _instance.context =
          "object" === typeof state && null !== state
            ? readContext(state)
            : emptyContextObject;
        _instance.state === nextProps &&
          ((state = getComponentNameFromType(Component) || "Component"),
          didWarnAboutDirectlyAssigningPropsToState.has(state) ||
            (didWarnAboutDirectlyAssigningPropsToState.add(state),
            console.error(
              "%s: It is not recommended to assign props directly to state because updates to props won't be reflected in state. In most cases, it is better to use props directly.",
              state
            )));
        workInProgress.mode & StrictLegacyMode &&
          ReactStrictModeWarnings.recordLegacyContextWarning(
            workInProgress,
            _instance
          );
        ReactStrictModeWarnings.recordUnsafeLifecycleWarnings(
          workInProgress,
          _instance
        );
        _instance.state = workInProgress.memoizedState;
        state = Component.getDerivedStateFromProps;
        "function" === typeof state &&
          (applyDerivedStateFromProps(
            workInProgress,
            Component,
            state,
            nextProps
          ),
          (_instance.state = workInProgress.memoizedState));
        "function" === typeof Component.getDerivedStateFromProps ||
          "function" === typeof _instance.getSnapshotBeforeUpdate ||
          ("function" !== typeof _instance.UNSAFE_componentWillMount &&
            "function" !== typeof _instance.componentWillMount) ||
          ((state = _instance.state),
          "function" === typeof _instance.componentWillMount &&
            _instance.componentWillMount(),
          "function" === typeof _instance.UNSAFE_componentWillMount &&
            _instance.UNSAFE_componentWillMount(),
          state !== _instance.state &&
            (console.error(
              "%s.componentWillMount(): Assigning directly to this.state is deprecated (except inside a component's constructor). Use setState instead.",
              getComponentNameFromFiber(workInProgress) || "Component"
            ),
            classComponentUpdater.enqueueReplaceState(
              _instance,
              _instance.state,
              null
            )),
          processUpdateQueue(workInProgress, nextProps, _instance, renderLanes),
          suspendIfUpdateReadFromEntangledAsyncAction(),
          (_instance.state = workInProgress.memoizedState));
        "function" === typeof _instance.componentDidMount &&
          (workInProgress.flags |= 4194308);
        (workInProgress.mode & StrictEffectsMode) !== NoMode &&
          (workInProgress.flags |= 134217728);
        _instance = !0;
      } else if (null === current) {
        _instance = workInProgress.stateNode;
        var unresolvedOldProps = workInProgress.memoizedProps;
        lane = resolveClassComponentProps(Component, unresolvedOldProps);
        _instance.props = lane;
        var oldContext = _instance.context;
        foundWillUpdateName = Component.contextType;
        state = emptyContextObject;
        "object" === typeof foundWillUpdateName &&
          null !== foundWillUpdateName &&
          (state = readContext(foundWillUpdateName));
        newApiName = Component.getDerivedStateFromProps;
        foundWillUpdateName =
          "function" === typeof newApiName ||
          "function" === typeof _instance.getSnapshotBeforeUpdate;
        unresolvedOldProps = workInProgress.pendingProps !== unresolvedOldProps;
        foundWillUpdateName ||
          ("function" !== typeof _instance.UNSAFE_componentWillReceiveProps &&
            "function" !== typeof _instance.componentWillReceiveProps) ||
          ((unresolvedOldProps || oldContext !== state) &&
            callComponentWillReceiveProps(
              workInProgress,
              _instance,
              nextProps,
              state
            ));
        hasForceUpdate = !1;
        var oldState = workInProgress.memoizedState;
        _instance.state = oldState;
        processUpdateQueue(workInProgress, nextProps, _instance, renderLanes);
        suspendIfUpdateReadFromEntangledAsyncAction();
        oldContext = workInProgress.memoizedState;
        unresolvedOldProps || oldState !== oldContext || hasForceUpdate
          ? ("function" === typeof newApiName &&
              (applyDerivedStateFromProps(
                workInProgress,
                Component,
                newApiName,
                nextProps
              ),
              (oldContext = workInProgress.memoizedState)),
            (lane =
              hasForceUpdate ||
              checkShouldComponentUpdate(
                workInProgress,
                Component,
                lane,
                nextProps,
                oldState,
                oldContext,
                state
              ))
              ? (foundWillUpdateName ||
                  ("function" !== typeof _instance.UNSAFE_componentWillMount &&
                    "function" !== typeof _instance.componentWillMount) ||
                  ("function" === typeof _instance.componentWillMount &&
                    _instance.componentWillMount(),
                  "function" === typeof _instance.UNSAFE_componentWillMount &&
                    _instance.UNSAFE_componentWillMount()),
                "function" === typeof _instance.componentDidMount &&
                  (workInProgress.flags |= 4194308),
                (workInProgress.mode & StrictEffectsMode) !== NoMode &&
                  (workInProgress.flags |= 134217728))
              : ("function" === typeof _instance.componentDidMount &&
                  (workInProgress.flags |= 4194308),
                (workInProgress.mode & StrictEffectsMode) !== NoMode &&
                  (workInProgress.flags |= 134217728),
                (workInProgress.memoizedProps = nextProps),
                (workInProgress.memoizedState = oldContext)),
            (_instance.props = nextProps),
            (_instance.state = oldContext),
            (_instance.context = state),
            (_instance = lane))
          : ("function" === typeof _instance.componentDidMount &&
              (workInProgress.flags |= 4194308),
            (workInProgress.mode & StrictEffectsMode) !== NoMode &&
              (workInProgress.flags |= 134217728),
            (_instance = !1));
      } else {
        _instance = workInProgress.stateNode;
        cloneUpdateQueue(current, workInProgress);
        state = workInProgress.memoizedProps;
        foundWillUpdateName = resolveClassComponentProps(Component, state);
        _instance.props = foundWillUpdateName;
        newApiName = workInProgress.pendingProps;
        oldState = _instance.context;
        oldContext = Component.contextType;
        lane = emptyContextObject;
        "object" === typeof oldContext &&
          null !== oldContext &&
          (lane = readContext(oldContext));
        unresolvedOldProps = Component.getDerivedStateFromProps;
        (oldContext =
          "function" === typeof unresolvedOldProps ||
          "function" === typeof _instance.getSnapshotBeforeUpdate) ||
          ("function" !== typeof _instance.UNSAFE_componentWillReceiveProps &&
            "function" !== typeof _instance.componentWillReceiveProps) ||
          ((state !== newApiName || oldState !== lane) &&
            callComponentWillReceiveProps(
              workInProgress,
              _instance,
              nextProps,
              lane
            ));
        hasForceUpdate = !1;
        oldState = workInProgress.memoizedState;
        _instance.state = oldState;
        processUpdateQueue(workInProgress, nextProps, _instance, renderLanes);
        suspendIfUpdateReadFromEntangledAsyncAction();
        var newState = workInProgress.memoizedState;
        state !== newApiName ||
        oldState !== newState ||
        hasForceUpdate ||
        (null !== current &&
          null !== current.dependencies &&
          checkIfContextChanged(current.dependencies))
          ? ("function" === typeof unresolvedOldProps &&
              (applyDerivedStateFromProps(
                workInProgress,
                Component,
                unresolvedOldProps,
                nextProps
              ),
              (newState = workInProgress.memoizedState)),
            (foundWillUpdateName =
              hasForceUpdate ||
              checkShouldComponentUpdate(
                workInProgress,
                Component,
                foundWillUpdateName,
                nextProps,
                oldState,
                newState,
                lane
              ) ||
              (null !== current &&
                null !== current.dependencies &&
                checkIfContextChanged(current.dependencies)))
              ? (oldContext ||
                  ("function" !== typeof _instance.UNSAFE_componentWillUpdate &&
                    "function" !== typeof _instance.componentWillUpdate) ||
                  ("function" === typeof _instance.componentWillUpdate &&
                    _instance.componentWillUpdate(nextProps, newState, lane),
                  "function" === typeof _instance.UNSAFE_componentWillUpdate &&
                    _instance.UNSAFE_componentWillUpdate(
                      nextProps,
                      newState,
                      lane
                    )),
                "function" === typeof _instance.componentDidUpdate &&
                  (workInProgress.flags |= 4),
                "function" === typeof _instance.getSnapshotBeforeUpdate &&
                  (workInProgress.flags |= 1024))
              : ("function" !== typeof _instance.componentDidUpdate ||
                  (state === current.memoizedProps &&
                    oldState === current.memoizedState) ||
                  (workInProgress.flags |= 4),
                "function" !== typeof _instance.getSnapshotBeforeUpdate ||
                  (state === current.memoizedProps &&
                    oldState === current.memoizedState) ||
                  (workInProgress.flags |= 1024),
                (workInProgress.memoizedProps = nextProps),
                (workInProgress.memoizedState = newState)),
            (_instance.props = nextProps),
            (_instance.state = newState),
            (_instance.context = lane),
            (_instance = foundWillUpdateName))
          : ("function" !== typeof _instance.componentDidUpdate ||
              (state === current.memoizedProps &&
                oldState === current.memoizedState) ||
              (workInProgress.flags |= 4),
            "function" !== typeof _instance.getSnapshotBeforeUpdate ||
              (state === current.memoizedProps &&
                oldState === current.memoizedState) ||
              (workInProgress.flags |= 1024),
            (_instance = !1));
      }
      lane = _instance;
      markRef(current, workInProgress);
      state = 0 !== (workInProgress.flags & 128);
      if (lane || state) {
        lane = workInProgress.stateNode;
        setCurrentFiber(workInProgress);
        if (state && "function" !== typeof Component.getDerivedStateFromError)
          (Component = null), (profilerStartTime = -1);
        else if (
          ((Component = callRenderInDEV(lane)),
          workInProgress.mode & StrictLegacyMode)
        ) {
          setIsStrictModeForDevtools(!0);
          try {
            callRenderInDEV(lane);
          } finally {
            setIsStrictModeForDevtools(!1);
          }
        }
        workInProgress.flags |= 1;
        null !== current && state
          ? ((workInProgress.child = reconcileChildFibers(
              workInProgress,
              current.child,
              null,
              renderLanes
            )),
            (workInProgress.child = reconcileChildFibers(
              workInProgress,
              null,
              Component,
              renderLanes
            )))
          : reconcileChildren(current, workInProgress, Component, renderLanes);
        workInProgress.memoizedState = lane.state;
        current = workInProgress.child;
      } else
        current = bailoutOnAlreadyFinishedWork(
          current,
          workInProgress,
          renderLanes
        );
      renderLanes = workInProgress.stateNode;
      _instance &&
        renderLanes.props !== nextProps &&
        (didWarnAboutReassigningProps ||
          console.error(
            "It looks like %s is reassigning its own `this.props` while rendering. This is not supported and can lead to confusing bugs.",
            getComponentNameFromFiber(workInProgress) || "a component"
          ),
        (didWarnAboutReassigningProps = !0));
      return current;
    }
    function mountHostRootWithoutHydrating(
      current,
      workInProgress,
      nextChildren,
      renderLanes
    ) {
      resetHydrationState();
      workInProgress.flags |= 256;
      reconcileChildren(current, workInProgress, nextChildren, renderLanes);
      return workInProgress.child;
    }
    function validateFunctionComponentInDev(workInProgress, Component) {
      Component &&
        Component.childContextTypes &&
        console.error(
          "childContextTypes cannot be defined on a function component.\n  %s.childContextTypes = ...",
          Component.displayName || Component.name || "Component"
        );
      "function" === typeof Component.getDerivedStateFromProps &&
        ((workInProgress = getComponentNameFromType(Component) || "Unknown"),
        didWarnAboutGetDerivedStateOnFunctionComponent[workInProgress] ||
          (console.error(
            "%s: Function components do not support getDerivedStateFromProps.",
            workInProgress
          ),
          (didWarnAboutGetDerivedStateOnFunctionComponent[workInProgress] =
            !0)));
      "object" === typeof Component.contextType &&
        null !== Component.contextType &&
        ((Component = getComponentNameFromType(Component) || "Unknown"),
        didWarnAboutContextTypeOnFunctionComponent[Component] ||
          (console.error(
            "%s: Function components do not support contextType.",
            Component
          ),
          (didWarnAboutContextTypeOnFunctionComponent[Component] = !0)));
    }
    function mountSuspenseOffscreenState(renderLanes) {
      return { baseLanes: renderLanes, cachePool: getSuspendedCache() };
    }
    function getRemainingWorkInPrimaryTree(
      current,
      primaryTreeDidDefer,
      renderLanes
    ) {
      current = null !== current ? current.childLanes & ~renderLanes : 0;
      primaryTreeDidDefer && (current |= workInProgressDeferredLane);
      return current;
    }
    function updateSuspenseComponent(current, workInProgress, renderLanes) {
      var JSCompiler_object_inline_digest_2724;
      var JSCompiler_object_inline_stack_2725 = workInProgress.pendingProps;
      shouldSuspendImpl(workInProgress) && (workInProgress.flags |= 128);
      var JSCompiler_object_inline_message_2723 = !1;
      var didSuspend = 0 !== (workInProgress.flags & 128);
      (JSCompiler_object_inline_digest_2724 = didSuspend) ||
        (JSCompiler_object_inline_digest_2724 =
          null !== current && null === current.memoizedState
            ? !1
            : 0 !== (suspenseStackCursor.current & ForceSuspenseFallback));
      JSCompiler_object_inline_digest_2724 &&
        ((JSCompiler_object_inline_message_2723 = !0),
        (workInProgress.flags &= -129));
      JSCompiler_object_inline_digest_2724 = 0 !== (workInProgress.flags & 32);
      workInProgress.flags &= -33;
      if (null === current) {
        if (isHydrating) {
          JSCompiler_object_inline_message_2723
            ? pushPrimaryTreeSuspenseHandler(workInProgress)
            : reuseSuspenseHandlerOnStack(workInProgress);
          (current = nextHydratableInstance)
            ? ((renderLanes = canHydrateHydrationBoundary(
                current,
                rootOrSingletonContext
              )),
              (renderLanes =
                null !== renderLanes && renderLanes.data !== ACTIVITY_START_DATA
                  ? renderLanes
                  : null),
              null !== renderLanes &&
                ((JSCompiler_object_inline_digest_2724 = {
                  dehydrated: renderLanes,
                  treeContext: getSuspendedTreeContext(),
                  retryLane: 536870912,
                  hydrationErrors: null
                }),
                (workInProgress.memoizedState =
                  JSCompiler_object_inline_digest_2724),
                (JSCompiler_object_inline_digest_2724 =
                  createFiberFromDehydratedFragment(renderLanes)),
                (JSCompiler_object_inline_digest_2724.return = workInProgress),
                (workInProgress.child = JSCompiler_object_inline_digest_2724),
                (hydrationParentFiber = workInProgress),
                (nextHydratableInstance = null)))
            : (renderLanes = null);
          if (null === renderLanes)
            throw (
              (warnNonHydratedInstance(workInProgress, current),
              throwOnHydrationMismatch(workInProgress))
            );
          isSuspenseInstanceFallback(renderLanes)
            ? (workInProgress.lanes = 32)
            : (workInProgress.lanes = 536870912);
          return null;
        }
        var nextPrimaryChildren = JSCompiler_object_inline_stack_2725.children;
        JSCompiler_object_inline_stack_2725 =
          JSCompiler_object_inline_stack_2725.fallback;
        if (JSCompiler_object_inline_message_2723) {
          reuseSuspenseHandlerOnStack(workInProgress);
          var mode = workInProgress.mode;
          nextPrimaryChildren = mountWorkInProgressOffscreenFiber(
            { mode: "hidden", children: nextPrimaryChildren },
            mode
          );
          JSCompiler_object_inline_stack_2725 = createFiberFromFragment(
            JSCompiler_object_inline_stack_2725,
            mode,
            renderLanes,
            null
          );
          nextPrimaryChildren.return = workInProgress;
          JSCompiler_object_inline_stack_2725.return = workInProgress;
          nextPrimaryChildren.sibling = JSCompiler_object_inline_stack_2725;
          workInProgress.child = nextPrimaryChildren;
          JSCompiler_object_inline_stack_2725 = workInProgress.child;
          JSCompiler_object_inline_stack_2725.memoizedState =
            mountSuspenseOffscreenState(renderLanes);
          JSCompiler_object_inline_stack_2725.childLanes =
            getRemainingWorkInPrimaryTree(
              current,
              JSCompiler_object_inline_digest_2724,
              renderLanes
            );
          workInProgress.memoizedState = SUSPENDED_MARKER;
          return bailoutOffscreenComponent(
            null,
            JSCompiler_object_inline_stack_2725
          );
        }
        pushPrimaryTreeSuspenseHandler(workInProgress);
        return mountSuspensePrimaryChildren(
          workInProgress,
          nextPrimaryChildren
        );
      }
      var prevState = current.memoizedState;
      if (null !== prevState) {
        var JSCompiler_object_inline_componentStack_2726 = prevState.dehydrated;
        if (null !== JSCompiler_object_inline_componentStack_2726) {
          if (didSuspend)
            workInProgress.flags & 256
              ? (pushPrimaryTreeSuspenseHandler(workInProgress),
                (workInProgress.flags &= -257),
                (workInProgress = retrySuspenseComponentWithoutHydrating(
                  current,
                  workInProgress,
                  renderLanes
                )))
              : null !== workInProgress.memoizedState
                ? (reuseSuspenseHandlerOnStack(workInProgress),
                  (workInProgress.child = current.child),
                  (workInProgress.flags |= 128),
                  (workInProgress = null))
                : (reuseSuspenseHandlerOnStack(workInProgress),
                  (nextPrimaryChildren =
                    JSCompiler_object_inline_stack_2725.fallback),
                  (mode = workInProgress.mode),
                  (JSCompiler_object_inline_stack_2725 =
                    mountWorkInProgressOffscreenFiber(
                      {
                        mode: "visible",
                        children: JSCompiler_object_inline_stack_2725.children
                      },
                      mode
                    )),
                  (nextPrimaryChildren = createFiberFromFragment(
                    nextPrimaryChildren,
                    mode,
                    renderLanes,
                    null
                  )),
                  (nextPrimaryChildren.flags |= 2),
                  (JSCompiler_object_inline_stack_2725.return = workInProgress),
                  (nextPrimaryChildren.return = workInProgress),
                  (JSCompiler_object_inline_stack_2725.sibling =
                    nextPrimaryChildren),
                  (workInProgress.child = JSCompiler_object_inline_stack_2725),
                  reconcileChildFibers(
                    workInProgress,
                    current.child,
                    null,
                    renderLanes
                  ),
                  (JSCompiler_object_inline_stack_2725 = workInProgress.child),
                  (JSCompiler_object_inline_stack_2725.memoizedState =
                    mountSuspenseOffscreenState(renderLanes)),
                  (JSCompiler_object_inline_stack_2725.childLanes =
                    getRemainingWorkInPrimaryTree(
                      current,
                      JSCompiler_object_inline_digest_2724,
                      renderLanes
                    )),
                  (workInProgress.memoizedState = SUSPENDED_MARKER),
                  (workInProgress = bailoutOffscreenComponent(
                    null,
                    JSCompiler_object_inline_stack_2725
                  )));
          else if (
            (pushPrimaryTreeSuspenseHandler(workInProgress),
            warnIfHydrating(),
            0 !== (renderLanes & 536870912) &&
              markRenderDerivedCause(workInProgress),
            isSuspenseInstanceFallback(
              JSCompiler_object_inline_componentStack_2726
            ))
          ) {
            JSCompiler_object_inline_digest_2724 =
              JSCompiler_object_inline_componentStack_2726.nextSibling &&
              JSCompiler_object_inline_componentStack_2726.nextSibling.dataset;
            if (JSCompiler_object_inline_digest_2724) {
              nextPrimaryChildren = JSCompiler_object_inline_digest_2724.dgst;
              var message = JSCompiler_object_inline_digest_2724.msg;
              mode = JSCompiler_object_inline_digest_2724.stck;
              var componentStack = JSCompiler_object_inline_digest_2724.cstck;
            }
            JSCompiler_object_inline_message_2723 = message;
            JSCompiler_object_inline_digest_2724 = nextPrimaryChildren;
            JSCompiler_object_inline_stack_2725 = mode;
            JSCompiler_object_inline_componentStack_2726 = componentStack;
            nextPrimaryChildren = JSCompiler_object_inline_message_2723;
            mode = JSCompiler_object_inline_componentStack_2726;
            nextPrimaryChildren = nextPrimaryChildren
              ? Error(nextPrimaryChildren)
              : Error(
                  "The server could not finish this Suspense boundary, likely due to an error during server rendering. Switched to client rendering."
                );
            nextPrimaryChildren.stack =
              JSCompiler_object_inline_stack_2725 || "";
            nextPrimaryChildren.digest = JSCompiler_object_inline_digest_2724;
            JSCompiler_object_inline_digest_2724 =
              void 0 === mode ? null : mode;
            JSCompiler_object_inline_stack_2725 = {
              value: nextPrimaryChildren,
              source: null,
              stack: JSCompiler_object_inline_digest_2724
            };
            "string" === typeof JSCompiler_object_inline_digest_2724 &&
              CapturedStacks.set(
                nextPrimaryChildren,
                JSCompiler_object_inline_stack_2725
              );
            queueHydrationError(JSCompiler_object_inline_stack_2725);
            workInProgress = retrySuspenseComponentWithoutHydrating(
              current,
              workInProgress,
              renderLanes
            );
          } else if (
            (didReceiveUpdate ||
              propagateParentContextChanges(
                current,
                workInProgress,
                renderLanes,
                !1
              ),
            (JSCompiler_object_inline_digest_2724 =
              0 !== (renderLanes & current.childLanes)),
            didReceiveUpdate || JSCompiler_object_inline_digest_2724)
          ) {
            JSCompiler_object_inline_digest_2724 = workInProgressRoot;
            if (
              null !== JSCompiler_object_inline_digest_2724 &&
              ((JSCompiler_object_inline_stack_2725 = getBumpedLaneForHydration(
                JSCompiler_object_inline_digest_2724,
                renderLanes
              )),
              0 !== JSCompiler_object_inline_stack_2725 &&
                JSCompiler_object_inline_stack_2725 !== prevState.retryLane)
            )
              throw (
                ((prevState.retryLane = JSCompiler_object_inline_stack_2725),
                enqueueConcurrentRenderForLane(
                  current,
                  JSCompiler_object_inline_stack_2725
                ),
                scheduleUpdateOnFiber(
                  JSCompiler_object_inline_digest_2724,
                  current,
                  JSCompiler_object_inline_stack_2725
                ),
                SelectiveHydrationException)
              );
            isSuspenseInstancePending(
              JSCompiler_object_inline_componentStack_2726
            ) || renderDidSuspendDelayIfPossible();
            workInProgress = retrySuspenseComponentWithoutHydrating(
              current,
              workInProgress,
              renderLanes
            );
          } else
            isSuspenseInstancePending(
              JSCompiler_object_inline_componentStack_2726
            )
              ? ((workInProgress.flags |= 192),
                (workInProgress.child = current.child),
                (workInProgress = null))
              : ((current = prevState.treeContext),
                (nextHydratableInstance = getNextHydratable(
                  JSCompiler_object_inline_componentStack_2726.nextSibling
                )),
                (hydrationParentFiber = workInProgress),
                (isHydrating = !0),
                (hydrationErrors = null),
                (didSuspendOrErrorDEV = !1),
                (hydrationDiffRootDEV = null),
                (rootOrSingletonContext = !1),
                null !== current &&
                  restoreSuspendedTreeContext(workInProgress, current),
                (workInProgress = mountSuspensePrimaryChildren(
                  workInProgress,
                  JSCompiler_object_inline_stack_2725.children
                )),
                (workInProgress.flags |= 4096));
          return workInProgress;
        }
      }
      if (JSCompiler_object_inline_message_2723)
        return (
          reuseSuspenseHandlerOnStack(workInProgress),
          (nextPrimaryChildren = JSCompiler_object_inline_stack_2725.fallback),
          (mode = workInProgress.mode),
          (componentStack = current.child),
          (JSCompiler_object_inline_componentStack_2726 =
            componentStack.sibling),
          (JSCompiler_object_inline_stack_2725 = createWorkInProgress(
            componentStack,
            {
              mode: "hidden",
              children: JSCompiler_object_inline_stack_2725.children
            }
          )),
          (JSCompiler_object_inline_stack_2725.subtreeFlags =
            componentStack.subtreeFlags & 65011712),
          null !== JSCompiler_object_inline_componentStack_2726
            ? (nextPrimaryChildren = createWorkInProgress(
                JSCompiler_object_inline_componentStack_2726,
                nextPrimaryChildren
              ))
            : ((nextPrimaryChildren = createFiberFromFragment(
                nextPrimaryChildren,
                mode,
                renderLanes,
                null
              )),
              (nextPrimaryChildren.flags |= 2)),
          (nextPrimaryChildren.return = workInProgress),
          (JSCompiler_object_inline_stack_2725.return = workInProgress),
          (JSCompiler_object_inline_stack_2725.sibling = nextPrimaryChildren),
          (workInProgress.child = JSCompiler_object_inline_stack_2725),
          bailoutOffscreenComponent(null, JSCompiler_object_inline_stack_2725),
          (JSCompiler_object_inline_stack_2725 = workInProgress.child),
          (nextPrimaryChildren = current.child.memoizedState),
          null === nextPrimaryChildren
            ? (nextPrimaryChildren = mountSuspenseOffscreenState(renderLanes))
            : ((mode = nextPrimaryChildren.cachePool),
              null !== mode
                ? ((componentStack = CacheContext._currentValue),
                  (mode =
                    mode.parent !== componentStack
                      ? { parent: componentStack, pool: componentStack }
                      : mode))
                : (mode = getSuspendedCache()),
              (nextPrimaryChildren = {
                baseLanes: nextPrimaryChildren.baseLanes | renderLanes,
                cachePool: mode
              })),
          (JSCompiler_object_inline_stack_2725.memoizedState =
            nextPrimaryChildren),
          (JSCompiler_object_inline_stack_2725.childLanes =
            getRemainingWorkInPrimaryTree(
              current,
              JSCompiler_object_inline_digest_2724,
              renderLanes
            )),
          (workInProgress.memoizedState = SUSPENDED_MARKER),
          bailoutOffscreenComponent(
            current.child,
            JSCompiler_object_inline_stack_2725
          )
        );
      null !== prevState &&
        (renderLanes & 62914560) === renderLanes &&
        0 !== (renderLanes & current.lanes) &&
        markRenderDerivedCause(workInProgress);
      pushPrimaryTreeSuspenseHandler(workInProgress);
      renderLanes = current.child;
      current = renderLanes.sibling;
      renderLanes = createWorkInProgress(renderLanes, {
        mode: "visible",
        children: JSCompiler_object_inline_stack_2725.children
      });
      renderLanes.return = workInProgress;
      renderLanes.sibling = null;
      null !== current &&
        ((JSCompiler_object_inline_digest_2724 = workInProgress.deletions),
        null === JSCompiler_object_inline_digest_2724
          ? ((workInProgress.deletions = [current]),
            (workInProgress.flags |= 16))
          : JSCompiler_object_inline_digest_2724.push(current));
      workInProgress.child = renderLanes;
      workInProgress.memoizedState = null;
      return renderLanes;
    }
    function mountSuspensePrimaryChildren(workInProgress, primaryChildren) {
      primaryChildren = mountWorkInProgressOffscreenFiber(
        { mode: "visible", children: primaryChildren },
        workInProgress.mode
      );
      primaryChildren.return = workInProgress;
      return (workInProgress.child = primaryChildren);
    }
    function mountWorkInProgressOffscreenFiber(offscreenProps, mode) {
      offscreenProps = createFiber(22, offscreenProps, null, mode);
      offscreenProps.lanes = 0;
      return offscreenProps;
    }
    function retrySuspenseComponentWithoutHydrating(
      current,
      workInProgress,
      renderLanes
    ) {
      reconcileChildFibers(workInProgress, current.child, null, renderLanes);
      current = mountSuspensePrimaryChildren(
        workInProgress,
        workInProgress.pendingProps.children
      );
      current.flags |= 2;
      workInProgress.memoizedState = null;
      return current;
    }
    function scheduleSuspenseWorkOnFiber(fiber, renderLanes, propagationRoot) {
      fiber.lanes |= renderLanes;
      var alternate = fiber.alternate;
      null !== alternate && (alternate.lanes |= renderLanes);
      scheduleContextWorkOnParentPath(
        fiber.return,
        renderLanes,
        propagationRoot
      );
    }
    function initSuspenseListRenderState(
      workInProgress,
      isBackwards,
      tail,
      lastContentRow,
      tailMode,
      treeForkCount
    ) {
      var renderState = workInProgress.memoizedState;
      null === renderState
        ? (workInProgress.memoizedState = {
            isBackwards: isBackwards,
            rendering: null,
            renderingStartTime: 0,
            last: lastContentRow,
            tail: tail,
            tailMode: tailMode,
            treeForkCount: treeForkCount
          })
        : ((renderState.isBackwards = isBackwards),
          (renderState.rendering = null),
          (renderState.renderingStartTime = 0),
          (renderState.last = lastContentRow),
          (renderState.tail = tail),
          (renderState.tailMode = tailMode),
          (renderState.treeForkCount = treeForkCount));
    }
    function updateSuspenseListComponent(current, workInProgress, renderLanes) {
      var nextProps = workInProgress.pendingProps,
        revealOrder = nextProps.revealOrder,
        tailMode = nextProps.tail,
        newChildren = nextProps.children,
        suspenseContext = suspenseStackCursor.current;
      (nextProps = 0 !== (suspenseContext & ForceSuspenseFallback))
        ? ((suspenseContext =
            (suspenseContext & SubtreeSuspenseContextMask) |
            ForceSuspenseFallback),
          (workInProgress.flags |= 128))
        : (suspenseContext &= SubtreeSuspenseContextMask);
      push(suspenseStackCursor, suspenseContext, workInProgress);
      suspenseContext = null == revealOrder ? "null" : revealOrder;
      if (
        "forwards" !== revealOrder &&
        "unstable_legacy-backwards" !== revealOrder &&
        "together" !== revealOrder &&
        "independent" !== revealOrder &&
        !didWarnAboutRevealOrder[suspenseContext]
      )
        if (
          ((didWarnAboutRevealOrder[suspenseContext] = !0), null == revealOrder)
        )
          console.error(
            'The default for the <SuspenseList revealOrder="..."> prop is changing. To be future compatible you must explictly specify either "independent" (the current default), "together", "forwards" or "legacy_unstable-backwards".'
          );
        else if ("backwards" === revealOrder)
          console.error(
            'The rendering order of <SuspenseList revealOrder="backwards"> is changing. To be future compatible you must specify revealOrder="legacy_unstable-backwards" instead.'
          );
        else if ("string" === typeof revealOrder)
          switch (revealOrder.toLowerCase()) {
            case "together":
            case "forwards":
            case "backwards":
            case "independent":
              console.error(
                '"%s" is not a valid value for revealOrder on <SuspenseList />. Use lowercase "%s" instead.',
                revealOrder,
                revealOrder.toLowerCase()
              );
              break;
            case "forward":
            case "backward":
              console.error(
                '"%s" is not a valid value for revealOrder on <SuspenseList />. React uses the -s suffix in the spelling. Use "%ss" instead.',
                revealOrder,
                revealOrder.toLowerCase()
              );
              break;
            default:
              console.error(
                '"%s" is not a supported revealOrder on <SuspenseList />. Did you mean "independent", "together", "forwards" or "backwards"?',
                revealOrder
              );
          }
        else
          console.error(
            '%s is not a supported value for revealOrder on <SuspenseList />. Did you mean "independent", "together", "forwards" or "backwards"?',
            revealOrder
          );
      suspenseContext = null == tailMode ? "null" : tailMode;
      if (!didWarnAboutTailOptions[suspenseContext])
        if (null == tailMode) {
          if (
            "forwards" === revealOrder ||
            "backwards" === revealOrder ||
            "unstable_legacy-backwards" === revealOrder
          )
            (didWarnAboutTailOptions[suspenseContext] = !0),
              console.error(
                'The default for the <SuspenseList tail="..."> prop is changing. To be future compatible you must explictly specify either "visible" (the current default), "collapsed" or "hidden".'
              );
        } else
          "visible" !== tailMode &&
          "collapsed" !== tailMode &&
          "hidden" !== tailMode
            ? ((didWarnAboutTailOptions[suspenseContext] = !0),
              console.error(
                '"%s" is not a supported value for tail on <SuspenseList />. Did you mean "visible", "collapsed" or "hidden"?',
                tailMode
              ))
            : "forwards" !== revealOrder &&
              "backwards" !== revealOrder &&
              "unstable_legacy-backwards" !== revealOrder &&
              ((didWarnAboutTailOptions[suspenseContext] = !0),
              console.error(
                '<SuspenseList tail="%s" /> is only valid if revealOrder is "forwards" or "backwards". Did you mean to specify revealOrder="forwards"?',
                tailMode
              ));
      a: if (
        ("forwards" === revealOrder ||
          "backwards" === revealOrder ||
          "unstable_legacy-backwards" === revealOrder) &&
        void 0 !== newChildren &&
        null !== newChildren &&
        !1 !== newChildren
      )
        if (isArrayImpl(newChildren))
          for (
            suspenseContext = 0;
            suspenseContext < newChildren.length;
            suspenseContext++
          ) {
            if (
              !validateSuspenseListNestedChild(
                newChildren[suspenseContext],
                suspenseContext
              )
            )
              break a;
          }
        else if (
          ((suspenseContext = getIteratorFn(newChildren)),
          "function" === typeof suspenseContext)
        ) {
          if ((suspenseContext = suspenseContext.call(newChildren)))
            for (
              var step = suspenseContext.next(), _i = 0;
              !step.done;
              step = suspenseContext.next()
            ) {
              if (!validateSuspenseListNestedChild(step.value, _i)) break a;
              _i++;
            }
        } else
          console.error(
            'A single row was passed to a <SuspenseList revealOrder="%s" />. This is not useful since it needs multiple rows. Did you mean to pass multiple children or an array?',
            revealOrder
          );
      reconcileChildren(current, workInProgress, newChildren, renderLanes);
      isHydrating
        ? (warnIfNotHydrating(), (newChildren = treeForkCount))
        : (newChildren = 0);
      if (!nextProps && null !== current && 0 !== (current.flags & 128))
        a: for (current = workInProgress.child; null !== current; ) {
          if (13 === current.tag)
            null !== current.memoizedState &&
              scheduleSuspenseWorkOnFiber(current, renderLanes, workInProgress);
          else if (19 === current.tag)
            scheduleSuspenseWorkOnFiber(current, renderLanes, workInProgress);
          else if (null !== current.child) {
            current.child.return = current;
            current = current.child;
            continue;
          }
          if (current === workInProgress) break a;
          for (; null === current.sibling; ) {
            if (null === current.return || current.return === workInProgress)
              break a;
            current = current.return;
          }
          current.sibling.return = current.return;
          current = current.sibling;
        }
      switch (revealOrder) {
        case "forwards":
          renderLanes = workInProgress.child;
          for (revealOrder = null; null !== renderLanes; )
            (current = renderLanes.alternate),
              null !== current &&
                null === findFirstSuspended(current) &&
                (revealOrder = renderLanes),
              (renderLanes = renderLanes.sibling);
          renderLanes = revealOrder;
          null === renderLanes
            ? ((revealOrder = workInProgress.child),
              (workInProgress.child = null))
            : ((revealOrder = renderLanes.sibling),
              (renderLanes.sibling = null));
          initSuspenseListRenderState(
            workInProgress,
            !1,
            revealOrder,
            renderLanes,
            tailMode,
            newChildren
          );
          break;
        case "backwards":
        case "unstable_legacy-backwards":
          renderLanes = null;
          revealOrder = workInProgress.child;
          for (workInProgress.child = null; null !== revealOrder; ) {
            current = revealOrder.alternate;
            if (null !== current && null === findFirstSuspended(current)) {
              workInProgress.child = revealOrder;
              break;
            }
            current = revealOrder.sibling;
            revealOrder.sibling = renderLanes;
            renderLanes = revealOrder;
            revealOrder = current;
          }
          initSuspenseListRenderState(
            workInProgress,
            !0,
            renderLanes,
            null,
            tailMode,
            newChildren
          );
          break;
        case "together":
          initSuspenseListRenderState(
            workInProgress,
            !1,
            null,
            null,
            void 0,
            newChildren
          );
          break;
        default:
          workInProgress.memoizedState = null;
      }
      return workInProgress.child;
    }
    function bailoutOnAlreadyFinishedWork(
      current,
      workInProgress,
      renderLanes
    ) {
      null !== current && (workInProgress.dependencies = current.dependencies);
      profilerStartTime = -1;
      workInProgressRootSkippedLanes |= workInProgress.lanes;
      if (0 === (renderLanes & workInProgress.childLanes))
        if (null !== current) {
          if (
            (propagateParentContextChanges(
              current,
              workInProgress,
              renderLanes,
              !1
            ),
            0 === (renderLanes & workInProgress.childLanes))
          )
            return null;
        } else return null;
      if (null !== current && workInProgress.child !== current.child)
        throw Error("Resuming work not yet implemented.");
      if (null !== workInProgress.child) {
        current = workInProgress.child;
        renderLanes = createWorkInProgress(current, current.pendingProps);
        workInProgress.child = renderLanes;
        for (renderLanes.return = workInProgress; null !== current.sibling; )
          (current = current.sibling),
            (renderLanes = renderLanes.sibling =
              createWorkInProgress(current, current.pendingProps)),
            (renderLanes.return = workInProgress);
        renderLanes.sibling = null;
      }
      return workInProgress.child;
    }
    function checkScheduledUpdateOrContext(current, renderLanes) {
      if (0 !== (current.lanes & renderLanes)) return !0;
      current = current.dependencies;
      return null !== current && checkIfContextChanged(current) ? !0 : !1;
    }
    function attemptEarlyBailoutIfNoScheduledUpdate(
      current,
      workInProgress,
      renderLanes
    ) {
      switch (workInProgress.tag) {
        case 3:
          pushHostContainer(
            workInProgress,
            workInProgress.stateNode.containerInfo
          );
          pushProvider(
            workInProgress,
            CacheContext,
            current.memoizedState.cache
          );
          resetHydrationState();
          break;
        case 27:
        case 5:
          pushHostContext(workInProgress);
          break;
        case 4:
          pushHostContainer(
            workInProgress,
            workInProgress.stateNode.containerInfo
          );
          break;
        case 10:
          pushProvider(
            workInProgress,
            workInProgress.type,
            workInProgress.memoizedProps.value
          );
          break;
        case 12:
          0 !== (renderLanes & workInProgress.childLanes) &&
            (workInProgress.flags |= 4);
          workInProgress.flags |= 2048;
          var stateNode = workInProgress.stateNode;
          stateNode.effectDuration = -0;
          stateNode.passiveEffectDuration = -0;
          break;
        case 31:
          if (null !== workInProgress.memoizedState)
            return (
              (workInProgress.flags |= 128),
              pushDehydratedActivitySuspenseHandler(workInProgress),
              null
            );
          break;
        case 13:
          stateNode = workInProgress.memoizedState;
          if (null !== stateNode) {
            if (null !== stateNode.dehydrated)
              return (
                pushPrimaryTreeSuspenseHandler(workInProgress),
                (workInProgress.flags |= 128),
                null
              );
            if (0 !== (renderLanes & workInProgress.child.childLanes))
              return updateSuspenseComponent(
                current,
                workInProgress,
                renderLanes
              );
            pushPrimaryTreeSuspenseHandler(workInProgress);
            current = bailoutOnAlreadyFinishedWork(
              current,
              workInProgress,
              renderLanes
            );
            return null !== current ? current.sibling : null;
          }
          pushPrimaryTreeSuspenseHandler(workInProgress);
          break;
        case 19:
          var didSuspendBefore = 0 !== (current.flags & 128);
          stateNode = 0 !== (renderLanes & workInProgress.childLanes);
          stateNode ||
            (propagateParentContextChanges(
              current,
              workInProgress,
              renderLanes,
              !1
            ),
            (stateNode = 0 !== (renderLanes & workInProgress.childLanes)));
          if (didSuspendBefore) {
            if (stateNode)
              return updateSuspenseListComponent(
                current,
                workInProgress,
                renderLanes
              );
            workInProgress.flags |= 128;
          }
          didSuspendBefore = workInProgress.memoizedState;
          null !== didSuspendBefore &&
            ((didSuspendBefore.rendering = null),
            (didSuspendBefore.tail = null),
            (didSuspendBefore.lastEffect = null));
          push(
            suspenseStackCursor,
            suspenseStackCursor.current,
            workInProgress
          );
          if (stateNode) break;
          else return null;
        case 22:
          return (
            (workInProgress.lanes = 0),
            updateOffscreenComponent(
              current,
              workInProgress,
              renderLanes,
              workInProgress.pendingProps
            )
          );
        case 24:
          pushProvider(
            workInProgress,
            CacheContext,
            current.memoizedState.cache
          );
      }
      return bailoutOnAlreadyFinishedWork(current, workInProgress, renderLanes);
    }
    function beginWork(current, workInProgress, renderLanes) {
      if (workInProgress._debugNeedsRemount && null !== current) {
        renderLanes = createFiberFromTypeAndProps(
          workInProgress.type,
          workInProgress.key,
          workInProgress.pendingProps,
          workInProgress._debugOwner || null,
          workInProgress.mode,
          workInProgress.lanes
        );
        renderLanes._debugStack = workInProgress._debugStack;
        renderLanes._debugTask = workInProgress._debugTask;
        var returnFiber = workInProgress.return;
        if (null === returnFiber) throw Error("Cannot swap the root fiber.");
        current.alternate = null;
        workInProgress.alternate = null;
        renderLanes.index = workInProgress.index;
        renderLanes.sibling = workInProgress.sibling;
        renderLanes.return = workInProgress.return;
        renderLanes.ref = workInProgress.ref;
        renderLanes._debugInfo = workInProgress._debugInfo;
        if (workInProgress === returnFiber.child)
          returnFiber.child = renderLanes;
        else {
          var prevSibling = returnFiber.child;
          if (null === prevSibling)
            throw Error("Expected parent to have a child.");
          for (; prevSibling.sibling !== workInProgress; )
            if (((prevSibling = prevSibling.sibling), null === prevSibling))
              throw Error("Expected to find the previous sibling.");
          prevSibling.sibling = renderLanes;
        }
        workInProgress = returnFiber.deletions;
        null === workInProgress
          ? ((returnFiber.deletions = [current]), (returnFiber.flags |= 16))
          : workInProgress.push(current);
        renderLanes.flags |= 2;
        return renderLanes;
      }
      if (null !== current)
        if (
          current.memoizedProps !== workInProgress.pendingProps ||
          workInProgress.type !== current.type
        )
          didReceiveUpdate = !0;
        else {
          if (
            !checkScheduledUpdateOrContext(current, renderLanes) &&
            0 === (workInProgress.flags & 128)
          )
            return (
              (didReceiveUpdate = !1),
              attemptEarlyBailoutIfNoScheduledUpdate(
                current,
                workInProgress,
                renderLanes
              )
            );
          didReceiveUpdate = 0 !== (current.flags & 131072) ? !0 : !1;
        }
      else {
        didReceiveUpdate = !1;
        if ((returnFiber = isHydrating))
          warnIfNotHydrating(),
            (returnFiber = 0 !== (workInProgress.flags & 1048576));
        returnFiber &&
          ((returnFiber = workInProgress.index),
          warnIfNotHydrating(),
          pushTreeId(workInProgress, treeForkCount, returnFiber));
      }
      workInProgress.lanes = 0;
      switch (workInProgress.tag) {
        case 16:
          a: if (
            ((returnFiber = workInProgress.pendingProps),
            (current = resolveLazy(workInProgress.elementType)),
            (workInProgress.type = current),
            "function" === typeof current)
          )
            shouldConstruct(current)
              ? ((returnFiber = resolveClassComponentProps(
                  current,
                  returnFiber
                )),
                (workInProgress.tag = 1),
                (workInProgress.type = current =
                  resolveFunctionForHotReloading(current)),
                (workInProgress = updateClassComponent(
                  null,
                  workInProgress,
                  current,
                  returnFiber,
                  renderLanes
                )))
              : ((workInProgress.tag = 0),
                validateFunctionComponentInDev(workInProgress, current),
                (workInProgress.type = current =
                  resolveFunctionForHotReloading(current)),
                (workInProgress = updateFunctionComponent(
                  null,
                  workInProgress,
                  current,
                  returnFiber,
                  renderLanes
                )));
          else {
            if (void 0 !== current && null !== current)
              if (
                ((prevSibling = current.$$typeof),
                prevSibling === REACT_FORWARD_REF_TYPE)
              ) {
                workInProgress.tag = 11;
                workInProgress.type = current =
                  resolveForwardRefForHotReloading(current);
                workInProgress = updateForwardRef(
                  null,
                  workInProgress,
                  current,
                  returnFiber,
                  renderLanes
                );
                break a;
              } else if (prevSibling === REACT_MEMO_TYPE) {
                workInProgress.tag = 14;
                workInProgress = updateMemoComponent(
                  null,
                  workInProgress,
                  current,
                  returnFiber,
                  renderLanes
                );
                break a;
              }
            workInProgress = "";
            null !== current &&
              "object" === typeof current &&
              current.$$typeof === REACT_LAZY_TYPE &&
              (workInProgress =
                " Did you wrap a component in React.lazy() more than once?");
            renderLanes = getComponentNameFromType(current) || current;
            throw Error(
              "Element type is invalid. Received a promise that resolves to: " +
                renderLanes +
                ". Lazy element type must resolve to a class or function." +
                workInProgress
            );
          }
          return workInProgress;
        case 0:
          return updateFunctionComponent(
            current,
            workInProgress,
            workInProgress.type,
            workInProgress.pendingProps,
            renderLanes
          );
        case 1:
          return (
            (returnFiber = workInProgress.type),
            (prevSibling = resolveClassComponentProps(
              returnFiber,
              workInProgress.pendingProps
            )),
            updateClassComponent(
              current,
              workInProgress,
              returnFiber,
              prevSibling,
              renderLanes
            )
          );
        case 3:
          a: {
            pushHostContainer(
              workInProgress,
              workInProgress.stateNode.containerInfo
            );
            if (null === current)
              throw Error(
                "Should have a current fiber. This is a bug in React."
              );
            returnFiber = workInProgress.pendingProps;
            var prevState = workInProgress.memoizedState;
            prevSibling = prevState.element;
            cloneUpdateQueue(current, workInProgress);
            processUpdateQueue(workInProgress, returnFiber, null, renderLanes);
            var nextState = workInProgress.memoizedState;
            returnFiber = nextState.cache;
            pushProvider(workInProgress, CacheContext, returnFiber);
            returnFiber !== prevState.cache &&
              propagateContextChanges(
                workInProgress,
                [CacheContext],
                renderLanes,
                !0
              );
            suspendIfUpdateReadFromEntangledAsyncAction();
            returnFiber = nextState.element;
            if (prevState.isDehydrated)
              if (
                ((prevState = {
                  element: returnFiber,
                  isDehydrated: !1,
                  cache: nextState.cache
                }),
                (workInProgress.updateQueue.baseState = prevState),
                (workInProgress.memoizedState = prevState),
                workInProgress.flags & 256)
              ) {
                workInProgress = mountHostRootWithoutHydrating(
                  current,
                  workInProgress,
                  returnFiber,
                  renderLanes
                );
                break a;
              } else if (returnFiber !== prevSibling) {
                prevSibling = createCapturedValueAtFiber(
                  Error(
                    "This root received an early update, before anything was able hydrate. Switched the entire root to client rendering."
                  ),
                  workInProgress
                );
                queueHydrationError(prevSibling);
                workInProgress = mountHostRootWithoutHydrating(
                  current,
                  workInProgress,
                  returnFiber,
                  renderLanes
                );
                break a;
              } else {
                current = workInProgress.stateNode.containerInfo;
                switch (current.nodeType) {
                  case 9:
                    current = current.body;
                    break;
                  default:
                    current =
                      "HTML" === current.nodeName
                        ? current.ownerDocument.body
                        : current;
                }
                nextHydratableInstance = getNextHydratable(current.firstChild);
                hydrationParentFiber = workInProgress;
                isHydrating = !0;
                hydrationErrors = null;
                didSuspendOrErrorDEV = !1;
                hydrationDiffRootDEV = null;
                rootOrSingletonContext = !0;
                renderLanes = mountChildFibers(
                  workInProgress,
                  null,
                  returnFiber,
                  renderLanes
                );
                for (workInProgress.child = renderLanes; renderLanes; )
                  (renderLanes.flags = (renderLanes.flags & -3) | 4096),
                    (renderLanes = renderLanes.sibling);
              }
            else {
              resetHydrationState();
              if (returnFiber === prevSibling) {
                workInProgress = bailoutOnAlreadyFinishedWork(
                  current,
                  workInProgress,
                  renderLanes
                );
                break a;
              }
              reconcileChildren(
                current,
                workInProgress,
                returnFiber,
                renderLanes
              );
            }
            workInProgress = workInProgress.child;
          }
          return workInProgress;
        case 26:
          return (
            markRef(current, workInProgress),
            null === current
              ? (renderLanes = getResource(
                  workInProgress.type,
                  null,
                  workInProgress.pendingProps,
                  null
                ))
                ? (workInProgress.memoizedState = renderLanes)
                : isHydrating ||
                  ((renderLanes = workInProgress.type),
                  (current = workInProgress.pendingProps),
                  (returnFiber = requiredContext(
                    rootInstanceStackCursor.current
                  )),
                  (returnFiber =
                    getOwnerDocumentFromRootContainer(
                      returnFiber
                    ).createElement(renderLanes)),
                  (returnFiber[internalInstanceKey] = workInProgress),
                  (returnFiber[internalPropsKey] = current),
                  setInitialProperties(returnFiber, renderLanes, current),
                  markNodeAsHoistable(returnFiber),
                  (workInProgress.stateNode = returnFiber))
              : (workInProgress.memoizedState = getResource(
                  workInProgress.type,
                  current.memoizedProps,
                  workInProgress.pendingProps,
                  current.memoizedState
                )),
            null
          );
        case 27:
          return (
            pushHostContext(workInProgress),
            null === current &&
              isHydrating &&
              ((returnFiber = requiredContext(rootInstanceStackCursor.current)),
              (prevSibling = getHostContext()),
              (returnFiber = workInProgress.stateNode =
                resolveSingletonInstance(
                  workInProgress.type,
                  workInProgress.pendingProps,
                  returnFiber,
                  prevSibling,
                  !1
                )),
              didSuspendOrErrorDEV ||
                ((prevSibling = diffHydratedProperties(
                  returnFiber,
                  workInProgress.type,
                  workInProgress.pendingProps,
                  prevSibling
                )),
                null !== prevSibling &&
                  (buildHydrationDiffNode(workInProgress, 0).serverProps =
                    prevSibling)),
              (hydrationParentFiber = workInProgress),
              (rootOrSingletonContext = !0),
              (prevSibling = nextHydratableInstance),
              isSingletonScope(workInProgress.type)
                ? ((previousHydratableOnEnteringScopedSingleton = prevSibling),
                  (nextHydratableInstance = getNextHydratable(
                    returnFiber.firstChild
                  )))
                : (nextHydratableInstance = prevSibling)),
            reconcileChildren(
              current,
              workInProgress,
              workInProgress.pendingProps.children,
              renderLanes
            ),
            markRef(current, workInProgress),
            null === current && (workInProgress.flags |= 4194304),
            workInProgress.child
          );
        case 5:
          return (
            null === current &&
              isHydrating &&
              ((prevState = getHostContext()),
              (returnFiber = validateDOMNesting(
                workInProgress.type,
                prevState.ancestorInfo
              )),
              (prevSibling = nextHydratableInstance),
              (nextState = !prevSibling) ||
                ((nextState = canHydrateInstance(
                  prevSibling,
                  workInProgress.type,
                  workInProgress.pendingProps,
                  rootOrSingletonContext
                )),
                null !== nextState
                  ? ((workInProgress.stateNode = nextState),
                    didSuspendOrErrorDEV ||
                      ((prevState = diffHydratedProperties(
                        nextState,
                        workInProgress.type,
                        workInProgress.pendingProps,
                        prevState
                      )),
                      null !== prevState &&
                        (buildHydrationDiffNode(workInProgress, 0).serverProps =
                          prevState)),
                    (hydrationParentFiber = workInProgress),
                    (nextHydratableInstance = getNextHydratable(
                      nextState.firstChild
                    )),
                    (rootOrSingletonContext = !1),
                    (prevState = !0))
                  : (prevState = !1),
                (nextState = !prevState)),
              nextState &&
                (returnFiber &&
                  warnNonHydratedInstance(workInProgress, prevSibling),
                throwOnHydrationMismatch(workInProgress))),
            pushHostContext(workInProgress),
            (prevSibling = workInProgress.type),
            (prevState = workInProgress.pendingProps),
            (nextState = null !== current ? current.memoizedProps : null),
            (returnFiber = prevState.children),
            shouldSetTextContent(prevSibling, prevState)
              ? (returnFiber = null)
              : null !== nextState &&
                shouldSetTextContent(prevSibling, nextState) &&
                (workInProgress.flags |= 32),
            null !== workInProgress.memoizedState &&
              ((prevSibling = renderWithHooks(
                current,
                workInProgress,
                TransitionAwareHostComponent,
                null,
                null,
                renderLanes
              )),
              (HostTransitionContext._currentValue = prevSibling)),
            markRef(current, workInProgress),
            reconcileChildren(
              current,
              workInProgress,
              returnFiber,
              renderLanes
            ),
            workInProgress.child
          );
        case 6:
          return (
            null === current &&
              isHydrating &&
              ((renderLanes = workInProgress.pendingProps),
              (current = getHostContext()),
              (returnFiber = current.ancestorInfo.current),
              (renderLanes =
                null != returnFiber
                  ? validateTextNesting(
                      renderLanes,
                      returnFiber.tag,
                      current.ancestorInfo.implicitRootScope
                    )
                  : !0),
              (current = nextHydratableInstance),
              (returnFiber = !current) ||
                ((returnFiber = canHydrateTextInstance(
                  current,
                  workInProgress.pendingProps,
                  rootOrSingletonContext
                )),
                null !== returnFiber
                  ? ((workInProgress.stateNode = returnFiber),
                    (hydrationParentFiber = workInProgress),
                    (nextHydratableInstance = null),
                    (returnFiber = !0))
                  : (returnFiber = !1),
                (returnFiber = !returnFiber)),
              returnFiber &&
                (renderLanes &&
                  warnNonHydratedInstance(workInProgress, current),
                throwOnHydrationMismatch(workInProgress))),
            null
          );
        case 13:
          return updateSuspenseComponent(current, workInProgress, renderLanes);
        case 4:
          return (
            pushHostContainer(
              workInProgress,
              workInProgress.stateNode.containerInfo
            ),
            (returnFiber = workInProgress.pendingProps),
            null === current
              ? (workInProgress.child = reconcileChildFibers(
                  workInProgress,
                  null,
                  returnFiber,
                  renderLanes
                ))
              : reconcileChildren(
                  current,
                  workInProgress,
                  returnFiber,
                  renderLanes
                ),
            workInProgress.child
          );
        case 11:
          return updateForwardRef(
            current,
            workInProgress,
            workInProgress.type,
            workInProgress.pendingProps,
            renderLanes
          );
        case 7:
          return (
            reconcileChildren(
              current,
              workInProgress,
              workInProgress.pendingProps,
              renderLanes
            ),
            workInProgress.child
          );
        case 8:
          return (
            reconcileChildren(
              current,
              workInProgress,
              workInProgress.pendingProps.children,
              renderLanes
            ),
            workInProgress.child
          );
        case 12:
          return (
            (workInProgress.flags |= 4),
            (workInProgress.flags |= 2048),
            (returnFiber = workInProgress.stateNode),
            (returnFiber.effectDuration = -0),
            (returnFiber.passiveEffectDuration = -0),
            reconcileChildren(
              current,
              workInProgress,
              workInProgress.pendingProps.children,
              renderLanes
            ),
            workInProgress.child
          );
        case 10:
          return (
            (returnFiber = workInProgress.type),
            (prevSibling = workInProgress.pendingProps),
            (prevState = prevSibling.value),
            "value" in prevSibling ||
              hasWarnedAboutUsingNoValuePropOnContextProvider ||
              ((hasWarnedAboutUsingNoValuePropOnContextProvider = !0),
              console.error(
                "The `value` prop is required for the `<Context.Provider>`. Did you misspell it or forget to pass it?"
              )),
            pushProvider(workInProgress, returnFiber, prevState),
            reconcileChildren(
              current,
              workInProgress,
              prevSibling.children,
              renderLanes
            ),
            workInProgress.child
          );
        case 9:
          return (
            (prevSibling = workInProgress.type._context),
            (returnFiber = workInProgress.pendingProps.children),
            "function" !== typeof returnFiber &&
              console.error(
                "A context consumer was rendered with multiple children, or a child that isn't a function. A context consumer expects a single child that is a function. If you did pass a function, make sure there is no trailing or leading whitespace around it."
              ),
            prepareToReadContext(workInProgress),
            (prevSibling = readContext(prevSibling)),
            (returnFiber = callComponentInDEV(
              returnFiber,
              prevSibling,
              void 0
            )),
            (workInProgress.flags |= 1),
            reconcileChildren(
              current,
              workInProgress,
              returnFiber,
              renderLanes
            ),
            workInProgress.child
          );
        case 14:
          return updateMemoComponent(
            current,
            workInProgress,
            workInProgress.type,
            workInProgress.pendingProps,
            renderLanes
          );
        case 15:
          return updateSimpleMemoComponent(
            current,
            workInProgress,
            workInProgress.type,
            workInProgress.pendingProps,
            renderLanes
          );
        case 19:
          return updateSuspenseListComponent(
            current,
            workInProgress,
            renderLanes
          );
        case 31:
          return updateActivityComponent(current, workInProgress, renderLanes);
        case 22:
          return updateOffscreenComponent(
            current,
            workInProgress,
            renderLanes,
            workInProgress.pendingProps
          );
        case 24:
          return (
            prepareToReadContext(workInProgress),
            (returnFiber = readContext(CacheContext)),
            null === current
              ? ((prevSibling = peekCacheFromPool()),
                null === prevSibling &&
                  ((prevSibling = workInProgressRoot),
                  (prevState = createCache()),
                  (prevSibling.pooledCache = prevState),
                  retainCache(prevState),
                  null !== prevState &&
                    (prevSibling.pooledCacheLanes |= renderLanes),
                  (prevSibling = prevState)),
                (workInProgress.memoizedState = {
                  parent: returnFiber,
                  cache: prevSibling
                }),
                initializeUpdateQueue(workInProgress),
                pushProvider(workInProgress, CacheContext, prevSibling))
              : (0 !== (current.lanes & renderLanes) &&
                  (cloneUpdateQueue(current, workInProgress),
                  processUpdateQueue(workInProgress, null, null, renderLanes),
                  suspendIfUpdateReadFromEntangledAsyncAction()),
                (prevSibling = current.memoizedState),
                (prevState = workInProgress.memoizedState),
                prevSibling.parent !== returnFiber
                  ? ((prevSibling = {
                      parent: returnFiber,
                      cache: returnFiber
                    }),
                    (workInProgress.memoizedState = prevSibling),
                    0 === workInProgress.lanes &&
                      (workInProgress.memoizedState =
                        workInProgress.updateQueue.baseState =
                          prevSibling),
                    pushProvider(workInProgress, CacheContext, returnFiber))
                  : ((returnFiber = prevState.cache),
                    pushProvider(workInProgress, CacheContext, returnFiber),
                    returnFiber !== prevSibling.cache &&
                      propagateContextChanges(
                        workInProgress,
                        [CacheContext],
                        renderLanes,
                        !0
                      ))),
            reconcileChildren(
              current,
              workInProgress,
              workInProgress.pendingProps.children,
              renderLanes
            ),
            workInProgress.child
          );
        case 29:
          throw workInProgress.pendingProps;
      }
      throw Error(
        "Unknown unit of work tag (" +
          workInProgress.tag +
          "). This error is likely caused by a bug in React. Please file an issue."
      );
    }
    function markUpdate(workInProgress) {
      workInProgress.flags |= 4;
    }
    function preloadInstanceAndSuspendIfNeeded(
      workInProgress,
      type,
      oldProps,
      newProps,
      renderLanes
    ) {
      if ((type = (workInProgress.mode & SuspenseyImagesMode) !== NoMode))
        type = !1;
      if (type) {
        if (
          ((workInProgress.flags |= 16777216),
          (renderLanes & 335544128) === renderLanes)
        )
          if (workInProgress.stateNode.complete) workInProgress.flags |= 8192;
          else if (shouldRemainOnPreviousScreen()) workInProgress.flags |= 8192;
          else
            throw (
              ((suspendedThenable = noopSuspenseyCommitThenable),
              SuspenseyCommitException)
            );
      } else workInProgress.flags &= -16777217;
    }
    function preloadResourceAndSuspendIfNeeded(workInProgress, resource) {
      if (
        "stylesheet" !== resource.type ||
        (resource.state.loading & Inserted) !== NotLoaded
      )
        workInProgress.flags &= -16777217;
      else if (((workInProgress.flags |= 16777216), !preloadResource(resource)))
        if (shouldRemainOnPreviousScreen()) workInProgress.flags |= 8192;
        else
          throw (
            ((suspendedThenable = noopSuspenseyCommitThenable),
            SuspenseyCommitException)
          );
    }
    function scheduleRetryEffect(workInProgress, retryQueue) {
      null !== retryQueue && (workInProgress.flags |= 4);
      workInProgress.flags & 16384 &&
        ((retryQueue =
          22 !== workInProgress.tag ? claimNextRetryLane() : 536870912),
        (workInProgress.lanes |= retryQueue),
        (workInProgressSuspendedRetryLanes |= retryQueue));
    }
    function cutOffTailIfNeeded(renderState, hasRenderedATailFallback) {
      if (!isHydrating)
        switch (renderState.tailMode) {
          case "hidden":
            hasRenderedATailFallback = renderState.tail;
            for (var lastTailNode = null; null !== hasRenderedATailFallback; )
              null !== hasRenderedATailFallback.alternate &&
                (lastTailNode = hasRenderedATailFallback),
                (hasRenderedATailFallback = hasRenderedATailFallback.sibling);
            null === lastTailNode
              ? (renderState.tail = null)
              : (lastTailNode.sibling = null);
            break;
          case "collapsed":
            lastTailNode = renderState.tail;
            for (var _lastTailNode = null; null !== lastTailNode; )
              null !== lastTailNode.alternate && (_lastTailNode = lastTailNode),
                (lastTailNode = lastTailNode.sibling);
            null === _lastTailNode
              ? hasRenderedATailFallback || null === renderState.tail
                ? (renderState.tail = null)
                : (renderState.tail.sibling = null)
              : (_lastTailNode.sibling = null);
        }
    }
    function bubbleProperties(completedWork) {
      var didBailout =
          null !== completedWork.alternate &&
          completedWork.alternate.child === completedWork.child,
        newChildLanes = 0,
        subtreeFlags = 0;
      if (didBailout)
        if ((completedWork.mode & ProfileMode) !== NoMode) {
          for (
            var _treeBaseDuration = completedWork.selfBaseDuration,
              _child2 = completedWork.child;
            null !== _child2;

          )
            (newChildLanes |= _child2.lanes | _child2.childLanes),
              (subtreeFlags |= _child2.subtreeFlags & 65011712),
              (subtreeFlags |= _child2.flags & 65011712),
              (_treeBaseDuration += _child2.treeBaseDuration),
              (_child2 = _child2.sibling);
          completedWork.treeBaseDuration = _treeBaseDuration;
        } else
          for (
            _treeBaseDuration = completedWork.child;
            null !== _treeBaseDuration;

          )
            (newChildLanes |=
              _treeBaseDuration.lanes | _treeBaseDuration.childLanes),
              (subtreeFlags |= _treeBaseDuration.subtreeFlags & 65011712),
              (subtreeFlags |= _treeBaseDuration.flags & 65011712),
              (_treeBaseDuration.return = completedWork),
              (_treeBaseDuration = _treeBaseDuration.sibling);
      else if ((completedWork.mode & ProfileMode) !== NoMode) {
        _treeBaseDuration = completedWork.actualDuration;
        _child2 = completedWork.selfBaseDuration;
        for (var child = completedWork.child; null !== child; )
          (newChildLanes |= child.lanes | child.childLanes),
            (subtreeFlags |= child.subtreeFlags),
            (subtreeFlags |= child.flags),
            (_treeBaseDuration += child.actualDuration),
            (_child2 += child.treeBaseDuration),
            (child = child.sibling);
        completedWork.actualDuration = _treeBaseDuration;
        completedWork.treeBaseDuration = _child2;
      } else
        for (
          _treeBaseDuration = completedWork.child;
          null !== _treeBaseDuration;

        )
          (newChildLanes |=
            _treeBaseDuration.lanes | _treeBaseDuration.childLanes),
            (subtreeFlags |= _treeBaseDuration.subtreeFlags),
            (subtreeFlags |= _treeBaseDuration.flags),
            (_treeBaseDuration.return = completedWork),
            (_treeBaseDuration = _treeBaseDuration.sibling);
      completedWork.subtreeFlags |= subtreeFlags;
      completedWork.childLanes = newChildLanes;
      return didBailout;
    }
    function completeWork(current, workInProgress, renderLanes) {
      var newProps = workInProgress.pendingProps;
      popTreeContext(workInProgress);
      switch (workInProgress.tag) {
        case 16:
        case 15:
        case 0:
        case 11:
        case 7:
        case 8:
        case 12:
        case 9:
        case 14:
          return bubbleProperties(workInProgress), null;
        case 1:
          return bubbleProperties(workInProgress), null;
        case 3:
          renderLanes = workInProgress.stateNode;
          newProps = null;
          null !== current && (newProps = current.memoizedState.cache);
          workInProgress.memoizedState.cache !== newProps &&
            (workInProgress.flags |= 2048);
          popProvider(CacheContext, workInProgress);
          popHostContainer(workInProgress);
          renderLanes.pendingContext &&
            ((renderLanes.context = renderLanes.pendingContext),
            (renderLanes.pendingContext = null));
          if (null === current || null === current.child)
            popHydrationState(workInProgress)
              ? (emitPendingHydrationWarnings(), markUpdate(workInProgress))
              : null === current ||
                (current.memoizedState.isDehydrated &&
                  0 === (workInProgress.flags & 256)) ||
                ((workInProgress.flags |= 1024),
                upgradeHydrationErrorsToRecoverable());
          bubbleProperties(workInProgress);
          return null;
        case 26:
          var type = workInProgress.type,
            nextResource = workInProgress.memoizedState;
          null === current
            ? (markUpdate(workInProgress),
              null !== nextResource
                ? (bubbleProperties(workInProgress),
                  preloadResourceAndSuspendIfNeeded(
                    workInProgress,
                    nextResource
                  ))
                : (bubbleProperties(workInProgress),
                  preloadInstanceAndSuspendIfNeeded(
                    workInProgress,
                    type,
                    null,
                    newProps,
                    renderLanes
                  )))
            : nextResource
              ? nextResource !== current.memoizedState
                ? (markUpdate(workInProgress),
                  bubbleProperties(workInProgress),
                  preloadResourceAndSuspendIfNeeded(
                    workInProgress,
                    nextResource
                  ))
                : (bubbleProperties(workInProgress),
                  (workInProgress.flags &= -16777217))
              : ((current = current.memoizedProps),
                current !== newProps && markUpdate(workInProgress),
                bubbleProperties(workInProgress),
                preloadInstanceAndSuspendIfNeeded(
                  workInProgress,
                  type,
                  current,
                  newProps,
                  renderLanes
                ));
          return null;
        case 27:
          popHostContext(workInProgress);
          renderLanes = requiredContext(rootInstanceStackCursor.current);
          type = workInProgress.type;
          if (null !== current && null != workInProgress.stateNode)
            current.memoizedProps !== newProps && markUpdate(workInProgress);
          else {
            if (!newProps) {
              if (null === workInProgress.stateNode)
                throw Error(
                  "We must have new props for new mounts. This error is likely caused by a bug in React. Please file an issue."
                );
              bubbleProperties(workInProgress);
              return null;
            }
            current = getHostContext();
            popHydrationState(workInProgress)
              ? prepareToHydrateHostInstance(workInProgress, current)
              : ((current = resolveSingletonInstance(
                  type,
                  newProps,
                  renderLanes,
                  current,
                  !0
                )),
                (workInProgress.stateNode = current),
                markUpdate(workInProgress));
          }
          bubbleProperties(workInProgress);
          return null;
        case 5:
          popHostContext(workInProgress);
          type = workInProgress.type;
          if (null !== current && null != workInProgress.stateNode)
            current.memoizedProps !== newProps && markUpdate(workInProgress);
          else {
            if (!newProps) {
              if (null === workInProgress.stateNode)
                throw Error(
                  "We must have new props for new mounts. This error is likely caused by a bug in React. Please file an issue."
                );
              bubbleProperties(workInProgress);
              return null;
            }
            var _currentHostContext = getHostContext();
            if (popHydrationState(workInProgress))
              prepareToHydrateHostInstance(workInProgress, _currentHostContext);
            else {
              nextResource = requiredContext(rootInstanceStackCursor.current);
              validateDOMNesting(type, _currentHostContext.ancestorInfo);
              _currentHostContext = _currentHostContext.context;
              nextResource = getOwnerDocumentFromRootContainer(nextResource);
              switch (_currentHostContext) {
                case HostContextNamespaceSvg:
                  nextResource = nextResource.createElementNS(
                    SVG_NAMESPACE,
                    type
                  );
                  break;
                case HostContextNamespaceMath:
                  nextResource = nextResource.createElementNS(
                    MATH_NAMESPACE,
                    type
                  );
                  break;
                default:
                  switch (type) {
                    case "svg":
                      nextResource = nextResource.createElementNS(
                        SVG_NAMESPACE,
                        type
                      );
                      break;
                    case "math":
                      nextResource = nextResource.createElementNS(
                        MATH_NAMESPACE,
                        type
                      );
                      break;
                    case "script":
                      nextResource = nextResource.createElement("div");
                      nextResource.innerHTML = "<script>\x3c/script>";
                      nextResource = nextResource.removeChild(
                        nextResource.firstChild
                      );
                      break;
                    case "select":
                      nextResource =
                        "string" === typeof newProps.is
                          ? nextResource.createElement("select", {
                              is: newProps.is
                            })
                          : nextResource.createElement("select");
                      newProps.multiple
                        ? (nextResource.multiple = !0)
                        : newProps.size && (nextResource.size = newProps.size);
                      break;
                    default:
                      (nextResource =
                        "string" === typeof newProps.is
                          ? nextResource.createElement(type, {
                              is: newProps.is
                            })
                          : nextResource.createElement(type)),
                        -1 === type.indexOf("-") &&
                          (type !== type.toLowerCase() &&
                            console.error(
                              "<%s /> is using incorrect casing. Use PascalCase for React components, or lowercase for HTML elements.",
                              type
                            ),
                          "[object HTMLUnknownElement]" !==
                            Object.prototype.toString.call(nextResource) ||
                            hasOwnProperty.call(warnedUnknownTags, type) ||
                            ((warnedUnknownTags[type] = !0),
                            console.error(
                              "The tag <%s> is unrecognized in this browser. If you meant to render a React component, start its name with an uppercase letter.",
                              type
                            )));
                  }
              }
              nextResource[internalInstanceKey] = workInProgress;
              nextResource[internalPropsKey] = newProps;
              a: for (
                _currentHostContext = workInProgress.child;
                null !== _currentHostContext;

              ) {
                if (
                  5 === _currentHostContext.tag ||
                  6 === _currentHostContext.tag
                )
                  nextResource.appendChild(_currentHostContext.stateNode);
                else if (
                  4 !== _currentHostContext.tag &&
                  27 !== _currentHostContext.tag &&
                  null !== _currentHostContext.child
                ) {
                  _currentHostContext.child.return = _currentHostContext;
                  _currentHostContext = _currentHostContext.child;
                  continue;
                }
                if (_currentHostContext === workInProgress) break a;
                for (; null === _currentHostContext.sibling; ) {
                  if (
                    null === _currentHostContext.return ||
                    _currentHostContext.return === workInProgress
                  )
                    break a;
                  _currentHostContext = _currentHostContext.return;
                }
                _currentHostContext.sibling.return = _currentHostContext.return;
                _currentHostContext = _currentHostContext.sibling;
              }
              workInProgress.stateNode = nextResource;
              a: switch (
                (setInitialProperties(nextResource, type, newProps), type)
              ) {
                case "button":
                case "input":
                case "select":
                case "textarea":
                  newProps = !!newProps.autoFocus;
                  break a;
                case "img":
                  newProps = !0;
                  break a;
                default:
                  newProps = !1;
              }
              newProps && markUpdate(workInProgress);
            }
          }
          bubbleProperties(workInProgress);
          preloadInstanceAndSuspendIfNeeded(
            workInProgress,
            workInProgress.type,
            null === current ? null : current.memoizedProps,
            workInProgress.pendingProps,
            renderLanes
          );
          return null;
        case 6:
          if (current && null != workInProgress.stateNode)
            current.memoizedProps !== newProps && markUpdate(workInProgress);
          else {
            if (
              "string" !== typeof newProps &&
              null === workInProgress.stateNode
            )
              throw Error(
                "We must have new props for new mounts. This error is likely caused by a bug in React. Please file an issue."
              );
            current = requiredContext(rootInstanceStackCursor.current);
            renderLanes = getHostContext();
            if (popHydrationState(workInProgress)) {
              current = workInProgress.stateNode;
              renderLanes = workInProgress.memoizedProps;
              type = !didSuspendOrErrorDEV;
              newProps = null;
              nextResource = hydrationParentFiber;
              if (null !== nextResource)
                switch (nextResource.tag) {
                  case 3:
                    type &&
                      ((type = diffHydratedTextForDevWarnings(
                        current,
                        renderLanes,
                        newProps
                      )),
                      null !== type &&
                        (buildHydrationDiffNode(workInProgress, 0).serverProps =
                          type));
                    break;
                  case 27:
                  case 5:
                    (newProps = nextResource.memoizedProps),
                      type &&
                        ((type = diffHydratedTextForDevWarnings(
                          current,
                          renderLanes,
                          newProps
                        )),
                        null !== type &&
                          (buildHydrationDiffNode(
                            workInProgress,
                            0
                          ).serverProps = type));
                }
              current[internalInstanceKey] = workInProgress;
              current =
                current.nodeValue === renderLanes ||
                (null !== newProps &&
                  !0 === newProps.suppressHydrationWarning) ||
                checkForUnmatchedText(current.nodeValue, renderLanes)
                  ? !0
                  : !1;
              current || throwOnHydrationMismatch(workInProgress, !0);
            } else
              (type = renderLanes.ancestorInfo.current),
                null != type &&
                  validateTextNesting(
                    newProps,
                    type.tag,
                    renderLanes.ancestorInfo.implicitRootScope
                  ),
                (current =
                  getOwnerDocumentFromRootContainer(current).createTextNode(
                    newProps
                  )),
                (current[internalInstanceKey] = workInProgress),
                (workInProgress.stateNode = current);
          }
          bubbleProperties(workInProgress);
          return null;
        case 31:
          renderLanes = workInProgress.memoizedState;
          if (null === current || null !== current.memoizedState) {
            newProps = popHydrationState(workInProgress);
            if (null !== renderLanes) {
              if (null === current) {
                if (!newProps)
                  throw Error(
                    "A dehydrated suspense component was completed without a hydrated node. This is probably a bug in React."
                  );
                current = workInProgress.memoizedState;
                current = null !== current ? current.dehydrated : null;
                if (!current)
                  throw Error(
                    "Expected to have a hydrated activity instance. This error is likely caused by a bug in React. Please file an issue."
                  );
                current[internalInstanceKey] = workInProgress;
                bubbleProperties(workInProgress);
                (workInProgress.mode & ProfileMode) !== NoMode &&
                  null !== renderLanes &&
                  ((current = workInProgress.child),
                  null !== current &&
                    (workInProgress.treeBaseDuration -=
                      current.treeBaseDuration));
              } else
                emitPendingHydrationWarnings(),
                  resetHydrationState(),
                  0 === (workInProgress.flags & 128) &&
                    (renderLanes = workInProgress.memoizedState = null),
                  (workInProgress.flags |= 4),
                  bubbleProperties(workInProgress),
                  (workInProgress.mode & ProfileMode) !== NoMode &&
                    null !== renderLanes &&
                    ((current = workInProgress.child),
                    null !== current &&
                      (workInProgress.treeBaseDuration -=
                        current.treeBaseDuration));
              current = !1;
            } else
              (renderLanes = upgradeHydrationErrorsToRecoverable()),
                null !== current &&
                  null !== current.memoizedState &&
                  (current.memoizedState.hydrationErrors = renderLanes),
                (current = !0);
            if (!current) {
              if (workInProgress.flags & 256)
                return popSuspenseHandler(workInProgress), workInProgress;
              popSuspenseHandler(workInProgress);
              return null;
            }
            if (0 !== (workInProgress.flags & 128))
              throw Error(
                "Client rendering an Activity suspended it again. This is a bug in React."
              );
          }
          bubbleProperties(workInProgress);
          return null;
        case 13:
          newProps = workInProgress.memoizedState;
          if (
            null === current ||
            (null !== current.memoizedState &&
              null !== current.memoizedState.dehydrated)
          ) {
            type = newProps;
            nextResource = popHydrationState(workInProgress);
            if (null !== type && null !== type.dehydrated) {
              if (null === current) {
                if (!nextResource)
                  throw Error(
                    "A dehydrated suspense component was completed without a hydrated node. This is probably a bug in React."
                  );
                nextResource = workInProgress.memoizedState;
                nextResource =
                  null !== nextResource ? nextResource.dehydrated : null;
                if (!nextResource)
                  throw Error(
                    "Expected to have a hydrated suspense instance. This error is likely caused by a bug in React. Please file an issue."
                  );
                nextResource[internalInstanceKey] = workInProgress;
                bubbleProperties(workInProgress);
                (workInProgress.mode & ProfileMode) !== NoMode &&
                  null !== type &&
                  ((type = workInProgress.child),
                  null !== type &&
                    (workInProgress.treeBaseDuration -= type.treeBaseDuration));
              } else
                emitPendingHydrationWarnings(),
                  resetHydrationState(),
                  0 === (workInProgress.flags & 128) &&
                    (type = workInProgress.memoizedState = null),
                  (workInProgress.flags |= 4),
                  bubbleProperties(workInProgress),
                  (workInProgress.mode & ProfileMode) !== NoMode &&
                    null !== type &&
                    ((type = workInProgress.child),
                    null !== type &&
                      (workInProgress.treeBaseDuration -=
                        type.treeBaseDuration));
              type = !1;
            } else
              (type = upgradeHydrationErrorsToRecoverable()),
                null !== current &&
                  null !== current.memoizedState &&
                  (current.memoizedState.hydrationErrors = type),
                (type = !0);
            if (!type) {
              if (workInProgress.flags & 256)
                return popSuspenseHandler(workInProgress), workInProgress;
              popSuspenseHandler(workInProgress);
              return null;
            }
          }
          popSuspenseHandler(workInProgress);
          if (0 !== (workInProgress.flags & 128))
            return (
              (workInProgress.lanes = renderLanes),
              (workInProgress.mode & ProfileMode) !== NoMode &&
                transferActualDuration(workInProgress),
              workInProgress
            );
          renderLanes = null !== newProps;
          current = null !== current && null !== current.memoizedState;
          renderLanes &&
            ((newProps = workInProgress.child),
            (type = null),
            null !== newProps.alternate &&
              null !== newProps.alternate.memoizedState &&
              null !== newProps.alternate.memoizedState.cachePool &&
              (type = newProps.alternate.memoizedState.cachePool.pool),
            (nextResource = null),
            null !== newProps.memoizedState &&
              null !== newProps.memoizedState.cachePool &&
              (nextResource = newProps.memoizedState.cachePool.pool),
            nextResource !== type && (newProps.flags |= 2048));
          renderLanes !== current &&
            renderLanes &&
            (workInProgress.child.flags |= 8192);
          scheduleRetryEffect(workInProgress, workInProgress.updateQueue);
          bubbleProperties(workInProgress);
          (workInProgress.mode & ProfileMode) !== NoMode &&
            renderLanes &&
            ((current = workInProgress.child),
            null !== current &&
              (workInProgress.treeBaseDuration -= current.treeBaseDuration));
          return null;
        case 4:
          return (
            popHostContainer(workInProgress),
            null === current &&
              listenToAllSupportedEvents(
                workInProgress.stateNode.containerInfo
              ),
            bubbleProperties(workInProgress),
            null
          );
        case 10:
          return (
            popProvider(workInProgress.type, workInProgress),
            bubbleProperties(workInProgress),
            null
          );
        case 19:
          pop(suspenseStackCursor, workInProgress);
          newProps = workInProgress.memoizedState;
          if (null === newProps) return bubbleProperties(workInProgress), null;
          type = 0 !== (workInProgress.flags & 128);
          nextResource = newProps.rendering;
          if (null === nextResource)
            if (type) cutOffTailIfNeeded(newProps, !1);
            else {
              if (
                workInProgressRootExitStatus !== RootInProgress ||
                (null !== current && 0 !== (current.flags & 128))
              )
                for (current = workInProgress.child; null !== current; ) {
                  nextResource = findFirstSuspended(current);
                  if (null !== nextResource) {
                    workInProgress.flags |= 128;
                    cutOffTailIfNeeded(newProps, !1);
                    current = nextResource.updateQueue;
                    workInProgress.updateQueue = current;
                    scheduleRetryEffect(workInProgress, current);
                    workInProgress.subtreeFlags = 0;
                    current = renderLanes;
                    for (
                      renderLanes = workInProgress.child;
                      null !== renderLanes;

                    )
                      resetWorkInProgress(renderLanes, current),
                        (renderLanes = renderLanes.sibling);
                    push(
                      suspenseStackCursor,
                      (suspenseStackCursor.current &
                        SubtreeSuspenseContextMask) |
                        ForceSuspenseFallback,
                      workInProgress
                    );
                    isHydrating &&
                      pushTreeFork(workInProgress, newProps.treeForkCount);
                    return workInProgress.child;
                  }
                  current = current.sibling;
                }
              null !== newProps.tail &&
                now$1() > workInProgressRootRenderTargetTime &&
                ((workInProgress.flags |= 128),
                (type = !0),
                cutOffTailIfNeeded(newProps, !1),
                (workInProgress.lanes = 4194304));
            }
          else {
            if (!type)
              if (
                ((current = findFirstSuspended(nextResource)), null !== current)
              ) {
                if (
                  ((workInProgress.flags |= 128),
                  (type = !0),
                  (current = current.updateQueue),
                  (workInProgress.updateQueue = current),
                  scheduleRetryEffect(workInProgress, current),
                  cutOffTailIfNeeded(newProps, !0),
                  null === newProps.tail &&
                    "hidden" === newProps.tailMode &&
                    !nextResource.alternate &&
                    !isHydrating)
                )
                  return bubbleProperties(workInProgress), null;
              } else
                2 * now$1() - newProps.renderingStartTime >
                  workInProgressRootRenderTargetTime &&
                  536870912 !== renderLanes &&
                  ((workInProgress.flags |= 128),
                  (type = !0),
                  cutOffTailIfNeeded(newProps, !1),
                  (workInProgress.lanes = 4194304));
            newProps.isBackwards
              ? ((nextResource.sibling = workInProgress.child),
                (workInProgress.child = nextResource))
              : ((current = newProps.last),
                null !== current
                  ? (current.sibling = nextResource)
                  : (workInProgress.child = nextResource),
                (newProps.last = nextResource));
          }
          if (null !== newProps.tail)
            return (
              (current = newProps.tail),
              (newProps.rendering = current),
              (newProps.tail = current.sibling),
              (newProps.renderingStartTime = now$1()),
              (current.sibling = null),
              (renderLanes = suspenseStackCursor.current),
              (renderLanes = type
                ? (renderLanes & SubtreeSuspenseContextMask) |
                  ForceSuspenseFallback
                : renderLanes & SubtreeSuspenseContextMask),
              push(suspenseStackCursor, renderLanes, workInProgress),
              isHydrating &&
                pushTreeFork(workInProgress, newProps.treeForkCount),
              current
            );
          bubbleProperties(workInProgress);
          return null;
        case 22:
        case 23:
          return (
            popSuspenseHandler(workInProgress),
            popHiddenContext(workInProgress),
            (newProps = null !== workInProgress.memoizedState),
            null !== current
              ? (null !== current.memoizedState) !== newProps &&
                (workInProgress.flags |= 8192)
              : newProps && (workInProgress.flags |= 8192),
            newProps
              ? 0 !== (renderLanes & 536870912) &&
                0 === (workInProgress.flags & 128) &&
                (bubbleProperties(workInProgress),
                workInProgress.subtreeFlags & 6 &&
                  (workInProgress.flags |= 8192))
              : bubbleProperties(workInProgress),
            (renderLanes = workInProgress.updateQueue),
            null !== renderLanes &&
              scheduleRetryEffect(workInProgress, renderLanes.retryQueue),
            (renderLanes = null),
            null !== current &&
              null !== current.memoizedState &&
              null !== current.memoizedState.cachePool &&
              (renderLanes = current.memoizedState.cachePool.pool),
            (newProps = null),
            null !== workInProgress.memoizedState &&
              null !== workInProgress.memoizedState.cachePool &&
              (newProps = workInProgress.memoizedState.cachePool.pool),
            newProps !== renderLanes && (workInProgress.flags |= 2048),
            null !== current && pop(resumedCache, workInProgress),
            null
          );
        case 24:
          return (
            (renderLanes = null),
            null !== current && (renderLanes = current.memoizedState.cache),
            workInProgress.memoizedState.cache !== renderLanes &&
              (workInProgress.flags |= 2048),
            popProvider(CacheContext, workInProgress),
            bubbleProperties(workInProgress),
            null
          );
        case 25:
          return null;
        case 30:
          return null;
      }
      throw Error(
        "Unknown unit of work tag (" +
          workInProgress.tag +
          "). This error is likely caused by a bug in React. Please file an issue."
      );
    }
    function unwindWork(current, workInProgress) {
      popTreeContext(workInProgress);
      switch (workInProgress.tag) {
        case 1:
          return (
            (current = workInProgress.flags),
            current & 65536
              ? ((workInProgress.flags = (current & -65537) | 128),
                (workInProgress.mode & ProfileMode) !== NoMode &&
                  transferActualDuration(workInProgress),
                workInProgress)
              : null
          );
        case 3:
          return (
            popProvider(CacheContext, workInProgress),
            popHostContainer(workInProgress),
            (current = workInProgress.flags),
            0 !== (current & 65536) && 0 === (current & 128)
              ? ((workInProgress.flags = (current & -65537) | 128),
                workInProgress)
              : null
          );
        case 26:
        case 27:
        case 5:
          return popHostContext(workInProgress), null;
        case 31:
          if (null !== workInProgress.memoizedState) {
            popSuspenseHandler(workInProgress);
            if (null === workInProgress.alternate)
              throw Error(
                "Threw in newly mounted dehydrated component. This is likely a bug in React. Please file an issue."
              );
            resetHydrationState();
          }
          current = workInProgress.flags;
          return current & 65536
            ? ((workInProgress.flags = (current & -65537) | 128),
              (workInProgress.mode & ProfileMode) !== NoMode &&
                transferActualDuration(workInProgress),
              workInProgress)
            : null;
        case 13:
          popSuspenseHandler(workInProgress);
          current = workInProgress.memoizedState;
          if (null !== current && null !== current.dehydrated) {
            if (null === workInProgress.alternate)
              throw Error(
                "Threw in newly mounted dehydrated component. This is likely a bug in React. Please file an issue."
              );
            resetHydrationState();
          }
          current = workInProgress.flags;
          return current & 65536
            ? ((workInProgress.flags = (current & -65537) | 128),
              (workInProgress.mode & ProfileMode) !== NoMode &&
                transferActualDuration(workInProgress),
              workInProgress)
            : null;
        case 19:
          return pop(suspenseStackCursor, workInProgress), null;
        case 4:
          return popHostContainer(workInProgress), null;
        case 10:
          return popProvider(workInProgress.type, workInProgress), null;
        case 22:
        case 23:
          return (
            popSuspenseHandler(workInProgress),
            popHiddenContext(workInProgress),
            null !== current && pop(resumedCache, workInProgress),
            (current = workInProgress.flags),
            current & 65536
              ? ((workInProgress.flags = (current & -65537) | 128),
                (workInProgress.mode & ProfileMode) !== NoMode &&
                  transferActualDuration(workInProgress),
                workInProgress)
              : null
          );
        case 24:
          return popProvider(CacheContext, workInProgress), null;
        case 25:
          return null;
        default:
          return null;
      }
    }
    function unwindInterruptedWork(current, interruptedWork) {
      popTreeContext(interruptedWork);
      switch (interruptedWork.tag) {
        case 3:
          popProvider(CacheContext, interruptedWork);
          popHostContainer(interruptedWork);
          break;
        case 26:
        case 27:
        case 5:
          popHostContext(interruptedWork);
          break;
        case 4:
          popHostContainer(interruptedWork);
          break;
        case 31:
          null !== interruptedWork.memoizedState &&
            popSuspenseHandler(interruptedWork);
          break;
        case 13:
          popSuspenseHandler(interruptedWork);
          break;
        case 19:
          pop(suspenseStackCursor, interruptedWork);
          break;
        case 10:
          popProvider(interruptedWork.type, interruptedWork);
          break;
        case 22:
        case 23:
          popSuspenseHandler(interruptedWork);
          popHiddenContext(interruptedWork);
          null !== current && pop(resumedCache, interruptedWork);
          break;
        case 24:
          popProvider(CacheContext, interruptedWork);
      }
    }
    function shouldProfile(current) {
      return (current.mode & ProfileMode) !== NoMode;
    }
    function commitHookLayoutEffects(finishedWork, hookFlags) {
      shouldProfile(finishedWork)
        ? (startEffectTimer(),
          commitHookEffectListMount(hookFlags, finishedWork),
          recordEffectDuration())
        : commitHookEffectListMount(hookFlags, finishedWork);
    }
    function commitHookLayoutUnmountEffects(
      finishedWork,
      nearestMountedAncestor,
      hookFlags
    ) {
      shouldProfile(finishedWork)
        ? (startEffectTimer(),
          commitHookEffectListUnmount(
            hookFlags,
            finishedWork,
            nearestMountedAncestor
          ),
          recordEffectDuration())
        : commitHookEffectListUnmount(
            hookFlags,
            finishedWork,
            nearestMountedAncestor
          );
    }
    function commitHookEffectListMount(flags, finishedWork) {
      try {
        var updateQueue = finishedWork.updateQueue,
          lastEffect = null !== updateQueue ? updateQueue.lastEffect : null;
        if (null !== lastEffect) {
          var firstEffect = lastEffect.next;
          updateQueue = firstEffect;
          do {
            if (
              (updateQueue.tag & flags) === flags &&
              ((lastEffect = void 0),
              (flags & Insertion) !== NoFlags &&
                (isRunningInsertionEffect = !0),
              (lastEffect = runWithFiberInDEV(
                finishedWork,
                callCreateInDEV,
                updateQueue
              )),
              (flags & Insertion) !== NoFlags &&
                (isRunningInsertionEffect = !1),
              void 0 !== lastEffect && "function" !== typeof lastEffect)
            ) {
              var hookName = void 0;
              hookName =
                0 !== (updateQueue.tag & Layout)
                  ? "useLayoutEffect"
                  : 0 !== (updateQueue.tag & Insertion)
                    ? "useInsertionEffect"
                    : "useEffect";
              var addendum = void 0;
              addendum =
                null === lastEffect
                  ? " You returned null. If your effect does not require clean up, return undefined (or nothing)."
                  : "function" === typeof lastEffect.then
                    ? "\n\nIt looks like you wrote " +
                      hookName +
                      "(async () => ...) or returned a Promise. Instead, write the async function inside your effect and call it immediately:\n\n" +
                      hookName +
                      "(() => {\n  async function fetchData() {\n    // You can await here\n    const response = await MyAPI.getData(someId);\n    // ...\n  }\n  fetchData();\n}, [someId]); // Or [] if effect doesn't need props or state\n\nLearn more about data fetching with Hooks: https://react.dev/link/hooks-data-fetching"
                    : " You returned: " + lastEffect;
              runWithFiberInDEV(
                finishedWork,
                function (n, a) {
                  console.error(
                    "%s must not return anything besides a function, which is used for clean-up.%s",
                    n,
                    a
                  );
                },
                hookName,
                addendum
              );
            }
            updateQueue = updateQueue.next;
          } while (updateQueue !== firstEffect);
        }
      } catch (error) {
        captureCommitPhaseError(finishedWork, finishedWork.return, error);
      }
    }
    function commitHookEffectListUnmount(
      flags,
      finishedWork,
      nearestMountedAncestor
    ) {
      try {
        var updateQueue = finishedWork.updateQueue,
          lastEffect = null !== updateQueue ? updateQueue.lastEffect : null;
        if (null !== lastEffect) {
          var firstEffect = lastEffect.next;
          updateQueue = firstEffect;
          do {
            if ((updateQueue.tag & flags) === flags) {
              var inst = updateQueue.inst,
                destroy = inst.destroy;
              void 0 !== destroy &&
                ((inst.destroy = void 0),
                (flags & Insertion) !== NoFlags &&
                  (isRunningInsertionEffect = !0),
                (lastEffect = finishedWork),
                runWithFiberInDEV(
                  lastEffect,
                  callDestroyInDEV,
                  lastEffect,
                  nearestMountedAncestor,
                  destroy
                ),
                (flags & Insertion) !== NoFlags &&
                  (isRunningInsertionEffect = !1));
            }
            updateQueue = updateQueue.next;
          } while (updateQueue !== firstEffect);
        }
      } catch (error) {
        captureCommitPhaseError(finishedWork, finishedWork.return, error);
      }
    }
    function commitHookPassiveMountEffects(finishedWork, hookFlags) {
      shouldProfile(finishedWork)
        ? (startEffectTimer(),
          commitHookEffectListMount(hookFlags, finishedWork),
          recordEffectDuration())
        : commitHookEffectListMount(hookFlags, finishedWork);
    }
    function commitHookPassiveUnmountEffects(
      finishedWork,
      nearestMountedAncestor,
      hookFlags
    ) {
      shouldProfile(finishedWork)
        ? (startEffectTimer(),
          commitHookEffectListUnmount(
            hookFlags,
            finishedWork,
            nearestMountedAncestor
          ),
          recordEffectDuration())
        : commitHookEffectListUnmount(
            hookFlags,
            finishedWork,
            nearestMountedAncestor
          );
    }
    function commitClassCallbacks(finishedWork) {
      var updateQueue = finishedWork.updateQueue;
      if (null !== updateQueue) {
        var instance = finishedWork.stateNode;
        finishedWork.type.defaultProps ||
          "ref" in finishedWork.memoizedProps ||
          didWarnAboutReassigningProps ||
          (instance.props !== finishedWork.memoizedProps &&
            console.error(
              "Expected %s props to match memoized props before processing the update queue. This might either be because of a bug in React, or because a component reassigns its own `this.props`. Please file an issue.",
              getComponentNameFromFiber(finishedWork) || "instance"
            ),
          instance.state !== finishedWork.memoizedState &&
            console.error(
              "Expected %s state to match memoized state before processing the update queue. This might either be because of a bug in React, or because a component reassigns its own `this.state`. Please file an issue.",
              getComponentNameFromFiber(finishedWork) || "instance"
            ));
        try {
          runWithFiberInDEV(
            finishedWork,
            commitCallbacks,
            updateQueue,
            instance
          );
        } catch (error) {
          captureCommitPhaseError(finishedWork, finishedWork.return, error);
        }
      }
    }
    function callGetSnapshotBeforeUpdates(instance, prevProps, prevState) {
      return instance.getSnapshotBeforeUpdate(prevProps, prevState);
    }
    function commitClassSnapshot(finishedWork, current) {
      var prevProps = current.memoizedProps,
        prevState = current.memoizedState;
      current = finishedWork.stateNode;
      finishedWork.type.defaultProps ||
        "ref" in finishedWork.memoizedProps ||
        didWarnAboutReassigningProps ||
        (current.props !== finishedWork.memoizedProps &&
          console.error(
            "Expected %s props to match memoized props before getSnapshotBeforeUpdate. This might either be because of a bug in React, or because a component reassigns its own `this.props`. Please file an issue.",
            getComponentNameFromFiber(finishedWork) || "instance"
          ),
        current.state !== finishedWork.memoizedState &&
          console.error(
            "Expected %s state to match memoized state before getSnapshotBeforeUpdate. This might either be because of a bug in React, or because a component reassigns its own `this.state`. Please file an issue.",
            getComponentNameFromFiber(finishedWork) || "instance"
          ));
      try {
        var resolvedPrevProps = resolveClassComponentProps(
          finishedWork.type,
          prevProps
        );
        var snapshot = runWithFiberInDEV(
          finishedWork,
          callGetSnapshotBeforeUpdates,
          current,
          resolvedPrevProps,
          prevState
        );
        prevProps = didWarnAboutUndefinedSnapshotBeforeUpdate;
        void 0 !== snapshot ||
          prevProps.has(finishedWork.type) ||
          (prevProps.add(finishedWork.type),
          runWithFiberInDEV(finishedWork, function () {
            console.error(
              "%s.getSnapshotBeforeUpdate(): A snapshot value (or null) must be returned. You have returned undefined.",
              getComponentNameFromFiber(finishedWork)
            );
          }));
        current.__reactInternalSnapshotBeforeUpdate = snapshot;
      } catch (error) {
        captureCommitPhaseError(finishedWork, finishedWork.return, error);
      }
    }
    function safelyCallComponentWillUnmount(
      current,
      nearestMountedAncestor,
      instance
    ) {
      instance.props = resolveClassComponentProps(
        current.type,
        current.memoizedProps
      );
      instance.state = current.memoizedState;
      shouldProfile(current)
        ? (startEffectTimer(),
          runWithFiberInDEV(
            current,
            callComponentWillUnmountInDEV,
            current,
            nearestMountedAncestor,
            instance
          ),
          recordEffectDuration())
        : runWithFiberInDEV(
            current,
            callComponentWillUnmountInDEV,
            current,
            nearestMountedAncestor,
            instance
          );
    }
    function commitAttachRef(finishedWork) {
      var ref = finishedWork.ref;
      if (null !== ref) {
        switch (finishedWork.tag) {
          case 26:
          case 27:
          case 5:
            var instanceToUse = finishedWork.stateNode;
            break;
          case 30:
            instanceToUse = finishedWork.stateNode;
            break;
          default:
            instanceToUse = finishedWork.stateNode;
        }
        if ("function" === typeof ref)
          if (shouldProfile(finishedWork))
            try {
              startEffectTimer(),
                (finishedWork.refCleanup = ref(instanceToUse));
            } finally {
              recordEffectDuration();
            }
          else finishedWork.refCleanup = ref(instanceToUse);
        else
          "string" === typeof ref
            ? console.error("String refs are no longer supported.")
            : ref.hasOwnProperty("current") ||
              console.error(
                "Unexpected ref object provided for %s. Use either a ref-setter function or React.createRef().",
                getComponentNameFromFiber(finishedWork)
              ),
            (ref.current = instanceToUse);
      }
    }
    function safelyAttachRef(current, nearestMountedAncestor) {
      try {
        runWithFiberInDEV(current, commitAttachRef, current);
      } catch (error) {
        captureCommitPhaseError(current, nearestMountedAncestor, error);
      }
    }
    function safelyDetachRef(current, nearestMountedAncestor) {
      var ref = current.ref,
        refCleanup = current.refCleanup;
      if (null !== ref)
        if ("function" === typeof refCleanup)
          try {
            if (shouldProfile(current))
              try {
                startEffectTimer(), runWithFiberInDEV(current, refCleanup);
              } finally {
                recordEffectDuration(current);
              }
            else runWithFiberInDEV(current, refCleanup);
          } catch (error) {
            captureCommitPhaseError(current, nearestMountedAncestor, error);
          } finally {
            (current.refCleanup = null),
              (current = current.alternate),
              null != current && (current.refCleanup = null);
          }
        else if ("function" === typeof ref)
          try {
            if (shouldProfile(current))
              try {
                startEffectTimer(), runWithFiberInDEV(current, ref, null);
              } finally {
                recordEffectDuration(current);
              }
            else runWithFiberInDEV(current, ref, null);
          } catch (error$7) {
            captureCommitPhaseError(current, nearestMountedAncestor, error$7);
          }
        else ref.current = null;
    }
    function commitProfiler(
      finishedWork,
      current,
      commitStartTime,
      effectDuration
    ) {
      var _finishedWork$memoize = finishedWork.memoizedProps,
        id = _finishedWork$memoize.id,
        onCommit = _finishedWork$memoize.onCommit;
      _finishedWork$memoize = _finishedWork$memoize.onRender;
      current = null === current ? "mount" : "update";
      currentUpdateIsNested && (current = "nested-update");
      "function" === typeof _finishedWork$memoize &&
        _finishedWork$memoize(
          id,
          current,
          finishedWork.actualDuration,
          finishedWork.treeBaseDuration,
          finishedWork.actualStartTime,
          commitStartTime
        );
      "function" === typeof onCommit &&
        onCommit(id, current, effectDuration, commitStartTime);
    }
    function commitProfilerPostCommitImpl(
      finishedWork,
      current,
      commitStartTime,
      passiveEffectDuration
    ) {
      var _finishedWork$memoize2 = finishedWork.memoizedProps;
      finishedWork = _finishedWork$memoize2.id;
      _finishedWork$memoize2 = _finishedWork$memoize2.onPostCommit;
      current = null === current ? "mount" : "update";
      currentUpdateIsNested && (current = "nested-update");
      "function" === typeof _finishedWork$memoize2 &&
        _finishedWork$memoize2(
          finishedWork,
          current,
          passiveEffectDuration,
          commitStartTime
        );
    }
    function commitHostMount(finishedWork) {
      var type = finishedWork.type,
        props = finishedWork.memoizedProps,
        instance = finishedWork.stateNode;
      try {
        runWithFiberInDEV(
          finishedWork,
          commitMount,
          instance,
          type,
          props,
          finishedWork
        );
      } catch (error) {
        captureCommitPhaseError(finishedWork, finishedWork.return, error);
      }
    }
    function commitHostUpdate(finishedWork, newProps, oldProps) {
      try {
        runWithFiberInDEV(
          finishedWork,
          commitUpdate,
          finishedWork.stateNode,
          finishedWork.type,
          oldProps,
          newProps,
          finishedWork
        );
      } catch (error) {
        captureCommitPhaseError(finishedWork, finishedWork.return, error);
      }
    }
    function isHostParent(fiber) {
      return (
        5 === fiber.tag ||
        3 === fiber.tag ||
        26 === fiber.tag ||
        (27 === fiber.tag && isSingletonScope(fiber.type)) ||
        4 === fiber.tag
      );
    }
    function getHostSibling(fiber) {
      a: for (;;) {
        for (; null === fiber.sibling; ) {
          if (null === fiber.return || isHostParent(fiber.return)) return null;
          fiber = fiber.return;
        }
        fiber.sibling.return = fiber.return;
        for (
          fiber = fiber.sibling;
          5 !== fiber.tag && 6 !== fiber.tag && 18 !== fiber.tag;

        ) {
          if (27 === fiber.tag && isSingletonScope(fiber.type)) continue a;
          if (fiber.flags & 2) continue a;
          if (null === fiber.child || 4 === fiber.tag) continue a;
          else (fiber.child.return = fiber), (fiber = fiber.child);
        }
        if (!(fiber.flags & 2)) return fiber.stateNode;
      }
    }
    function insertOrAppendPlacementNodeIntoContainer(node, before, parent) {
      var tag = node.tag;
      if (5 === tag || 6 === tag)
        (node = node.stateNode),
          before
            ? (warnForReactChildrenConflict(parent),
              (9 === parent.nodeType
                ? parent.body
                : "HTML" === parent.nodeName
                  ? parent.ownerDocument.body
                  : parent
              ).insertBefore(node, before))
            : (warnForReactChildrenConflict(parent),
              (before =
                9 === parent.nodeType
                  ? parent.body
                  : "HTML" === parent.nodeName
                    ? parent.ownerDocument.body
                    : parent),
              before.appendChild(node),
              (parent = parent._reactRootContainer),
              (null !== parent && void 0 !== parent) ||
                null !== before.onclick ||
                (before.onclick = noop$1));
      else if (
        4 !== tag &&
        (27 === tag &&
          isSingletonScope(node.type) &&
          ((parent = node.stateNode), (before = null)),
        (node = node.child),
        null !== node)
      )
        for (
          insertOrAppendPlacementNodeIntoContainer(node, before, parent),
            node = node.sibling;
          null !== node;

        )
          insertOrAppendPlacementNodeIntoContainer(node, before, parent),
            (node = node.sibling);
    }
    function insertOrAppendPlacementNode(node, before, parent) {
      var tag = node.tag;
      if (5 === tag || 6 === tag)
        (node = node.stateNode),
          before ? parent.insertBefore(node, before) : parent.appendChild(node);
      else if (
        4 !== tag &&
        (27 === tag && isSingletonScope(node.type) && (parent = node.stateNode),
        (node = node.child),
        null !== node)
      )
        for (
          insertOrAppendPlacementNode(node, before, parent),
            node = node.sibling;
          null !== node;

        )
          insertOrAppendPlacementNode(node, before, parent),
            (node = node.sibling);
    }
    function commitPlacement(finishedWork) {
      for (
        var hostParentFiber, parentFiber = finishedWork.return;
        null !== parentFiber;

      ) {
        if (isHostParent(parentFiber)) {
          hostParentFiber = parentFiber;
          break;
        }
        parentFiber = parentFiber.return;
      }
      if (null == hostParentFiber)
        throw Error(
          "Expected to find a host parent. This error is likely caused by a bug in React. Please file an issue."
        );
      switch (hostParentFiber.tag) {
        case 27:
          hostParentFiber = hostParentFiber.stateNode;
          parentFiber = getHostSibling(finishedWork);
          insertOrAppendPlacementNode(
            finishedWork,
            parentFiber,
            hostParentFiber
          );
          break;
        case 5:
          parentFiber = hostParentFiber.stateNode;
          hostParentFiber.flags & 32 &&
            (resetTextContent(parentFiber), (hostParentFiber.flags &= -33));
          hostParentFiber = getHostSibling(finishedWork);
          insertOrAppendPlacementNode(
            finishedWork,
            hostParentFiber,
            parentFiber
          );
          break;
        case 3:
        case 4:
          hostParentFiber = hostParentFiber.stateNode.containerInfo;
          parentFiber = getHostSibling(finishedWork);
          insertOrAppendPlacementNodeIntoContainer(
            finishedWork,
            parentFiber,
            hostParentFiber
          );
          break;
        default:
          throw Error(
            "Invalid host parent fiber. This error is likely caused by a bug in React. Please file an issue."
          );
      }
    }
    function commitHostSingletonAcquisition(finishedWork) {
      var singleton = finishedWork.stateNode,
        props = finishedWork.memoizedProps;
      try {
        runWithFiberInDEV(
          finishedWork,
          acquireSingletonInstance,
          finishedWork.type,
          props,
          singleton,
          finishedWork
        );
      } catch (error) {
        captureCommitPhaseError(finishedWork, finishedWork.return, error);
      }
    }
    function isHydratingParent(current, finishedWork) {
      return 31 === finishedWork.tag
        ? ((finishedWork = finishedWork.memoizedState),
          null !== current.memoizedState && null === finishedWork)
        : 13 === finishedWork.tag
          ? ((current = current.memoizedState),
            (finishedWork = finishedWork.memoizedState),
            null !== current &&
              null !== current.dehydrated &&
              (null === finishedWork || null === finishedWork.dehydrated))
          : 3 === finishedWork.tag
            ? current.memoizedState.isDehydrated &&
              0 === (finishedWork.flags & 256)
            : !1;
    }
    function commitBeforeMutationEffects(root, firstChild) {
      root = root.containerInfo;
      eventsEnabled = _enabled;
      root = getActiveElementDeep(root);
      if (hasSelectionCapabilities(root)) {
        if ("selectionStart" in root)
          var JSCompiler_temp = {
            start: root.selectionStart,
            end: root.selectionEnd
          };
        else
          a: {
            JSCompiler_temp =
              ((JSCompiler_temp = root.ownerDocument) &&
                JSCompiler_temp.defaultView) ||
              window;
            var selection =
              JSCompiler_temp.getSelection && JSCompiler_temp.getSelection();
            if (selection && 0 !== selection.rangeCount) {
              JSCompiler_temp = selection.anchorNode;
              var anchorOffset = selection.anchorOffset,
                focusNode = selection.focusNode;
              selection = selection.focusOffset;
              try {
                JSCompiler_temp.nodeType, focusNode.nodeType;
              } catch (e$2) {
                JSCompiler_temp = null;
                break a;
              }
              var length = 0,
                start = -1,
                end = -1,
                indexWithinAnchor = 0,
                indexWithinFocus = 0,
                node = root,
                parentNode = null;
              b: for (;;) {
                for (var next; ; ) {
                  node !== JSCompiler_temp ||
                    (0 !== anchorOffset && 3 !== node.nodeType) ||
                    (start = length + anchorOffset);
                  node !== focusNode ||
                    (0 !== selection && 3 !== node.nodeType) ||
                    (end = length + selection);
                  3 === node.nodeType && (length += node.nodeValue.length);
                  if (null === (next = node.firstChild)) break;
                  parentNode = node;
                  node = next;
                }
                for (;;) {
                  if (node === root) break b;
                  parentNode === JSCompiler_temp &&
                    ++indexWithinAnchor === anchorOffset &&
                    (start = length);
                  parentNode === focusNode &&
                    ++indexWithinFocus === selection &&
                    (end = length);
                  if (null !== (next = node.nextSibling)) break;
                  node = parentNode;
                  parentNode = node.parentNode;
                }
                node = next;
              }
              JSCompiler_temp =
                -1 === start || -1 === end ? null : { start: start, end: end };
            } else JSCompiler_temp = null;
          }
        JSCompiler_temp = JSCompiler_temp || { start: 0, end: 0 };
      } else JSCompiler_temp = null;
      selectionInformation = {
        focusedElem: root,
        selectionRange: JSCompiler_temp
      };
      _enabled = !1;
      for (nextEffect = firstChild; null !== nextEffect; )
        if (
          ((firstChild = nextEffect),
          (root = firstChild.child),
          0 !== (firstChild.subtreeFlags & 1028) && null !== root)
        )
          (root.return = firstChild), (nextEffect = root);
        else
          for (; null !== nextEffect; ) {
            root = firstChild = nextEffect;
            JSCompiler_temp = root.alternate;
            anchorOffset = root.flags;
            switch (root.tag) {
              case 0:
                if (
                  0 !== (anchorOffset & 4) &&
                  ((root = root.updateQueue),
                  (root = null !== root ? root.events : null),
                  null !== root)
                )
                  for (
                    JSCompiler_temp = 0;
                    JSCompiler_temp < root.length;
                    JSCompiler_temp++
                  )
                    (anchorOffset = root[JSCompiler_temp]),
                      (anchorOffset.ref.impl = anchorOffset.nextImpl);
                break;
              case 11:
              case 15:
                break;
              case 1:
                0 !== (anchorOffset & 1024) &&
                  null !== JSCompiler_temp &&
                  commitClassSnapshot(root, JSCompiler_temp);
                break;
              case 3:
                if (0 !== (anchorOffset & 1024))
                  if (
                    ((root = root.stateNode.containerInfo),
                    (JSCompiler_temp = root.nodeType),
                    9 === JSCompiler_temp)
                  )
                    clearContainerSparingly(root);
                  else if (1 === JSCompiler_temp)
                    switch (root.nodeName) {
                      case "HEAD":
                      case "HTML":
                      case "BODY":
                        clearContainerSparingly(root);
                        break;
                      default:
                        root.textContent = "";
                    }
                break;
              case 5:
              case 26:
              case 27:
              case 6:
              case 4:
              case 17:
                break;
              default:
                if (0 !== (anchorOffset & 1024))
                  throw Error(
                    "This unit of work tag should not have side-effects. This error is likely caused by a bug in React. Please file an issue."
                  );
            }
            root = firstChild.sibling;
            if (null !== root) {
              root.return = firstChild.return;
              nextEffect = root;
              break;
            }
            nextEffect = firstChild.return;
          }
    }
    function commitLayoutEffectOnFiber(finishedRoot, current, finishedWork) {
      var prevEffectStart = pushComponentEffectStart(),
        prevEffectDuration = pushComponentEffectDuration(),
        prevEffectErrors = pushComponentEffectErrors(),
        prevEffectDidSpawnUpdate = pushComponentEffectDidSpawnUpdate(),
        flags = finishedWork.flags;
      switch (finishedWork.tag) {
        case 0:
        case 11:
        case 15:
          recursivelyTraverseLayoutEffects(finishedRoot, finishedWork);
          flags & 4 &&
            commitHookLayoutEffects(finishedWork, Layout | HasEffect);
          break;
        case 1:
          recursivelyTraverseLayoutEffects(finishedRoot, finishedWork);
          if (flags & 4)
            if (((finishedRoot = finishedWork.stateNode), null === current))
              finishedWork.type.defaultProps ||
                "ref" in finishedWork.memoizedProps ||
                didWarnAboutReassigningProps ||
                (finishedRoot.props !== finishedWork.memoizedProps &&
                  console.error(
                    "Expected %s props to match memoized props before componentDidMount. This might either be because of a bug in React, or because a component reassigns its own `this.props`. Please file an issue.",
                    getComponentNameFromFiber(finishedWork) || "instance"
                  ),
                finishedRoot.state !== finishedWork.memoizedState &&
                  console.error(
                    "Expected %s state to match memoized state before componentDidMount. This might either be because of a bug in React, or because a component reassigns its own `this.state`. Please file an issue.",
                    getComponentNameFromFiber(finishedWork) || "instance"
                  )),
                shouldProfile(finishedWork)
                  ? (startEffectTimer(),
                    runWithFiberInDEV(
                      finishedWork,
                      callComponentDidMountInDEV,
                      finishedWork,
                      finishedRoot
                    ),
                    recordEffectDuration())
                  : runWithFiberInDEV(
                      finishedWork,
                      callComponentDidMountInDEV,
                      finishedWork,
                      finishedRoot
                    );
            else {
              var prevProps = resolveClassComponentProps(
                finishedWork.type,
                current.memoizedProps
              );
              current = current.memoizedState;
              finishedWork.type.defaultProps ||
                "ref" in finishedWork.memoizedProps ||
                didWarnAboutReassigningProps ||
                (finishedRoot.props !== finishedWork.memoizedProps &&
                  console.error(
                    "Expected %s props to match memoized props before componentDidUpdate. This might either be because of a bug in React, or because a component reassigns its own `this.props`. Please file an issue.",
                    getComponentNameFromFiber(finishedWork) || "instance"
                  ),
                finishedRoot.state !== finishedWork.memoizedState &&
                  console.error(
                    "Expected %s state to match memoized state before componentDidUpdate. This might either be because of a bug in React, or because a component reassigns its own `this.state`. Please file an issue.",
                    getComponentNameFromFiber(finishedWork) || "instance"
                  ));
              shouldProfile(finishedWork)
                ? (startEffectTimer(),
                  runWithFiberInDEV(
                    finishedWork,
                    callComponentDidUpdateInDEV,
                    finishedWork,
                    finishedRoot,
                    prevProps,
                    current,
                    finishedRoot.__reactInternalSnapshotBeforeUpdate
                  ),
                  recordEffectDuration())
                : runWithFiberInDEV(
                    finishedWork,
                    callComponentDidUpdateInDEV,
                    finishedWork,
                    finishedRoot,
                    prevProps,
                    current,
                    finishedRoot.__reactInternalSnapshotBeforeUpdate
                  );
            }
          flags & 64 && commitClassCallbacks(finishedWork);
          flags & 512 && safelyAttachRef(finishedWork, finishedWork.return);
          break;
        case 3:
          current = pushNestedEffectDurations();
          recursivelyTraverseLayoutEffects(finishedRoot, finishedWork);
          if (
            flags & 64 &&
            ((flags = finishedWork.updateQueue), null !== flags)
          ) {
            prevProps = null;
            if (null !== finishedWork.child)
              switch (finishedWork.child.tag) {
                case 27:
                case 5:
                  prevProps = finishedWork.child.stateNode;
                  break;
                case 1:
                  prevProps = finishedWork.child.stateNode;
              }
            try {
              runWithFiberInDEV(
                finishedWork,
                commitCallbacks,
                flags,
                prevProps
              );
            } catch (error) {
              captureCommitPhaseError(finishedWork, finishedWork.return, error);
            }
          }
          finishedRoot.effectDuration += popNestedEffectDurations(current);
          break;
        case 27:
          null === current &&
            flags & 4 &&
            commitHostSingletonAcquisition(finishedWork);
        case 26:
        case 5:
          recursivelyTraverseLayoutEffects(finishedRoot, finishedWork);
          if (null === current)
            if (flags & 4) commitHostMount(finishedWork);
            else if (flags & 64) {
              finishedRoot = finishedWork.type;
              current = finishedWork.memoizedProps;
              prevProps = finishedWork.stateNode;
              try {
                runWithFiberInDEV(
                  finishedWork,
                  commitHydratedInstance,
                  prevProps,
                  finishedRoot,
                  current,
                  finishedWork
                );
              } catch (error) {
                captureCommitPhaseError(
                  finishedWork,
                  finishedWork.return,
                  error
                );
              }
            }
          flags & 512 && safelyAttachRef(finishedWork, finishedWork.return);
          break;
        case 12:
          if (flags & 4) {
            flags = pushNestedEffectDurations();
            recursivelyTraverseLayoutEffects(finishedRoot, finishedWork);
            finishedRoot = finishedWork.stateNode;
            finishedRoot.effectDuration += bubbleNestedEffectDurations(flags);
            try {
              runWithFiberInDEV(
                finishedWork,
                commitProfiler,
                finishedWork,
                current,
                commitStartTime,
                finishedRoot.effectDuration
              );
            } catch (error) {
              captureCommitPhaseError(finishedWork, finishedWork.return, error);
            }
          } else recursivelyTraverseLayoutEffects(finishedRoot, finishedWork);
          break;
        case 31:
          recursivelyTraverseLayoutEffects(finishedRoot, finishedWork);
          flags & 4 &&
            commitActivityHydrationCallbacks(finishedRoot, finishedWork);
          break;
        case 13:
          recursivelyTraverseLayoutEffects(finishedRoot, finishedWork);
          flags & 4 &&
            commitSuspenseHydrationCallbacks(finishedRoot, finishedWork);
          flags & 64 &&
            ((finishedRoot = finishedWork.memoizedState),
            null !== finishedRoot &&
              ((finishedRoot = finishedRoot.dehydrated),
              null !== finishedRoot &&
                ((flags = retryDehydratedSuspenseBoundary.bind(
                  null,
                  finishedWork
                )),
                registerSuspenseInstanceRetry(finishedRoot, flags))));
          break;
        case 22:
          flags =
            null !== finishedWork.memoizedState || offscreenSubtreeIsHidden;
          if (!flags) {
            current =
              (null !== current && null !== current.memoizedState) ||
              offscreenSubtreeWasHidden;
            prevProps = offscreenSubtreeIsHidden;
            var prevOffscreenSubtreeWasHidden = offscreenSubtreeWasHidden;
            offscreenSubtreeIsHidden = flags;
            (offscreenSubtreeWasHidden = current) &&
            !prevOffscreenSubtreeWasHidden
              ? (recursivelyTraverseReappearLayoutEffects(
                  finishedRoot,
                  finishedWork,
                  0 !== (finishedWork.subtreeFlags & 8772)
                ),
                (finishedWork.mode & ProfileMode) !== NoMode &&
                  0 <= componentEffectStartTime &&
                  0 <= componentEffectEndTime &&
                  0.05 < componentEffectEndTime - componentEffectStartTime &&
                  logComponentReappeared(
                    finishedWork,
                    componentEffectStartTime,
                    componentEffectEndTime
                  ))
              : recursivelyTraverseLayoutEffects(finishedRoot, finishedWork);
            offscreenSubtreeIsHidden = prevProps;
            offscreenSubtreeWasHidden = prevOffscreenSubtreeWasHidden;
          }
          break;
        case 30:
          break;
        default:
          recursivelyTraverseLayoutEffects(finishedRoot, finishedWork);
      }
      (finishedWork.mode & ProfileMode) !== NoMode &&
        0 <= componentEffectStartTime &&
        0 <= componentEffectEndTime &&
        ((componentEffectSpawnedUpdate || 0.05 < componentEffectDuration) &&
          logComponentEffect(
            finishedWork,
            componentEffectStartTime,
            componentEffectEndTime,
            componentEffectDuration,
            componentEffectErrors
          ),
        null === finishedWork.alternate &&
          null !== finishedWork.return &&
          null !== finishedWork.return.alternate &&
          0.05 < componentEffectEndTime - componentEffectStartTime &&
          (isHydratingParent(
            finishedWork.return.alternate,
            finishedWork.return
          ) ||
            logComponentTrigger(
              finishedWork,
              componentEffectStartTime,
              componentEffectEndTime,
              "Mount"
            )));
      popComponentEffectStart(prevEffectStart);
      popComponentEffectDuration(prevEffectDuration);
      componentEffectErrors = prevEffectErrors;
      componentEffectSpawnedUpdate = prevEffectDidSpawnUpdate;
    }
    function detachFiberAfterEffects(fiber) {
      var alternate = fiber.alternate;
      null !== alternate &&
        ((fiber.alternate = null), detachFiberAfterEffects(alternate));
      fiber.child = null;
      fiber.deletions = null;
      fiber.sibling = null;
      5 === fiber.tag &&
        ((alternate = fiber.stateNode),
        null !== alternate && detachDeletedInstance(alternate));
      fiber.stateNode = null;
      fiber._debugOwner = null;
      fiber.return = null;
      fiber.dependencies = null;
      fiber.memoizedProps = null;
      fiber.memoizedState = null;
      fiber.pendingProps = null;
      fiber.stateNode = null;
      fiber.updateQueue = null;
    }
    function recursivelyTraverseDeletionEffects(
      finishedRoot,
      nearestMountedAncestor,
      parent
    ) {
      for (parent = parent.child; null !== parent; )
        commitDeletionEffectsOnFiber(
          finishedRoot,
          nearestMountedAncestor,
          parent
        ),
          (parent = parent.sibling);
    }
    function commitDeletionEffectsOnFiber(
      finishedRoot,
      nearestMountedAncestor,
      deletedFiber
    ) {
      if (
        injectedHook &&
        "function" === typeof injectedHook.onCommitFiberUnmount
      )
        try {
          injectedHook.onCommitFiberUnmount(rendererID, deletedFiber);
        } catch (err) {
          hasLoggedError ||
            ((hasLoggedError = !0),
            console.error(
              "React instrumentation encountered an error: %o",
              err
            ));
        }
      var prevEffectStart = pushComponentEffectStart(),
        prevEffectDuration = pushComponentEffectDuration(),
        prevEffectErrors = pushComponentEffectErrors(),
        prevEffectDidSpawnUpdate = pushComponentEffectDidSpawnUpdate();
      switch (deletedFiber.tag) {
        case 26:
          offscreenSubtreeWasHidden ||
            safelyDetachRef(deletedFiber, nearestMountedAncestor);
          recursivelyTraverseDeletionEffects(
            finishedRoot,
            nearestMountedAncestor,
            deletedFiber
          );
          deletedFiber.memoizedState
            ? deletedFiber.memoizedState.count--
            : deletedFiber.stateNode &&
              ((finishedRoot = deletedFiber.stateNode),
              finishedRoot.parentNode.removeChild(finishedRoot));
          break;
        case 27:
          offscreenSubtreeWasHidden ||
            safelyDetachRef(deletedFiber, nearestMountedAncestor);
          var prevHostParent = hostParent,
            prevHostParentIsContainer = hostParentIsContainer;
          isSingletonScope(deletedFiber.type) &&
            ((hostParent = deletedFiber.stateNode),
            (hostParentIsContainer = !1));
          recursivelyTraverseDeletionEffects(
            finishedRoot,
            nearestMountedAncestor,
            deletedFiber
          );
          runWithFiberInDEV(
            deletedFiber,
            releaseSingletonInstance,
            deletedFiber.stateNode
          );
          hostParent = prevHostParent;
          hostParentIsContainer = prevHostParentIsContainer;
          break;
        case 5:
          offscreenSubtreeWasHidden ||
            safelyDetachRef(deletedFiber, nearestMountedAncestor);
        case 6:
          prevHostParent = hostParent;
          prevHostParentIsContainer = hostParentIsContainer;
          hostParent = null;
          recursivelyTraverseDeletionEffects(
            finishedRoot,
            nearestMountedAncestor,
            deletedFiber
          );
          hostParent = prevHostParent;
          hostParentIsContainer = prevHostParentIsContainer;
          if (null !== hostParent)
            if (hostParentIsContainer)
              try {
                runWithFiberInDEV(
                  deletedFiber,
                  removeChildFromContainer,
                  hostParent,
                  deletedFiber.stateNode
                );
              } catch (error) {
                captureCommitPhaseError(
                  deletedFiber,
                  nearestMountedAncestor,
                  error
                );
              }
            else
              try {
                runWithFiberInDEV(
                  deletedFiber,
                  removeChild,
                  hostParent,
                  deletedFiber.stateNode
                );
              } catch (error) {
                captureCommitPhaseError(
                  deletedFiber,
                  nearestMountedAncestor,
                  error
                );
              }
          break;
        case 18:
          null !== hostParent &&
            (hostParentIsContainer
              ? ((finishedRoot = hostParent),
                clearHydrationBoundary(
                  9 === finishedRoot.nodeType
                    ? finishedRoot.body
                    : "HTML" === finishedRoot.nodeName
                      ? finishedRoot.ownerDocument.body
                      : finishedRoot,
                  deletedFiber.stateNode
                ),
                retryIfBlockedOn(finishedRoot))
              : clearHydrationBoundary(hostParent, deletedFiber.stateNode));
          break;
        case 4:
          prevHostParent = hostParent;
          prevHostParentIsContainer = hostParentIsContainer;
          hostParent = deletedFiber.stateNode.containerInfo;
          hostParentIsContainer = !0;
          recursivelyTraverseDeletionEffects(
            finishedRoot,
            nearestMountedAncestor,
            deletedFiber
          );
          hostParent = prevHostParent;
          hostParentIsContainer = prevHostParentIsContainer;
          break;
        case 0:
        case 11:
        case 14:
        case 15:
          commitHookEffectListUnmount(
            Insertion,
            deletedFiber,
            nearestMountedAncestor
          );
          offscreenSubtreeWasHidden ||
            commitHookLayoutUnmountEffects(
              deletedFiber,
              nearestMountedAncestor,
              Layout
            );
          recursivelyTraverseDeletionEffects(
            finishedRoot,
            nearestMountedAncestor,
            deletedFiber
          );
          break;
        case 1:
          offscreenSubtreeWasHidden ||
            (safelyDetachRef(deletedFiber, nearestMountedAncestor),
            (prevHostParent = deletedFiber.stateNode),
            "function" === typeof prevHostParent.componentWillUnmount &&
              safelyCallComponentWillUnmount(
                deletedFiber,
                nearestMountedAncestor,
                prevHostParent
              ));
          recursivelyTraverseDeletionEffects(
            finishedRoot,
            nearestMountedAncestor,
            deletedFiber
          );
          break;
        case 21:
          recursivelyTraverseDeletionEffects(
            finishedRoot,
            nearestMountedAncestor,
            deletedFiber
          );
          break;
        case 22:
          offscreenSubtreeWasHidden =
            (prevHostParent = offscreenSubtreeWasHidden) ||
            null !== deletedFiber.memoizedState;
          recursivelyTraverseDeletionEffects(
            finishedRoot,
            nearestMountedAncestor,
            deletedFiber
          );
          offscreenSubtreeWasHidden = prevHostParent;
          break;
        default:
          recursivelyTraverseDeletionEffects(
            finishedRoot,
            nearestMountedAncestor,
            deletedFiber
          );
      }
      (deletedFiber.mode & ProfileMode) !== NoMode &&
        0 <= componentEffectStartTime &&
        0 <= componentEffectEndTime &&
        (componentEffectSpawnedUpdate || 0.05 < componentEffectDuration) &&
        logComponentEffect(
          deletedFiber,
          componentEffectStartTime,
          componentEffectEndTime,
          componentEffectDuration,
          componentEffectErrors
        );
      popComponentEffectStart(prevEffectStart);
      popComponentEffectDuration(prevEffectDuration);
      componentEffectErrors = prevEffectErrors;
      componentEffectSpawnedUpdate = prevEffectDidSpawnUpdate;
    }
    function commitActivityHydrationCallbacks(finishedRoot, finishedWork) {
      if (
        null === finishedWork.memoizedState &&
        ((finishedRoot = finishedWork.alternate),
        null !== finishedRoot &&
          ((finishedRoot = finishedRoot.memoizedState), null !== finishedRoot))
      ) {
        finishedRoot = finishedRoot.dehydrated;
        try {
          runWithFiberInDEV(
            finishedWork,
            commitHydratedActivityInstance,
            finishedRoot
          );
        } catch (error) {
          captureCommitPhaseError(finishedWork, finishedWork.return, error);
        }
      }
    }
    function commitSuspenseHydrationCallbacks(finishedRoot, finishedWork) {
      if (
        null === finishedWork.memoizedState &&
        ((finishedRoot = finishedWork.alternate),
        null !== finishedRoot &&
          ((finishedRoot = finishedRoot.memoizedState),
          null !== finishedRoot &&
            ((finishedRoot = finishedRoot.dehydrated), null !== finishedRoot)))
      )
        try {
          runWithFiberInDEV(
            finishedWork,
            commitHydratedSuspenseInstance,
            finishedRoot
          );
        } catch (error) {
          captureCommitPhaseError(finishedWork, finishedWork.return, error);
        }
    }
    function getRetryCache(finishedWork) {
      switch (finishedWork.tag) {
        case 31:
        case 13:
        case 19:
          var retryCache = finishedWork.stateNode;
          null === retryCache &&
            (retryCache = finishedWork.stateNode = new PossiblyWeakSet());
          return retryCache;
        case 22:
          return (
            (finishedWork = finishedWork.stateNode),
            (retryCache = finishedWork._retryCache),
            null === retryCache &&
              (retryCache = finishedWork._retryCache = new PossiblyWeakSet()),
            retryCache
          );
        default:
          throw Error(
            "Unexpected Suspense handler tag (" +
              finishedWork.tag +
              "). This is a bug in React."
          );
      }
    }
    function attachSuspenseRetryListeners(finishedWork, wakeables) {
      var retryCache = getRetryCache(finishedWork);
      wakeables.forEach(function (wakeable) {
        if (!retryCache.has(wakeable)) {
          retryCache.add(wakeable);
          if (isDevToolsPresent)
            if (null !== inProgressLanes && null !== inProgressRoot)
              restorePendingUpdaters(inProgressRoot, inProgressLanes);
            else
              throw Error(
                "Expected finished root and lanes to be set. This is a bug in React."
              );
          var retry = resolveRetryWakeable.bind(null, finishedWork, wakeable);
          wakeable.then(retry, retry);
        }
      });
    }
    function recursivelyTraverseMutationEffects(root$jscomp$0, parentFiber) {
      var deletions = parentFiber.deletions;
      if (null !== deletions)
        for (var i = 0; i < deletions.length; i++) {
          var root = root$jscomp$0,
            returnFiber = parentFiber,
            deletedFiber = deletions[i],
            prevEffectStart = pushComponentEffectStart(),
            parent = returnFiber;
          a: for (; null !== parent; ) {
            switch (parent.tag) {
              case 27:
                if (isSingletonScope(parent.type)) {
                  hostParent = parent.stateNode;
                  hostParentIsContainer = !1;
                  break a;
                }
                break;
              case 5:
                hostParent = parent.stateNode;
                hostParentIsContainer = !1;
                break a;
              case 3:
              case 4:
                hostParent = parent.stateNode.containerInfo;
                hostParentIsContainer = !0;
                break a;
            }
            parent = parent.return;
          }
          if (null === hostParent)
            throw Error(
              "Expected to find a host parent. This error is likely caused by a bug in React. Please file an issue."
            );
          commitDeletionEffectsOnFiber(root, returnFiber, deletedFiber);
          hostParent = null;
          hostParentIsContainer = !1;
          (deletedFiber.mode & ProfileMode) !== NoMode &&
            0 <= componentEffectStartTime &&
            0 <= componentEffectEndTime &&
            0.05 < componentEffectEndTime - componentEffectStartTime &&
            logComponentTrigger(
              deletedFiber,
              componentEffectStartTime,
              componentEffectEndTime,
              "Unmount"
            );
          popComponentEffectStart(prevEffectStart);
          root = deletedFiber;
          returnFiber = root.alternate;
          null !== returnFiber && (returnFiber.return = null);
          root.return = null;
        }
      if (parentFiber.subtreeFlags & 13886)
        for (parentFiber = parentFiber.child; null !== parentFiber; )
          commitMutationEffectsOnFiber(parentFiber, root$jscomp$0),
            (parentFiber = parentFiber.sibling);
    }
    function commitMutationEffectsOnFiber(finishedWork, root) {
      var prevEffectStart = pushComponentEffectStart(),
        prevEffectDuration = pushComponentEffectDuration(),
        prevEffectErrors = pushComponentEffectErrors(),
        prevEffectDidSpawnUpdate = pushComponentEffectDidSpawnUpdate(),
        current = finishedWork.alternate,
        flags = finishedWork.flags;
      switch (finishedWork.tag) {
        case 0:
        case 11:
        case 14:
        case 15:
          recursivelyTraverseMutationEffects(root, finishedWork);
          commitReconciliationEffects(finishedWork);
          flags & 4 &&
            (commitHookEffectListUnmount(
              Insertion | HasEffect,
              finishedWork,
              finishedWork.return
            ),
            commitHookEffectListMount(Insertion | HasEffect, finishedWork),
            commitHookLayoutUnmountEffects(
              finishedWork,
              finishedWork.return,
              Layout | HasEffect
            ));
          break;
        case 1:
          recursivelyTraverseMutationEffects(root, finishedWork);
          commitReconciliationEffects(finishedWork);
          flags & 512 &&
            (offscreenSubtreeWasHidden ||
              null === current ||
              safelyDetachRef(current, current.return));
          if (
            flags & 64 &&
            offscreenSubtreeIsHidden &&
            ((flags = finishedWork.updateQueue),
            null !== flags && ((current = flags.callbacks), null !== current))
          ) {
            var existingHiddenCallbacks = flags.shared.hiddenCallbacks;
            flags.shared.hiddenCallbacks =
              null === existingHiddenCallbacks
                ? current
                : existingHiddenCallbacks.concat(current);
          }
          break;
        case 26:
          existingHiddenCallbacks = currentHoistableRoot;
          recursivelyTraverseMutationEffects(root, finishedWork);
          commitReconciliationEffects(finishedWork);
          flags & 512 &&
            (offscreenSubtreeWasHidden ||
              null === current ||
              safelyDetachRef(current, current.return));
          if (flags & 4) {
            var currentResource =
              null !== current ? current.memoizedState : null;
            flags = finishedWork.memoizedState;
            if (null === current)
              if (null === flags)
                if (null === finishedWork.stateNode) {
                  a: {
                    flags = finishedWork.type;
                    current = finishedWork.memoizedProps;
                    existingHiddenCallbacks =
                      existingHiddenCallbacks.ownerDocument ||
                      existingHiddenCallbacks;
                    b: switch (flags) {
                      case "title":
                        currentResource =
                          existingHiddenCallbacks.getElementsByTagName(
                            "title"
                          )[0];
                        if (
                          !currentResource ||
                          currentResource[internalHoistableMarker] ||
                          currentResource[internalInstanceKey] ||
                          currentResource.namespaceURI === SVG_NAMESPACE ||
                          currentResource.hasAttribute("itemprop")
                        )
                          (currentResource =
                            existingHiddenCallbacks.createElement(flags)),
                            existingHiddenCallbacks.head.insertBefore(
                              currentResource,
                              existingHiddenCallbacks.querySelector(
                                "head > title"
                              )
                            );
                        setInitialProperties(currentResource, flags, current);
                        currentResource[internalInstanceKey] = finishedWork;
                        markNodeAsHoistable(currentResource);
                        flags = currentResource;
                        break a;
                      case "link":
                        var maybeNodes = getHydratableHoistableCache(
                          "link",
                          "href",
                          existingHiddenCallbacks
                        ).get(flags + (current.href || ""));
                        if (maybeNodes)
                          for (var i = 0; i < maybeNodes.length; i++)
                            if (
                              ((currentResource = maybeNodes[i]),
                              currentResource.getAttribute("href") ===
                                (null == current.href || "" === current.href
                                  ? null
                                  : current.href) &&
                                currentResource.getAttribute("rel") ===
                                  (null == current.rel ? null : current.rel) &&
                                currentResource.getAttribute("title") ===
                                  (null == current.title
                                    ? null
                                    : current.title) &&
                                currentResource.getAttribute("crossorigin") ===
                                  (null == current.crossOrigin
                                    ? null
                                    : current.crossOrigin))
                            ) {
                              maybeNodes.splice(i, 1);
                              break b;
                            }
                        currentResource =
                          existingHiddenCallbacks.createElement(flags);
                        setInitialProperties(currentResource, flags, current);
                        existingHiddenCallbacks.head.appendChild(
                          currentResource
                        );
                        break;
                      case "meta":
                        if (
                          (maybeNodes = getHydratableHoistableCache(
                            "meta",
                            "content",
                            existingHiddenCallbacks
                          ).get(flags + (current.content || "")))
                        )
                          for (i = 0; i < maybeNodes.length; i++)
                            if (
                              ((currentResource = maybeNodes[i]),
                              checkAttributeStringCoercion(
                                current.content,
                                "content"
                              ),
                              currentResource.getAttribute("content") ===
                                (null == current.content
                                  ? null
                                  : "" + current.content) &&
                                currentResource.getAttribute("name") ===
                                  (null == current.name
                                    ? null
                                    : current.name) &&
                                currentResource.getAttribute("property") ===
                                  (null == current.property
                                    ? null
                                    : current.property) &&
                                currentResource.getAttribute("http-equiv") ===
                                  (null == current.httpEquiv
                                    ? null
                                    : current.httpEquiv) &&
                                currentResource.getAttribute("charset") ===
                                  (null == current.charSet
                                    ? null
                                    : current.charSet))
                            ) {
                              maybeNodes.splice(i, 1);
                              break b;
                            }
                        currentResource =
                          existingHiddenCallbacks.createElement(flags);
                        setInitialProperties(currentResource, flags, current);
                        existingHiddenCallbacks.head.appendChild(
                          currentResource
                        );
                        break;
                      default:
                        throw Error(
                          'getNodesForType encountered a type it did not expect: "' +
                            flags +
                            '". This is a bug in React.'
                        );
                    }
                    currentResource[internalInstanceKey] = finishedWork;
                    markNodeAsHoistable(currentResource);
                    flags = currentResource;
                  }
                  finishedWork.stateNode = flags;
                } else
                  mountHoistable(
                    existingHiddenCallbacks,
                    finishedWork.type,
                    finishedWork.stateNode
                  );
              else
                finishedWork.stateNode = acquireResource(
                  existingHiddenCallbacks,
                  flags,
                  finishedWork.memoizedProps
                );
            else
              currentResource !== flags
                ? (null === currentResource
                    ? null !== current.stateNode &&
                      ((current = current.stateNode),
                      current.parentNode.removeChild(current))
                    : currentResource.count--,
                  null === flags
                    ? mountHoistable(
                        existingHiddenCallbacks,
                        finishedWork.type,
                        finishedWork.stateNode
                      )
                    : acquireResource(
                        existingHiddenCallbacks,
                        flags,
                        finishedWork.memoizedProps
                      ))
                : null === flags &&
                  null !== finishedWork.stateNode &&
                  commitHostUpdate(
                    finishedWork,
                    finishedWork.memoizedProps,
                    current.memoizedProps
                  );
          }
          break;
        case 27:
          recursivelyTraverseMutationEffects(root, finishedWork);
          commitReconciliationEffects(finishedWork);
          flags & 512 &&
            (offscreenSubtreeWasHidden ||
              null === current ||
              safelyDetachRef(current, current.return));
          null !== current &&
            flags & 4 &&
            commitHostUpdate(
              finishedWork,
              finishedWork.memoizedProps,
              current.memoizedProps
            );
          break;
        case 5:
          recursivelyTraverseMutationEffects(root, finishedWork);
          commitReconciliationEffects(finishedWork);
          flags & 512 &&
            (offscreenSubtreeWasHidden ||
              null === current ||
              safelyDetachRef(current, current.return));
          if (finishedWork.flags & 32) {
            existingHiddenCallbacks = finishedWork.stateNode;
            try {
              runWithFiberInDEV(
                finishedWork,
                resetTextContent,
                existingHiddenCallbacks
              );
            } catch (error) {
              captureCommitPhaseError(finishedWork, finishedWork.return, error);
            }
          }
          flags & 4 &&
            null != finishedWork.stateNode &&
            ((existingHiddenCallbacks = finishedWork.memoizedProps),
            commitHostUpdate(
              finishedWork,
              existingHiddenCallbacks,
              null !== current ? current.memoizedProps : existingHiddenCallbacks
            ));
          flags & 1024 &&
            ((needsFormReset = !0),
            "form" !== finishedWork.type &&
              console.error(
                "Unexpected host component type. Expected a form. This is a bug in React."
              ));
          break;
        case 6:
          recursivelyTraverseMutationEffects(root, finishedWork);
          commitReconciliationEffects(finishedWork);
          if (flags & 4) {
            if (null === finishedWork.stateNode)
              throw Error(
                "This should have a text node initialized. This error is likely caused by a bug in React. Please file an issue."
              );
            flags = finishedWork.memoizedProps;
            current = null !== current ? current.memoizedProps : flags;
            existingHiddenCallbacks = finishedWork.stateNode;
            try {
              runWithFiberInDEV(
                finishedWork,
                commitTextUpdate,
                existingHiddenCallbacks,
                current,
                flags
              );
            } catch (error) {
              captureCommitPhaseError(finishedWork, finishedWork.return, error);
            }
          }
          break;
        case 3:
          existingHiddenCallbacks = pushNestedEffectDurations();
          tagCaches = null;
          currentResource = currentHoistableRoot;
          currentHoistableRoot = getHoistableRoot(root.containerInfo);
          recursivelyTraverseMutationEffects(root, finishedWork);
          currentHoistableRoot = currentResource;
          commitReconciliationEffects(finishedWork);
          if (
            flags & 4 &&
            null !== current &&
            current.memoizedState.isDehydrated
          )
            try {
              runWithFiberInDEV(
                finishedWork,
                commitHydratedContainer,
                root.containerInfo
              );
            } catch (error) {
              captureCommitPhaseError(finishedWork, finishedWork.return, error);
            }
          needsFormReset &&
            ((needsFormReset = !1), recursivelyResetForms(finishedWork));
          root.effectDuration += popNestedEffectDurations(
            existingHiddenCallbacks
          );
          break;
        case 4:
          flags = currentHoistableRoot;
          currentHoistableRoot = getHoistableRoot(
            finishedWork.stateNode.containerInfo
          );
          recursivelyTraverseMutationEffects(root, finishedWork);
          commitReconciliationEffects(finishedWork);
          currentHoistableRoot = flags;
          break;
        case 12:
          flags = pushNestedEffectDurations();
          recursivelyTraverseMutationEffects(root, finishedWork);
          commitReconciliationEffects(finishedWork);
          finishedWork.stateNode.effectDuration +=
            bubbleNestedEffectDurations(flags);
          break;
        case 31:
          recursivelyTraverseMutationEffects(root, finishedWork);
          commitReconciliationEffects(finishedWork);
          flags & 4 &&
            ((flags = finishedWork.updateQueue),
            null !== flags &&
              ((finishedWork.updateQueue = null),
              attachSuspenseRetryListeners(finishedWork, flags)));
          break;
        case 13:
          recursivelyTraverseMutationEffects(root, finishedWork);
          commitReconciliationEffects(finishedWork);
          finishedWork.child.flags & 8192 &&
            (null !== finishedWork.memoizedState) !==
              (null !== current && null !== current.memoizedState) &&
            (globalMostRecentFallbackTime = now$1());
          flags & 4 &&
            ((flags = finishedWork.updateQueue),
            null !== flags &&
              ((finishedWork.updateQueue = null),
              attachSuspenseRetryListeners(finishedWork, flags)));
          break;
        case 22:
          existingHiddenCallbacks = null !== finishedWork.memoizedState;
          var wasHidden = null !== current && null !== current.memoizedState,
            prevOffscreenSubtreeIsHidden = offscreenSubtreeIsHidden,
            prevOffscreenSubtreeWasHidden = offscreenSubtreeWasHidden;
          offscreenSubtreeIsHidden =
            prevOffscreenSubtreeIsHidden || existingHiddenCallbacks;
          offscreenSubtreeWasHidden =
            prevOffscreenSubtreeWasHidden || wasHidden;
          recursivelyTraverseMutationEffects(root, finishedWork);
          offscreenSubtreeWasHidden = prevOffscreenSubtreeWasHidden;
          offscreenSubtreeIsHidden = prevOffscreenSubtreeIsHidden;
          wasHidden &&
            !existingHiddenCallbacks &&
            !prevOffscreenSubtreeIsHidden &&
            !prevOffscreenSubtreeWasHidden &&
            (finishedWork.mode & ProfileMode) !== NoMode &&
            0 <= componentEffectStartTime &&
            0 <= componentEffectEndTime &&
            0.05 < componentEffectEndTime - componentEffectStartTime &&
            logComponentReappeared(
              finishedWork,
              componentEffectStartTime,
              componentEffectEndTime
            );
          commitReconciliationEffects(finishedWork);
          if (flags & 8192)
            a: for (
              root = finishedWork.stateNode,
                root._visibility = existingHiddenCallbacks
                  ? root._visibility & ~OffscreenVisible
                  : root._visibility | OffscreenVisible,
                !existingHiddenCallbacks ||
                  null === current ||
                  wasHidden ||
                  offscreenSubtreeIsHidden ||
                  offscreenSubtreeWasHidden ||
                  (recursivelyTraverseDisappearLayoutEffects(finishedWork),
                  (finishedWork.mode & ProfileMode) !== NoMode &&
                    0 <= componentEffectStartTime &&
                    0 <= componentEffectEndTime &&
                    0.05 < componentEffectEndTime - componentEffectStartTime &&
                    logComponentTrigger(
                      finishedWork,
                      componentEffectStartTime,
                      componentEffectEndTime,
                      "Disconnect"
                    )),
                current = null,
                root = finishedWork;
              ;

            ) {
              if (5 === root.tag || 26 === root.tag) {
                if (null === current) {
                  wasHidden = current = root;
                  try {
                    (currentResource = wasHidden.stateNode),
                      existingHiddenCallbacks
                        ? runWithFiberInDEV(
                            wasHidden,
                            hideInstance,
                            currentResource
                          )
                        : runWithFiberInDEV(
                            wasHidden,
                            unhideInstance,
                            wasHidden.stateNode,
                            wasHidden.memoizedProps
                          );
                  } catch (error) {
                    captureCommitPhaseError(wasHidden, wasHidden.return, error);
                  }
                }
              } else if (6 === root.tag) {
                if (null === current) {
                  wasHidden = root;
                  try {
                    (maybeNodes = wasHidden.stateNode),
                      existingHiddenCallbacks
                        ? runWithFiberInDEV(
                            wasHidden,
                            hideTextInstance,
                            maybeNodes
                          )
                        : runWithFiberInDEV(
                            wasHidden,
                            unhideTextInstance,
                            maybeNodes,
                            wasHidden.memoizedProps
                          );
                  } catch (error) {
                    captureCommitPhaseError(wasHidden, wasHidden.return, error);
                  }
                }
              } else if (18 === root.tag) {
                if (null === current) {
                  wasHidden = root;
                  try {
                    (i = wasHidden.stateNode),
                      existingHiddenCallbacks
                        ? runWithFiberInDEV(
                            wasHidden,
                            hideDehydratedBoundary,
                            i
                          )
                        : runWithFiberInDEV(
                            wasHidden,
                            unhideDehydratedBoundary,
                            wasHidden.stateNode
                          );
                  } catch (error) {
                    captureCommitPhaseError(wasHidden, wasHidden.return, error);
                  }
                }
              } else if (
                ((22 !== root.tag && 23 !== root.tag) ||
                  null === root.memoizedState ||
                  root === finishedWork) &&
                null !== root.child
              ) {
                root.child.return = root;
                root = root.child;
                continue;
              }
              if (root === finishedWork) break a;
              for (; null === root.sibling; ) {
                if (null === root.return || root.return === finishedWork)
                  break a;
                current === root && (current = null);
                root = root.return;
              }
              current === root && (current = null);
              root.sibling.return = root.return;
              root = root.sibling;
            }
          flags & 4 &&
            ((flags = finishedWork.updateQueue),
            null !== flags &&
              ((current = flags.retryQueue),
              null !== current &&
                ((flags.retryQueue = null),
                attachSuspenseRetryListeners(finishedWork, current))));
          break;
        case 19:
          recursivelyTraverseMutationEffects(root, finishedWork);
          commitReconciliationEffects(finishedWork);
          flags & 4 &&
            ((flags = finishedWork.updateQueue),
            null !== flags &&
              ((finishedWork.updateQueue = null),
              attachSuspenseRetryListeners(finishedWork, flags)));
          break;
        case 30:
          break;
        case 21:
          break;
        default:
          recursivelyTraverseMutationEffects(root, finishedWork),
            commitReconciliationEffects(finishedWork);
      }
      (finishedWork.mode & ProfileMode) !== NoMode &&
        0 <= componentEffectStartTime &&
        0 <= componentEffectEndTime &&
        ((componentEffectSpawnedUpdate || 0.05 < componentEffectDuration) &&
          logComponentEffect(
            finishedWork,
            componentEffectStartTime,
            componentEffectEndTime,
            componentEffectDuration,
            componentEffectErrors
          ),
        null === finishedWork.alternate &&
          null !== finishedWork.return &&
          null !== finishedWork.return.alternate &&
          0.05 < componentEffectEndTime - componentEffectStartTime &&
          (isHydratingParent(
            finishedWork.return.alternate,
            finishedWork.return
          ) ||
            logComponentTrigger(
              finishedWork,
              componentEffectStartTime,
              componentEffectEndTime,
              "Mount"
            )));
      popComponentEffectStart(prevEffectStart);
      popComponentEffectDuration(prevEffectDuration);
      componentEffectErrors = prevEffectErrors;
      componentEffectSpawnedUpdate = prevEffectDidSpawnUpdate;
    }
    function commitReconciliationEffects(finishedWork) {
      var flags = finishedWork.flags;
      if (flags & 2) {
        try {
          runWithFiberInDEV(finishedWork, commitPlacement, finishedWork);
        } catch (error) {
          captureCommitPhaseError(finishedWork, finishedWork.return, error);
        }
        finishedWork.flags &= -3;
      }
      flags & 4096 && (finishedWork.flags &= -4097);
    }
    function recursivelyResetForms(parentFiber) {
      if (parentFiber.subtreeFlags & 1024)
        for (parentFiber = parentFiber.child; null !== parentFiber; ) {
          var fiber = parentFiber;
          recursivelyResetForms(fiber);
          5 === fiber.tag && fiber.flags & 1024 && fiber.stateNode.reset();
          parentFiber = parentFiber.sibling;
        }
    }
    function recursivelyTraverseLayoutEffects(root, parentFiber) {
      if (parentFiber.subtreeFlags & 8772)
        for (parentFiber = parentFiber.child; null !== parentFiber; )
          commitLayoutEffectOnFiber(root, parentFiber.alternate, parentFiber),
            (parentFiber = parentFiber.sibling);
    }
    function disappearLayoutEffects(finishedWork) {
      var prevEffectStart = pushComponentEffectStart(),
        prevEffectDuration = pushComponentEffectDuration(),
        prevEffectErrors = pushComponentEffectErrors(),
        prevEffectDidSpawnUpdate = pushComponentEffectDidSpawnUpdate();
      switch (finishedWork.tag) {
        case 0:
        case 11:
        case 14:
        case 15:
          commitHookLayoutUnmountEffects(
            finishedWork,
            finishedWork.return,
            Layout
          );
          recursivelyTraverseDisappearLayoutEffects(finishedWork);
          break;
        case 1:
          safelyDetachRef(finishedWork, finishedWork.return);
          var instance = finishedWork.stateNode;
          "function" === typeof instance.componentWillUnmount &&
            safelyCallComponentWillUnmount(
              finishedWork,
              finishedWork.return,
              instance
            );
          recursivelyTraverseDisappearLayoutEffects(finishedWork);
          break;
        case 27:
          runWithFiberInDEV(
            finishedWork,
            releaseSingletonInstance,
            finishedWork.stateNode
          );
        case 26:
        case 5:
          safelyDetachRef(finishedWork, finishedWork.return);
          recursivelyTraverseDisappearLayoutEffects(finishedWork);
          break;
        case 22:
          null === finishedWork.memoizedState &&
            recursivelyTraverseDisappearLayoutEffects(finishedWork);
          break;
        case 30:
          recursivelyTraverseDisappearLayoutEffects(finishedWork);
          break;
        default:
          recursivelyTraverseDisappearLayoutEffects(finishedWork);
      }
      (finishedWork.mode & ProfileMode) !== NoMode &&
        0 <= componentEffectStartTime &&
        0 <= componentEffectEndTime &&
        (componentEffectSpawnedUpdate || 0.05 < componentEffectDuration) &&
        logComponentEffect(
          finishedWork,
          componentEffectStartTime,
          componentEffectEndTime,
          componentEffectDuration,
          componentEffectErrors
        );
      popComponentEffectStart(prevEffectStart);
      popComponentEffectDuration(prevEffectDuration);
      componentEffectErrors = prevEffectErrors;
      componentEffectSpawnedUpdate = prevEffectDidSpawnUpdate;
    }
    function recursivelyTraverseDisappearLayoutEffects(parentFiber) {
      for (parentFiber = parentFiber.child; null !== parentFiber; )
        disappearLayoutEffects(parentFiber),
          (parentFiber = parentFiber.sibling);
    }
    function reappearLayoutEffects(
      finishedRoot,
      current,
      finishedWork,
      includeWorkInProgressEffects
    ) {
      var prevEffectStart = pushComponentEffectStart(),
        prevEffectDuration = pushComponentEffectDuration(),
        prevEffectErrors = pushComponentEffectErrors(),
        prevEffectDidSpawnUpdate = pushComponentEffectDidSpawnUpdate(),
        flags = finishedWork.flags;
      switch (finishedWork.tag) {
        case 0:
        case 11:
        case 15:
          recursivelyTraverseReappearLayoutEffects(
            finishedRoot,
            finishedWork,
            includeWorkInProgressEffects
          );
          commitHookLayoutEffects(finishedWork, Layout);
          break;
        case 1:
          recursivelyTraverseReappearLayoutEffects(
            finishedRoot,
            finishedWork,
            includeWorkInProgressEffects
          );
          current = finishedWork.stateNode;
          "function" === typeof current.componentDidMount &&
            runWithFiberInDEV(
              finishedWork,
              callComponentDidMountInDEV,
              finishedWork,
              current
            );
          current = finishedWork.updateQueue;
          if (null !== current) {
            finishedRoot = finishedWork.stateNode;
            try {
              runWithFiberInDEV(
                finishedWork,
                commitHiddenCallbacks,
                current,
                finishedRoot
              );
            } catch (error) {
              captureCommitPhaseError(finishedWork, finishedWork.return, error);
            }
          }
          includeWorkInProgressEffects &&
            flags & 64 &&
            commitClassCallbacks(finishedWork);
          safelyAttachRef(finishedWork, finishedWork.return);
          break;
        case 27:
          commitHostSingletonAcquisition(finishedWork);
        case 26:
        case 5:
          recursivelyTraverseReappearLayoutEffects(
            finishedRoot,
            finishedWork,
            includeWorkInProgressEffects
          );
          includeWorkInProgressEffects &&
            null === current &&
            flags & 4 &&
            commitHostMount(finishedWork);
          safelyAttachRef(finishedWork, finishedWork.return);
          break;
        case 12:
          if (includeWorkInProgressEffects && flags & 4) {
            flags = pushNestedEffectDurations();
            recursivelyTraverseReappearLayoutEffects(
              finishedRoot,
              finishedWork,
              includeWorkInProgressEffects
            );
            includeWorkInProgressEffects = finishedWork.stateNode;
            includeWorkInProgressEffects.effectDuration +=
              bubbleNestedEffectDurations(flags);
            try {
              runWithFiberInDEV(
                finishedWork,
                commitProfiler,
                finishedWork,
                current,
                commitStartTime,
                includeWorkInProgressEffects.effectDuration
              );
            } catch (error) {
              captureCommitPhaseError(finishedWork, finishedWork.return, error);
            }
          } else
            recursivelyTraverseReappearLayoutEffects(
              finishedRoot,
              finishedWork,
              includeWorkInProgressEffects
            );
          break;
        case 31:
          recursivelyTraverseReappearLayoutEffects(
            finishedRoot,
            finishedWork,
            includeWorkInProgressEffects
          );
          includeWorkInProgressEffects &&
            flags & 4 &&
            commitActivityHydrationCallbacks(finishedRoot, finishedWork);
          break;
        case 13:
          recursivelyTraverseReappearLayoutEffects(
            finishedRoot,
            finishedWork,
            includeWorkInProgressEffects
          );
          includeWorkInProgressEffects &&
            flags & 4 &&
            commitSuspenseHydrationCallbacks(finishedRoot, finishedWork);
          break;
        case 22:
          null === finishedWork.memoizedState &&
            recursivelyTraverseReappearLayoutEffects(
              finishedRoot,
              finishedWork,
              includeWorkInProgressEffects
            );
          safelyAttachRef(finishedWork, finishedWork.return);
          break;
        case 30:
          break;
        default:
          recursivelyTraverseReappearLayoutEffects(
            finishedRoot,
            finishedWork,
            includeWorkInProgressEffects
          );
      }
      (finishedWork.mode & ProfileMode) !== NoMode &&
        0 <= componentEffectStartTime &&
        0 <= componentEffectEndTime &&
        (componentEffectSpawnedUpdate || 0.05 < componentEffectDuration) &&
        logComponentEffect(
          finishedWork,
          componentEffectStartTime,
          componentEffectEndTime,
          componentEffectDuration,
          componentEffectErrors
        );
      popComponentEffectStart(prevEffectStart);
      popComponentEffectDuration(prevEffectDuration);
      componentEffectErrors = prevEffectErrors;
      componentEffectSpawnedUpdate = prevEffectDidSpawnUpdate;
    }
    function recursivelyTraverseReappearLayoutEffects(
      finishedRoot,
      parentFiber,
      includeWorkInProgressEffects
    ) {
      includeWorkInProgressEffects =
        includeWorkInProgressEffects && 0 !== (parentFiber.subtreeFlags & 8772);
      for (parentFiber = parentFiber.child; null !== parentFiber; )
        reappearLayoutEffects(
          finishedRoot,
          parentFiber.alternate,
          parentFiber,
          includeWorkInProgressEffects
        ),
          (parentFiber = parentFiber.sibling);
    }
    function commitOffscreenPassiveMountEffects(current, finishedWork) {
      var previousCache = null;
      null !== current &&
        null !== current.memoizedState &&
        null !== current.memoizedState.cachePool &&
        (previousCache = current.memoizedState.cachePool.pool);
      current = null;
      null !== finishedWork.memoizedState &&
        null !== finishedWork.memoizedState.cachePool &&
        (current = finishedWork.memoizedState.cachePool.pool);
      current !== previousCache &&
        (null != current && retainCache(current),
        null != previousCache && releaseCache(previousCache));
    }
    function commitCachePassiveMountEffect(current, finishedWork) {
      current = null;
      null !== finishedWork.alternate &&
        (current = finishedWork.alternate.memoizedState.cache);
      finishedWork = finishedWork.memoizedState.cache;
      finishedWork !== current &&
        (retainCache(finishedWork), null != current && releaseCache(current));
    }
    function recursivelyTraversePassiveMountEffects(
      root,
      parentFiber,
      committedLanes,
      committedTransitions,
      endTime
    ) {
      if (
        parentFiber.subtreeFlags & 10256 ||
        (0 !== parentFiber.actualDuration &&
          (null === parentFiber.alternate ||
            parentFiber.alternate.child !== parentFiber.child))
      )
        for (parentFiber = parentFiber.child; null !== parentFiber; ) {
          var nextSibling = parentFiber.sibling;
          commitPassiveMountOnFiber(
            root,
            parentFiber,
            committedLanes,
            committedTransitions,
            null !== nextSibling ? nextSibling.actualStartTime : endTime
          );
          parentFiber = nextSibling;
        }
    }
    function commitPassiveMountOnFiber(
      finishedRoot,
      finishedWork,
      committedLanes,
      committedTransitions,
      endTime
    ) {
      var prevEffectStart = pushComponentEffectStart(),
        prevEffectDuration = pushComponentEffectDuration(),
        prevEffectErrors = pushComponentEffectErrors(),
        prevEffectDidSpawnUpdate = pushComponentEffectDidSpawnUpdate(),
        prevDeepEquality = alreadyWarnedForDeepEquality,
        flags = finishedWork.flags;
      switch (finishedWork.tag) {
        case 0:
        case 11:
        case 15:
          (finishedWork.mode & ProfileMode) !== NoMode &&
            0 < finishedWork.actualStartTime &&
            0 !== (finishedWork.flags & 1) &&
            logComponentRender(
              finishedWork,
              finishedWork.actualStartTime,
              endTime,
              inHydratedSubtree,
              committedLanes
            );
          recursivelyTraversePassiveMountEffects(
            finishedRoot,
            finishedWork,
            committedLanes,
            committedTransitions,
            endTime
          );
          flags & 2048 &&
            commitHookPassiveMountEffects(finishedWork, Passive | HasEffect);
          break;
        case 1:
          (finishedWork.mode & ProfileMode) !== NoMode &&
            0 < finishedWork.actualStartTime &&
            (0 !== (finishedWork.flags & 128)
              ? logComponentErrored(
                  finishedWork,
                  finishedWork.actualStartTime,
                  endTime,
                  []
                )
              : 0 !== (finishedWork.flags & 1) &&
                logComponentRender(
                  finishedWork,
                  finishedWork.actualStartTime,
                  endTime,
                  inHydratedSubtree,
                  committedLanes
                ));
          recursivelyTraversePassiveMountEffects(
            finishedRoot,
            finishedWork,
            committedLanes,
            committedTransitions,
            endTime
          );
          break;
        case 3:
          var prevProfilerEffectDuration = pushNestedEffectDurations(),
            wasInHydratedSubtree = inHydratedSubtree;
          inHydratedSubtree =
            null !== finishedWork.alternate &&
            finishedWork.alternate.memoizedState.isDehydrated &&
            0 === (finishedWork.flags & 256);
          recursivelyTraversePassiveMountEffects(
            finishedRoot,
            finishedWork,
            committedLanes,
            committedTransitions,
            endTime
          );
          inHydratedSubtree = wasInHydratedSubtree;
          flags & 2048 &&
            ((committedLanes = null),
            null !== finishedWork.alternate &&
              (committedLanes = finishedWork.alternate.memoizedState.cache),
            (committedTransitions = finishedWork.memoizedState.cache),
            committedTransitions !== committedLanes &&
              (retainCache(committedTransitions),
              null != committedLanes && releaseCache(committedLanes)));
          finishedRoot.passiveEffectDuration += popNestedEffectDurations(
            prevProfilerEffectDuration
          );
          break;
        case 12:
          if (flags & 2048) {
            flags = pushNestedEffectDurations();
            recursivelyTraversePassiveMountEffects(
              finishedRoot,
              finishedWork,
              committedLanes,
              committedTransitions,
              endTime
            );
            finishedRoot = finishedWork.stateNode;
            finishedRoot.passiveEffectDuration +=
              bubbleNestedEffectDurations(flags);
            try {
              runWithFiberInDEV(
                finishedWork,
                commitProfilerPostCommitImpl,
                finishedWork,
                finishedWork.alternate,
                commitStartTime,
                finishedRoot.passiveEffectDuration
              );
            } catch (error) {
              captureCommitPhaseError(finishedWork, finishedWork.return, error);
            }
          } else
            recursivelyTraversePassiveMountEffects(
              finishedRoot,
              finishedWork,
              committedLanes,
              committedTransitions,
              endTime
            );
          break;
        case 31:
          flags = inHydratedSubtree;
          prevProfilerEffectDuration =
            null !== finishedWork.alternate
              ? finishedWork.alternate.memoizedState
              : null;
          wasInHydratedSubtree = finishedWork.memoizedState;
          null !== prevProfilerEffectDuration && null === wasInHydratedSubtree
            ? ((wasInHydratedSubtree = finishedWork.deletions),
              null !== wasInHydratedSubtree &&
              0 < wasInHydratedSubtree.length &&
              18 === wasInHydratedSubtree[0].tag
                ? ((inHydratedSubtree = !1),
                  (prevProfilerEffectDuration =
                    prevProfilerEffectDuration.hydrationErrors),
                  null !== prevProfilerEffectDuration &&
                    logComponentErrored(
                      finishedWork,
                      finishedWork.actualStartTime,
                      endTime,
                      prevProfilerEffectDuration
                    ))
                : (inHydratedSubtree = !0))
            : (inHydratedSubtree = !1);
          recursivelyTraversePassiveMountEffects(
            finishedRoot,
            finishedWork,
            committedLanes,
            committedTransitions,
            endTime
          );
          inHydratedSubtree = flags;
          break;
        case 13:
          flags = inHydratedSubtree;
          prevProfilerEffectDuration =
            null !== finishedWork.alternate
              ? finishedWork.alternate.memoizedState
              : null;
          wasInHydratedSubtree = finishedWork.memoizedState;
          null === prevProfilerEffectDuration ||
          null === prevProfilerEffectDuration.dehydrated ||
          (null !== wasInHydratedSubtree &&
            null !== wasInHydratedSubtree.dehydrated)
            ? (inHydratedSubtree = !1)
            : ((wasInHydratedSubtree = finishedWork.deletions),
              null !== wasInHydratedSubtree &&
              0 < wasInHydratedSubtree.length &&
              18 === wasInHydratedSubtree[0].tag
                ? ((inHydratedSubtree = !1),
                  (prevProfilerEffectDuration =
                    prevProfilerEffectDuration.hydrationErrors),
                  null !== prevProfilerEffectDuration &&
                    logComponentErrored(
                      finishedWork,
                      finishedWork.actualStartTime,
                      endTime,
                      prevProfilerEffectDuration
                    ))
                : (inHydratedSubtree = !0));
          recursivelyTraversePassiveMountEffects(
            finishedRoot,
            finishedWork,
            committedLanes,
            committedTransitions,
            endTime
          );
          inHydratedSubtree = flags;
          break;
        case 23:
          break;
        case 22:
          wasInHydratedSubtree = finishedWork.stateNode;
          prevProfilerEffectDuration = finishedWork.alternate;
          null !== finishedWork.memoizedState
            ? wasInHydratedSubtree._visibility &
              OffscreenPassiveEffectsConnected
              ? recursivelyTraversePassiveMountEffects(
                  finishedRoot,
                  finishedWork,
                  committedLanes,
                  committedTransitions,
                  endTime
                )
              : recursivelyTraverseAtomicPassiveEffects(
                  finishedRoot,
                  finishedWork,
                  committedLanes,
                  committedTransitions,
                  endTime
                )
            : wasInHydratedSubtree._visibility &
                OffscreenPassiveEffectsConnected
              ? recursivelyTraversePassiveMountEffects(
                  finishedRoot,
                  finishedWork,
                  committedLanes,
                  committedTransitions,
                  endTime
                )
              : ((wasInHydratedSubtree._visibility |=
                  OffscreenPassiveEffectsConnected),
                recursivelyTraverseReconnectPassiveEffects(
                  finishedRoot,
                  finishedWork,
                  committedLanes,
                  committedTransitions,
                  0 !== (finishedWork.subtreeFlags & 10256) ||
                    (0 !== finishedWork.actualDuration &&
                      (null === finishedWork.alternate ||
                        finishedWork.alternate.child !== finishedWork.child)),
                  endTime
                ),
                (finishedWork.mode & ProfileMode) === NoMode ||
                  inHydratedSubtree ||
                  ((finishedRoot = finishedWork.actualStartTime),
                  0 <= finishedRoot &&
                    0.05 < endTime - finishedRoot &&
                    logComponentReappeared(finishedWork, finishedRoot, endTime),
                  0 <= componentEffectStartTime &&
                    0 <= componentEffectEndTime &&
                    0.05 < componentEffectEndTime - componentEffectStartTime &&
                    logComponentReappeared(
                      finishedWork,
                      componentEffectStartTime,
                      componentEffectEndTime
                    )));
          flags & 2048 &&
            commitOffscreenPassiveMountEffects(
              prevProfilerEffectDuration,
              finishedWork
            );
          break;
        case 24:
          recursivelyTraversePassiveMountEffects(
            finishedRoot,
            finishedWork,
            committedLanes,
            committedTransitions,
            endTime
          );
          flags & 2048 &&
            commitCachePassiveMountEffect(finishedWork.alternate, finishedWork);
          break;
        default:
          recursivelyTraversePassiveMountEffects(
            finishedRoot,
            finishedWork,
            committedLanes,
            committedTransitions,
            endTime
          );
      }
      if ((finishedWork.mode & ProfileMode) !== NoMode) {
        if (
          (finishedRoot =
            !inHydratedSubtree &&
            null === finishedWork.alternate &&
            null !== finishedWork.return &&
            null !== finishedWork.return.alternate)
        )
          (committedLanes = finishedWork.actualStartTime),
            0 <= committedLanes &&
              0.05 < endTime - committedLanes &&
              logComponentTrigger(
                finishedWork,
                committedLanes,
                endTime,
                "Mount"
              );
        0 <= componentEffectStartTime &&
          0 <= componentEffectEndTime &&
          ((componentEffectSpawnedUpdate || 0.05 < componentEffectDuration) &&
            logComponentEffect(
              finishedWork,
              componentEffectStartTime,
              componentEffectEndTime,
              componentEffectDuration,
              componentEffectErrors
            ),
          finishedRoot &&
            0.05 < componentEffectEndTime - componentEffectStartTime &&
            logComponentTrigger(
              finishedWork,
              componentEffectStartTime,
              componentEffectEndTime,
              "Mount"
            ));
      }
      popComponentEffectStart(prevEffectStart);
      popComponentEffectDuration(prevEffectDuration);
      componentEffectErrors = prevEffectErrors;
      componentEffectSpawnedUpdate = prevEffectDidSpawnUpdate;
      alreadyWarnedForDeepEquality = prevDeepEquality;
    }
    function recursivelyTraverseReconnectPassiveEffects(
      finishedRoot,
      parentFiber,
      committedLanes,
      committedTransitions,
      includeWorkInProgressEffects,
      endTime
    ) {
      includeWorkInProgressEffects =
        includeWorkInProgressEffects &&
        (0 !== (parentFiber.subtreeFlags & 10256) ||
          (0 !== parentFiber.actualDuration &&
            (null === parentFiber.alternate ||
              parentFiber.alternate.child !== parentFiber.child)));
      for (parentFiber = parentFiber.child; null !== parentFiber; ) {
        var nextSibling = parentFiber.sibling;
        reconnectPassiveEffects(
          finishedRoot,
          parentFiber,
          committedLanes,
          committedTransitions,
          includeWorkInProgressEffects,
          null !== nextSibling ? nextSibling.actualStartTime : endTime
        );
        parentFiber = nextSibling;
      }
    }
    function reconnectPassiveEffects(
      finishedRoot,
      finishedWork,
      committedLanes,
      committedTransitions,
      includeWorkInProgressEffects,
      endTime
    ) {
      var prevEffectStart = pushComponentEffectStart(),
        prevEffectDuration = pushComponentEffectDuration(),
        prevEffectErrors = pushComponentEffectErrors(),
        prevEffectDidSpawnUpdate = pushComponentEffectDidSpawnUpdate(),
        prevDeepEquality = alreadyWarnedForDeepEquality;
      includeWorkInProgressEffects &&
        (finishedWork.mode & ProfileMode) !== NoMode &&
        0 < finishedWork.actualStartTime &&
        0 !== (finishedWork.flags & 1) &&
        logComponentRender(
          finishedWork,
          finishedWork.actualStartTime,
          endTime,
          inHydratedSubtree,
          committedLanes
        );
      var flags = finishedWork.flags;
      switch (finishedWork.tag) {
        case 0:
        case 11:
        case 15:
          recursivelyTraverseReconnectPassiveEffects(
            finishedRoot,
            finishedWork,
            committedLanes,
            committedTransitions,
            includeWorkInProgressEffects,
            endTime
          );
          commitHookPassiveMountEffects(finishedWork, Passive);
          break;
        case 23:
          break;
        case 22:
          var _instance2 = finishedWork.stateNode;
          null !== finishedWork.memoizedState
            ? _instance2._visibility & OffscreenPassiveEffectsConnected
              ? recursivelyTraverseReconnectPassiveEffects(
                  finishedRoot,
                  finishedWork,
                  committedLanes,
                  committedTransitions,
                  includeWorkInProgressEffects,
                  endTime
                )
              : recursivelyTraverseAtomicPassiveEffects(
                  finishedRoot,
                  finishedWork,
                  committedLanes,
                  committedTransitions,
                  endTime
                )
            : ((_instance2._visibility |= OffscreenPassiveEffectsConnected),
              recursivelyTraverseReconnectPassiveEffects(
                finishedRoot,
                finishedWork,
                committedLanes,
                committedTransitions,
                includeWorkInProgressEffects,
                endTime
              ));
          includeWorkInProgressEffects &&
            flags & 2048 &&
            commitOffscreenPassiveMountEffects(
              finishedWork.alternate,
              finishedWork
            );
          break;
        case 24:
          recursivelyTraverseReconnectPassiveEffects(
            finishedRoot,
            finishedWork,
            committedLanes,
            committedTransitions,
            includeWorkInProgressEffects,
            endTime
          );
          includeWorkInProgressEffects &&
            flags & 2048 &&
            commitCachePassiveMountEffect(finishedWork.alternate, finishedWork);
          break;
        default:
          recursivelyTraverseReconnectPassiveEffects(
            finishedRoot,
            finishedWork,
            committedLanes,
            committedTransitions,
            includeWorkInProgressEffects,
            endTime
          );
      }
      (finishedWork.mode & ProfileMode) !== NoMode &&
        0 <= componentEffectStartTime &&
        0 <= componentEffectEndTime &&
        (componentEffectSpawnedUpdate || 0.05 < componentEffectDuration) &&
        logComponentEffect(
          finishedWork,
          componentEffectStartTime,
          componentEffectEndTime,
          componentEffectDuration,
          componentEffectErrors
        );
      popComponentEffectStart(prevEffectStart);
      popComponentEffectDuration(prevEffectDuration);
      componentEffectErrors = prevEffectErrors;
      componentEffectSpawnedUpdate = prevEffectDidSpawnUpdate;
      alreadyWarnedForDeepEquality = prevDeepEquality;
    }
    function recursivelyTraverseAtomicPassiveEffects(
      finishedRoot$jscomp$0,
      parentFiber,
      committedLanes$jscomp$0,
      committedTransitions$jscomp$0,
      endTime$jscomp$0
    ) {
      if (
        parentFiber.subtreeFlags & 10256 ||
        (0 !== parentFiber.actualDuration &&
          (null === parentFiber.alternate ||
            parentFiber.alternate.child !== parentFiber.child))
      )
        for (var child = parentFiber.child; null !== child; ) {
          parentFiber = child.sibling;
          var finishedRoot = finishedRoot$jscomp$0,
            committedLanes = committedLanes$jscomp$0,
            committedTransitions = committedTransitions$jscomp$0,
            endTime =
              null !== parentFiber
                ? parentFiber.actualStartTime
                : endTime$jscomp$0,
            prevDeepEquality = alreadyWarnedForDeepEquality;
          (child.mode & ProfileMode) !== NoMode &&
            0 < child.actualStartTime &&
            0 !== (child.flags & 1) &&
            logComponentRender(
              child,
              child.actualStartTime,
              endTime,
              inHydratedSubtree,
              committedLanes
            );
          var flags = child.flags;
          switch (child.tag) {
            case 22:
              recursivelyTraverseAtomicPassiveEffects(
                finishedRoot,
                child,
                committedLanes,
                committedTransitions,
                endTime
              );
              flags & 2048 &&
                commitOffscreenPassiveMountEffects(child.alternate, child);
              break;
            case 24:
              recursivelyTraverseAtomicPassiveEffects(
                finishedRoot,
                child,
                committedLanes,
                committedTransitions,
                endTime
              );
              flags & 2048 &&
                commitCachePassiveMountEffect(child.alternate, child);
              break;
            default:
              recursivelyTraverseAtomicPassiveEffects(
                finishedRoot,
                child,
                committedLanes,
                committedTransitions,
                endTime
              );
          }
          alreadyWarnedForDeepEquality = prevDeepEquality;
          child = parentFiber;
        }
    }
    function recursivelyAccumulateSuspenseyCommit(
      parentFiber,
      committedLanes,
      suspendedState
    ) {
      if (parentFiber.subtreeFlags & suspenseyCommitFlag)
        for (parentFiber = parentFiber.child; null !== parentFiber; )
          accumulateSuspenseyCommitOnFiber(
            parentFiber,
            committedLanes,
            suspendedState
          ),
            (parentFiber = parentFiber.sibling);
    }
    function accumulateSuspenseyCommitOnFiber(
      fiber,
      committedLanes,
      suspendedState
    ) {
      switch (fiber.tag) {
        case 26:
          recursivelyAccumulateSuspenseyCommit(
            fiber,
            committedLanes,
            suspendedState
          );
          fiber.flags & suspenseyCommitFlag &&
            null !== fiber.memoizedState &&
            suspendResource(
              suspendedState,
              currentHoistableRoot,
              fiber.memoizedState,
              fiber.memoizedProps
            );
          break;
        case 5:
          recursivelyAccumulateSuspenseyCommit(
            fiber,
            committedLanes,
            suspendedState
          );
          break;
        case 3:
        case 4:
          var previousHoistableRoot = currentHoistableRoot;
          currentHoistableRoot = getHoistableRoot(
            fiber.stateNode.containerInfo
          );
          recursivelyAccumulateSuspenseyCommit(
            fiber,
            committedLanes,
            suspendedState
          );
          currentHoistableRoot = previousHoistableRoot;
          break;
        case 22:
          null === fiber.memoizedState &&
            ((previousHoistableRoot = fiber.alternate),
            null !== previousHoistableRoot &&
            null !== previousHoistableRoot.memoizedState
              ? ((previousHoistableRoot = suspenseyCommitFlag),
                (suspenseyCommitFlag = 16777216),
                recursivelyAccumulateSuspenseyCommit(
                  fiber,
                  committedLanes,
                  suspendedState
                ),
                (suspenseyCommitFlag = previousHoistableRoot))
              : recursivelyAccumulateSuspenseyCommit(
                  fiber,
                  committedLanes,
                  suspendedState
                ));
          break;
        default:
          recursivelyAccumulateSuspenseyCommit(
            fiber,
            committedLanes,
            suspendedState
          );
      }
    }
    function detachAlternateSiblings(parentFiber) {
      var previousFiber = parentFiber.alternate;
      if (
        null !== previousFiber &&
        ((parentFiber = previousFiber.child), null !== parentFiber)
      ) {
        previousFiber.child = null;
        do
          (previousFiber = parentFiber.sibling),
            (parentFiber.sibling = null),
            (parentFiber = previousFiber);
        while (null !== parentFiber);
      }
    }
    function recursivelyTraversePassiveUnmountEffects(parentFiber) {
      var deletions = parentFiber.deletions;
      if (0 !== (parentFiber.flags & 16)) {
        if (null !== deletions)
          for (var i = 0; i < deletions.length; i++) {
            var childToDelete = deletions[i],
              prevEffectStart = pushComponentEffectStart();
            nextEffect = childToDelete;
            commitPassiveUnmountEffectsInsideOfDeletedTree_begin(
              childToDelete,
              parentFiber
            );
            (childToDelete.mode & ProfileMode) !== NoMode &&
              0 <= componentEffectStartTime &&
              0 <= componentEffectEndTime &&
              0.05 < componentEffectEndTime - componentEffectStartTime &&
              logComponentTrigger(
                childToDelete,
                componentEffectStartTime,
                componentEffectEndTime,
                "Unmount"
              );
            popComponentEffectStart(prevEffectStart);
          }
        detachAlternateSiblings(parentFiber);
      }
      if (parentFiber.subtreeFlags & 10256)
        for (parentFiber = parentFiber.child; null !== parentFiber; )
          commitPassiveUnmountOnFiber(parentFiber),
            (parentFiber = parentFiber.sibling);
    }
    function commitPassiveUnmountOnFiber(finishedWork) {
      var prevEffectStart = pushComponentEffectStart(),
        prevEffectDuration = pushComponentEffectDuration(),
        prevEffectErrors = pushComponentEffectErrors(),
        prevEffectDidSpawnUpdate = pushComponentEffectDidSpawnUpdate();
      switch (finishedWork.tag) {
        case 0:
        case 11:
        case 15:
          recursivelyTraversePassiveUnmountEffects(finishedWork);
          finishedWork.flags & 2048 &&
            commitHookPassiveUnmountEffects(
              finishedWork,
              finishedWork.return,
              Passive | HasEffect
            );
          break;
        case 3:
          var prevProfilerEffectDuration = pushNestedEffectDurations();
          recursivelyTraversePassiveUnmountEffects(finishedWork);
          finishedWork.stateNode.passiveEffectDuration +=
            popNestedEffectDurations(prevProfilerEffectDuration);
          break;
        case 12:
          prevProfilerEffectDuration = pushNestedEffectDurations();
          recursivelyTraversePassiveUnmountEffects(finishedWork);
          finishedWork.stateNode.passiveEffectDuration +=
            bubbleNestedEffectDurations(prevProfilerEffectDuration);
          break;
        case 22:
          prevProfilerEffectDuration = finishedWork.stateNode;
          null !== finishedWork.memoizedState &&
          prevProfilerEffectDuration._visibility &
            OffscreenPassiveEffectsConnected &&
          (null === finishedWork.return || 13 !== finishedWork.return.tag)
            ? ((prevProfilerEffectDuration._visibility &=
                ~OffscreenPassiveEffectsConnected),
              recursivelyTraverseDisconnectPassiveEffects(finishedWork),
              (finishedWork.mode & ProfileMode) !== NoMode &&
                0 <= componentEffectStartTime &&
                0 <= componentEffectEndTime &&
                0.05 < componentEffectEndTime - componentEffectStartTime &&
                logComponentTrigger(
                  finishedWork,
                  componentEffectStartTime,
                  componentEffectEndTime,
                  "Disconnect"
                ))
            : recursivelyTraversePassiveUnmountEffects(finishedWork);
          break;
        default:
          recursivelyTraversePassiveUnmountEffects(finishedWork);
      }
      (finishedWork.mode & ProfileMode) !== NoMode &&
        0 <= componentEffectStartTime &&
        0 <= componentEffectEndTime &&
        (componentEffectSpawnedUpdate || 0.05 < componentEffectDuration) &&
        logComponentEffect(
          finishedWork,
          componentEffectStartTime,
          componentEffectEndTime,
          componentEffectDuration,
          componentEffectErrors
        );
      popComponentEffectStart(prevEffectStart);
      popComponentEffectDuration(prevEffectDuration);
      componentEffectSpawnedUpdate = prevEffectDidSpawnUpdate;
      componentEffectErrors = prevEffectErrors;
    }
    function recursivelyTraverseDisconnectPassiveEffects(parentFiber) {
      var deletions = parentFiber.deletions;
      if (0 !== (parentFiber.flags & 16)) {
        if (null !== deletions)
          for (var i = 0; i < deletions.length; i++) {
            var childToDelete = deletions[i],
              prevEffectStart = pushComponentEffectStart();
            nextEffect = childToDelete;
            commitPassiveUnmountEffectsInsideOfDeletedTree_begin(
              childToDelete,
              parentFiber
            );
            (childToDelete.mode & ProfileMode) !== NoMode &&
              0 <= componentEffectStartTime &&
              0 <= componentEffectEndTime &&
              0.05 < componentEffectEndTime - componentEffectStartTime &&
              logComponentTrigger(
                childToDelete,
                componentEffectStartTime,
                componentEffectEndTime,
                "Unmount"
              );
            popComponentEffectStart(prevEffectStart);
          }
        detachAlternateSiblings(parentFiber);
      }
      for (parentFiber = parentFiber.child; null !== parentFiber; )
        disconnectPassiveEffect(parentFiber),
          (parentFiber = parentFiber.sibling);
    }
    function disconnectPassiveEffect(finishedWork) {
      var prevEffectStart = pushComponentEffectStart(),
        prevEffectDuration = pushComponentEffectDuration(),
        prevEffectErrors = pushComponentEffectErrors(),
        prevEffectDidSpawnUpdate = pushComponentEffectDidSpawnUpdate();
      switch (finishedWork.tag) {
        case 0:
        case 11:
        case 15:
          commitHookPassiveUnmountEffects(
            finishedWork,
            finishedWork.return,
            Passive
          );
          recursivelyTraverseDisconnectPassiveEffects(finishedWork);
          break;
        case 22:
          var instance = finishedWork.stateNode;
          instance._visibility & OffscreenPassiveEffectsConnected &&
            ((instance._visibility &= ~OffscreenPassiveEffectsConnected),
            recursivelyTraverseDisconnectPassiveEffects(finishedWork));
          break;
        default:
          recursivelyTraverseDisconnectPassiveEffects(finishedWork);
      }
      (finishedWork.mode & ProfileMode) !== NoMode &&
        0 <= componentEffectStartTime &&
        0 <= componentEffectEndTime &&
        (componentEffectSpawnedUpdate || 0.05 < componentEffectDuration) &&
        logComponentEffect(
          finishedWork,
          componentEffectStartTime,
          componentEffectEndTime,
          componentEffectDuration,
          componentEffectErrors
        );
      popComponentEffectStart(prevEffectStart);
      popComponentEffectDuration(prevEffectDuration);
      componentEffectSpawnedUpdate = prevEffectDidSpawnUpdate;
      componentEffectErrors = prevEffectErrors;
    }
    function commitPassiveUnmountEffectsInsideOfDeletedTree_begin(
      deletedSubtreeRoot,
      nearestMountedAncestor$jscomp$0
    ) {
      for (; null !== nextEffect; ) {
        var fiber = nextEffect,
          current = fiber,
          nearestMountedAncestor = nearestMountedAncestor$jscomp$0,
          prevEffectStart = pushComponentEffectStart(),
          prevEffectDuration = pushComponentEffectDuration(),
          prevEffectErrors = pushComponentEffectErrors(),
          prevEffectDidSpawnUpdate = pushComponentEffectDidSpawnUpdate();
        switch (current.tag) {
          case 0:
          case 11:
          case 15:
            commitHookPassiveUnmountEffects(
              current,
              nearestMountedAncestor,
              Passive
            );
            break;
          case 23:
          case 22:
            null !== current.memoizedState &&
              null !== current.memoizedState.cachePool &&
              ((nearestMountedAncestor = current.memoizedState.cachePool.pool),
              null != nearestMountedAncestor &&
                retainCache(nearestMountedAncestor));
            break;
          case 24:
            releaseCache(current.memoizedState.cache);
        }
        (current.mode & ProfileMode) !== NoMode &&
          0 <= componentEffectStartTime &&
          0 <= componentEffectEndTime &&
          (componentEffectSpawnedUpdate || 0.05 < componentEffectDuration) &&
          logComponentEffect(
            current,
            componentEffectStartTime,
            componentEffectEndTime,
            componentEffectDuration,
            componentEffectErrors
          );
        popComponentEffectStart(prevEffectStart);
        popComponentEffectDuration(prevEffectDuration);
        componentEffectSpawnedUpdate = prevEffectDidSpawnUpdate;
        componentEffectErrors = prevEffectErrors;
        current = fiber.child;
        if (null !== current) (current.return = fiber), (nextEffect = current);
        else
          a: for (fiber = deletedSubtreeRoot; null !== nextEffect; ) {
            current = nextEffect;
            prevEffectStart = current.sibling;
            prevEffectDuration = current.return;
            detachFiberAfterEffects(current);
            if (current === fiber) {
              nextEffect = null;
              break a;
            }
            if (null !== prevEffectStart) {
              prevEffectStart.return = prevEffectDuration;
              nextEffect = prevEffectStart;
              break a;
            }
            nextEffect = prevEffectDuration;
          }
      }
    }
    function onCommitRoot() {
      commitHooks.forEach(function (commitHook) {
        return commitHook();
      });
    }
    function isConcurrentActEnvironment() {
      var isReactActEnvironmentGlobal =
        "undefined" !== typeof IS_REACT_ACT_ENVIRONMENT
          ? IS_REACT_ACT_ENVIRONMENT
          : void 0;
      isReactActEnvironmentGlobal ||
        null === ReactSharedInternals.actQueue ||
        console.error(
          "The current testing environment is not configured to support act(...)"
        );
      return isReactActEnvironmentGlobal;
    }
    function requestUpdateLane(fiber) {
      if (
        (executionContext & RenderContext) !== NoContext &&
        0 !== workInProgressRootRenderLanes
      )
        return workInProgressRootRenderLanes & -workInProgressRootRenderLanes;
      var transition = ReactSharedInternals.T;
      return null !== transition
        ? (transition._updatedFibers || (transition._updatedFibers = new Set()),
          transition._updatedFibers.add(fiber),
          requestTransitionLane())
        : resolveUpdatePriority();
    }
    function requestDeferredLane() {
      if (0 === workInProgressDeferredLane)
        if (0 === (workInProgressRootRenderLanes & 536870912) || isHydrating) {
          var lane = nextTransitionDeferredLane;
          nextTransitionDeferredLane <<= 1;
          0 === (nextTransitionDeferredLane & 3932160) &&
            (nextTransitionDeferredLane = 262144);
          workInProgressDeferredLane = lane;
        } else workInProgressDeferredLane = 536870912;
      lane = suspenseHandlerStackCursor.current;
      null !== lane && (lane.flags |= 32);
      return workInProgressDeferredLane;
    }
    function scheduleUpdateOnFiber(root, fiber, lane) {
      isRunningInsertionEffect &&
        console.error("useInsertionEffect must not schedule updates.");
      isFlushingPassiveEffects && (didScheduleUpdateDuringPassiveEffects = !0);
      if (
        (root === workInProgressRoot &&
          (workInProgressSuspendedReason === SuspendedOnData ||
            workInProgressSuspendedReason === SuspendedOnAction)) ||
        null !== root.cancelPendingCommit
      )
        prepareFreshStack(root, 0),
          markRootSuspended(
            root,
            workInProgressRootRenderLanes,
            workInProgressDeferredLane,
            !1
          );
      markRootUpdated$1(root, lane);
      if (
        (executionContext & RenderContext) !== NoContext &&
        root === workInProgressRoot
      ) {
        if (isRendering)
          switch (fiber.tag) {
            case 0:
            case 11:
            case 15:
              root =
                (workInProgress && getComponentNameFromFiber(workInProgress)) ||
                "Unknown";
              didWarnAboutUpdateInRenderForAnotherComponent.has(root) ||
                (didWarnAboutUpdateInRenderForAnotherComponent.add(root),
                (fiber = getComponentNameFromFiber(fiber) || "Unknown"),
                console.error(
                  "Cannot update a component (`%s`) while rendering a different component (`%s`). To locate the bad setState() call inside `%s`, follow the stack trace as described in https://react.dev/link/setstate-in-render",
                  fiber,
                  root,
                  root
                ));
              break;
            case 1:
              didWarnAboutUpdateInRender ||
                (console.error(
                  "Cannot update during an existing state transition (such as within `render`). Render methods should be a pure function of props and state."
                ),
                (didWarnAboutUpdateInRender = !0));
          }
      } else
        isDevToolsPresent && addFiberToLanesMap(root, fiber, lane),
          warnIfUpdatesNotWrappedWithActDEV(fiber),
          root === workInProgressRoot &&
            ((executionContext & RenderContext) === NoContext &&
              (workInProgressRootInterleavedUpdatedLanes |= lane),
            workInProgressRootExitStatus === RootSuspendedWithDelay &&
              markRootSuspended(
                root,
                workInProgressRootRenderLanes,
                workInProgressDeferredLane,
                !1
              )),
          ensureRootIsScheduled(root);
    }
    function performWorkOnRoot(root, lanes, forceSync) {
      if ((executionContext & (RenderContext | CommitContext)) !== NoContext)
        throw Error("Should not already be working.");
      if (0 !== workInProgressRootRenderLanes && null !== workInProgress) {
        var yieldedFiber = workInProgress,
          yieldEndTime = now$1();
        switch (yieldReason) {
          case SuspendedOnImmediate:
          case SuspendedOnData:
            var startTime = yieldStartTime;
            supportsUserTiming &&
              ((yieldedFiber = yieldedFiber._debugTask)
                ? yieldedFiber.run(
                    console.timeStamp.bind(
                      console,
                      "Suspended",
                      startTime,
                      yieldEndTime,
                      COMPONENTS_TRACK,
                      void 0,
                      "primary-light"
                    )
                  )
                : console.timeStamp(
                    "Suspended",
                    startTime,
                    yieldEndTime,
                    COMPONENTS_TRACK,
                    void 0,
                    "primary-light"
                  ));
            break;
          case SuspendedOnAction:
            startTime = yieldStartTime;
            supportsUserTiming &&
              ((yieldedFiber = yieldedFiber._debugTask)
                ? yieldedFiber.run(
                    console.timeStamp.bind(
                      console,
                      "Action",
                      startTime,
                      yieldEndTime,
                      COMPONENTS_TRACK,
                      void 0,
                      "primary-light"
                    )
                  )
                : console.timeStamp(
                    "Action",
                    startTime,
                    yieldEndTime,
                    COMPONENTS_TRACK,
                    void 0,
                    "primary-light"
                  ));
            break;
          default:
            supportsUserTiming &&
              ((yieldedFiber = yieldEndTime - yieldStartTime),
              3 > yieldedFiber ||
                console.timeStamp(
                  "Blocked",
                  yieldStartTime,
                  yieldEndTime,
                  COMPONENTS_TRACK,
                  void 0,
                  5 > yieldedFiber
                    ? "primary-light"
                    : 10 > yieldedFiber
                      ? "primary"
                      : 100 > yieldedFiber
                        ? "primary-dark"
                        : "error"
                ));
        }
      }
      startTime = (forceSync =
        (!forceSync &&
          0 === (lanes & 127) &&
          0 === (lanes & root.expiredLanes)) ||
        checkIfRootIsPrerendering(root, lanes))
        ? renderRootConcurrent(root, lanes)
        : renderRootSync(root, lanes, !0);
      var renderWasConcurrent = forceSync;
      do {
        if (startTime === RootInProgress) {
          workInProgressRootIsPrerendering &&
            !forceSync &&
            markRootSuspended(root, lanes, 0, !1);
          lanes = workInProgressSuspendedReason;
          yieldStartTime = now();
          yieldReason = lanes;
          break;
        } else {
          yieldedFiber = now$1();
          yieldEndTime = root.current.alternate;
          if (
            renderWasConcurrent &&
            !isRenderConsistentWithExternalStores(yieldEndTime)
          ) {
            setCurrentTrackFromLanes(lanes);
            yieldEndTime = renderStartTime;
            startTime = yieldedFiber;
            !supportsUserTiming ||
              startTime <= yieldEndTime ||
              (workInProgressUpdateTask
                ? workInProgressUpdateTask.run(
                    console.timeStamp.bind(
                      console,
                      "Teared Render",
                      yieldEndTime,
                      startTime,
                      currentTrack,
                      LANES_TRACK_GROUP,
                      "error"
                    )
                  )
                : console.timeStamp(
                    "Teared Render",
                    yieldEndTime,
                    startTime,
                    currentTrack,
                    LANES_TRACK_GROUP,
                    "error"
                  ));
            finalizeRender(lanes, yieldedFiber);
            startTime = renderRootSync(root, lanes, !1);
            renderWasConcurrent = !1;
            continue;
          }
          if (startTime === RootErrored) {
            renderWasConcurrent = lanes;
            if (root.errorRecoveryDisabledLanes & renderWasConcurrent)
              var errorRetryLanes = 0;
            else
              (errorRetryLanes = root.pendingLanes & -536870913),
                (errorRetryLanes =
                  0 !== errorRetryLanes
                    ? errorRetryLanes
                    : errorRetryLanes & 536870912
                      ? 536870912
                      : 0);
            if (0 !== errorRetryLanes) {
              setCurrentTrackFromLanes(lanes);
              logErroredRenderPhase(
                renderStartTime,
                yieldedFiber,
                lanes,
                workInProgressUpdateTask
              );
              finalizeRender(lanes, yieldedFiber);
              lanes = errorRetryLanes;
              a: {
                yieldedFiber = root;
                startTime = renderWasConcurrent;
                renderWasConcurrent = workInProgressRootConcurrentErrors;
                var wasRootDehydrated =
                  yieldedFiber.current.memoizedState.isDehydrated;
                wasRootDehydrated &&
                  (prepareFreshStack(yieldedFiber, errorRetryLanes).flags |=
                    256);
                errorRetryLanes = renderRootSync(
                  yieldedFiber,
                  errorRetryLanes,
                  !1
                );
                if (errorRetryLanes !== RootErrored) {
                  if (
                    workInProgressRootDidAttachPingListener &&
                    !wasRootDehydrated
                  ) {
                    yieldedFiber.errorRecoveryDisabledLanes |= startTime;
                    workInProgressRootInterleavedUpdatedLanes |= startTime;
                    startTime = RootSuspendedWithDelay;
                    break a;
                  }
                  yieldedFiber = workInProgressRootRecoverableErrors;
                  workInProgressRootRecoverableErrors = renderWasConcurrent;
                  null !== yieldedFiber &&
                    (null === workInProgressRootRecoverableErrors
                      ? (workInProgressRootRecoverableErrors = yieldedFiber)
                      : workInProgressRootRecoverableErrors.push.apply(
                          workInProgressRootRecoverableErrors,
                          yieldedFiber
                        ));
                }
                startTime = errorRetryLanes;
              }
              renderWasConcurrent = !1;
              if (startTime !== RootErrored) continue;
              else yieldedFiber = now$1();
            }
          }
          if (startTime === RootFatalErrored) {
            setCurrentTrackFromLanes(lanes);
            logErroredRenderPhase(
              renderStartTime,
              yieldedFiber,
              lanes,
              workInProgressUpdateTask
            );
            finalizeRender(lanes, yieldedFiber);
            prepareFreshStack(root, 0);
            markRootSuspended(root, lanes, 0, !0);
            break;
          }
          a: {
            forceSync = root;
            switch (startTime) {
              case RootInProgress:
              case RootFatalErrored:
                throw Error("Root did not complete. This is a bug in React.");
              case RootSuspendedWithDelay:
                if ((lanes & 4194048) !== lanes) break;
              case RootSuspendedAtTheShell:
                setCurrentTrackFromLanes(lanes);
                logSuspendedRenderPhase(
                  renderStartTime,
                  yieldedFiber,
                  lanes,
                  workInProgressUpdateTask
                );
                finalizeRender(lanes, yieldedFiber);
                yieldEndTime = lanes;
                0 !== (yieldEndTime & 127)
                  ? (blockingSuspendedTime = yieldedFiber)
                  : 0 !== (yieldEndTime & 4194048) &&
                    (transitionSuspendedTime = yieldedFiber);
                markRootSuspended(
                  forceSync,
                  lanes,
                  workInProgressDeferredLane,
                  !workInProgressRootDidSkipSuspendedSiblings
                );
                break a;
              case RootErrored:
                workInProgressRootRecoverableErrors = null;
                break;
              case RootSuspended:
              case RootCompleted:
                break;
              default:
                throw Error("Unknown root exit status.");
            }
            if (null !== ReactSharedInternals.actQueue)
              commitRoot(
                forceSync,
                yieldEndTime,
                lanes,
                workInProgressRootRecoverableErrors,
                workInProgressTransitions,
                workInProgressRootDidIncludeRecursiveRenderUpdate,
                workInProgressDeferredLane,
                workInProgressRootInterleavedUpdatedLanes,
                workInProgressSuspendedRetryLanes,
                startTime,
                null,
                null,
                renderStartTime,
                yieldedFiber
              );
            else {
              if (
                (lanes & 62914560) === lanes &&
                ((renderWasConcurrent =
                  globalMostRecentFallbackTime +
                  FALLBACK_THROTTLE_MS -
                  now$1()),
                10 < renderWasConcurrent)
              ) {
                markRootSuspended(
                  forceSync,
                  lanes,
                  workInProgressDeferredLane,
                  !workInProgressRootDidSkipSuspendedSiblings
                );
                if (0 !== getNextLanes(forceSync, 0, !0)) break a;
                pendingEffectsLanes = lanes;
                forceSync.timeoutHandle = scheduleTimeout(
                  commitRootWhenReady.bind(
                    null,
                    forceSync,
                    yieldEndTime,
                    workInProgressRootRecoverableErrors,
                    workInProgressTransitions,
                    workInProgressRootDidIncludeRecursiveRenderUpdate,
                    lanes,
                    workInProgressDeferredLane,
                    workInProgressRootInterleavedUpdatedLanes,
                    workInProgressSuspendedRetryLanes,
                    workInProgressRootDidSkipSuspendedSiblings,
                    startTime,
                    "Throttled",
                    renderStartTime,
                    yieldedFiber
                  ),
                  renderWasConcurrent
                );
                break a;
              }
              commitRootWhenReady(
                forceSync,
                yieldEndTime,
                workInProgressRootRecoverableErrors,
                workInProgressTransitions,
                workInProgressRootDidIncludeRecursiveRenderUpdate,
                lanes,
                workInProgressDeferredLane,
                workInProgressRootInterleavedUpdatedLanes,
                workInProgressSuspendedRetryLanes,
                workInProgressRootDidSkipSuspendedSiblings,
                startTime,
                null,
                renderStartTime,
                yieldedFiber
              );
            }
          }
        }
        break;
      } while (1);
      ensureRootIsScheduled(root);
    }
    function commitRootWhenReady(
      root,
      finishedWork,
      recoverableErrors,
      transitions,
      didIncludeRenderPhaseUpdate,
      lanes,
      spawnedLane,
      updatedLanes,
      suspendedRetryLanes,
      didSkipSuspendedSiblings,
      exitStatus,
      suspendedCommitReason,
      completedRenderStartTime,
      completedRenderEndTime
    ) {
      root.timeoutHandle = noTimeout;
      var subtreeFlags = finishedWork.subtreeFlags,
        suspendedState = null;
      if (subtreeFlags & 8192 || 16785408 === (subtreeFlags & 16785408))
        if (
          ((suspendedState = {
            stylesheets: null,
            count: 0,
            imgCount: 0,
            imgBytes: 0,
            suspenseyImages: [],
            waitingForImages: !0,
            waitingForViewTransition: !1,
            unsuspend: noop$1
          }),
          accumulateSuspenseyCommitOnFiber(finishedWork, lanes, suspendedState),
          (subtreeFlags =
            (lanes & 62914560) === lanes
              ? globalMostRecentFallbackTime - now$1()
              : (lanes & 4194048) === lanes
                ? globalMostRecentTransitionTime - now$1()
                : 0),
          (subtreeFlags = waitForCommitToBeReady(suspendedState, subtreeFlags)),
          null !== subtreeFlags)
        ) {
          pendingEffectsLanes = lanes;
          root.cancelPendingCommit = subtreeFlags(
            commitRoot.bind(
              null,
              root,
              finishedWork,
              lanes,
              recoverableErrors,
              transitions,
              didIncludeRenderPhaseUpdate,
              spawnedLane,
              updatedLanes,
              suspendedRetryLanes,
              exitStatus,
              suspendedState,
              suspendedState.waitingForViewTransition
                ? "Waiting for the previous Animation"
                : 0 < suspendedState.count
                  ? 0 < suspendedState.imgCount
                    ? "Suspended on CSS and Images"
                    : "Suspended on CSS"
                  : 1 === suspendedState.imgCount
                    ? "Suspended on an Image"
                    : 0 < suspendedState.imgCount
                      ? "Suspended on Images"
                      : null,
              completedRenderStartTime,
              completedRenderEndTime
            )
          );
          markRootSuspended(
            root,
            lanes,
            spawnedLane,
            !didSkipSuspendedSiblings
          );
          return;
        }
      commitRoot(
        root,
        finishedWork,
        lanes,
        recoverableErrors,
        transitions,
        didIncludeRenderPhaseUpdate,
        spawnedLane,
        updatedLanes,
        suspendedRetryLanes,
        exitStatus,
        suspendedState,
        suspendedCommitReason,
        completedRenderStartTime,
        completedRenderEndTime
      );
    }
    function isRenderConsistentWithExternalStores(finishedWork) {
      for (var node = finishedWork; ; ) {
        var tag = node.tag;
        if (
          (0 === tag || 11 === tag || 15 === tag) &&
          node.flags & 16384 &&
          ((tag = node.updateQueue),
          null !== tag && ((tag = tag.stores), null !== tag))
        )
          for (var i = 0; i < tag.length; i++) {
            var check = tag[i],
              getSnapshot = check.getSnapshot;
            check = check.value;
            try {
              if (!objectIs(getSnapshot(), check)) return !1;
            } catch (error) {
              return !1;
            }
          }
        tag = node.child;
        if (node.subtreeFlags & 16384 && null !== tag)
          (tag.return = node), (node = tag);
        else {
          if (node === finishedWork) break;
          for (; null === node.sibling; ) {
            if (null === node.return || node.return === finishedWork) return !0;
            node = node.return;
          }
          node.sibling.return = node.return;
          node = node.sibling;
        }
      }
      return !0;
    }
    function markRootSuspended(
      root,
      suspendedLanes,
      spawnedLane,
      didAttemptEntireTree
    ) {
      suspendedLanes &= ~workInProgressRootPingedLanes;
      suspendedLanes &= ~workInProgressRootInterleavedUpdatedLanes;
      root.suspendedLanes |= suspendedLanes;
      root.pingedLanes &= ~suspendedLanes;
      didAttemptEntireTree && (root.warmLanes |= suspendedLanes);
      didAttemptEntireTree = root.expirationTimes;
      for (var lanes = suspendedLanes; 0 < lanes; ) {
        var index = 31 - clz32(lanes),
          lane = 1 << index;
        didAttemptEntireTree[index] = -1;
        lanes &= ~lane;
      }
      0 !== spawnedLane &&
        markSpawnedDeferredLane(root, spawnedLane, suspendedLanes);
    }
    function flushSyncWork$1() {
      return (executionContext & (RenderContext | CommitContext)) === NoContext
        ? (flushSyncWorkAcrossRoots_impl(0, !1), !1)
        : !0;
    }
    function resetWorkInProgressStack() {
      if (null !== workInProgress) {
        if (workInProgressSuspendedReason === NotSuspended)
          var interruptedWork = workInProgress.return;
        else
          (interruptedWork = workInProgress),
            resetContextDependencies(),
            resetHooksOnUnwind(interruptedWork),
            (thenableState$1 = null),
            (thenableIndexCounter$1 = 0),
            (interruptedWork = workInProgress);
        for (; null !== interruptedWork; )
          unwindInterruptedWork(interruptedWork.alternate, interruptedWork),
            (interruptedWork = interruptedWork.return);
        workInProgress = null;
      }
    }
    function finalizeRender(lanes, finalizationTime) {
      0 !== (lanes & 127) && (blockingClampTime = finalizationTime);
      0 !== (lanes & 4194048) && (transitionClampTime = finalizationTime);
      0 !== (lanes & 62914560) && (retryClampTime = finalizationTime);
      0 !== (lanes & 2080374784) && (idleClampTime = finalizationTime);
    }
    function prepareFreshStack(root, lanes) {
      supportsUserTiming &&
        (console.timeStamp(
          "Blocking Track",
          0.003,
          0.003,
          "Blocking",
          LANES_TRACK_GROUP,
          "primary-light"
        ),
        console.timeStamp(
          "Transition Track",
          0.003,
          0.003,
          "Transition",
          LANES_TRACK_GROUP,
          "primary-light"
        ),
        console.timeStamp(
          "Suspense Track",
          0.003,
          0.003,
          "Suspense",
          LANES_TRACK_GROUP,
          "primary-light"
        ),
        console.timeStamp(
          "Idle Track",
          0.003,
          0.003,
          "Idle",
          LANES_TRACK_GROUP,
          "primary-light"
        ));
      var previousRenderStartTime = renderStartTime;
      renderStartTime = now();
      if (0 !== workInProgressRootRenderLanes && 0 < previousRenderStartTime) {
        setCurrentTrackFromLanes(workInProgressRootRenderLanes);
        if (
          workInProgressRootExitStatus === RootSuspended ||
          workInProgressRootExitStatus === RootSuspendedWithDelay
        )
          logSuspendedRenderPhase(
            previousRenderStartTime,
            renderStartTime,
            lanes,
            workInProgressUpdateTask
          );
        else {
          var endTime = renderStartTime,
            debugTask = workInProgressUpdateTask;
          if (supportsUserTiming && !(endTime <= previousRenderStartTime)) {
            var color =
                (lanes & 738197653) === lanes
                  ? "tertiary-dark"
                  : "primary-dark",
              label =
                (lanes & 536870912) === lanes
                  ? "Prewarm"
                  : (lanes & 201326741) === lanes
                    ? "Interrupted Hydration"
                    : "Interrupted Render";
            debugTask
              ? debugTask.run(
                  console.timeStamp.bind(
                    console,
                    label,
                    previousRenderStartTime,
                    endTime,
                    currentTrack,
                    LANES_TRACK_GROUP,
                    color
                  )
                )
              : console.timeStamp(
                  label,
                  previousRenderStartTime,
                  endTime,
                  currentTrack,
                  LANES_TRACK_GROUP,
                  color
                );
          }
        }
        finalizeRender(workInProgressRootRenderLanes, renderStartTime);
      }
      previousRenderStartTime = workInProgressUpdateTask;
      workInProgressUpdateTask = null;
      if (0 !== (lanes & 127)) {
        workInProgressUpdateTask = blockingUpdateTask;
        debugTask =
          0 <= blockingUpdateTime && blockingUpdateTime < blockingClampTime
            ? blockingClampTime
            : blockingUpdateTime;
        endTime =
          0 <= blockingEventTime && blockingEventTime < blockingClampTime
            ? blockingClampTime
            : blockingEventTime;
        color =
          0 <= endTime ? endTime : 0 <= debugTask ? debugTask : renderStartTime;
        0 <= blockingSuspendedTime
          ? (setCurrentTrackFromLanes(2),
            logSuspendedWithDelayPhase(
              blockingSuspendedTime,
              color,
              lanes,
              previousRenderStartTime
            ))
          : 0 !== (animatingLanes & 127) &&
            (setCurrentTrackFromLanes(2),
            logAnimatingPhase(blockingClampTime, color, animatingTask));
        previousRenderStartTime = debugTask;
        var eventTime = endTime,
          eventType = blockingEventType,
          eventIsRepeat = 0 < blockingEventRepeatTime,
          isSpawnedUpdate = blockingUpdateType === SPAWNED_UPDATE,
          isPingedUpdate = blockingUpdateType === PINGED_UPDATE;
        debugTask = renderStartTime;
        endTime = blockingUpdateTask;
        color = blockingUpdateMethodName;
        label = blockingUpdateComponentName;
        if (supportsUserTiming) {
          currentTrack = "Blocking";
          0 < previousRenderStartTime
            ? previousRenderStartTime > debugTask &&
              (previousRenderStartTime = debugTask)
            : (previousRenderStartTime = debugTask);
          0 < eventTime
            ? eventTime > previousRenderStartTime &&
              (eventTime = previousRenderStartTime)
            : (eventTime = previousRenderStartTime);
          if (null !== eventType && previousRenderStartTime > eventTime) {
            var color$jscomp$0 = eventIsRepeat ? "secondary-light" : "warning";
            endTime
              ? endTime.run(
                  console.timeStamp.bind(
                    console,
                    eventIsRepeat ? "Consecutive" : "Event: " + eventType,
                    eventTime,
                    previousRenderStartTime,
                    currentTrack,
                    LANES_TRACK_GROUP,
                    color$jscomp$0
                  )
                )
              : console.timeStamp(
                  eventIsRepeat ? "Consecutive" : "Event: " + eventType,
                  eventTime,
                  previousRenderStartTime,
                  currentTrack,
                  LANES_TRACK_GROUP,
                  color$jscomp$0
                );
          }
          debugTask > previousRenderStartTime &&
            ((eventTime = isSpawnedUpdate
              ? "error"
              : (lanes & 738197653) === lanes
                ? "tertiary-light"
                : "primary-light"),
            (isSpawnedUpdate = isPingedUpdate
              ? "Promise Resolved"
              : isSpawnedUpdate
                ? "Cascading Update"
                : 5 < debugTask - previousRenderStartTime
                  ? "Update Blocked"
                  : "Update"),
            (isPingedUpdate = []),
            null != label && isPingedUpdate.push(["Component name", label]),
            null != color && isPingedUpdate.push(["Method name", color]),
            (previousRenderStartTime = {
              start: previousRenderStartTime,
              end: debugTask,
              detail: {
                devtools: {
                  properties: isPingedUpdate,
                  track: currentTrack,
                  trackGroup: LANES_TRACK_GROUP,
                  color: eventTime
                }
              }
            }),
            endTime
              ? endTime.run(
                  performance.measure.bind(
                    performance,
                    isSpawnedUpdate,
                    previousRenderStartTime
                  )
                )
              : performance.measure(isSpawnedUpdate, previousRenderStartTime));
        }
        blockingUpdateTime = -1.1;
        blockingUpdateType = 0;
        blockingUpdateComponentName = blockingUpdateMethodName = null;
        blockingSuspendedTime = -1.1;
        blockingEventRepeatTime = blockingEventTime;
        blockingEventTime = -1.1;
        blockingClampTime = now();
      }
      0 !== (lanes & 4194048) &&
        ((workInProgressUpdateTask = transitionUpdateTask),
        (debugTask =
          0 <= transitionStartTime && transitionStartTime < transitionClampTime
            ? transitionClampTime
            : transitionStartTime),
        (previousRenderStartTime =
          0 <= transitionUpdateTime &&
          transitionUpdateTime < transitionClampTime
            ? transitionClampTime
            : transitionUpdateTime),
        (endTime =
          0 <= transitionEventTime && transitionEventTime < transitionClampTime
            ? transitionClampTime
            : transitionEventTime),
        (color =
          0 <= endTime
            ? endTime
            : 0 <= previousRenderStartTime
              ? previousRenderStartTime
              : renderStartTime),
        0 <= transitionSuspendedTime
          ? (setCurrentTrackFromLanes(256),
            logSuspendedWithDelayPhase(
              transitionSuspendedTime,
              color,
              lanes,
              workInProgressUpdateTask
            ))
          : 0 !== (animatingLanes & 4194048) &&
            (setCurrentTrackFromLanes(256),
            logAnimatingPhase(transitionClampTime, color, animatingTask)),
        (isPingedUpdate = endTime),
        (eventTime = transitionEventType),
        (eventType = 0 < transitionEventRepeatTime),
        (eventIsRepeat = transitionUpdateType === PINGED_UPDATE),
        (color = renderStartTime),
        (endTime = transitionUpdateTask),
        (label = transitionUpdateMethodName),
        (isSpawnedUpdate = transitionUpdateComponentName),
        supportsUserTiming &&
          ((currentTrack = "Transition"),
          0 < previousRenderStartTime
            ? previousRenderStartTime > color &&
              (previousRenderStartTime = color)
            : (previousRenderStartTime = color),
          0 < debugTask
            ? debugTask > previousRenderStartTime &&
              (debugTask = previousRenderStartTime)
            : (debugTask = previousRenderStartTime),
          0 < isPingedUpdate
            ? isPingedUpdate > debugTask && (isPingedUpdate = debugTask)
            : (isPingedUpdate = debugTask),
          debugTask > isPingedUpdate &&
            null !== eventTime &&
            ((color$jscomp$0 = eventType ? "secondary-light" : "warning"),
            endTime
              ? endTime.run(
                  console.timeStamp.bind(
                    console,
                    eventType ? "Consecutive" : "Event: " + eventTime,
                    isPingedUpdate,
                    debugTask,
                    currentTrack,
                    LANES_TRACK_GROUP,
                    color$jscomp$0
                  )
                )
              : console.timeStamp(
                  eventType ? "Consecutive" : "Event: " + eventTime,
                  isPingedUpdate,
                  debugTask,
                  currentTrack,
                  LANES_TRACK_GROUP,
                  color$jscomp$0
                )),
          previousRenderStartTime > debugTask &&
            (endTime
              ? endTime.run(
                  console.timeStamp.bind(
                    console,
                    "Action",
                    debugTask,
                    previousRenderStartTime,
                    currentTrack,
                    LANES_TRACK_GROUP,
                    "primary-dark"
                  )
                )
              : console.timeStamp(
                  "Action",
                  debugTask,
                  previousRenderStartTime,
                  currentTrack,
                  LANES_TRACK_GROUP,
                  "primary-dark"
                )),
          color > previousRenderStartTime &&
            ((debugTask = eventIsRepeat
              ? "Promise Resolved"
              : 5 < color - previousRenderStartTime
                ? "Update Blocked"
                : "Update"),
            (isPingedUpdate = []),
            null != isSpawnedUpdate &&
              isPingedUpdate.push(["Component name", isSpawnedUpdate]),
            null != label && isPingedUpdate.push(["Method name", label]),
            (previousRenderStartTime = {
              start: previousRenderStartTime,
              end: color,
              detail: {
                devtools: {
                  properties: isPingedUpdate,
                  track: currentTrack,
                  trackGroup: LANES_TRACK_GROUP,
                  color: "primary-light"
                }
              }
            }),
            endTime
              ? endTime.run(
                  performance.measure.bind(
                    performance,
                    debugTask,
                    previousRenderStartTime
                  )
                )
              : performance.measure(debugTask, previousRenderStartTime))),
        (transitionUpdateTime = transitionStartTime = -1.1),
        (transitionUpdateType = 0),
        (transitionSuspendedTime = -1.1),
        (transitionEventRepeatTime = transitionEventTime),
        (transitionEventTime = -1.1),
        (transitionClampTime = now()));
      0 !== (lanes & 62914560) &&
        0 !== (animatingLanes & 62914560) &&
        (setCurrentTrackFromLanes(4194304),
        logAnimatingPhase(retryClampTime, renderStartTime, animatingTask));
      0 !== (lanes & 2080374784) &&
        0 !== (animatingLanes & 2080374784) &&
        (setCurrentTrackFromLanes(268435456),
        logAnimatingPhase(idleClampTime, renderStartTime, animatingTask));
      previousRenderStartTime = root.timeoutHandle;
      previousRenderStartTime !== noTimeout &&
        ((root.timeoutHandle = noTimeout),
        cancelTimeout(previousRenderStartTime));
      previousRenderStartTime = root.cancelPendingCommit;
      null !== previousRenderStartTime &&
        ((root.cancelPendingCommit = null), previousRenderStartTime());
      pendingEffectsLanes = 0;
      resetWorkInProgressStack();
      workInProgressRoot = root;
      workInProgress = previousRenderStartTime = createWorkInProgress(
        root.current,
        null
      );
      workInProgressRootRenderLanes = lanes;
      workInProgressSuspendedReason = NotSuspended;
      workInProgressThrownValue = null;
      workInProgressRootDidSkipSuspendedSiblings = !1;
      workInProgressRootIsPrerendering = checkIfRootIsPrerendering(root, lanes);
      workInProgressRootDidAttachPingListener = !1;
      workInProgressRootExitStatus = RootInProgress;
      workInProgressSuspendedRetryLanes =
        workInProgressDeferredLane =
        workInProgressRootPingedLanes =
        workInProgressRootInterleavedUpdatedLanes =
        workInProgressRootSkippedLanes =
          0;
      workInProgressRootRecoverableErrors = workInProgressRootConcurrentErrors =
        null;
      workInProgressRootDidIncludeRecursiveRenderUpdate = !1;
      0 !== (lanes & 8) && (lanes |= lanes & 32);
      endTime = root.entangledLanes;
      if (0 !== endTime)
        for (root = root.entanglements, endTime &= lanes; 0 < endTime; )
          (debugTask = 31 - clz32(endTime)),
            (color = 1 << debugTask),
            (lanes |= root[debugTask]),
            (endTime &= ~color);
      entangledRenderLanes = lanes;
      finishQueueingConcurrentUpdates();
      root = getCurrentTime();
      1e3 < root - lastResetTime &&
        ((ReactSharedInternals.recentlyCreatedOwnerStacks = 0),
        (lastResetTime = root));
      ReactStrictModeWarnings.discardPendingWarnings();
      return previousRenderStartTime;
    }
    function handleThrow(root, thrownValue) {
      currentlyRenderingFiber = null;
      ReactSharedInternals.H = ContextOnlyDispatcher;
      ReactSharedInternals.getCurrentStack = null;
      isRendering = !1;
      current = null;
      thrownValue === SuspenseException ||
      thrownValue === SuspenseActionException
        ? ((thrownValue = getSuspendedThenable()),
          (workInProgressSuspendedReason = SuspendedOnImmediate))
        : thrownValue === SuspenseyCommitException
          ? ((thrownValue = getSuspendedThenable()),
            (workInProgressSuspendedReason = SuspendedOnInstance))
          : (workInProgressSuspendedReason =
              thrownValue === SelectiveHydrationException
                ? SuspendedOnHydration
                : null !== thrownValue &&
                    "object" === typeof thrownValue &&
                    "function" === typeof thrownValue.then
                  ? SuspendedOnDeprecatedThrowPromise
                  : SuspendedOnError);
      workInProgressThrownValue = thrownValue;
      var erroredWork = workInProgress;
      null === erroredWork
        ? ((workInProgressRootExitStatus = RootFatalErrored),
          logUncaughtError(
            root,
            createCapturedValueAtFiber(thrownValue, root.current)
          ))
        : erroredWork.mode & ProfileMode &&
          stopProfilerTimerIfRunningAndRecordDuration(erroredWork);
    }
    function shouldRemainOnPreviousScreen() {
      var handler = suspenseHandlerStackCursor.current;
      return null === handler
        ? !0
        : (workInProgressRootRenderLanes & 4194048) ===
            workInProgressRootRenderLanes
          ? null === shellBoundary
            ? !0
            : !1
          : (workInProgressRootRenderLanes & 62914560) ===
                workInProgressRootRenderLanes ||
              0 !== (workInProgressRootRenderLanes & 536870912)
            ? handler === shellBoundary
            : !1;
    }
    function pushDispatcher() {
      var prevDispatcher = ReactSharedInternals.H;
      ReactSharedInternals.H = ContextOnlyDispatcher;
      return null === prevDispatcher ? ContextOnlyDispatcher : prevDispatcher;
    }
    function pushAsyncDispatcher() {
      var prevAsyncDispatcher = ReactSharedInternals.A;
      ReactSharedInternals.A = DefaultAsyncDispatcher;
      return prevAsyncDispatcher;
    }
    function markRenderDerivedCause(fiber) {
      null === workInProgressUpdateTask &&
        (workInProgressUpdateTask =
          null == fiber._debugTask ? null : fiber._debugTask);
    }
    function renderDidSuspendDelayIfPossible() {
      workInProgressRootExitStatus = RootSuspendedWithDelay;
      workInProgressRootDidSkipSuspendedSiblings ||
        ((workInProgressRootRenderLanes & 4194048) !==
          workInProgressRootRenderLanes &&
          null !== suspenseHandlerStackCursor.current) ||
        (workInProgressRootIsPrerendering = !0);
      (0 === (workInProgressRootSkippedLanes & 134217727) &&
        0 === (workInProgressRootInterleavedUpdatedLanes & 134217727)) ||
        null === workInProgressRoot ||
        markRootSuspended(
          workInProgressRoot,
          workInProgressRootRenderLanes,
          workInProgressDeferredLane,
          !1
        );
    }
    function renderRootSync(root, lanes, shouldYieldForPrerendering) {
      var prevExecutionContext = executionContext;
      executionContext |= RenderContext;
      var prevDispatcher = pushDispatcher(),
        prevAsyncDispatcher = pushAsyncDispatcher();
      if (
        workInProgressRoot !== root ||
        workInProgressRootRenderLanes !== lanes
      ) {
        if (isDevToolsPresent) {
          var memoizedUpdaters = root.memoizedUpdaters;
          0 < memoizedUpdaters.size &&
            (restorePendingUpdaters(root, workInProgressRootRenderLanes),
            memoizedUpdaters.clear());
          movePendingFibersToMemoized(root, lanes);
        }
        workInProgressTransitions = null;
        prepareFreshStack(root, lanes);
      }
      lanes = !1;
      memoizedUpdaters = workInProgressRootExitStatus;
      a: do
        try {
          if (
            workInProgressSuspendedReason !== NotSuspended &&
            null !== workInProgress
          ) {
            var unitOfWork = workInProgress,
              thrownValue = workInProgressThrownValue;
            switch (workInProgressSuspendedReason) {
              case SuspendedOnHydration:
                resetWorkInProgressStack();
                memoizedUpdaters = RootSuspendedAtTheShell;
                break a;
              case SuspendedOnImmediate:
              case SuspendedOnData:
              case SuspendedOnAction:
              case SuspendedOnDeprecatedThrowPromise:
                null === suspenseHandlerStackCursor.current && (lanes = !0);
                var reason = workInProgressSuspendedReason;
                workInProgressSuspendedReason = NotSuspended;
                workInProgressThrownValue = null;
                throwAndUnwindWorkLoop(root, unitOfWork, thrownValue, reason);
                if (
                  shouldYieldForPrerendering &&
                  workInProgressRootIsPrerendering
                ) {
                  memoizedUpdaters = RootInProgress;
                  break a;
                }
                break;
              default:
                (reason = workInProgressSuspendedReason),
                  (workInProgressSuspendedReason = NotSuspended),
                  (workInProgressThrownValue = null),
                  throwAndUnwindWorkLoop(root, unitOfWork, thrownValue, reason);
            }
          }
          workLoopSync();
          memoizedUpdaters = workInProgressRootExitStatus;
          break;
        } catch (thrownValue$8) {
          handleThrow(root, thrownValue$8);
        }
      while (1);
      lanes && root.shellSuspendCounter++;
      resetContextDependencies();
      executionContext = prevExecutionContext;
      ReactSharedInternals.H = prevDispatcher;
      ReactSharedInternals.A = prevAsyncDispatcher;
      null === workInProgress &&
        ((workInProgressRoot = null),
        (workInProgressRootRenderLanes = 0),
        finishQueueingConcurrentUpdates());
      return memoizedUpdaters;
    }
    function workLoopSync() {
      for (; null !== workInProgress; ) performUnitOfWork(workInProgress);
    }
    function renderRootConcurrent(root, lanes) {
      var prevExecutionContext = executionContext;
      executionContext |= RenderContext;
      var prevDispatcher = pushDispatcher(),
        prevAsyncDispatcher = pushAsyncDispatcher();
      if (
        workInProgressRoot !== root ||
        workInProgressRootRenderLanes !== lanes
      ) {
        if (isDevToolsPresent) {
          var memoizedUpdaters = root.memoizedUpdaters;
          0 < memoizedUpdaters.size &&
            (restorePendingUpdaters(root, workInProgressRootRenderLanes),
            memoizedUpdaters.clear());
          movePendingFibersToMemoized(root, lanes);
        }
        workInProgressTransitions = null;
        workInProgressRootRenderTargetTime = now$1() + RENDER_TIMEOUT_MS;
        prepareFreshStack(root, lanes);
      } else
        workInProgressRootIsPrerendering = checkIfRootIsPrerendering(
          root,
          lanes
        );
      a: do
        try {
          if (
            workInProgressSuspendedReason !== NotSuspended &&
            null !== workInProgress
          )
            b: switch (
              ((lanes = workInProgress),
              (memoizedUpdaters = workInProgressThrownValue),
              workInProgressSuspendedReason)
            ) {
              case SuspendedOnError:
                workInProgressSuspendedReason = NotSuspended;
                workInProgressThrownValue = null;
                throwAndUnwindWorkLoop(
                  root,
                  lanes,
                  memoizedUpdaters,
                  SuspendedOnError
                );
                break;
              case SuspendedOnData:
              case SuspendedOnAction:
                if (isThenableResolved(memoizedUpdaters)) {
                  workInProgressSuspendedReason = NotSuspended;
                  workInProgressThrownValue = null;
                  replaySuspendedUnitOfWork(lanes);
                  break;
                }
                lanes = function () {
                  (workInProgressSuspendedReason !== SuspendedOnData &&
                    workInProgressSuspendedReason !== SuspendedOnAction) ||
                    workInProgressRoot !== root ||
                    (workInProgressSuspendedReason =
                      SuspendedAndReadyToContinue);
                  ensureRootIsScheduled(root);
                };
                memoizedUpdaters.then(lanes, lanes);
                break a;
              case SuspendedOnImmediate:
                workInProgressSuspendedReason = SuspendedAndReadyToContinue;
                break a;
              case SuspendedOnInstance:
                workInProgressSuspendedReason =
                  SuspendedOnInstanceAndReadyToContinue;
                break a;
              case SuspendedAndReadyToContinue:
                isThenableResolved(memoizedUpdaters)
                  ? ((workInProgressSuspendedReason = NotSuspended),
                    (workInProgressThrownValue = null),
                    replaySuspendedUnitOfWork(lanes))
                  : ((workInProgressSuspendedReason = NotSuspended),
                    (workInProgressThrownValue = null),
                    throwAndUnwindWorkLoop(
                      root,
                      lanes,
                      memoizedUpdaters,
                      SuspendedAndReadyToContinue
                    ));
                break;
              case SuspendedOnInstanceAndReadyToContinue:
                var resource = null;
                switch (workInProgress.tag) {
                  case 26:
                    resource = workInProgress.memoizedState;
                  case 5:
                  case 27:
                    var hostFiber = workInProgress;
                    if (
                      resource
                        ? preloadResource(resource)
                        : hostFiber.stateNode.complete
                    ) {
                      workInProgressSuspendedReason = NotSuspended;
                      workInProgressThrownValue = null;
                      var sibling = hostFiber.sibling;
                      if (null !== sibling) workInProgress = sibling;
                      else {
                        var returnFiber = hostFiber.return;
                        null !== returnFiber
                          ? ((workInProgress = returnFiber),
                            completeUnitOfWork(returnFiber))
                          : (workInProgress = null);
                      }
                      break b;
                    }
                    break;
                  default:
                    console.error(
                      "Unexpected type of fiber triggered a suspensey commit. This is a bug in React."
                    );
                }
                workInProgressSuspendedReason = NotSuspended;
                workInProgressThrownValue = null;
                throwAndUnwindWorkLoop(
                  root,
                  lanes,
                  memoizedUpdaters,
                  SuspendedOnInstanceAndReadyToContinue
                );
                break;
              case SuspendedOnDeprecatedThrowPromise:
                workInProgressSuspendedReason = NotSuspended;
                workInProgressThrownValue = null;
                throwAndUnwindWorkLoop(
                  root,
                  lanes,
                  memoizedUpdaters,
                  SuspendedOnDeprecatedThrowPromise
                );
                break;
              case SuspendedOnHydration:
                resetWorkInProgressStack();
                workInProgressRootExitStatus = RootSuspendedAtTheShell;
                break a;
              default:
                throw Error(
                  "Unexpected SuspendedReason. This is a bug in React."
                );
            }
          null !== ReactSharedInternals.actQueue
            ? workLoopSync()
            : workLoopConcurrentByScheduler();
          break;
        } catch (thrownValue$9) {
          handleThrow(root, thrownValue$9);
        }
      while (1);
      resetContextDependencies();
      ReactSharedInternals.H = prevDispatcher;
      ReactSharedInternals.A = prevAsyncDispatcher;
      executionContext = prevExecutionContext;
      if (null !== workInProgress) return RootInProgress;
      workInProgressRoot = null;
      workInProgressRootRenderLanes = 0;
      finishQueueingConcurrentUpdates();
      return workInProgressRootExitStatus;
    }
    function workLoopConcurrentByScheduler() {
      for (; null !== workInProgress && !shouldYield(); )
        performUnitOfWork(workInProgress);
    }
    function performUnitOfWork(unitOfWork) {
      var current = unitOfWork.alternate;
      (unitOfWork.mode & ProfileMode) !== NoMode
        ? (startProfilerTimer(unitOfWork),
          (current = runWithFiberInDEV(
            unitOfWork,
            beginWork,
            current,
            unitOfWork,
            entangledRenderLanes
          )),
          stopProfilerTimerIfRunningAndRecordDuration(unitOfWork))
        : (current = runWithFiberInDEV(
            unitOfWork,
            beginWork,
            current,
            unitOfWork,
            entangledRenderLanes
          ));
      unitOfWork.memoizedProps = unitOfWork.pendingProps;
      null === current
        ? completeUnitOfWork(unitOfWork)
        : (workInProgress = current);
    }
    function replaySuspendedUnitOfWork(unitOfWork) {
      var next = runWithFiberInDEV(unitOfWork, replayBeginWork, unitOfWork);
      unitOfWork.memoizedProps = unitOfWork.pendingProps;
      null === next ? completeUnitOfWork(unitOfWork) : (workInProgress = next);
    }
    function replayBeginWork(unitOfWork) {
      var current = unitOfWork.alternate,
        isProfilingMode = (unitOfWork.mode & ProfileMode) !== NoMode;
      isProfilingMode && startProfilerTimer(unitOfWork);
      switch (unitOfWork.tag) {
        case 15:
        case 0:
          current = replayFunctionComponent(
            current,
            unitOfWork,
            unitOfWork.pendingProps,
            unitOfWork.type,
            void 0,
            workInProgressRootRenderLanes
          );
          break;
        case 11:
          current = replayFunctionComponent(
            current,
            unitOfWork,
            unitOfWork.pendingProps,
            unitOfWork.type.render,
            unitOfWork.ref,
            workInProgressRootRenderLanes
          );
          break;
        case 5:
          resetHooksOnUnwind(unitOfWork);
        default:
          unwindInterruptedWork(current, unitOfWork),
            (unitOfWork = workInProgress =
              resetWorkInProgress(unitOfWork, entangledRenderLanes)),
            (current = beginWork(current, unitOfWork, entangledRenderLanes));
      }
      isProfilingMode &&
        stopProfilerTimerIfRunningAndRecordDuration(unitOfWork);
      return current;
    }
    function throwAndUnwindWorkLoop(
      root,
      unitOfWork,
      thrownValue,
      suspendedReason
    ) {
      resetContextDependencies();
      resetHooksOnUnwind(unitOfWork);
      thenableState$1 = null;
      thenableIndexCounter$1 = 0;
      var returnFiber = unitOfWork.return;
      try {
        if (
          throwException(
            root,
            returnFiber,
            unitOfWork,
            thrownValue,
            workInProgressRootRenderLanes
          )
        ) {
          workInProgressRootExitStatus = RootFatalErrored;
          logUncaughtError(
            root,
            createCapturedValueAtFiber(thrownValue, root.current)
          );
          workInProgress = null;
          return;
        }
      } catch (error) {
        if (null !== returnFiber) throw ((workInProgress = returnFiber), error);
        workInProgressRootExitStatus = RootFatalErrored;
        logUncaughtError(
          root,
          createCapturedValueAtFiber(thrownValue, root.current)
        );
        workInProgress = null;
        return;
      }
      if (unitOfWork.flags & 32768) {
        if (isHydrating || suspendedReason === SuspendedOnError) root = !0;
        else if (
          workInProgressRootIsPrerendering ||
          0 !== (workInProgressRootRenderLanes & 536870912)
        )
          root = !1;
        else if (
          ((workInProgressRootDidSkipSuspendedSiblings = root = !0),
          suspendedReason === SuspendedOnData ||
            suspendedReason === SuspendedOnAction ||
            suspendedReason === SuspendedOnImmediate ||
            suspendedReason === SuspendedOnDeprecatedThrowPromise)
        )
          (suspendedReason = suspenseHandlerStackCursor.current),
            null !== suspendedReason &&
              13 === suspendedReason.tag &&
              (suspendedReason.flags |= 16384);
        unwindUnitOfWork(unitOfWork, root);
      } else completeUnitOfWork(unitOfWork);
    }
    function completeUnitOfWork(unitOfWork) {
      var completedWork = unitOfWork;
      do {
        if (0 !== (completedWork.flags & 32768)) {
          unwindUnitOfWork(
            completedWork,
            workInProgressRootDidSkipSuspendedSiblings
          );
          return;
        }
        var current = completedWork.alternate;
        unitOfWork = completedWork.return;
        startProfilerTimer(completedWork);
        current = runWithFiberInDEV(
          completedWork,
          completeWork,
          current,
          completedWork,
          entangledRenderLanes
        );
        (completedWork.mode & ProfileMode) !== NoMode &&
          stopProfilerTimerIfRunningAndRecordIncompleteDuration(completedWork);
        if (null !== current) {
          workInProgress = current;
          return;
        }
        completedWork = completedWork.sibling;
        if (null !== completedWork) {
          workInProgress = completedWork;
          return;
        }
        workInProgress = completedWork = unitOfWork;
      } while (null !== completedWork);
      workInProgressRootExitStatus === RootInProgress &&
        (workInProgressRootExitStatus = RootCompleted);
    }
    function unwindUnitOfWork(unitOfWork, skipSiblings) {
      do {
        var next = unwindWork(unitOfWork.alternate, unitOfWork);
        if (null !== next) {
          next.flags &= 32767;
          workInProgress = next;
          return;
        }
        if ((unitOfWork.mode & ProfileMode) !== NoMode) {
          stopProfilerTimerIfRunningAndRecordIncompleteDuration(unitOfWork);
          next = unitOfWork.actualDuration;
          for (var child = unitOfWork.child; null !== child; )
            (next += child.actualDuration), (child = child.sibling);
          unitOfWork.actualDuration = next;
        }
        next = unitOfWork.return;
        null !== next &&
          ((next.flags |= 32768),
          (next.subtreeFlags = 0),
          (next.deletions = null));
        if (
          !skipSiblings &&
          ((unitOfWork = unitOfWork.sibling), null !== unitOfWork)
        ) {
          workInProgress = unitOfWork;
          return;
        }
        workInProgress = unitOfWork = next;
      } while (null !== unitOfWork);
      workInProgressRootExitStatus = RootSuspendedAtTheShell;
      workInProgress = null;
    }
    function commitRoot(
      root,
      finishedWork,
      lanes,
      recoverableErrors,
      transitions,
      didIncludeRenderPhaseUpdate,
      spawnedLane,
      updatedLanes,
      suspendedRetryLanes,
      exitStatus,
      suspendedState,
      suspendedCommitReason,
      completedRenderStartTime,
      completedRenderEndTime
    ) {
      root.cancelPendingCommit = null;
      do flushPendingEffects();
      while (pendingEffectsStatus !== NO_PENDING_EFFECTS);
      ReactStrictModeWarnings.flushLegacyContextWarning();
      ReactStrictModeWarnings.flushPendingUnsafeLifecycleWarnings();
      if ((executionContext & (RenderContext | CommitContext)) !== NoContext)
        throw Error("Should not already be working.");
      setCurrentTrackFromLanes(lanes);
      exitStatus === RootErrored
        ? logErroredRenderPhase(
            completedRenderStartTime,
            completedRenderEndTime,
            lanes,
            workInProgressUpdateTask
          )
        : null !== recoverableErrors
          ? logRecoveredRenderPhase(
              completedRenderStartTime,
              completedRenderEndTime,
              lanes,
              recoverableErrors,
              null !== finishedWork &&
                null !== finishedWork.alternate &&
                finishedWork.alternate.memoizedState.isDehydrated &&
                0 !== (finishedWork.flags & 256),
              workInProgressUpdateTask
            )
          : logRenderPhase(
              completedRenderStartTime,
              completedRenderEndTime,
              lanes,
              workInProgressUpdateTask
            );
      if (null !== finishedWork) {
        0 === lanes &&
          console.error(
            "finishedLanes should not be empty during a commit. This is a bug in React."
          );
        if (finishedWork === root.current)
          throw Error(
            "Cannot commit the same tree as before. This error is likely caused by a bug in React. Please file an issue."
          );
        didIncludeRenderPhaseUpdate =
          finishedWork.lanes | finishedWork.childLanes;
        didIncludeRenderPhaseUpdate |= concurrentlyUpdatedLanes;
        markRootFinished(
          root,
          lanes,
          didIncludeRenderPhaseUpdate,
          spawnedLane,
          updatedLanes,
          suspendedRetryLanes
        );
        root === workInProgressRoot &&
          ((workInProgress = workInProgressRoot = null),
          (workInProgressRootRenderLanes = 0));
        pendingFinishedWork = finishedWork;
        pendingEffectsRoot = root;
        pendingEffectsLanes = lanes;
        pendingEffectsRemainingLanes = didIncludeRenderPhaseUpdate;
        pendingPassiveTransitions = transitions;
        pendingRecoverableErrors = recoverableErrors;
        pendingEffectsRenderEndTime = completedRenderEndTime;
        pendingSuspendedCommitReason = suspendedCommitReason;
        pendingDelayedCommitReason = IMMEDIATE_COMMIT;
        pendingSuspendedViewTransitionReason = null;
        0 !== finishedWork.actualDuration ||
        0 !== (finishedWork.subtreeFlags & 10256) ||
        0 !== (finishedWork.flags & 10256)
          ? ((root.callbackNode = null),
            (root.callbackPriority = 0),
            scheduleCallback$1(NormalPriority$1, function () {
              schedulerEvent = window.event;
              pendingDelayedCommitReason === IMMEDIATE_COMMIT &&
                (pendingDelayedCommitReason = DELAYED_PASSIVE_COMMIT);
              flushPassiveEffects();
              return null;
            }))
          : ((root.callbackNode = null), (root.callbackPriority = 0));
        commitErrors = null;
        commitStartTime = now();
        null !== suspendedCommitReason &&
          logSuspendedCommitPhase(
            completedRenderEndTime,
            commitStartTime,
            suspendedCommitReason,
            workInProgressUpdateTask
          );
        recoverableErrors = 0 !== (finishedWork.flags & 13878);
        if (0 !== (finishedWork.subtreeFlags & 13878) || recoverableErrors) {
          recoverableErrors = ReactSharedInternals.T;
          ReactSharedInternals.T = null;
          transitions = ReactDOMSharedInternals.p;
          ReactDOMSharedInternals.p = DiscreteEventPriority;
          spawnedLane = executionContext;
          executionContext |= CommitContext;
          try {
            commitBeforeMutationEffects(root, finishedWork, lanes);
          } finally {
            (executionContext = spawnedLane),
              (ReactDOMSharedInternals.p = transitions),
              (ReactSharedInternals.T = recoverableErrors);
          }
        }
        pendingEffectsStatus = PENDING_MUTATION_PHASE;
        flushMutationEffects();
        flushLayoutEffects();
        flushSpawnedWork();
      }
    }
    function flushMutationEffects() {
      if (pendingEffectsStatus === PENDING_MUTATION_PHASE) {
        pendingEffectsStatus = NO_PENDING_EFFECTS;
        var root = pendingEffectsRoot,
          finishedWork = pendingFinishedWork,
          lanes = pendingEffectsLanes,
          rootMutationHasEffect = 0 !== (finishedWork.flags & 13878);
        if (
          0 !== (finishedWork.subtreeFlags & 13878) ||
          rootMutationHasEffect
        ) {
          rootMutationHasEffect = ReactSharedInternals.T;
          ReactSharedInternals.T = null;
          var previousPriority = ReactDOMSharedInternals.p;
          ReactDOMSharedInternals.p = DiscreteEventPriority;
          var prevExecutionContext = executionContext;
          executionContext |= CommitContext;
          try {
            inProgressLanes = lanes;
            inProgressRoot = root;
            resetComponentEffectTimers();
            commitMutationEffectsOnFiber(finishedWork, root);
            inProgressRoot = inProgressLanes = null;
            lanes = selectionInformation;
            var curFocusedElem = getActiveElementDeep(root.containerInfo),
              priorFocusedElem = lanes.focusedElem,
              priorSelectionRange = lanes.selectionRange;
            if (
              curFocusedElem !== priorFocusedElem &&
              priorFocusedElem &&
              priorFocusedElem.ownerDocument &&
              containsNode(
                priorFocusedElem.ownerDocument.documentElement,
                priorFocusedElem
              )
            ) {
              if (
                null !== priorSelectionRange &&
                hasSelectionCapabilities(priorFocusedElem)
              ) {
                var start = priorSelectionRange.start,
                  end = priorSelectionRange.end;
                void 0 === end && (end = start);
                if ("selectionStart" in priorFocusedElem)
                  (priorFocusedElem.selectionStart = start),
                    (priorFocusedElem.selectionEnd = Math.min(
                      end,
                      priorFocusedElem.value.length
                    ));
                else {
                  var doc = priorFocusedElem.ownerDocument || document,
                    win = (doc && doc.defaultView) || window;
                  if (win.getSelection) {
                    var selection = win.getSelection(),
                      length = priorFocusedElem.textContent.length,
                      start$jscomp$0 = Math.min(
                        priorSelectionRange.start,
                        length
                      ),
                      end$jscomp$0 =
                        void 0 === priorSelectionRange.end
                          ? start$jscomp$0
                          : Math.min(priorSelectionRange.end, length);
                    !selection.extend &&
                      start$jscomp$0 > end$jscomp$0 &&
                      ((curFocusedElem = end$jscomp$0),
                      (end$jscomp$0 = start$jscomp$0),
                      (start$jscomp$0 = curFocusedElem));
                    var startMarker = getNodeForCharacterOffset(
                        priorFocusedElem,
                        start$jscomp$0
                      ),
                      endMarker = getNodeForCharacterOffset(
                        priorFocusedElem,
                        end$jscomp$0
                      );
                    if (
                      startMarker &&
                      endMarker &&
                      (1 !== selection.rangeCount ||
                        selection.anchorNode !== startMarker.node ||
                        selection.anchorOffset !== startMarker.offset ||
                        selection.focusNode !== endMarker.node ||
                        selection.focusOffset !== endMarker.offset)
                    ) {
                      var range = doc.createRange();
                      range.setStart(startMarker.node, startMarker.offset);
                      selection.removeAllRanges();
                      start$jscomp$0 > end$jscomp$0
                        ? (selection.addRange(range),
                          selection.extend(endMarker.node, endMarker.offset))
                        : (range.setEnd(endMarker.node, endMarker.offset),
                          selection.addRange(range));
                    }
                  }
                }
              }
              doc = [];
              for (
                selection = priorFocusedElem;
                (selection = selection.parentNode);

              )
                1 === selection.nodeType &&
                  doc.push({
                    element: selection,
                    left: selection.scrollLeft,
                    top: selection.scrollTop
                  });
              "function" === typeof priorFocusedElem.focus &&
                priorFocusedElem.focus();
              for (
                priorFocusedElem = 0;
                priorFocusedElem < doc.length;
                priorFocusedElem++
              ) {
                var info = doc[priorFocusedElem];
                info.element.scrollLeft = info.left;
                info.element.scrollTop = info.top;
              }
            }
            _enabled = !!eventsEnabled;
            selectionInformation = eventsEnabled = null;
          } finally {
            (executionContext = prevExecutionContext),
              (ReactDOMSharedInternals.p = previousPriority),
              (ReactSharedInternals.T = rootMutationHasEffect);
          }
        }
        root.current = finishedWork;
        pendingEffectsStatus = PENDING_LAYOUT_PHASE;
      }
    }
    function flushLayoutEffects() {
      if (pendingEffectsStatus === PENDING_LAYOUT_PHASE) {
        pendingEffectsStatus = NO_PENDING_EFFECTS;
        var suspendedViewTransitionReason =
          pendingSuspendedViewTransitionReason;
        if (null !== suspendedViewTransitionReason) {
          commitStartTime = now();
          var startTime = commitEndTime,
            endTime = commitStartTime;
          !supportsUserTiming ||
            endTime <= startTime ||
            (animatingTask
              ? animatingTask.run(
                  console.timeStamp.bind(
                    console,
                    suspendedViewTransitionReason,
                    startTime,
                    endTime,
                    currentTrack,
                    LANES_TRACK_GROUP,
                    "secondary-light"
                  )
                )
              : console.timeStamp(
                  suspendedViewTransitionReason,
                  startTime,
                  endTime,
                  currentTrack,
                  LANES_TRACK_GROUP,
                  "secondary-light"
                ));
        }
        suspendedViewTransitionReason = pendingEffectsRoot;
        startTime = pendingFinishedWork;
        endTime = pendingEffectsLanes;
        var rootHasLayoutEffect = 0 !== (startTime.flags & 8772);
        if (0 !== (startTime.subtreeFlags & 8772) || rootHasLayoutEffect) {
          rootHasLayoutEffect = ReactSharedInternals.T;
          ReactSharedInternals.T = null;
          var _previousPriority = ReactDOMSharedInternals.p;
          ReactDOMSharedInternals.p = DiscreteEventPriority;
          var _prevExecutionContext = executionContext;
          executionContext |= CommitContext;
          try {
            (inProgressLanes = endTime),
              (inProgressRoot = suspendedViewTransitionReason),
              resetComponentEffectTimers(),
              commitLayoutEffectOnFiber(
                suspendedViewTransitionReason,
                startTime.alternate,
                startTime
              ),
              (inProgressRoot = inProgressLanes = null);
          } finally {
            (executionContext = _prevExecutionContext),
              (ReactDOMSharedInternals.p = _previousPriority),
              (ReactSharedInternals.T = rootHasLayoutEffect);
          }
        }
        suspendedViewTransitionReason = pendingEffectsRenderEndTime;
        startTime = pendingSuspendedCommitReason;
        commitEndTime = now();
        suspendedViewTransitionReason =
          null === startTime ? suspendedViewTransitionReason : commitStartTime;
        startTime = commitEndTime;
        endTime = pendingDelayedCommitReason === ABORTED_VIEW_TRANSITION_COMMIT;
        rootHasLayoutEffect = workInProgressUpdateTask;
        null !== commitErrors
          ? logCommitErrored(
              suspendedViewTransitionReason,
              startTime,
              commitErrors,
              !1,
              rootHasLayoutEffect
            )
          : !supportsUserTiming ||
            startTime <= suspendedViewTransitionReason ||
            (rootHasLayoutEffect
              ? rootHasLayoutEffect.run(
                  console.timeStamp.bind(
                    console,
                    endTime ? "Commit Interrupted View Transition" : "Commit",
                    suspendedViewTransitionReason,
                    startTime,
                    currentTrack,
                    LANES_TRACK_GROUP,
                    endTime ? "error" : "secondary-dark"
                  )
                )
              : console.timeStamp(
                  endTime ? "Commit Interrupted View Transition" : "Commit",
                  suspendedViewTransitionReason,
                  startTime,
                  currentTrack,
                  LANES_TRACK_GROUP,
                  endTime ? "error" : "secondary-dark"
                ));
        pendingEffectsStatus = PENDING_AFTER_MUTATION_PHASE;
      }
    }
    function flushSpawnedWork() {
      if (
        pendingEffectsStatus === PENDING_SPAWNED_WORK ||
        pendingEffectsStatus === PENDING_AFTER_MUTATION_PHASE
      ) {
        if (pendingEffectsStatus === PENDING_SPAWNED_WORK) {
          var startViewTransitionStartTime = commitEndTime;
          commitEndTime = now();
          var endTime = commitEndTime,
            abortedViewTransition =
              pendingDelayedCommitReason === ABORTED_VIEW_TRANSITION_COMMIT;
          !supportsUserTiming ||
            endTime <= startViewTransitionStartTime ||
            (animatingTask
              ? animatingTask.run(
                  console.timeStamp.bind(
                    console,
                    abortedViewTransition
                      ? "Interrupted View Transition"
                      : "Starting Animation",
                    startViewTransitionStartTime,
                    endTime,
                    currentTrack,
                    LANES_TRACK_GROUP,
                    abortedViewTransition ? "error" : "secondary-light"
                  )
                )
              : console.timeStamp(
                  abortedViewTransition
                    ? "Interrupted View Transition"
                    : "Starting Animation",
                  startViewTransitionStartTime,
                  endTime,
                  currentTrack,
                  LANES_TRACK_GROUP,
                  abortedViewTransition ? " error" : "secondary-light"
                ));
          pendingDelayedCommitReason !== ABORTED_VIEW_TRANSITION_COMMIT &&
            (pendingDelayedCommitReason = ANIMATION_STARTED_COMMIT);
        }
        pendingEffectsStatus = NO_PENDING_EFFECTS;
        requestPaint();
        startViewTransitionStartTime = pendingEffectsRoot;
        var finishedWork = pendingFinishedWork;
        endTime = pendingEffectsLanes;
        abortedViewTransition = pendingRecoverableErrors;
        var rootDidHavePassiveEffects =
          0 !== finishedWork.actualDuration ||
          0 !== (finishedWork.subtreeFlags & 10256) ||
          0 !== (finishedWork.flags & 10256);
        rootDidHavePassiveEffects
          ? (pendingEffectsStatus = PENDING_PASSIVE_PHASE)
          : ((pendingEffectsStatus = NO_PENDING_EFFECTS),
            (pendingFinishedWork = pendingEffectsRoot = null),
            releaseRootPooledCache(
              startViewTransitionStartTime,
              startViewTransitionStartTime.pendingLanes
            ),
            (nestedPassiveUpdateCount = 0),
            (rootWithPassiveNestedUpdates = null));
        var remainingLanes = startViewTransitionStartTime.pendingLanes;
        0 === remainingLanes && (legacyErrorBoundariesThatAlreadyFailed = null);
        rootDidHavePassiveEffects ||
          commitDoubleInvokeEffectsInDEV(startViewTransitionStartTime);
        remainingLanes = lanesToEventPriority(endTime);
        finishedWork = finishedWork.stateNode;
        if (
          injectedHook &&
          "function" === typeof injectedHook.onCommitFiberRoot
        )
          try {
            var didError = 128 === (finishedWork.current.flags & 128);
            switch (remainingLanes) {
              case DiscreteEventPriority:
                var schedulerPriority = ImmediatePriority;
                break;
              case ContinuousEventPriority:
                schedulerPriority = UserBlockingPriority;
                break;
              case DefaultEventPriority:
                schedulerPriority = NormalPriority$1;
                break;
              case IdleEventPriority:
                schedulerPriority = IdlePriority;
                break;
              default:
                schedulerPriority = NormalPriority$1;
            }
            injectedHook.onCommitFiberRoot(
              rendererID,
              finishedWork,
              schedulerPriority,
              didError
            );
          } catch (err) {
            hasLoggedError ||
              ((hasLoggedError = !0),
              console.error(
                "React instrumentation encountered an error: %o",
                err
              ));
          }
        isDevToolsPresent &&
          startViewTransitionStartTime.memoizedUpdaters.clear();
        onCommitRoot();
        if (null !== abortedViewTransition) {
          didError = ReactSharedInternals.T;
          schedulerPriority = ReactDOMSharedInternals.p;
          ReactDOMSharedInternals.p = DiscreteEventPriority;
          ReactSharedInternals.T = null;
          try {
            var onRecoverableError =
              startViewTransitionStartTime.onRecoverableError;
            for (
              finishedWork = 0;
              finishedWork < abortedViewTransition.length;
              finishedWork++
            ) {
              var recoverableError = abortedViewTransition[finishedWork],
                errorInfo = makeErrorInfo(recoverableError.stack);
              runWithFiberInDEV(
                recoverableError.source,
                onRecoverableError,
                recoverableError.value,
                errorInfo
              );
            }
          } finally {
            (ReactSharedInternals.T = didError),
              (ReactDOMSharedInternals.p = schedulerPriority);
          }
        }
        0 !== (pendingEffectsLanes & 3) && flushPendingEffects();
        ensureRootIsScheduled(startViewTransitionStartTime);
        remainingLanes = startViewTransitionStartTime.pendingLanes;
        0 !== (endTime & 261930) && 0 !== (remainingLanes & 42)
          ? ((nestedUpdateScheduled = !0),
            startViewTransitionStartTime === rootWithNestedUpdates
              ? nestedUpdateCount++
              : ((nestedUpdateCount = 0),
                (rootWithNestedUpdates = startViewTransitionStartTime)))
          : (nestedUpdateCount = 0);
        rootDidHavePassiveEffects || finalizeRender(endTime, commitEndTime);
        flushSyncWorkAcrossRoots_impl(0, !1);
      }
    }
    function makeErrorInfo(componentStack) {
      componentStack = { componentStack: componentStack };
      Object.defineProperty(componentStack, "digest", {
        get: function () {
          console.error(
            'You are accessing "digest" from the errorInfo object passed to onRecoverableError. This property is no longer provided as part of errorInfo but can be accessed as a property of the Error instance itself.'
          );
        }
      });
      return componentStack;
    }
    function releaseRootPooledCache(root, remainingLanes) {
      0 === (root.pooledCacheLanes &= remainingLanes) &&
        ((remainingLanes = root.pooledCache),
        null != remainingLanes &&
          ((root.pooledCache = null), releaseCache(remainingLanes)));
    }
    function flushPendingEffects() {
      flushMutationEffects();
      flushLayoutEffects();
      flushSpawnedWork();
      return flushPassiveEffects();
    }
    function flushPassiveEffects() {
      if (pendingEffectsStatus !== PENDING_PASSIVE_PHASE) return !1;
      var root = pendingEffectsRoot,
        remainingLanes = pendingEffectsRemainingLanes;
      pendingEffectsRemainingLanes = 0;
      var renderPriority = lanesToEventPriority(pendingEffectsLanes),
        priority =
          0 === DefaultEventPriority || DefaultEventPriority > renderPriority
            ? DefaultEventPriority
            : renderPriority;
      renderPriority = ReactSharedInternals.T;
      var previousPriority = ReactDOMSharedInternals.p;
      try {
        ReactDOMSharedInternals.p = priority;
        ReactSharedInternals.T = null;
        var transitions = pendingPassiveTransitions;
        pendingPassiveTransitions = null;
        priority = pendingEffectsRoot;
        var lanes = pendingEffectsLanes;
        pendingEffectsStatus = NO_PENDING_EFFECTS;
        pendingFinishedWork = pendingEffectsRoot = null;
        pendingEffectsLanes = 0;
        if ((executionContext & (RenderContext | CommitContext)) !== NoContext)
          throw Error("Cannot flush passive effects while already rendering.");
        setCurrentTrackFromLanes(lanes);
        isFlushingPassiveEffects = !0;
        didScheduleUpdateDuringPassiveEffects = !1;
        var passiveEffectStartTime = 0;
        commitErrors = null;
        passiveEffectStartTime = now$1();
        if (pendingDelayedCommitReason === ANIMATION_STARTED_COMMIT)
          logAnimatingPhase(
            commitEndTime,
            passiveEffectStartTime,
            animatingTask
          );
        else {
          var startTime = commitEndTime,
            endTime = passiveEffectStartTime,
            delayedUntilPaint =
              pendingDelayedCommitReason === DELAYED_PASSIVE_COMMIT;
          !supportsUserTiming ||
            endTime <= startTime ||
            (workInProgressUpdateTask
              ? workInProgressUpdateTask.run(
                  console.timeStamp.bind(
                    console,
                    delayedUntilPaint ? "Waiting for Paint" : "Waiting",
                    startTime,
                    endTime,
                    currentTrack,
                    LANES_TRACK_GROUP,
                    "secondary-light"
                  )
                )
              : console.timeStamp(
                  delayedUntilPaint ? "Waiting for Paint" : "Waiting",
                  startTime,
                  endTime,
                  currentTrack,
                  LANES_TRACK_GROUP,
                  "secondary-light"
                ));
        }
        startTime = executionContext;
        executionContext |= CommitContext;
        var finishedWork = priority.current;
        resetComponentEffectTimers();
        commitPassiveUnmountOnFiber(finishedWork);
        var finishedWork$jscomp$0 = priority.current;
        finishedWork = pendingEffectsRenderEndTime;
        resetComponentEffectTimers();
        commitPassiveMountOnFiber(
          priority,
          finishedWork$jscomp$0,
          lanes,
          transitions,
          finishedWork
        );
        commitDoubleInvokeEffectsInDEV(priority);
        executionContext = startTime;
        var passiveEffectsEndTime = now$1();
        finishedWork$jscomp$0 = passiveEffectStartTime;
        finishedWork = workInProgressUpdateTask;
        null !== commitErrors
          ? logCommitErrored(
              finishedWork$jscomp$0,
              passiveEffectsEndTime,
              commitErrors,
              !0,
              finishedWork
            )
          : !supportsUserTiming ||
            passiveEffectsEndTime <= finishedWork$jscomp$0 ||
            (finishedWork
              ? finishedWork.run(
                  console.timeStamp.bind(
                    console,
                    "Remaining Effects",
                    finishedWork$jscomp$0,
                    passiveEffectsEndTime,
                    currentTrack,
                    LANES_TRACK_GROUP,
                    "secondary-dark"
                  )
                )
              : console.timeStamp(
                  "Remaining Effects",
                  finishedWork$jscomp$0,
                  passiveEffectsEndTime,
                  currentTrack,
                  LANES_TRACK_GROUP,
                  "secondary-dark"
                ));
        finalizeRender(lanes, passiveEffectsEndTime);
        flushSyncWorkAcrossRoots_impl(0, !1);
        didScheduleUpdateDuringPassiveEffects
          ? priority === rootWithPassiveNestedUpdates
            ? nestedPassiveUpdateCount++
            : ((nestedPassiveUpdateCount = 0),
              (rootWithPassiveNestedUpdates = priority))
          : (nestedPassiveUpdateCount = 0);
        didScheduleUpdateDuringPassiveEffects = isFlushingPassiveEffects = !1;
        if (
          injectedHook &&
          "function" === typeof injectedHook.onPostCommitFiberRoot
        )
          try {
            injectedHook.onPostCommitFiberRoot(rendererID, priority);
          } catch (err) {
            hasLoggedError ||
              ((hasLoggedError = !0),
              console.error(
                "React instrumentation encountered an error: %o",
                err
              ));
          }
        var stateNode = priority.current.stateNode;
        stateNode.effectDuration = 0;
        stateNode.passiveEffectDuration = 0;
        return !0;
      } finally {
        (ReactDOMSharedInternals.p = previousPriority),
          (ReactSharedInternals.T = renderPriority),
          releaseRootPooledCache(root, remainingLanes);
      }
    }
    function captureCommitPhaseErrorOnRoot(rootFiber, sourceFiber, error) {
      sourceFiber = createCapturedValueAtFiber(error, sourceFiber);
      recordEffectError(sourceFiber);
      sourceFiber = createRootErrorUpdate(rootFiber.stateNode, sourceFiber, 2);
      rootFiber = enqueueUpdate(rootFiber, sourceFiber, 2);
      null !== rootFiber &&
        (markRootUpdated$1(rootFiber, 2), ensureRootIsScheduled(rootFiber));
    }
    function captureCommitPhaseError(
      sourceFiber,
      nearestMountedAncestor,
      error
    ) {
      isRunningInsertionEffect = !1;
      if (3 === sourceFiber.tag)
        captureCommitPhaseErrorOnRoot(sourceFiber, sourceFiber, error);
      else {
        for (; null !== nearestMountedAncestor; ) {
          if (3 === nearestMountedAncestor.tag) {
            captureCommitPhaseErrorOnRoot(
              nearestMountedAncestor,
              sourceFiber,
              error
            );
            return;
          }
          if (1 === nearestMountedAncestor.tag) {
            var instance = nearestMountedAncestor.stateNode;
            if (
              "function" ===
                typeof nearestMountedAncestor.type.getDerivedStateFromError ||
              ("function" === typeof instance.componentDidCatch &&
                (null === legacyErrorBoundariesThatAlreadyFailed ||
                  !legacyErrorBoundariesThatAlreadyFailed.has(instance)))
            ) {
              sourceFiber = createCapturedValueAtFiber(error, sourceFiber);
              recordEffectError(sourceFiber);
              error = createClassErrorUpdate(2);
              instance = enqueueUpdate(nearestMountedAncestor, error, 2);
              null !== instance &&
                (initializeClassErrorUpdate(
                  error,
                  instance,
                  nearestMountedAncestor,
                  sourceFiber
                ),
                markRootUpdated$1(instance, 2),
                ensureRootIsScheduled(instance));
              return;
            }
          }
          nearestMountedAncestor = nearestMountedAncestor.return;
        }
        console.error(
          "Internal React error: Attempted to capture a commit phase error inside a detached tree. This indicates a bug in React. Potential causes include deleting the same fiber more than once, committing an already-finished tree, or an inconsistent return pointer.\n\nError message:\n\n%s",
          error
        );
      }
    }
    function attachPingListener(root, wakeable, lanes) {
      var pingCache = root.pingCache;
      if (null === pingCache) {
        pingCache = root.pingCache = new PossiblyWeakMap();
        var threadIDs = new Set();
        pingCache.set(wakeable, threadIDs);
      } else
        (threadIDs = pingCache.get(wakeable)),
          void 0 === threadIDs &&
            ((threadIDs = new Set()), pingCache.set(wakeable, threadIDs));
      threadIDs.has(lanes) ||
        ((workInProgressRootDidAttachPingListener = !0),
        threadIDs.add(lanes),
        (pingCache = pingSuspendedRoot.bind(null, root, wakeable, lanes)),
        isDevToolsPresent && restorePendingUpdaters(root, lanes),
        wakeable.then(pingCache, pingCache));
    }
    function pingSuspendedRoot(root, wakeable, pingedLanes) {
      var pingCache = root.pingCache;
      null !== pingCache && pingCache.delete(wakeable);
      root.pingedLanes |= root.suspendedLanes & pingedLanes;
      root.warmLanes &= ~pingedLanes;
      0 !== (pingedLanes & 127)
        ? 0 > blockingUpdateTime &&
          ((blockingClampTime = blockingUpdateTime = now()),
          (blockingUpdateTask = createTask("Promise Resolved")),
          (blockingUpdateType = PINGED_UPDATE))
        : 0 !== (pingedLanes & 4194048) &&
          0 > transitionUpdateTime &&
          ((transitionClampTime = transitionUpdateTime = now()),
          (transitionUpdateTask = createTask("Promise Resolved")),
          (transitionUpdateType = PINGED_UPDATE));
      isConcurrentActEnvironment() &&
        null === ReactSharedInternals.actQueue &&
        console.error(
          "A suspended resource finished loading inside a test, but the event was not wrapped in act(...).\n\nWhen testing, code that resolves suspended data should be wrapped into act(...):\n\nact(() => {\n  /* finish loading suspended data */\n});\n/* assert on the output */\n\nThis ensures that you're testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act"
        );
      workInProgressRoot === root &&
        (workInProgressRootRenderLanes & pingedLanes) === pingedLanes &&
        (workInProgressRootExitStatus === RootSuspendedWithDelay ||
        (workInProgressRootExitStatus === RootSuspended &&
          (workInProgressRootRenderLanes & 62914560) ===
            workInProgressRootRenderLanes &&
          now$1() - globalMostRecentFallbackTime < FALLBACK_THROTTLE_MS)
          ? (executionContext & RenderContext) === NoContext &&
            prepareFreshStack(root, 0)
          : (workInProgressRootPingedLanes |= pingedLanes),
        workInProgressSuspendedRetryLanes === workInProgressRootRenderLanes &&
          (workInProgressSuspendedRetryLanes = 0));
      ensureRootIsScheduled(root);
    }
    function retryTimedOutBoundary(boundaryFiber, retryLane) {
      0 === retryLane && (retryLane = claimNextRetryLane());
      boundaryFiber = enqueueConcurrentRenderForLane(boundaryFiber, retryLane);
      null !== boundaryFiber &&
        (markRootUpdated$1(boundaryFiber, retryLane),
        ensureRootIsScheduled(boundaryFiber));
    }
    function retryDehydratedSuspenseBoundary(boundaryFiber) {
      var suspenseState = boundaryFiber.memoizedState,
        retryLane = 0;
      null !== suspenseState && (retryLane = suspenseState.retryLane);
      retryTimedOutBoundary(boundaryFiber, retryLane);
    }
    function resolveRetryWakeable(boundaryFiber, wakeable) {
      var retryLane = 0;
      switch (boundaryFiber.tag) {
        case 31:
        case 13:
          var retryCache = boundaryFiber.stateNode;
          var suspenseState = boundaryFiber.memoizedState;
          null !== suspenseState && (retryLane = suspenseState.retryLane);
          break;
        case 19:
          retryCache = boundaryFiber.stateNode;
          break;
        case 22:
          retryCache = boundaryFiber.stateNode._retryCache;
          break;
        default:
          throw Error(
            "Pinged unknown suspense boundary type. This is probably a bug in React."
          );
      }
      null !== retryCache && retryCache.delete(wakeable);
      retryTimedOutBoundary(boundaryFiber, retryLane);
    }
    function recursivelyTraverseAndDoubleInvokeEffectsInDEV(
      root$jscomp$0,
      parentFiber,
      isInStrictMode
    ) {
      if (0 !== (parentFiber.subtreeFlags & 67117056))
        for (parentFiber = parentFiber.child; null !== parentFiber; ) {
          var root = root$jscomp$0,
            fiber = parentFiber,
            isStrictModeFiber = fiber.type === REACT_STRICT_MODE_TYPE;
          isStrictModeFiber = isInStrictMode || isStrictModeFiber;
          22 !== fiber.tag
            ? fiber.flags & 67108864
              ? isStrictModeFiber &&
                runWithFiberInDEV(
                  fiber,
                  doubleInvokeEffectsOnFiber,
                  root,
                  fiber
                )
              : recursivelyTraverseAndDoubleInvokeEffectsInDEV(
                  root,
                  fiber,
                  isStrictModeFiber
                )
            : null === fiber.memoizedState &&
              (isStrictModeFiber && fiber.flags & 8192
                ? runWithFiberInDEV(
                    fiber,
                    doubleInvokeEffectsOnFiber,
                    root,
                    fiber
                  )
                : fiber.subtreeFlags & 67108864 &&
                  runWithFiberInDEV(
                    fiber,
                    recursivelyTraverseAndDoubleInvokeEffectsInDEV,
                    root,
                    fiber,
                    isStrictModeFiber
                  ));
          parentFiber = parentFiber.sibling;
        }
    }
    function doubleInvokeEffectsOnFiber(root, fiber) {
      setIsStrictModeForDevtools(!0);
      try {
        disappearLayoutEffects(fiber),
          disconnectPassiveEffect(fiber),
          reappearLayoutEffects(root, fiber.alternate, fiber, !1),
          reconnectPassiveEffects(root, fiber, 0, null, !1, 0);
      } finally {
        setIsStrictModeForDevtools(!1);
      }
    }
    function commitDoubleInvokeEffectsInDEV(root) {
      var doubleInvokeEffects = !0;
      root.current.mode & (StrictLegacyMode | StrictEffectsMode) ||
        (doubleInvokeEffects = !1);
      recursivelyTraverseAndDoubleInvokeEffectsInDEV(
        root,
        root.current,
        doubleInvokeEffects
      );
    }
    function warnAboutUpdateOnNotYetMountedFiberInDEV(fiber) {
      if ((executionContext & RenderContext) === NoContext) {
        var tag = fiber.tag;
        if (
          3 === tag ||
          1 === tag ||
          0 === tag ||
          11 === tag ||
          14 === tag ||
          15 === tag
        ) {
          tag = getComponentNameFromFiber(fiber) || "ReactComponent";
          if (null !== didWarnStateUpdateForNotYetMountedComponent) {
            if (didWarnStateUpdateForNotYetMountedComponent.has(tag)) return;
            didWarnStateUpdateForNotYetMountedComponent.add(tag);
          } else didWarnStateUpdateForNotYetMountedComponent = new Set([tag]);
          runWithFiberInDEV(fiber, function () {
            console.error(
              "Can't perform a React state update on a component that hasn't mounted yet. This indicates that you have a side-effect in your render function that asynchronously tries to update the component. Move this work to useEffect instead."
            );
          });
        }
      }
    }
    function restorePendingUpdaters(root, lanes) {
      isDevToolsPresent &&
        root.memoizedUpdaters.forEach(function (schedulingFiber) {
          addFiberToLanesMap(root, schedulingFiber, lanes);
        });
    }
    function scheduleCallback$1(priorityLevel, callback) {
      var actQueue = ReactSharedInternals.actQueue;
      return null !== actQueue
        ? (actQueue.push(callback), fakeActCallbackNode$1)
        : scheduleCallback$3(priorityLevel, callback);
    }
    function warnIfUpdatesNotWrappedWithActDEV(fiber) {
      isConcurrentActEnvironment() &&
        null === ReactSharedInternals.actQueue &&
        runWithFiberInDEV(fiber, function () {
          console.error(
            "An update to %s inside a test was not wrapped in act(...).\n\nWhen testing, code that causes React state updates should be wrapped into act(...):\n\nact(() => {\n  /* fire events that update state */\n});\n/* assert on the output */\n\nThis ensures that you're testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act",
            getComponentNameFromFiber(fiber)
          );
        });
    }
    function ensureRootIsScheduled(root) {
      root !== lastScheduledRoot &&
        null === root.next &&
        (null === lastScheduledRoot
          ? (firstScheduledRoot = lastScheduledRoot = root)
          : (lastScheduledRoot = lastScheduledRoot.next = root));
      mightHavePendingSyncWork = !0;
      null !== ReactSharedInternals.actQueue
        ? didScheduleMicrotask_act ||
          ((didScheduleMicrotask_act = !0), scheduleImmediateRootScheduleTask())
        : didScheduleMicrotask ||
          ((didScheduleMicrotask = !0), scheduleImmediateRootScheduleTask());
    }
    function flushSyncWorkAcrossRoots_impl(syncTransitionLanes, onlyLegacy) {
      if (!isFlushingWork && mightHavePendingSyncWork) {
        isFlushingWork = !0;
        do {
          var didPerformSomeWork = !1;
          for (var root = firstScheduledRoot; null !== root; ) {
            if (!onlyLegacy)
              if (0 !== syncTransitionLanes) {
                var pendingLanes = root.pendingLanes;
                if (0 === pendingLanes) var nextLanes = 0;
                else {
                  var suspendedLanes = root.suspendedLanes,
                    pingedLanes = root.pingedLanes;
                  nextLanes =
                    (1 << (31 - clz32(42 | syncTransitionLanes) + 1)) - 1;
                  nextLanes &= pendingLanes & ~(suspendedLanes & ~pingedLanes);
                  nextLanes =
                    nextLanes & 201326741
                      ? (nextLanes & 201326741) | 1
                      : nextLanes
                        ? nextLanes | 2
                        : 0;
                }
                0 !== nextLanes &&
                  ((didPerformSomeWork = !0),
                  performSyncWorkOnRoot(root, nextLanes));
              } else
                (nextLanes = workInProgressRootRenderLanes),
                  (nextLanes = getNextLanes(
                    root,
                    root === workInProgressRoot ? nextLanes : 0,
                    null !== root.cancelPendingCommit ||
                      root.timeoutHandle !== noTimeout
                  )),
                  0 === (nextLanes & 3) ||
                    checkIfRootIsPrerendering(root, nextLanes) ||
                    ((didPerformSomeWork = !0),
                    performSyncWorkOnRoot(root, nextLanes));
            root = root.next;
          }
        } while (didPerformSomeWork);
        isFlushingWork = !1;
      }
    }
    function processRootScheduleInImmediateTask() {
      schedulerEvent = window.event;
      processRootScheduleInMicrotask();
    }
    function processRootScheduleInMicrotask() {
      mightHavePendingSyncWork =
        didScheduleMicrotask_act =
        didScheduleMicrotask =
          !1;
      var syncTransitionLanes = 0;
      0 !== currentEventTransitionLane &&
        shouldAttemptEagerTransition() &&
        (syncTransitionLanes = currentEventTransitionLane);
      for (
        var currentTime = now$1(), prev = null, root = firstScheduledRoot;
        null !== root;

      ) {
        var next = root.next,
          nextLanes = scheduleTaskForRootDuringMicrotask(root, currentTime);
        if (0 === nextLanes)
          (root.next = null),
            null === prev ? (firstScheduledRoot = next) : (prev.next = next),
            null === next && (lastScheduledRoot = prev);
        else if (
          ((prev = root), 0 !== syncTransitionLanes || 0 !== (nextLanes & 3))
        )
          mightHavePendingSyncWork = !0;
        root = next;
      }
      (pendingEffectsStatus !== NO_PENDING_EFFECTS &&
        pendingEffectsStatus !== PENDING_PASSIVE_PHASE) ||
        flushSyncWorkAcrossRoots_impl(syncTransitionLanes, !1);
      0 !== currentEventTransitionLane && (currentEventTransitionLane = 0);
    }
    function scheduleTaskForRootDuringMicrotask(root, currentTime) {
      for (
        var suspendedLanes = root.suspendedLanes,
          pingedLanes = root.pingedLanes,
          expirationTimes = root.expirationTimes,
          lanes = root.pendingLanes & -62914561;
        0 < lanes;

      ) {
        var index = 31 - clz32(lanes),
          lane = 1 << index,
          expirationTime = expirationTimes[index];
        if (-1 === expirationTime) {
          if (0 === (lane & suspendedLanes) || 0 !== (lane & pingedLanes))
            expirationTimes[index] = computeExpirationTime(lane, currentTime);
        } else expirationTime <= currentTime && (root.expiredLanes |= lane);
        lanes &= ~lane;
      }
      currentTime = workInProgressRoot;
      suspendedLanes = workInProgressRootRenderLanes;
      suspendedLanes = getNextLanes(
        root,
        root === currentTime ? suspendedLanes : 0,
        null !== root.cancelPendingCommit || root.timeoutHandle !== noTimeout
      );
      pingedLanes = root.callbackNode;
      if (
        0 === suspendedLanes ||
        (root === currentTime &&
          (workInProgressSuspendedReason === SuspendedOnData ||
            workInProgressSuspendedReason === SuspendedOnAction)) ||
        null !== root.cancelPendingCommit
      )
        return (
          null !== pingedLanes && cancelCallback(pingedLanes),
          (root.callbackNode = null),
          (root.callbackPriority = 0)
        );
      if (
        0 === (suspendedLanes & 3) ||
        checkIfRootIsPrerendering(root, suspendedLanes)
      ) {
        currentTime = suspendedLanes & -suspendedLanes;
        if (
          currentTime !== root.callbackPriority ||
          (null !== ReactSharedInternals.actQueue &&
            pingedLanes !== fakeActCallbackNode)
        )
          cancelCallback(pingedLanes);
        else return currentTime;
        switch (lanesToEventPriority(suspendedLanes)) {
          case DiscreteEventPriority:
          case ContinuousEventPriority:
            suspendedLanes = UserBlockingPriority;
            break;
          case DefaultEventPriority:
            suspendedLanes = NormalPriority$1;
            break;
          case IdleEventPriority:
            suspendedLanes = IdlePriority;
            break;
          default:
            suspendedLanes = NormalPriority$1;
        }
        pingedLanes = performWorkOnRootViaSchedulerTask.bind(null, root);
        null !== ReactSharedInternals.actQueue
          ? (ReactSharedInternals.actQueue.push(pingedLanes),
            (suspendedLanes = fakeActCallbackNode))
          : (suspendedLanes = scheduleCallback$3(suspendedLanes, pingedLanes));
        root.callbackPriority = currentTime;
        root.callbackNode = suspendedLanes;
        return currentTime;
      }
      null !== pingedLanes && cancelCallback(pingedLanes);
      root.callbackPriority = 2;
      root.callbackNode = null;
      return 2;
    }
    function performWorkOnRootViaSchedulerTask(root, didTimeout) {
      nestedUpdateScheduled = currentUpdateIsNested = !1;
      schedulerEvent = window.event;
      if (
        pendingEffectsStatus !== NO_PENDING_EFFECTS &&
        pendingEffectsStatus !== PENDING_PASSIVE_PHASE
      )
        return (root.callbackNode = null), (root.callbackPriority = 0), null;
      var originalCallbackNode = root.callbackNode;
      pendingDelayedCommitReason === IMMEDIATE_COMMIT &&
        (pendingDelayedCommitReason = DELAYED_PASSIVE_COMMIT);
      if (flushPendingEffects() && root.callbackNode !== originalCallbackNode)
        return null;
      var workInProgressRootRenderLanes$jscomp$0 =
        workInProgressRootRenderLanes;
      workInProgressRootRenderLanes$jscomp$0 = getNextLanes(
        root,
        root === workInProgressRoot
          ? workInProgressRootRenderLanes$jscomp$0
          : 0,
        null !== root.cancelPendingCommit || root.timeoutHandle !== noTimeout
      );
      if (0 === workInProgressRootRenderLanes$jscomp$0) return null;
      performWorkOnRoot(
        root,
        workInProgressRootRenderLanes$jscomp$0,
        didTimeout
      );
      scheduleTaskForRootDuringMicrotask(root, now$1());
      return null != root.callbackNode &&
        root.callbackNode === originalCallbackNode
        ? performWorkOnRootViaSchedulerTask.bind(null, root)
        : null;
    }
    function performSyncWorkOnRoot(root, lanes) {
      if (flushPendingEffects()) return null;
      currentUpdateIsNested = nestedUpdateScheduled;
      nestedUpdateScheduled = !1;
      performWorkOnRoot(root, lanes, !0);
    }
    function cancelCallback(callbackNode) {
      callbackNode !== fakeActCallbackNode &&
        null !== callbackNode &&
        cancelCallback$1(callbackNode);
    }
    function scheduleImmediateRootScheduleTask() {
      null !== ReactSharedInternals.actQueue &&
        ReactSharedInternals.actQueue.push(function () {
          processRootScheduleInMicrotask();
          return null;
        });
      scheduleMicrotask(function () {
        (executionContext & (RenderContext | CommitContext)) !== NoContext
          ? scheduleCallback$3(
              ImmediatePriority,
              processRootScheduleInImmediateTask
            )
          : processRootScheduleInMicrotask();
      });
    }
    function requestTransitionLane() {
      if (0 === currentEventTransitionLane) {
        var actionScopeLane = currentEntangledLane;
        0 === actionScopeLane &&
          ((actionScopeLane = nextTransitionUpdateLane),
          (nextTransitionUpdateLane <<= 1),
          0 === (nextTransitionUpdateLane & 261888) &&
            (nextTransitionUpdateLane = 256));
        currentEventTransitionLane = actionScopeLane;
      }
      return currentEventTransitionLane;
    }
    function coerceFormActionProp(actionProp) {
      if (
        null == actionProp ||
        "symbol" === typeof actionProp ||
        "boolean" === typeof actionProp
      )
        return null;
      if ("function" === typeof actionProp) return actionProp;
      checkAttributeStringCoercion(actionProp, "action");
      return sanitizeURL("" + actionProp);
    }
    function createFormDataWithSubmitter(form, submitter) {
      var temp = submitter.ownerDocument.createElement("input");
      temp.name = submitter.name;
      temp.value = submitter.value;
      form.id && temp.setAttribute("form", form.id);
      submitter.parentNode.insertBefore(temp, submitter);
      form = new FormData(form);
      temp.parentNode.removeChild(temp);
      return form;
    }
    function extractEvents$1(
      dispatchQueue,
      domEventName,
      maybeTargetInst,
      nativeEvent,
      nativeEventTarget
    ) {
      if (
        "submit" === domEventName &&
        maybeTargetInst &&
        maybeTargetInst.stateNode === nativeEventTarget
      ) {
        var action = coerceFormActionProp(
            (nativeEventTarget[internalPropsKey] || null).action
          ),
          submitter = nativeEvent.submitter;
        submitter &&
          ((domEventName = (domEventName = submitter[internalPropsKey] || null)
            ? coerceFormActionProp(domEventName.formAction)
            : submitter.getAttribute("formAction")),
          null !== domEventName &&
            ((action = domEventName), (submitter = null)));
        var event = new SyntheticEvent(
          "action",
          "action",
          null,
          nativeEvent,
          nativeEventTarget
        );
        dispatchQueue.push({
          event: event,
          listeners: [
            {
              instance: null,
              listener: function () {
                if (nativeEvent.defaultPrevented) {
                  if (0 !== currentEventTransitionLane) {
                    var formData = submitter
                        ? createFormDataWithSubmitter(
                            nativeEventTarget,
                            submitter
                          )
                        : new FormData(nativeEventTarget),
                      pendingState = {
                        pending: !0,
                        data: formData,
                        method: nativeEventTarget.method,
                        action: action
                      };
                    Object.freeze(pendingState);
                    startHostTransition(
                      maybeTargetInst,
                      pendingState,
                      null,
                      formData
                    );
                  }
                } else
                  "function" === typeof action &&
                    (event.preventDefault(),
                    (formData = submitter
                      ? createFormDataWithSubmitter(
                          nativeEventTarget,
                          submitter
                        )
                      : new FormData(nativeEventTarget)),
                    (pendingState = {
                      pending: !0,
                      data: formData,
                      method: nativeEventTarget.method,
                      action: action
                    }),
                    Object.freeze(pendingState),
                    startHostTransition(
                      maybeTargetInst,
                      pendingState,
                      action,
                      formData
                    ));
              },
              currentTarget: nativeEventTarget
            }
          ]
        });
      }
    }
    function executeDispatch(event, listener, currentTarget) {
      event.currentTarget = currentTarget;
      try {
        listener(event);
      } catch (error) {
        reportGlobalError(error);
      }
      event.currentTarget = null;
    }
    function processDispatchQueue(dispatchQueue, eventSystemFlags) {
      eventSystemFlags = 0 !== (eventSystemFlags & 4);
      for (var i = 0; i < dispatchQueue.length; i++) {
        var _dispatchQueue$i = dispatchQueue[i];
        a: {
          var previousInstance = void 0,
            event = _dispatchQueue$i.event;
          _dispatchQueue$i = _dispatchQueue$i.listeners;
          if (eventSystemFlags)
            for (
              var i$jscomp$0 = _dispatchQueue$i.length - 1;
              0 <= i$jscomp$0;
              i$jscomp$0--
            ) {
              var _dispatchListeners$i = _dispatchQueue$i[i$jscomp$0],
                instance = _dispatchListeners$i.instance,
                currentTarget = _dispatchListeners$i.currentTarget;
              _dispatchListeners$i = _dispatchListeners$i.listener;
              if (instance !== previousInstance && event.isPropagationStopped())
                break a;
              null !== instance
                ? runWithFiberInDEV(
                    instance,
                    executeDispatch,
                    event,
                    _dispatchListeners$i,
                    currentTarget
                  )
                : executeDispatch(event, _dispatchListeners$i, currentTarget);
              previousInstance = instance;
            }
          else
            for (
              i$jscomp$0 = 0;
              i$jscomp$0 < _dispatchQueue$i.length;
              i$jscomp$0++
            ) {
              _dispatchListeners$i = _dispatchQueue$i[i$jscomp$0];
              instance = _dispatchListeners$i.instance;
              currentTarget = _dispatchListeners$i.currentTarget;
              _dispatchListeners$i = _dispatchListeners$i.listener;
              if (instance !== previousInstance && event.isPropagationStopped())
                break a;
              null !== instance
                ? runWithFiberInDEV(
                    instance,
                    executeDispatch,
                    event,
                    _dispatchListeners$i,
                    currentTarget
                  )
                : executeDispatch(event, _dispatchListeners$i, currentTarget);
              previousInstance = instance;
            }
        }
      }
    }
    function listenToNonDelegatedEvent(domEventName, targetElement) {
      nonDelegatedEvents.has(domEventName) ||
        console.error(
          'Did not expect a listenToNonDelegatedEvent() call for "%s". This is a bug in React. Please file an issue.',
          domEventName
        );
      var listenerSet = targetElement[internalEventHandlersKey];
      void 0 === listenerSet &&
        (listenerSet = targetElement[internalEventHandlersKey] = new Set());
      var listenerSetKey = domEventName + "__bubble";
      listenerSet.has(listenerSetKey) ||
        (addTrappedEventListener(targetElement, domEventName, 2, !1),
        listenerSet.add(listenerSetKey));
    }
    function listenToNativeEvent(domEventName, isCapturePhaseListener, target) {
      nonDelegatedEvents.has(domEventName) &&
        !isCapturePhaseListener &&
        console.error(
          'Did not expect a listenToNativeEvent() call for "%s" in the bubble phase. This is a bug in React. Please file an issue.',
          domEventName
        );
      var eventSystemFlags = 0;
      isCapturePhaseListener && (eventSystemFlags |= 4);
      addTrappedEventListener(
        target,
        domEventName,
        eventSystemFlags,
        isCapturePhaseListener
      );
    }
    function listenToAllSupportedEvents(rootContainerElement) {
      if (!rootContainerElement[listeningMarker]) {
        rootContainerElement[listeningMarker] = !0;
        allNativeEvents.forEach(function (domEventName) {
          "selectionchange" !== domEventName &&
            (nonDelegatedEvents.has(domEventName) ||
              listenToNativeEvent(domEventName, !1, rootContainerElement),
            listenToNativeEvent(domEventName, !0, rootContainerElement));
        });
        var ownerDocument =
          9 === rootContainerElement.nodeType
            ? rootContainerElement
            : rootContainerElement.ownerDocument;
        null === ownerDocument ||
          ownerDocument[listeningMarker] ||
          ((ownerDocument[listeningMarker] = !0),
          listenToNativeEvent("selectionchange", !1, ownerDocument));
      }
    }
    function addTrappedEventListener(
      targetContainer,
      domEventName,
      eventSystemFlags,
      isCapturePhaseListener
    ) {
      switch (getEventPriority(domEventName)) {
        case DiscreteEventPriority:
          var listenerWrapper = dispatchDiscreteEvent;
          break;
        case ContinuousEventPriority:
          listenerWrapper = dispatchContinuousEvent;
          break;
        default:
          listenerWrapper = dispatchEvent;
      }
      eventSystemFlags = listenerWrapper.bind(
        null,
        domEventName,
        eventSystemFlags,
        targetContainer
      );
      listenerWrapper = void 0;
      !passiveBrowserEventsSupported ||
        ("touchstart" !== domEventName &&
          "touchmove" !== domEventName &&
          "wheel" !== domEventName) ||
        (listenerWrapper = !0);
      isCapturePhaseListener
        ? void 0 !== listenerWrapper
          ? targetContainer.addEventListener(domEventName, eventSystemFlags, {
              capture: !0,
              passive: listenerWrapper
            })
          : targetContainer.addEventListener(domEventName, eventSystemFlags, !0)
        : void 0 !== listenerWrapper
          ? targetContainer.addEventListener(domEventName, eventSystemFlags, {
              passive: listenerWrapper
            })
          : targetContainer.addEventListener(
              domEventName,
              eventSystemFlags,
              !1
            );
    }
    function dispatchEventForPluginEventSystem(
      domEventName,
      eventSystemFlags,
      nativeEvent,
      targetInst$jscomp$0,
      targetContainer
    ) {
      var ancestorInst = targetInst$jscomp$0;
      if (
        0 === (eventSystemFlags & 1) &&
        0 === (eventSystemFlags & 2) &&
        null !== targetInst$jscomp$0
      )
        a: for (;;) {
          if (null === targetInst$jscomp$0) return;
          var nodeTag = targetInst$jscomp$0.tag;
          if (3 === nodeTag || 4 === nodeTag) {
            var container = targetInst$jscomp$0.stateNode.containerInfo;
            if (container === targetContainer) break;
            if (4 === nodeTag)
              for (nodeTag = targetInst$jscomp$0.return; null !== nodeTag; ) {
                var grandTag = nodeTag.tag;
                if (
                  (3 === grandTag || 4 === grandTag) &&
                  nodeTag.stateNode.containerInfo === targetContainer
                )
                  return;
                nodeTag = nodeTag.return;
              }
            for (; null !== container; ) {
              nodeTag = getClosestInstanceFromNode(container);
              if (null === nodeTag) return;
              grandTag = nodeTag.tag;
              if (
                5 === grandTag ||
                6 === grandTag ||
                26 === grandTag ||
                27 === grandTag
              ) {
                targetInst$jscomp$0 = ancestorInst = nodeTag;
                continue a;
              }
              container = container.parentNode;
            }
          }
          targetInst$jscomp$0 = targetInst$jscomp$0.return;
        }
      batchedUpdates$1(function () {
        var targetInst = ancestorInst,
          nativeEventTarget = getEventTarget(nativeEvent),
          dispatchQueue = [];
        a: {
          var reactName = topLevelEventsToReactNames.get(domEventName);
          if (void 0 !== reactName) {
            var SyntheticEventCtor = SyntheticEvent,
              reactEventType = domEventName;
            switch (domEventName) {
              case "keypress":
                if (0 === getEventCharCode(nativeEvent)) break a;
              case "keydown":
              case "keyup":
                SyntheticEventCtor = SyntheticKeyboardEvent;
                break;
              case "focusin":
                reactEventType = "focus";
                SyntheticEventCtor = SyntheticFocusEvent;
                break;
              case "focusout":
                reactEventType = "blur";
                SyntheticEventCtor = SyntheticFocusEvent;
                break;
              case "beforeblur":
              case "afterblur":
                SyntheticEventCtor = SyntheticFocusEvent;
                break;
              case "click":
                if (2 === nativeEvent.button) break a;
              case "auxclick":
              case "dblclick":
              case "mousedown":
              case "mousemove":
              case "mouseup":
              case "mouseout":
              case "mouseover":
              case "contextmenu":
                SyntheticEventCtor = SyntheticMouseEvent;
                break;
              case "drag":
              case "dragend":
              case "dragenter":
              case "dragexit":
              case "dragleave":
              case "dragover":
              case "dragstart":
              case "drop":
                SyntheticEventCtor = SyntheticDragEvent;
                break;
              case "touchcancel":
              case "touchend":
              case "touchmove":
              case "touchstart":
                SyntheticEventCtor = SyntheticTouchEvent;
                break;
              case ANIMATION_END:
              case ANIMATION_ITERATION:
              case ANIMATION_START:
                SyntheticEventCtor = SyntheticAnimationEvent;
                break;
              case TRANSITION_END:
                SyntheticEventCtor = SyntheticTransitionEvent;
                break;
              case "scroll":
              case "scrollend":
                SyntheticEventCtor = SyntheticUIEvent;
                break;
              case "wheel":
                SyntheticEventCtor = SyntheticWheelEvent;
                break;
              case "copy":
              case "cut":
              case "paste":
                SyntheticEventCtor = SyntheticClipboardEvent;
                break;
              case "gotpointercapture":
              case "lostpointercapture":
              case "pointercancel":
              case "pointerdown":
              case "pointermove":
              case "pointerout":
              case "pointerover":
              case "pointerup":
                SyntheticEventCtor = SyntheticPointerEvent;
                break;
              case "toggle":
              case "beforetoggle":
                SyntheticEventCtor = SyntheticToggleEvent;
            }
            var inCapturePhase = 0 !== (eventSystemFlags & 4),
              accumulateTargetOnly =
                !inCapturePhase &&
                ("scroll" === domEventName || "scrollend" === domEventName),
              reactEventName = inCapturePhase
                ? null !== reactName
                  ? reactName + "Capture"
                  : null
                : reactName;
            inCapturePhase = [];
            for (
              var instance = targetInst, lastHostComponent;
              null !== instance;

            ) {
              var _instance2 = instance;
              lastHostComponent = _instance2.stateNode;
              _instance2 = _instance2.tag;
              (5 !== _instance2 && 26 !== _instance2 && 27 !== _instance2) ||
                null === lastHostComponent ||
                null === reactEventName ||
                ((_instance2 = getListener(instance, reactEventName)),
                null != _instance2 &&
                  inCapturePhase.push(
                    createDispatchListener(
                      instance,
                      _instance2,
                      lastHostComponent
                    )
                  ));
              if (accumulateTargetOnly) break;
              instance = instance.return;
            }
            0 < inCapturePhase.length &&
              ((reactName = new SyntheticEventCtor(
                reactName,
                reactEventType,
                null,
                nativeEvent,
                nativeEventTarget
              )),
              dispatchQueue.push({
                event: reactName,
                listeners: inCapturePhase
              }));
          }
        }
        if (0 === (eventSystemFlags & 7)) {
          a: {
            reactName =
              "mouseover" === domEventName || "pointerover" === domEventName;
            SyntheticEventCtor =
              "mouseout" === domEventName || "pointerout" === domEventName;
            if (
              reactName &&
              nativeEvent !== currentReplayingEvent &&
              (reactEventType =
                nativeEvent.relatedTarget || nativeEvent.fromElement) &&
              (getClosestInstanceFromNode(reactEventType) ||
                reactEventType[internalContainerInstanceKey])
            )
              break a;
            if (SyntheticEventCtor || reactName) {
              reactName =
                nativeEventTarget.window === nativeEventTarget
                  ? nativeEventTarget
                  : (reactName = nativeEventTarget.ownerDocument)
                    ? reactName.defaultView || reactName.parentWindow
                    : window;
              if (SyntheticEventCtor) {
                if (
                  ((reactEventType =
                    nativeEvent.relatedTarget || nativeEvent.toElement),
                  (SyntheticEventCtor = targetInst),
                  (reactEventType = reactEventType
                    ? getClosestInstanceFromNode(reactEventType)
                    : null),
                  null !== reactEventType &&
                    ((accumulateTargetOnly =
                      getNearestMountedFiber(reactEventType)),
                    (inCapturePhase = reactEventType.tag),
                    reactEventType !== accumulateTargetOnly ||
                      (5 !== inCapturePhase &&
                        27 !== inCapturePhase &&
                        6 !== inCapturePhase)))
                )
                  reactEventType = null;
              } else (SyntheticEventCtor = null), (reactEventType = targetInst);
              if (SyntheticEventCtor !== reactEventType) {
                inCapturePhase = SyntheticMouseEvent;
                _instance2 = "onMouseLeave";
                reactEventName = "onMouseEnter";
                instance = "mouse";
                if (
                  "pointerout" === domEventName ||
                  "pointerover" === domEventName
                )
                  (inCapturePhase = SyntheticPointerEvent),
                    (_instance2 = "onPointerLeave"),
                    (reactEventName = "onPointerEnter"),
                    (instance = "pointer");
                accumulateTargetOnly =
                  null == SyntheticEventCtor
                    ? reactName
                    : getNodeFromInstance(SyntheticEventCtor);
                lastHostComponent =
                  null == reactEventType
                    ? reactName
                    : getNodeFromInstance(reactEventType);
                reactName = new inCapturePhase(
                  _instance2,
                  instance + "leave",
                  SyntheticEventCtor,
                  nativeEvent,
                  nativeEventTarget
                );
                reactName.target = accumulateTargetOnly;
                reactName.relatedTarget = lastHostComponent;
                _instance2 = null;
                getClosestInstanceFromNode(nativeEventTarget) === targetInst &&
                  ((inCapturePhase = new inCapturePhase(
                    reactEventName,
                    instance + "enter",
                    reactEventType,
                    nativeEvent,
                    nativeEventTarget
                  )),
                  (inCapturePhase.target = lastHostComponent),
                  (inCapturePhase.relatedTarget = accumulateTargetOnly),
                  (_instance2 = inCapturePhase));
                accumulateTargetOnly = _instance2;
                if (SyntheticEventCtor && reactEventType)
                  b: {
                    inCapturePhase = getParent;
                    reactEventName = SyntheticEventCtor;
                    instance = reactEventType;
                    lastHostComponent = 0;
                    for (
                      _instance2 = reactEventName;
                      _instance2;
                      _instance2 = inCapturePhase(_instance2)
                    )
                      lastHostComponent++;
                    _instance2 = 0;
                    for (
                      var tempB = instance;
                      tempB;
                      tempB = inCapturePhase(tempB)
                    )
                      _instance2++;
                    for (; 0 < lastHostComponent - _instance2; )
                      (reactEventName = inCapturePhase(reactEventName)),
                        lastHostComponent--;
                    for (; 0 < _instance2 - lastHostComponent; )
                      (instance = inCapturePhase(instance)), _instance2--;
                    for (; lastHostComponent--; ) {
                      if (
                        reactEventName === instance ||
                        (null !== instance &&
                          reactEventName === instance.alternate)
                      ) {
                        inCapturePhase = reactEventName;
                        break b;
                      }
                      reactEventName = inCapturePhase(reactEventName);
                      instance = inCapturePhase(instance);
                    }
                    inCapturePhase = null;
                  }
                else inCapturePhase = null;
                null !== SyntheticEventCtor &&
                  accumulateEnterLeaveListenersForEvent(
                    dispatchQueue,
                    reactName,
                    SyntheticEventCtor,
                    inCapturePhase,
                    !1
                  );
                null !== reactEventType &&
                  null !== accumulateTargetOnly &&
                  accumulateEnterLeaveListenersForEvent(
                    dispatchQueue,
                    accumulateTargetOnly,
                    reactEventType,
                    inCapturePhase,
                    !0
                  );
              }
            }
          }
          a: {
            reactName = targetInst ? getNodeFromInstance(targetInst) : window;
            SyntheticEventCtor =
              reactName.nodeName && reactName.nodeName.toLowerCase();
            if (
              "select" === SyntheticEventCtor ||
              ("input" === SyntheticEventCtor && "file" === reactName.type)
            )
              var getTargetInstFunc = getTargetInstForChangeEvent;
            else if (isTextInputElement(reactName))
              if (isInputEventSupported)
                getTargetInstFunc = getTargetInstForInputOrChangeEvent;
              else {
                getTargetInstFunc = getTargetInstForInputEventPolyfill;
                var handleEventFunc = handleEventsForInputEventPolyfill;
              }
            else
              (SyntheticEventCtor = reactName.nodeName),
                !SyntheticEventCtor ||
                "input" !== SyntheticEventCtor.toLowerCase() ||
                ("checkbox" !== reactName.type && "radio" !== reactName.type)
                  ? targetInst &&
                    isCustomElement(targetInst.elementType) &&
                    (getTargetInstFunc = getTargetInstForChangeEvent)
                  : (getTargetInstFunc = getTargetInstForClickEvent);
            if (
              getTargetInstFunc &&
              (getTargetInstFunc = getTargetInstFunc(domEventName, targetInst))
            ) {
              createAndAccumulateChangeEvent(
                dispatchQueue,
                getTargetInstFunc,
                nativeEvent,
                nativeEventTarget
              );
              break a;
            }
            handleEventFunc &&
              handleEventFunc(domEventName, reactName, targetInst);
            "focusout" === domEventName &&
              targetInst &&
              "number" === reactName.type &&
              null != targetInst.memoizedProps.value &&
              setDefaultValue(reactName, "number", reactName.value);
          }
          handleEventFunc = targetInst
            ? getNodeFromInstance(targetInst)
            : window;
          switch (domEventName) {
            case "focusin":
              if (
                isTextInputElement(handleEventFunc) ||
                "true" === handleEventFunc.contentEditable
              )
                (activeElement = handleEventFunc),
                  (activeElementInst = targetInst),
                  (lastSelection = null);
              break;
            case "focusout":
              lastSelection = activeElementInst = activeElement = null;
              break;
            case "mousedown":
              mouseDown = !0;
              break;
            case "contextmenu":
            case "mouseup":
            case "dragend":
              mouseDown = !1;
              constructSelectEvent(
                dispatchQueue,
                nativeEvent,
                nativeEventTarget
              );
              break;
            case "selectionchange":
              if (skipSelectionChangeEvent) break;
            case "keydown":
            case "keyup":
              constructSelectEvent(
                dispatchQueue,
                nativeEvent,
                nativeEventTarget
              );
          }
          var fallbackData;
          if (canUseCompositionEvent)
            b: {
              switch (domEventName) {
                case "compositionstart":
                  var eventType = "onCompositionStart";
                  break b;
                case "compositionend":
                  eventType = "onCompositionEnd";
                  break b;
                case "compositionupdate":
                  eventType = "onCompositionUpdate";
                  break b;
              }
              eventType = void 0;
            }
          else
            isComposing
              ? isFallbackCompositionEnd(domEventName, nativeEvent) &&
                (eventType = "onCompositionEnd")
              : "keydown" === domEventName &&
                nativeEvent.keyCode === START_KEYCODE &&
                (eventType = "onCompositionStart");
          eventType &&
            (useFallbackCompositionData &&
              "ko" !== nativeEvent.locale &&
              (isComposing || "onCompositionStart" !== eventType
                ? "onCompositionEnd" === eventType &&
                  isComposing &&
                  (fallbackData = getData())
                : ((root = nativeEventTarget),
                  (startText = "value" in root ? root.value : root.textContent),
                  (isComposing = !0))),
            (handleEventFunc = accumulateTwoPhaseListeners(
              targetInst,
              eventType
            )),
            0 < handleEventFunc.length &&
              ((eventType = new SyntheticCompositionEvent(
                eventType,
                domEventName,
                null,
                nativeEvent,
                nativeEventTarget
              )),
              dispatchQueue.push({
                event: eventType,
                listeners: handleEventFunc
              }),
              fallbackData
                ? (eventType.data = fallbackData)
                : ((fallbackData = getDataFromCustomEvent(nativeEvent)),
                  null !== fallbackData && (eventType.data = fallbackData))));
          if (
            (fallbackData = canUseTextInputEvent
              ? getNativeBeforeInputChars(domEventName, nativeEvent)
              : getFallbackBeforeInputChars(domEventName, nativeEvent))
          )
            (eventType = accumulateTwoPhaseListeners(
              targetInst,
              "onBeforeInput"
            )),
              0 < eventType.length &&
                ((handleEventFunc = new SyntheticInputEvent(
                  "onBeforeInput",
                  "beforeinput",
                  null,
                  nativeEvent,
                  nativeEventTarget
                )),
                dispatchQueue.push({
                  event: handleEventFunc,
                  listeners: eventType
                }),
                (handleEventFunc.data = fallbackData));
          extractEvents$1(
            dispatchQueue,
            domEventName,
            targetInst,
            nativeEvent,
            nativeEventTarget
          );
        }
        processDispatchQueue(dispatchQueue, eventSystemFlags);
      });
    }
    function createDispatchListener(instance, listener, currentTarget) {
      return {
        instance: instance,
        listener: listener,
        currentTarget: currentTarget
      };
    }
    function accumulateTwoPhaseListeners(targetFiber, reactName) {
      for (
        var captureName = reactName + "Capture", listeners = [];
        null !== targetFiber;

      ) {
        var _instance3 = targetFiber,
          stateNode = _instance3.stateNode;
        _instance3 = _instance3.tag;
        (5 !== _instance3 && 26 !== _instance3 && 27 !== _instance3) ||
          null === stateNode ||
          ((_instance3 = getListener(targetFiber, captureName)),
          null != _instance3 &&
            listeners.unshift(
              createDispatchListener(targetFiber, _instance3, stateNode)
            ),
          (_instance3 = getListener(targetFiber, reactName)),
          null != _instance3 &&
            listeners.push(
              createDispatchListener(targetFiber, _instance3, stateNode)
            ));
        if (3 === targetFiber.tag) return listeners;
        targetFiber = targetFiber.return;
      }
      return [];
    }
    function getParent(inst) {
      if (null === inst) return null;
      do inst = inst.return;
      while (inst && 5 !== inst.tag && 27 !== inst.tag);
      return inst ? inst : null;
    }
    function accumulateEnterLeaveListenersForEvent(
      dispatchQueue,
      event,
      target,
      common,
      inCapturePhase
    ) {
      for (
        var registrationName = event._reactName, listeners = [];
        null !== target && target !== common;

      ) {
        var _instance4 = target,
          alternate = _instance4.alternate,
          stateNode = _instance4.stateNode;
        _instance4 = _instance4.tag;
        if (null !== alternate && alternate === common) break;
        (5 !== _instance4 && 26 !== _instance4 && 27 !== _instance4) ||
          null === stateNode ||
          ((alternate = stateNode),
          inCapturePhase
            ? ((stateNode = getListener(target, registrationName)),
              null != stateNode &&
                listeners.unshift(
                  createDispatchListener(target, stateNode, alternate)
                ))
            : inCapturePhase ||
              ((stateNode = getListener(target, registrationName)),
              null != stateNode &&
                listeners.push(
                  createDispatchListener(target, stateNode, alternate)
                )));
        target = target.return;
      }
      0 !== listeners.length &&
        dispatchQueue.push({ event: event, listeners: listeners });
    }
    function validatePropertiesInDevelopment(type, props) {
      validateProperties$2(type, props);
      ("input" !== type && "textarea" !== type && "select" !== type) ||
        null == props ||
        null !== props.value ||
        didWarnValueNull ||
        ((didWarnValueNull = !0),
        "select" === type && props.multiple
          ? console.error(
              "`value` prop on `%s` should not be null. Consider using an empty array when `multiple` is set to `true` to clear the component or `undefined` for uncontrolled components.",
              type
            )
          : console.error(
              "`value` prop on `%s` should not be null. Consider using an empty string to clear the component or `undefined` for uncontrolled components.",
              type
            ));
      var eventRegistry = {
        registrationNameDependencies: registrationNameDependencies,
        possibleRegistrationNames: possibleRegistrationNames
      };
      isCustomElement(type) ||
        "string" === typeof props.is ||
        warnUnknownProperties(type, props, eventRegistry);
      props.contentEditable &&
        !props.suppressContentEditableWarning &&
        null != props.children &&
        console.error(
          "A component is `contentEditable` and contains `children` managed by React. It is now your responsibility to guarantee that none of those nodes are unexpectedly modified or duplicated. This is probably not intentional."
        );
    }
    function warnForPropDifference(
      propName,
      serverValue,
      clientValue,
      serverDifferences
    ) {
      serverValue !== clientValue &&
        ((clientValue = normalizeMarkupForTextOrAttribute(clientValue)),
        normalizeMarkupForTextOrAttribute(serverValue) !== clientValue &&
          (serverDifferences[propName] = serverValue));
    }
    function warnForExtraAttributes(
      domElement,
      attributeNames,
      serverDifferences
    ) {
      attributeNames.forEach(function (attributeName) {
        serverDifferences[getPropNameFromAttributeName(attributeName)] =
          "style" === attributeName
            ? getStylesObjectFromElement(domElement)
            : domElement.getAttribute(attributeName);
      });
    }
    function warnForInvalidEventListener(registrationName, listener) {
      !1 === listener
        ? console.error(
            "Expected `%s` listener to be a function, instead got `false`.\n\nIf you used to conditionally omit it with %s={condition && value}, pass %s={condition ? value : undefined} instead.",
            registrationName,
            registrationName,
            registrationName
          )
        : console.error(
            "Expected `%s` listener to be a function, instead got a value of `%s` type.",
            registrationName,
            typeof listener
          );
    }
    function normalizeHTML(parent, html) {
      parent =
        parent.namespaceURI === MATH_NAMESPACE ||
        parent.namespaceURI === SVG_NAMESPACE
          ? parent.ownerDocument.createElementNS(
              parent.namespaceURI,
              parent.tagName
            )
          : parent.ownerDocument.createElement(parent.tagName);
      parent.innerHTML = html;
      return parent.innerHTML;
    }
    function normalizeMarkupForTextOrAttribute(markup) {
      willCoercionThrow(markup) &&
        (console.error(
          "The provided HTML markup uses a value of unsupported type %s. This value must be coerced to a string before using it here.",
          typeName(markup)
        ),
        testStringCoercion(markup));
      return ("string" === typeof markup ? markup : "" + markup)
        .replace(NORMALIZE_NEWLINES_REGEX, "\n")
        .replace(NORMALIZE_NULL_AND_REPLACEMENT_REGEX, "");
    }
    function checkForUnmatchedText(serverText, clientText) {
      clientText = normalizeMarkupForTextOrAttribute(clientText);
      return normalizeMarkupForTextOrAttribute(serverText) === clientText
        ? !0
        : !1;
    }
    function setProp(domElement, tag, key, value, props, prevValue) {
      switch (key) {
        case "children":
          if ("string" === typeof value)
            validateTextNesting(value, tag, !1),
              "body" === tag ||
                ("textarea" === tag && "" === value) ||
                setTextContent(domElement, value);
          else if ("number" === typeof value || "bigint" === typeof value)
            validateTextNesting("" + value, tag, !1),
              "body" !== tag && setTextContent(domElement, "" + value);
          break;
        case "className":
          setValueForKnownAttribute(domElement, "class", value);
          break;
        case "tabIndex":
          setValueForKnownAttribute(domElement, "tabindex", value);
          break;
        case "dir":
        case "role":
        case "viewBox":
        case "width":
        case "height":
          setValueForKnownAttribute(domElement, key, value);
          break;
        case "style":
          setValueForStyles(domElement, value, prevValue);
          break;
        case "data":
          if ("object" !== tag) {
            setValueForKnownAttribute(domElement, "data", value);
            break;
          }
        case "src":
        case "href":
          if ("" === value && ("a" !== tag || "href" !== key)) {
            "src" === key
              ? console.error(
                  'An empty string ("") was passed to the %s attribute. This may cause the browser to download the whole page again over the network. To fix this, either do not render the element at all or pass null to %s instead of an empty string.',
                  key,
                  key
                )
              : console.error(
                  'An empty string ("") was passed to the %s attribute. To fix this, either do not render the element at all or pass null to %s instead of an empty string.',
                  key,
                  key
                );
            domElement.removeAttribute(key);
            break;
          }
          if (
            null == value ||
            "function" === typeof value ||
            "symbol" === typeof value ||
            "boolean" === typeof value
          ) {
            domElement.removeAttribute(key);
            break;
          }
          checkAttributeStringCoercion(value, key);
          value = sanitizeURL("" + value);
          domElement.setAttribute(key, value);
          break;
        case "action":
        case "formAction":
          null != value &&
            ("form" === tag
              ? "formAction" === key
                ? console.error(
                    "You can only pass the formAction prop to <input> or <button>. Use the action prop on <form>."
                  )
                : "function" === typeof value &&
                  ((null == props.encType && null == props.method) ||
                    didWarnFormActionMethod ||
                    ((didWarnFormActionMethod = !0),
                    console.error(
                      "Cannot specify a encType or method for a form that specifies a function as the action. React provides those automatically. They will get overridden."
                    )),
                  null == props.target ||
                    didWarnFormActionTarget ||
                    ((didWarnFormActionTarget = !0),
                    console.error(
                      "Cannot specify a target for a form that specifies a function as the action. The function will always be executed in the same window."
                    )))
              : "input" === tag || "button" === tag
                ? "action" === key
                  ? console.error(
                      "You can only pass the action prop to <form>. Use the formAction prop on <input> or <button>."
                    )
                  : "input" !== tag ||
                      "submit" === props.type ||
                      "image" === props.type ||
                      didWarnFormActionType
                    ? "button" !== tag ||
                      null == props.type ||
                      "submit" === props.type ||
                      didWarnFormActionType
                      ? "function" === typeof value &&
                        (null == props.name ||
                          didWarnFormActionName ||
                          ((didWarnFormActionName = !0),
                          console.error(
                            'Cannot specify a "name" prop for a button that specifies a function as a formAction. React needs it to encode which action should be invoked. It will get overridden.'
                          )),
                        (null == props.formEncType &&
                          null == props.formMethod) ||
                          didWarnFormActionMethod ||
                          ((didWarnFormActionMethod = !0),
                          console.error(
                            "Cannot specify a formEncType or formMethod for a button that specifies a function as a formAction. React provides those automatically. They will get overridden."
                          )),
                        null == props.formTarget ||
                          didWarnFormActionTarget ||
                          ((didWarnFormActionTarget = !0),
                          console.error(
                            "Cannot specify a formTarget for a button that specifies a function as a formAction. The function will always be executed in the same window."
                          )))
                      : ((didWarnFormActionType = !0),
                        console.error(
                          'A button can only specify a formAction along with type="submit" or no type.'
                        ))
                    : ((didWarnFormActionType = !0),
                      console.error(
                        'An input can only specify a formAction along with type="submit" or type="image".'
                      ))
                : "action" === key
                  ? console.error(
                      "You can only pass the action prop to <form>."
                    )
                  : console.error(
                      "You can only pass the formAction prop to <input> or <button>."
                    ));
          if ("function" === typeof value) {
            domElement.setAttribute(
              key,
              "javascript:throw new Error('A React form was unexpectedly submitted. If you called form.submit() manually, consider using form.requestSubmit() instead. If you\\'re trying to use event.stopPropagation() in a submit event handler, consider also calling event.preventDefault().')"
            );
            break;
          } else
            "function" === typeof prevValue &&
              ("formAction" === key
                ? ("input" !== tag &&
                    setProp(domElement, tag, "name", props.name, props, null),
                  setProp(
                    domElement,
                    tag,
                    "formEncType",
                    props.formEncType,
                    props,
                    null
                  ),
                  setProp(
                    domElement,
                    tag,
                    "formMethod",
                    props.formMethod,
                    props,
                    null
                  ),
                  setProp(
                    domElement,
                    tag,
                    "formTarget",
                    props.formTarget,
                    props,
                    null
                  ))
                : (setProp(
                    domElement,
                    tag,
                    "encType",
                    props.encType,
                    props,
                    null
                  ),
                  setProp(domElement, tag, "method", props.method, props, null),
                  setProp(
                    domElement,
                    tag,
                    "target",
                    props.target,
                    props,
                    null
                  )));
          if (
            null == value ||
            "symbol" === typeof value ||
            "boolean" === typeof value
          ) {
            domElement.removeAttribute(key);
            break;
          }
          checkAttributeStringCoercion(value, key);
          value = sanitizeURL("" + value);
          domElement.setAttribute(key, value);
          break;
        case "onClick":
          null != value &&
            ("function" !== typeof value &&
              warnForInvalidEventListener(key, value),
            (domElement.onclick = noop$1));
          break;
        case "onScroll":
          null != value &&
            ("function" !== typeof value &&
              warnForInvalidEventListener(key, value),
            listenToNonDelegatedEvent("scroll", domElement));
          break;
        case "onScrollEnd":
          null != value &&
            ("function" !== typeof value &&
              warnForInvalidEventListener(key, value),
            listenToNonDelegatedEvent("scrollend", domElement));
          break;
        case "dangerouslySetInnerHTML":
          if (null != value) {
            if ("object" !== typeof value || !("__html" in value))
              throw Error(
                "`props.dangerouslySetInnerHTML` must be in the form `{__html: ...}`. Please visit https://react.dev/link/dangerously-set-inner-html for more information."
              );
            key = value.__html;
            if (null != key) {
              if (null != props.children)
                throw Error(
                  "Can only set one of `children` or `props.dangerouslySetInnerHTML`."
                );
              domElement.innerHTML = key;
            }
          }
          break;
        case "multiple":
          domElement.multiple =
            value && "function" !== typeof value && "symbol" !== typeof value;
          break;
        case "muted":
          domElement.muted =
            value && "function" !== typeof value && "symbol" !== typeof value;
          break;
        case "suppressContentEditableWarning":
        case "suppressHydrationWarning":
        case "defaultValue":
        case "defaultChecked":
        case "innerHTML":
        case "ref":
          break;
        case "autoFocus":
          break;
        case "xlinkHref":
          if (
            null == value ||
            "function" === typeof value ||
            "boolean" === typeof value ||
            "symbol" === typeof value
          ) {
            domElement.removeAttribute("xlink:href");
            break;
          }
          checkAttributeStringCoercion(value, key);
          key = sanitizeURL("" + value);
          domElement.setAttributeNS(xlinkNamespace, "xlink:href", key);
          break;
        case "contentEditable":
        case "spellCheck":
        case "draggable":
        case "value":
        case "autoReverse":
        case "externalResourcesRequired":
        case "focusable":
        case "preserveAlpha":
          null != value &&
          "function" !== typeof value &&
          "symbol" !== typeof value
            ? (checkAttributeStringCoercion(value, key),
              domElement.setAttribute(key, "" + value))
            : domElement.removeAttribute(key);
          break;
        case "inert":
          "" !== value ||
            didWarnForNewBooleanPropsWithEmptyValue[key] ||
            ((didWarnForNewBooleanPropsWithEmptyValue[key] = !0),
            console.error(
              "Received an empty string for a boolean attribute `%s`. This will treat the attribute as if it were false. Either pass `false` to silence this warning, or pass `true` if you used an empty string in earlier versions of React to indicate this attribute is true.",
              key
            ));
        case "allowFullScreen":
        case "async":
        case "autoPlay":
        case "controls":
        case "default":
        case "defer":
        case "disabled":
        case "disablePictureInPicture":
        case "disableRemotePlayback":
        case "formNoValidate":
        case "hidden":
        case "loop":
        case "noModule":
        case "noValidate":
        case "open":
        case "playsInline":
        case "readOnly":
        case "required":
        case "reversed":
        case "scoped":
        case "seamless":
        case "itemScope":
          value && "function" !== typeof value && "symbol" !== typeof value
            ? domElement.setAttribute(key, "")
            : domElement.removeAttribute(key);
          break;
        case "capture":
        case "download":
          !0 === value
            ? domElement.setAttribute(key, "")
            : !1 !== value &&
                null != value &&
                "function" !== typeof value &&
                "symbol" !== typeof value
              ? (checkAttributeStringCoercion(value, key),
                domElement.setAttribute(key, value))
              : domElement.removeAttribute(key);
          break;
        case "cols":
        case "rows":
        case "size":
        case "span":
          null != value &&
          "function" !== typeof value &&
          "symbol" !== typeof value &&
          !isNaN(value) &&
          1 <= value
            ? (checkAttributeStringCoercion(value, key),
              domElement.setAttribute(key, value))
            : domElement.removeAttribute(key);
          break;
        case "rowSpan":
        case "start":
          null == value ||
          "function" === typeof value ||
          "symbol" === typeof value ||
          isNaN(value)
            ? domElement.removeAttribute(key)
            : (checkAttributeStringCoercion(value, key),
              domElement.setAttribute(key, value));
          break;
        case "popover":
          listenToNonDelegatedEvent("beforetoggle", domElement);
          listenToNonDelegatedEvent("toggle", domElement);
          setValueForAttribute(domElement, "popover", value);
          break;
        case "xlinkActuate":
          setValueForNamespacedAttribute(
            domElement,
            xlinkNamespace,
            "xlink:actuate",
            value
          );
          break;
        case "xlinkArcrole":
          setValueForNamespacedAttribute(
            domElement,
            xlinkNamespace,
            "xlink:arcrole",
            value
          );
          break;
        case "xlinkRole":
          setValueForNamespacedAttribute(
            domElement,
            xlinkNamespace,
            "xlink:role",
            value
          );
          break;
        case "xlinkShow":
          setValueForNamespacedAttribute(
            domElement,
            xlinkNamespace,
            "xlink:show",
            value
          );
          break;
        case "xlinkTitle":
          setValueForNamespacedAttribute(
            domElement,
            xlinkNamespace,
            "xlink:title",
            value
          );
          break;
        case "xlinkType":
          setValueForNamespacedAttribute(
            domElement,
            xlinkNamespace,
            "xlink:type",
            value
          );
          break;
        case "xmlBase":
          setValueForNamespacedAttribute(
            domElement,
            xmlNamespace,
            "xml:base",
            value
          );
          break;
        case "xmlLang":
          setValueForNamespacedAttribute(
            domElement,
            xmlNamespace,
            "xml:lang",
            value
          );
          break;
        case "xmlSpace":
          setValueForNamespacedAttribute(
            domElement,
            xmlNamespace,
            "xml:space",
            value
          );
          break;
        case "is":
          null != prevValue &&
            console.error(
              'Cannot update the "is" prop after it has been initialized.'
            );
          setValueForAttribute(domElement, "is", value);
          break;
        case "innerText":
        case "textContent":
          break;
        case "popoverTarget":
          didWarnPopoverTargetObject ||
            null == value ||
            "object" !== typeof value ||
            ((didWarnPopoverTargetObject = !0),
            console.error(
              "The `popoverTarget` prop expects the ID of an Element as a string. Received %s instead.",
              value
            ));
        default:
          !(2 < key.length) ||
          ("o" !== key[0] && "O" !== key[0]) ||
          ("n" !== key[1] && "N" !== key[1])
            ? ((key = getAttributeAlias(key)),
              setValueForAttribute(domElement, key, value))
            : registrationNameDependencies.hasOwnProperty(key) &&
              null != value &&
              "function" !== typeof value &&
              warnForInvalidEventListener(key, value);
      }
    }
    function setPropOnCustomElement(
      domElement,
      tag,
      key,
      value,
      props,
      prevValue
    ) {
      switch (key) {
        case "style":
          setValueForStyles(domElement, value, prevValue);
          break;
        case "dangerouslySetInnerHTML":
          if (null != value) {
            if ("object" !== typeof value || !("__html" in value))
              throw Error(
                "`props.dangerouslySetInnerHTML` must be in the form `{__html: ...}`. Please visit https://react.dev/link/dangerously-set-inner-html for more information."
              );
            key = value.__html;
            if (null != key) {
              if (null != props.children)
                throw Error(
                  "Can only set one of `children` or `props.dangerouslySetInnerHTML`."
                );
              domElement.innerHTML = key;
            }
          }
          break;
        case "children":
          "string" === typeof value
            ? setTextContent(domElement, value)
            : ("number" === typeof value || "bigint" === typeof value) &&
              setTextContent(domElement, "" + value);
          break;
        case "onScroll":
          null != value &&
            ("function" !== typeof value &&
              warnForInvalidEventListener(key, value),
            listenToNonDelegatedEvent("scroll", domElement));
          break;
        case "onScrollEnd":
          null != value &&
            ("function" !== typeof value &&
              warnForInvalidEventListener(key, value),
            listenToNonDelegatedEvent("scrollend", domElement));
          break;
        case "onClick":
          null != value &&
            ("function" !== typeof value &&
              warnForInvalidEventListener(key, value),
            (domElement.onclick = noop$1));
          break;
        case "suppressContentEditableWarning":
        case "suppressHydrationWarning":
        case "innerHTML":
        case "ref":
          break;
        case "innerText":
        case "textContent":
          break;
        default:
          if (registrationNameDependencies.hasOwnProperty(key))
            null != value &&
              "function" !== typeof value &&
              warnForInvalidEventListener(key, value);
          else
            a: {
              if (
                "o" === key[0] &&
                "n" === key[1] &&
                ((props = key.endsWith("Capture")),
                (tag = key.slice(2, props ? key.length - 7 : void 0)),
                (prevValue = domElement[internalPropsKey] || null),
                (prevValue = null != prevValue ? prevValue[key] : null),
                "function" === typeof prevValue &&
                  domElement.removeEventListener(tag, prevValue, props),
                "function" === typeof value)
              ) {
                "function" !== typeof prevValue &&
                  null !== prevValue &&
                  (key in domElement
                    ? (domElement[key] = null)
                    : domElement.hasAttribute(key) &&
                      domElement.removeAttribute(key));
                domElement.addEventListener(tag, value, props);
                break a;
              }
              key in domElement
                ? (domElement[key] = value)
                : !0 === value
                  ? domElement.setAttribute(key, "")
                  : setValueForAttribute(domElement, key, value);
            }
      }
    }
    function setInitialProperties(domElement, tag, props) {
      validatePropertiesInDevelopment(tag, props);
      switch (tag) {
        case "div":
        case "span":
        case "svg":
        case "path":
        case "a":
        case "g":
        case "p":
        case "li":
          break;
        case "img":
          listenToNonDelegatedEvent("error", domElement);
          listenToNonDelegatedEvent("load", domElement);
          var hasSrc = !1,
            hasSrcSet = !1,
            propKey;
          for (propKey in props)
            if (props.hasOwnProperty(propKey)) {
              var propValue = props[propKey];
              if (null != propValue)
                switch (propKey) {
                  case "src":
                    hasSrc = !0;
                    break;
                  case "srcSet":
                    hasSrcSet = !0;
                    break;
                  case "children":
                  case "dangerouslySetInnerHTML":
                    throw Error(
                      tag +
                        " is a void element tag and must neither have `children` nor use `dangerouslySetInnerHTML`."
                    );
                  default:
                    setProp(domElement, tag, propKey, propValue, props, null);
                }
            }
          hasSrcSet &&
            setProp(domElement, tag, "srcSet", props.srcSet, props, null);
          hasSrc && setProp(domElement, tag, "src", props.src, props, null);
          return;
        case "input":
          checkControlledValueProps("input", props);
          listenToNonDelegatedEvent("invalid", domElement);
          var defaultValue = (propKey = propValue = hasSrcSet = null),
            checked = null,
            defaultChecked = null;
          for (hasSrc in props)
            if (props.hasOwnProperty(hasSrc)) {
              var _propValue = props[hasSrc];
              if (null != _propValue)
                switch (hasSrc) {
                  case "name":
                    hasSrcSet = _propValue;
                    break;
                  case "type":
                    propValue = _propValue;
                    break;
                  case "checked":
                    checked = _propValue;
                    break;
                  case "defaultChecked":
                    defaultChecked = _propValue;
                    break;
                  case "value":
                    propKey = _propValue;
                    break;
                  case "defaultValue":
                    defaultValue = _propValue;
                    break;
                  case "children":
                  case "dangerouslySetInnerHTML":
                    if (null != _propValue)
                      throw Error(
                        tag +
                          " is a void element tag and must neither have `children` nor use `dangerouslySetInnerHTML`."
                      );
                    break;
                  default:
                    setProp(domElement, tag, hasSrc, _propValue, props, null);
                }
            }
          validateInputProps(domElement, props);
          initInput(
            domElement,
            propKey,
            defaultValue,
            checked,
            defaultChecked,
            propValue,
            hasSrcSet,
            !1
          );
          return;
        case "select":
          checkControlledValueProps("select", props);
          listenToNonDelegatedEvent("invalid", domElement);
          hasSrc = propValue = propKey = null;
          for (hasSrcSet in props)
            if (
              props.hasOwnProperty(hasSrcSet) &&
              ((defaultValue = props[hasSrcSet]), null != defaultValue)
            )
              switch (hasSrcSet) {
                case "value":
                  propKey = defaultValue;
                  break;
                case "defaultValue":
                  propValue = defaultValue;
                  break;
                case "multiple":
                  hasSrc = defaultValue;
                default:
                  setProp(
                    domElement,
                    tag,
                    hasSrcSet,
                    defaultValue,
                    props,
                    null
                  );
              }
          validateSelectProps(domElement, props);
          tag = propKey;
          props = propValue;
          domElement.multiple = !!hasSrc;
          null != tag
            ? updateOptions(domElement, !!hasSrc, tag, !1)
            : null != props && updateOptions(domElement, !!hasSrc, props, !0);
          return;
        case "textarea":
          checkControlledValueProps("textarea", props);
          listenToNonDelegatedEvent("invalid", domElement);
          propKey = hasSrcSet = hasSrc = null;
          for (propValue in props)
            if (
              props.hasOwnProperty(propValue) &&
              ((defaultValue = props[propValue]), null != defaultValue)
            )
              switch (propValue) {
                case "value":
                  hasSrc = defaultValue;
                  break;
                case "defaultValue":
                  hasSrcSet = defaultValue;
                  break;
                case "children":
                  propKey = defaultValue;
                  break;
                case "dangerouslySetInnerHTML":
                  if (null != defaultValue)
                    throw Error(
                      "`dangerouslySetInnerHTML` does not make sense on <textarea>."
                    );
                  break;
                default:
                  setProp(
                    domElement,
                    tag,
                    propValue,
                    defaultValue,
                    props,
                    null
                  );
              }
          validateTextareaProps(domElement, props);
          initTextarea(domElement, hasSrc, hasSrcSet, propKey);
          return;
        case "option":
          validateOptionProps(domElement, props);
          for (checked in props)
            if (
              props.hasOwnProperty(checked) &&
              ((hasSrc = props[checked]), null != hasSrc)
            )
              switch (checked) {
                case "selected":
                  domElement.selected =
                    hasSrc &&
                    "function" !== typeof hasSrc &&
                    "symbol" !== typeof hasSrc;
                  break;
                default:
                  setProp(domElement, tag, checked, hasSrc, props, null);
              }
          return;
        case "dialog":
          listenToNonDelegatedEvent("beforetoggle", domElement);
          listenToNonDelegatedEvent("toggle", domElement);
          listenToNonDelegatedEvent("cancel", domElement);
          listenToNonDelegatedEvent("close", domElement);
          break;
        case "iframe":
        case "object":
          listenToNonDelegatedEvent("load", domElement);
          break;
        case "video":
        case "audio":
          for (hasSrc = 0; hasSrc < mediaEventTypes.length; hasSrc++)
            listenToNonDelegatedEvent(mediaEventTypes[hasSrc], domElement);
          break;
        case "image":
          listenToNonDelegatedEvent("error", domElement);
          listenToNonDelegatedEvent("load", domElement);
          break;
        case "details":
          listenToNonDelegatedEvent("toggle", domElement);
          break;
        case "embed":
        case "source":
        case "link":
          listenToNonDelegatedEvent("error", domElement),
            listenToNonDelegatedEvent("load", domElement);
        case "area":
        case "base":
        case "br":
        case "col":
        case "hr":
        case "keygen":
        case "meta":
        case "param":
        case "track":
        case "wbr":
        case "menuitem":
          for (defaultChecked in props)
            if (
              props.hasOwnProperty(defaultChecked) &&
              ((hasSrc = props[defaultChecked]), null != hasSrc)
            )
              switch (defaultChecked) {
                case "children":
                case "dangerouslySetInnerHTML":
                  throw Error(
                    tag +
                      " is a void element tag and must neither have `children` nor use `dangerouslySetInnerHTML`."
                  );
                default:
                  setProp(domElement, tag, defaultChecked, hasSrc, props, null);
              }
          return;
        default:
          if (isCustomElement(tag)) {
            for (_propValue in props)
              props.hasOwnProperty(_propValue) &&
                ((hasSrc = props[_propValue]),
                void 0 !== hasSrc &&
                  setPropOnCustomElement(
                    domElement,
                    tag,
                    _propValue,
                    hasSrc,
                    props,
                    void 0
                  ));
            return;
          }
      }
      for (defaultValue in props)
        props.hasOwnProperty(defaultValue) &&
          ((hasSrc = props[defaultValue]),
          null != hasSrc &&
            setProp(domElement, tag, defaultValue, hasSrc, props, null));
    }
    function updateProperties(domElement, tag, lastProps, nextProps) {
      validatePropertiesInDevelopment(tag, nextProps);
      switch (tag) {
        case "div":
        case "span":
        case "svg":
        case "path":
        case "a":
        case "g":
        case "p":
        case "li":
          break;
        case "input":
          var name = null,
            type = null,
            value = null,
            defaultValue = null,
            lastDefaultValue = null,
            checked = null,
            defaultChecked = null;
          for (propKey in lastProps) {
            var lastProp = lastProps[propKey];
            if (lastProps.hasOwnProperty(propKey) && null != lastProp)
              switch (propKey) {
                case "checked":
                  break;
                case "value":
                  break;
                case "defaultValue":
                  lastDefaultValue = lastProp;
                default:
                  nextProps.hasOwnProperty(propKey) ||
                    setProp(
                      domElement,
                      tag,
                      propKey,
                      null,
                      nextProps,
                      lastProp
                    );
              }
          }
          for (var _propKey8 in nextProps) {
            var propKey = nextProps[_propKey8];
            lastProp = lastProps[_propKey8];
            if (
              nextProps.hasOwnProperty(_propKey8) &&
              (null != propKey || null != lastProp)
            )
              switch (_propKey8) {
                case "type":
                  type = propKey;
                  break;
                case "name":
                  name = propKey;
                  break;
                case "checked":
                  checked = propKey;
                  break;
                case "defaultChecked":
                  defaultChecked = propKey;
                  break;
                case "value":
                  value = propKey;
                  break;
                case "defaultValue":
                  defaultValue = propKey;
                  break;
                case "children":
                case "dangerouslySetInnerHTML":
                  if (null != propKey)
                    throw Error(
                      tag +
                        " is a void element tag and must neither have `children` nor use `dangerouslySetInnerHTML`."
                    );
                  break;
                default:
                  propKey !== lastProp &&
                    setProp(
                      domElement,
                      tag,
                      _propKey8,
                      propKey,
                      nextProps,
                      lastProp
                    );
              }
          }
          tag =
            "checkbox" === lastProps.type || "radio" === lastProps.type
              ? null != lastProps.checked
              : null != lastProps.value;
          nextProps =
            "checkbox" === nextProps.type || "radio" === nextProps.type
              ? null != nextProps.checked
              : null != nextProps.value;
          tag ||
            !nextProps ||
            didWarnUncontrolledToControlled ||
            (console.error(
              "A component is changing an uncontrolled input to be controlled. This is likely caused by the value changing from undefined to a defined value, which should not happen. Decide between using a controlled or uncontrolled input element for the lifetime of the component. More info: https://react.dev/link/controlled-components"
            ),
            (didWarnUncontrolledToControlled = !0));
          !tag ||
            nextProps ||
            didWarnControlledToUncontrolled ||
            (console.error(
              "A component is changing a controlled input to be uncontrolled. This is likely caused by the value changing from a defined to undefined, which should not happen. Decide between using a controlled or uncontrolled input element for the lifetime of the component. More info: https://react.dev/link/controlled-components"
            ),
            (didWarnControlledToUncontrolled = !0));
          updateInput(
            domElement,
            value,
            defaultValue,
            lastDefaultValue,
            checked,
            defaultChecked,
            type,
            name
          );
          return;
        case "select":
          propKey = value = defaultValue = _propKey8 = null;
          for (type in lastProps)
            if (
              ((lastDefaultValue = lastProps[type]),
              lastProps.hasOwnProperty(type) && null != lastDefaultValue)
            )
              switch (type) {
                case "value":
                  break;
                case "multiple":
                  propKey = lastDefaultValue;
                default:
                  nextProps.hasOwnProperty(type) ||
                    setProp(
                      domElement,
                      tag,
                      type,
                      null,
                      nextProps,
                      lastDefaultValue
                    );
              }
          for (name in nextProps)
            if (
              ((type = nextProps[name]),
              (lastDefaultValue = lastProps[name]),
              nextProps.hasOwnProperty(name) &&
                (null != type || null != lastDefaultValue))
            )
              switch (name) {
                case "value":
                  _propKey8 = type;
                  break;
                case "defaultValue":
                  defaultValue = type;
                  break;
                case "multiple":
                  value = type;
                default:
                  type !== lastDefaultValue &&
                    setProp(
                      domElement,
                      tag,
                      name,
                      type,
                      nextProps,
                      lastDefaultValue
                    );
              }
          nextProps = defaultValue;
          tag = value;
          lastProps = propKey;
          null != _propKey8
            ? updateOptions(domElement, !!tag, _propKey8, !1)
            : !!lastProps !== !!tag &&
              (null != nextProps
                ? updateOptions(domElement, !!tag, nextProps, !0)
                : updateOptions(domElement, !!tag, tag ? [] : "", !1));
          return;
        case "textarea":
          propKey = _propKey8 = null;
          for (defaultValue in lastProps)
            if (
              ((name = lastProps[defaultValue]),
              lastProps.hasOwnProperty(defaultValue) &&
                null != name &&
                !nextProps.hasOwnProperty(defaultValue))
            )
              switch (defaultValue) {
                case "value":
                  break;
                case "children":
                  break;
                default:
                  setProp(domElement, tag, defaultValue, null, nextProps, name);
              }
          for (value in nextProps)
            if (
              ((name = nextProps[value]),
              (type = lastProps[value]),
              nextProps.hasOwnProperty(value) && (null != name || null != type))
            )
              switch (value) {
                case "value":
                  _propKey8 = name;
                  break;
                case "defaultValue":
                  propKey = name;
                  break;
                case "children":
                  break;
                case "dangerouslySetInnerHTML":
                  if (null != name)
                    throw Error(
                      "`dangerouslySetInnerHTML` does not make sense on <textarea>."
                    );
                  break;
                default:
                  name !== type &&
                    setProp(domElement, tag, value, name, nextProps, type);
              }
          updateTextarea(domElement, _propKey8, propKey);
          return;
        case "option":
          for (var _propKey13 in lastProps)
            if (
              ((_propKey8 = lastProps[_propKey13]),
              lastProps.hasOwnProperty(_propKey13) &&
                null != _propKey8 &&
                !nextProps.hasOwnProperty(_propKey13))
            )
              switch (_propKey13) {
                case "selected":
                  domElement.selected = !1;
                  break;
                default:
                  setProp(
                    domElement,
                    tag,
                    _propKey13,
                    null,
                    nextProps,
                    _propKey8
                  );
              }
          for (lastDefaultValue in nextProps)
            if (
              ((_propKey8 = nextProps[lastDefaultValue]),
              (propKey = lastProps[lastDefaultValue]),
              nextProps.hasOwnProperty(lastDefaultValue) &&
                _propKey8 !== propKey &&
                (null != _propKey8 || null != propKey))
            )
              switch (lastDefaultValue) {
                case "selected":
                  domElement.selected =
                    _propKey8 &&
                    "function" !== typeof _propKey8 &&
                    "symbol" !== typeof _propKey8;
                  break;
                default:
                  setProp(
                    domElement,
                    tag,
                    lastDefaultValue,
                    _propKey8,
                    nextProps,
                    propKey
                  );
              }
          return;
        case "img":
        case "link":
        case "area":
        case "base":
        case "br":
        case "col":
        case "embed":
        case "hr":
        case "keygen":
        case "meta":
        case "param":
        case "source":
        case "track":
        case "wbr":
        case "menuitem":
          for (var _propKey15 in lastProps)
            (_propKey8 = lastProps[_propKey15]),
              lastProps.hasOwnProperty(_propKey15) &&
                null != _propKey8 &&
                !nextProps.hasOwnProperty(_propKey15) &&
                setProp(
                  domElement,
                  tag,
                  _propKey15,
                  null,
                  nextProps,
                  _propKey8
                );
          for (checked in nextProps)
            if (
              ((_propKey8 = nextProps[checked]),
              (propKey = lastProps[checked]),
              nextProps.hasOwnProperty(checked) &&
                _propKey8 !== propKey &&
                (null != _propKey8 || null != propKey))
            )
              switch (checked) {
                case "children":
                case "dangerouslySetInnerHTML":
                  if (null != _propKey8)
                    throw Error(
                      tag +
                        " is a void element tag and must neither have `children` nor use `dangerouslySetInnerHTML`."
                    );
                  break;
                default:
                  setProp(
                    domElement,
                    tag,
                    checked,
                    _propKey8,
                    nextProps,
                    propKey
                  );
              }
          return;
        default:
          if (isCustomElement(tag)) {
            for (var _propKey17 in lastProps)
              (_propKey8 = lastProps[_propKey17]),
                lastProps.hasOwnProperty(_propKey17) &&
                  void 0 !== _propKey8 &&
                  !nextProps.hasOwnProperty(_propKey17) &&
                  setPropOnCustomElement(
                    domElement,
                    tag,
                    _propKey17,
                    void 0,
                    nextProps,
                    _propKey8
                  );
            for (defaultChecked in nextProps)
              (_propKey8 = nextProps[defaultChecked]),
                (propKey = lastProps[defaultChecked]),
                !nextProps.hasOwnProperty(defaultChecked) ||
                  _propKey8 === propKey ||
                  (void 0 === _propKey8 && void 0 === propKey) ||
                  setPropOnCustomElement(
                    domElement,
                    tag,
                    defaultChecked,
                    _propKey8,
                    nextProps,
                    propKey
                  );
            return;
          }
      }
      for (var _propKey19 in lastProps)
        (_propKey8 = lastProps[_propKey19]),
          lastProps.hasOwnProperty(_propKey19) &&
            null != _propKey8 &&
            !nextProps.hasOwnProperty(_propKey19) &&
            setProp(domElement, tag, _propKey19, null, nextProps, _propKey8);
      for (lastProp in nextProps)
        (_propKey8 = nextProps[lastProp]),
          (propKey = lastProps[lastProp]),
          !nextProps.hasOwnProperty(lastProp) ||
            _propKey8 === propKey ||
            (null == _propKey8 && null == propKey) ||
            setProp(domElement, tag, lastProp, _propKey8, nextProps, propKey);
    }
    function getPropNameFromAttributeName(attrName) {
      switch (attrName) {
        case "class":
          return "className";
        case "for":
          return "htmlFor";
        default:
          return attrName;
      }
    }
    function getStylesObjectFromElement(domElement) {
      var serverValueInObjectForm = {};
      domElement = domElement.style;
      for (var i = 0; i < domElement.length; i++) {
        var styleName = domElement[i];
        serverValueInObjectForm[styleName] =
          domElement.getPropertyValue(styleName);
      }
      return serverValueInObjectForm;
    }
    function diffHydratedStyles(domElement, value$jscomp$0, serverDifferences) {
      if (null != value$jscomp$0 && "object" !== typeof value$jscomp$0)
        console.error(
          "The `style` prop expects a mapping from style properties to values, not a string. For example, style={{marginRight: spacing + 'em'}} when using JSX."
        );
      else {
        var clientValue;
        var delimiter = (clientValue = ""),
          styleName;
        for (styleName in value$jscomp$0)
          if (value$jscomp$0.hasOwnProperty(styleName)) {
            var value = value$jscomp$0[styleName];
            null != value &&
              "boolean" !== typeof value &&
              "" !== value &&
              (0 === styleName.indexOf("--")
                ? (checkCSSPropertyStringCoercion(value, styleName),
                  (clientValue +=
                    delimiter + styleName + ":" + ("" + value).trim()))
                : "number" !== typeof value ||
                    0 === value ||
                    unitlessNumbers.has(styleName)
                  ? (checkCSSPropertyStringCoercion(value, styleName),
                    (clientValue +=
                      delimiter +
                      styleName
                        .replace(uppercasePattern, "-$1")
                        .toLowerCase()
                        .replace(msPattern$1, "-ms-") +
                      ":" +
                      ("" + value).trim()))
                  : (clientValue +=
                      delimiter +
                      styleName
                        .replace(uppercasePattern, "-$1")
                        .toLowerCase()
                        .replace(msPattern$1, "-ms-") +
                      ":" +
                      value +
                      "px"),
              (delimiter = ";"));
          }
        clientValue = clientValue || null;
        value$jscomp$0 = domElement.getAttribute("style");
        value$jscomp$0 !== clientValue &&
          ((clientValue = normalizeMarkupForTextOrAttribute(clientValue)),
          normalizeMarkupForTextOrAttribute(value$jscomp$0) !== clientValue &&
            (serverDifferences.style = getStylesObjectFromElement(domElement)));
      }
    }
    function hydrateAttribute(
      domElement,
      propKey,
      attributeName,
      value,
      extraAttributes,
      serverDifferences
    ) {
      extraAttributes.delete(attributeName);
      domElement = domElement.getAttribute(attributeName);
      if (null === domElement)
        switch (typeof value) {
          case "undefined":
          case "function":
          case "symbol":
          case "boolean":
            return;
        }
      else if (null != value)
        switch (typeof value) {
          case "function":
          case "symbol":
          case "boolean":
            break;
          default:
            if (
              (checkAttributeStringCoercion(value, propKey),
              domElement === "" + value)
            )
              return;
        }
      warnForPropDifference(propKey, domElement, value, serverDifferences);
    }
    function hydrateBooleanAttribute(
      domElement,
      propKey,
      attributeName,
      value,
      extraAttributes,
      serverDifferences
    ) {
      extraAttributes.delete(attributeName);
      domElement = domElement.getAttribute(attributeName);
      if (null === domElement) {
        switch (typeof value) {
          case "function":
          case "symbol":
            return;
        }
        if (!value) return;
      } else
        switch (typeof value) {
          case "function":
          case "symbol":
            break;
          default:
            if (value) return;
        }
      warnForPropDifference(propKey, domElement, value, serverDifferences);
    }
    function hydrateBooleanishAttribute(
      domElement,
      propKey,
      attributeName,
      value,
      extraAttributes,
      serverDifferences
    ) {
      extraAttributes.delete(attributeName);
      domElement = domElement.getAttribute(attributeName);
      if (null === domElement)
        switch (typeof value) {
          case "undefined":
          case "function":
          case "symbol":
            return;
        }
      else if (null != value)
        switch (typeof value) {
          case "function":
          case "symbol":
            break;
          default:
            if (
              (checkAttributeStringCoercion(value, attributeName),
              domElement === "" + value)
            )
              return;
        }
      warnForPropDifference(propKey, domElement, value, serverDifferences);
    }
    function hydrateNumericAttribute(
      domElement,
      propKey,
      attributeName,
      value,
      extraAttributes,
      serverDifferences
    ) {
      extraAttributes.delete(attributeName);
      domElement = domElement.getAttribute(attributeName);
      if (null === domElement)
        switch (typeof value) {
          case "undefined":
          case "function":
          case "symbol":
          case "boolean":
            return;
          default:
            if (isNaN(value)) return;
        }
      else if (null != value)
        switch (typeof value) {
          case "function":
          case "symbol":
          case "boolean":
            break;
          default:
            if (
              !isNaN(value) &&
              (checkAttributeStringCoercion(value, propKey),
              domElement === "" + value)
            )
              return;
        }
      warnForPropDifference(propKey, domElement, value, serverDifferences);
    }
    function hydrateSanitizedAttribute(
      domElement,
      propKey,
      attributeName,
      value,
      extraAttributes,
      serverDifferences
    ) {
      extraAttributes.delete(attributeName);
      domElement = domElement.getAttribute(attributeName);
      if (null === domElement)
        switch (typeof value) {
          case "undefined":
          case "function":
          case "symbol":
          case "boolean":
            return;
        }
      else if (null != value)
        switch (typeof value) {
          case "function":
          case "symbol":
          case "boolean":
            break;
          default:
            if (
              (checkAttributeStringCoercion(value, propKey),
              (attributeName = sanitizeURL("" + value)),
              domElement === attributeName)
            )
              return;
        }
      warnForPropDifference(propKey, domElement, value, serverDifferences);
    }
    function diffHydratedProperties(domElement, tag, props, hostContext) {
      for (
        var serverDifferences = {},
          extraAttributes = new Set(),
          attributes = domElement.attributes,
          i = 0;
        i < attributes.length;
        i++
      )
        switch (attributes[i].name.toLowerCase()) {
          case "value":
            break;
          case "checked":
            break;
          case "selected":
            break;
          default:
            extraAttributes.add(attributes[i].name);
        }
      if (isCustomElement(tag))
        for (var propKey in props) {
          if (props.hasOwnProperty(propKey)) {
            var value = props[propKey];
            if (null != value)
              if (registrationNameDependencies.hasOwnProperty(propKey))
                "function" !== typeof value &&
                  warnForInvalidEventListener(propKey, value);
              else if (!0 !== props.suppressHydrationWarning)
                switch (propKey) {
                  case "children":
                    ("string" !== typeof value && "number" !== typeof value) ||
                      warnForPropDifference(
                        "children",
                        domElement.textContent,
                        value,
                        serverDifferences
                      );
                    continue;
                  case "suppressContentEditableWarning":
                  case "suppressHydrationWarning":
                  case "defaultValue":
                  case "defaultChecked":
                  case "innerHTML":
                  case "ref":
                    continue;
                  case "dangerouslySetInnerHTML":
                    attributes = domElement.innerHTML;
                    value = value ? value.__html : void 0;
                    null != value &&
                      ((value = normalizeHTML(domElement, value)),
                      warnForPropDifference(
                        propKey,
                        attributes,
                        value,
                        serverDifferences
                      ));
                    continue;
                  case "style":
                    extraAttributes.delete(propKey);
                    diffHydratedStyles(domElement, value, serverDifferences);
                    continue;
                  case "offsetParent":
                  case "offsetTop":
                  case "offsetLeft":
                  case "offsetWidth":
                  case "offsetHeight":
                  case "isContentEditable":
                  case "outerText":
                  case "outerHTML":
                    extraAttributes.delete(propKey.toLowerCase());
                    console.error(
                      "Assignment to read-only property will result in a no-op: `%s`",
                      propKey
                    );
                    continue;
                  case "className":
                    extraAttributes.delete("class");
                    attributes = getValueForAttributeOnCustomComponent(
                      domElement,
                      "class",
                      value
                    );
                    warnForPropDifference(
                      "className",
                      attributes,
                      value,
                      serverDifferences
                    );
                    continue;
                  default:
                    hostContext.context === HostContextNamespaceNone &&
                    "svg" !== tag &&
                    "math" !== tag
                      ? extraAttributes.delete(propKey.toLowerCase())
                      : extraAttributes.delete(propKey),
                      (attributes = getValueForAttributeOnCustomComponent(
                        domElement,
                        propKey,
                        value
                      )),
                      warnForPropDifference(
                        propKey,
                        attributes,
                        value,
                        serverDifferences
                      );
                }
          }
        }
      else
        for (value in props)
          if (
            props.hasOwnProperty(value) &&
            ((propKey = props[value]), null != propKey)
          )
            if (registrationNameDependencies.hasOwnProperty(value))
              "function" !== typeof propKey &&
                warnForInvalidEventListener(value, propKey);
            else if (!0 !== props.suppressHydrationWarning)
              switch (value) {
                case "children":
                  ("string" !== typeof propKey &&
                    "number" !== typeof propKey) ||
                    warnForPropDifference(
                      "children",
                      domElement.textContent,
                      propKey,
                      serverDifferences
                    );
                  continue;
                case "suppressContentEditableWarning":
                case "suppressHydrationWarning":
                case "value":
                case "checked":
                case "selected":
                case "defaultValue":
                case "defaultChecked":
                case "innerHTML":
                case "ref":
                  continue;
                case "dangerouslySetInnerHTML":
                  attributes = domElement.innerHTML;
                  propKey = propKey ? propKey.__html : void 0;
                  null != propKey &&
                    ((propKey = normalizeHTML(domElement, propKey)),
                    attributes !== propKey &&
                      (serverDifferences[value] = { __html: attributes }));
                  continue;
                case "className":
                  hydrateAttribute(
                    domElement,
                    value,
                    "class",
                    propKey,
                    extraAttributes,
                    serverDifferences
                  );
                  continue;
                case "tabIndex":
                  hydrateAttribute(
                    domElement,
                    value,
                    "tabindex",
                    propKey,
                    extraAttributes,
                    serverDifferences
                  );
                  continue;
                case "style":
                  extraAttributes.delete(value);
                  diffHydratedStyles(domElement, propKey, serverDifferences);
                  continue;
                case "multiple":
                  extraAttributes.delete(value);
                  warnForPropDifference(
                    value,
                    domElement.multiple,
                    propKey,
                    serverDifferences
                  );
                  continue;
                case "muted":
                  extraAttributes.delete(value);
                  warnForPropDifference(
                    value,
                    domElement.muted,
                    propKey,
                    serverDifferences
                  );
                  continue;
                case "autoFocus":
                  extraAttributes.delete("autofocus");
                  warnForPropDifference(
                    value,
                    domElement.autofocus,
                    propKey,
                    serverDifferences
                  );
                  continue;
                case "data":
                  if ("object" !== tag) {
                    extraAttributes.delete(value);
                    attributes = domElement.getAttribute("data");
                    warnForPropDifference(
                      value,
                      attributes,
                      propKey,
                      serverDifferences
                    );
                    continue;
                  }
                case "src":
                case "href":
                  if (
                    !(
                      "" !== propKey ||
                      ("a" === tag && "href" === value) ||
                      ("object" === tag && "data" === value)
                    )
                  ) {
                    "src" === value
                      ? console.error(
                          'An empty string ("") was passed to the %s attribute. This may cause the browser to download the whole page again over the network. To fix this, either do not render the element at all or pass null to %s instead of an empty string.',
                          value,
                          value
                        )
                      : console.error(
                          'An empty string ("") was passed to the %s attribute. To fix this, either do not render the element at all or pass null to %s instead of an empty string.',
                          value,
                          value
                        );
                    continue;
                  }
                  hydrateSanitizedAttribute(
                    domElement,
                    value,
                    value,
                    propKey,
                    extraAttributes,
                    serverDifferences
                  );
                  continue;
                case "action":
                case "formAction":
                  attributes = domElement.getAttribute(value);
                  if ("function" === typeof propKey) {
                    extraAttributes.delete(value.toLowerCase());
                    "formAction" === value
                      ? (extraAttributes.delete("name"),
                        extraAttributes.delete("formenctype"),
                        extraAttributes.delete("formmethod"),
                        extraAttributes.delete("formtarget"))
                      : (extraAttributes.delete("enctype"),
                        extraAttributes.delete("method"),
                        extraAttributes.delete("target"));
                    continue;
                  } else if (attributes === EXPECTED_FORM_ACTION_URL) {
                    extraAttributes.delete(value.toLowerCase());
                    warnForPropDifference(
                      value,
                      "function",
                      propKey,
                      serverDifferences
                    );
                    continue;
                  }
                  hydrateSanitizedAttribute(
                    domElement,
                    value,
                    value.toLowerCase(),
                    propKey,
                    extraAttributes,
                    serverDifferences
                  );
                  continue;
                case "xlinkHref":
                  hydrateSanitizedAttribute(
                    domElement,
                    value,
                    "xlink:href",
                    propKey,
                    extraAttributes,
                    serverDifferences
                  );
                  continue;
                case "contentEditable":
                  hydrateBooleanishAttribute(
                    domElement,
                    value,
                    "contenteditable",
                    propKey,
                    extraAttributes,
                    serverDifferences
                  );
                  continue;
                case "spellCheck":
                  hydrateBooleanishAttribute(
                    domElement,
                    value,
                    "spellcheck",
                    propKey,
                    extraAttributes,
                    serverDifferences
                  );
                  continue;
                case "draggable":
                case "autoReverse":
                case "externalResourcesRequired":
                case "focusable":
                case "preserveAlpha":
                  hydrateBooleanishAttribute(
                    domElement,
                    value,
                    value,
                    propKey,
                    extraAttributes,
                    serverDifferences
                  );
                  continue;
                case "allowFullScreen":
                case "async":
                case "autoPlay":
                case "controls":
                case "default":
                case "defer":
                case "disabled":
                case "disablePictureInPicture":
                case "disableRemotePlayback":
                case "formNoValidate":
                case "hidden":
                case "loop":
                case "noModule":
                case "noValidate":
                case "open":
                case "playsInline":
                case "readOnly":
                case "required":
                case "reversed":
                case "scoped":
                case "seamless":
                case "itemScope":
                  hydrateBooleanAttribute(
                    domElement,
                    value,
                    value.toLowerCase(),
                    propKey,
                    extraAttributes,
                    serverDifferences
                  );
                  continue;
                case "capture":
                case "download":
                  a: {
                    i = domElement;
                    var attributeName = (attributes = value),
                      serverDifferences$jscomp$0 = serverDifferences;
                    extraAttributes.delete(attributeName);
                    i = i.getAttribute(attributeName);
                    if (null === i)
                      switch (typeof propKey) {
                        case "undefined":
                        case "function":
                        case "symbol":
                          break a;
                        default:
                          if (!1 === propKey) break a;
                      }
                    else if (null != propKey)
                      switch (typeof propKey) {
                        case "function":
                        case "symbol":
                          break;
                        case "boolean":
                          if (!0 === propKey && "" === i) break a;
                          break;
                        default:
                          if (
                            (checkAttributeStringCoercion(propKey, attributes),
                            i === "" + propKey)
                          )
                            break a;
                      }
                    warnForPropDifference(
                      attributes,
                      i,
                      propKey,
                      serverDifferences$jscomp$0
                    );
                  }
                  continue;
                case "cols":
                case "rows":
                case "size":
                case "span":
                  a: {
                    i = domElement;
                    attributeName = attributes = value;
                    serverDifferences$jscomp$0 = serverDifferences;
                    extraAttributes.delete(attributeName);
                    i = i.getAttribute(attributeName);
                    if (null === i)
                      switch (typeof propKey) {
                        case "undefined":
                        case "function":
                        case "symbol":
                        case "boolean":
                          break a;
                        default:
                          if (isNaN(propKey) || 1 > propKey) break a;
                      }
                    else if (null != propKey)
                      switch (typeof propKey) {
                        case "function":
                        case "symbol":
                        case "boolean":
                          break;
                        default:
                          if (
                            !(isNaN(propKey) || 1 > propKey) &&
                            (checkAttributeStringCoercion(propKey, attributes),
                            i === "" + propKey)
                          )
                            break a;
                      }
                    warnForPropDifference(
                      attributes,
                      i,
                      propKey,
                      serverDifferences$jscomp$0
                    );
                  }
                  continue;
                case "rowSpan":
                  hydrateNumericAttribute(
                    domElement,
                    value,
                    "rowspan",
                    propKey,
                    extraAttributes,
                    serverDifferences
                  );
                  continue;
                case "start":
                  hydrateNumericAttribute(
                    domElement,
                    value,
                    value,
                    propKey,
                    extraAttributes,
                    serverDifferences
                  );
                  continue;
                case "xHeight":
                  hydrateAttribute(
                    domElement,
                    value,
                    "x-height",
                    propKey,
                    extraAttributes,
                    serverDifferences
                  );
                  continue;
                case "xlinkActuate":
                  hydrateAttribute(
                    domElement,
                    value,
                    "xlink:actuate",
                    propKey,
                    extraAttributes,
                    serverDifferences
                  );
                  continue;
                case "xlinkArcrole":
                  hydrateAttribute(
                    domElement,
                    value,
                    "xlink:arcrole",
                    propKey,
                    extraAttributes,
                    serverDifferences
                  );
                  continue;
                case "xlinkRole":
                  hydrateAttribute(
                    domElement,
                    value,
                    "xlink:role",
                    propKey,
                    extraAttributes,
                    serverDifferences
                  );
                  continue;
                case "xlinkShow":
                  hydrateAttribute(
                    domElement,
                    value,
                    "xlink:show",
                    propKey,
                    extraAttributes,
                    serverDifferences
                  );
                  continue;
                case "xlinkTitle":
                  hydrateAttribute(
                    domElement,
                    value,
                    "xlink:title",
                    propKey,
                    extraAttributes,
                    serverDifferences
                  );
                  continue;
                case "xlinkType":
                  hydrateAttribute(
                    domElement,
                    value,
                    "xlink:type",
                    propKey,
                    extraAttributes,
                    serverDifferences
                  );
                  continue;
                case "xmlBase":
                  hydrateAttribute(
                    domElement,
                    value,
                    "xml:base",
                    propKey,
                    extraAttributes,
                    serverDifferences
                  );
                  continue;
                case "xmlLang":
                  hydrateAttribute(
                    domElement,
                    value,
                    "xml:lang",
                    propKey,
                    extraAttributes,
                    serverDifferences
                  );
                  continue;
                case "xmlSpace":
                  hydrateAttribute(
                    domElement,
                    value,
                    "xml:space",
                    propKey,
                    extraAttributes,
                    serverDifferences
                  );
                  continue;
                case "inert":
                  "" !== propKey ||
                    didWarnForNewBooleanPropsWithEmptyValue[value] ||
                    ((didWarnForNewBooleanPropsWithEmptyValue[value] = !0),
                    console.error(
                      "Received an empty string for a boolean attribute `%s`. This will treat the attribute as if it were false. Either pass `false` to silence this warning, or pass `true` if you used an empty string in earlier versions of React to indicate this attribute is true.",
                      value
                    ));
                  hydrateBooleanAttribute(
                    domElement,
                    value,
                    value,
                    propKey,
                    extraAttributes,
                    serverDifferences
                  );
                  continue;
                default:
                  if (
                    !(2 < value.length) ||
                    ("o" !== value[0] && "O" !== value[0]) ||
                    ("n" !== value[1] && "N" !== value[1])
                  ) {
                    i = getAttributeAlias(value);
                    attributes = !1;
                    hostContext.context === HostContextNamespaceNone &&
                    "svg" !== tag &&
                    "math" !== tag
                      ? extraAttributes.delete(i.toLowerCase())
                      : ((attributeName = value.toLowerCase()),
                        (attributeName = possibleStandardNames.hasOwnProperty(
                          attributeName
                        )
                          ? possibleStandardNames[attributeName] || null
                          : null),
                        null !== attributeName &&
                          attributeName !== value &&
                          ((attributes = !0),
                          extraAttributes.delete(attributeName)),
                        extraAttributes.delete(i));
                    a: if (
                      ((attributeName = domElement),
                      (serverDifferences$jscomp$0 = i),
                      (i = propKey),
                      isAttributeNameSafe(serverDifferences$jscomp$0))
                    )
                      if (
                        attributeName.hasAttribute(serverDifferences$jscomp$0)
                      )
                        (attributeName = attributeName.getAttribute(
                          serverDifferences$jscomp$0
                        )),
                          checkAttributeStringCoercion(
                            i,
                            serverDifferences$jscomp$0
                          ),
                          (i = attributeName === "" + i ? i : attributeName);
                      else {
                        switch (typeof i) {
                          case "function":
                          case "symbol":
                            break a;
                          case "boolean":
                            if (
                              ((attributeName = serverDifferences$jscomp$0
                                .toLowerCase()
                                .slice(0, 5)),
                              "data-" !== attributeName &&
                                "aria-" !== attributeName)
                            )
                              break a;
                        }
                        i = void 0 === i ? void 0 : null;
                      }
                    else i = void 0;
                    attributes ||
                      warnForPropDifference(
                        value,
                        i,
                        propKey,
                        serverDifferences
                      );
                  }
              }
      0 < extraAttributes.size &&
        !0 !== props.suppressHydrationWarning &&
        warnForExtraAttributes(domElement, extraAttributes, serverDifferences);
      return 0 === Object.keys(serverDifferences).length
        ? null
        : serverDifferences;
    }
    function propNamesListJoin(list, combinator) {
      switch (list.length) {
        case 0:
          return "";
        case 1:
          return list[0];
        case 2:
          return list[0] + " " + combinator + " " + list[1];
        default:
          return (
            list.slice(0, -1).join(", ") +
            ", " +
            combinator +
            " " +
            list[list.length - 1]
          );
      }
    }
    function isLikelyStaticResource(initiatorType) {
      switch (initiatorType) {
        case "css":
        case "script":
        case "font":
        case "img":
        case "image":
        case "input":
        case "link":
          return !0;
        default:
          return !1;
      }
    }
    function estimateBandwidth() {
      if ("function" === typeof performance.getEntriesByType) {
        for (
          var count = 0,
            bits = 0,
            resourceEntries = performance.getEntriesByType("resource"),
            i = 0;
          i < resourceEntries.length;
          i++
        ) {
          var entry = resourceEntries[i],
            transferSize = entry.transferSize,
            initiatorType = entry.initiatorType,
            duration = entry.duration;
          if (
            transferSize &&
            duration &&
            isLikelyStaticResource(initiatorType)
          ) {
            initiatorType = 0;
            duration = entry.responseEnd;
            for (i += 1; i < resourceEntries.length; i++) {
              var overlapEntry = resourceEntries[i],
                overlapStartTime = overlapEntry.startTime;
              if (overlapStartTime > duration) break;
              var overlapTransferSize = overlapEntry.transferSize,
                overlapInitiatorType = overlapEntry.initiatorType;
              overlapTransferSize &&
                isLikelyStaticResource(overlapInitiatorType) &&
                ((overlapEntry = overlapEntry.responseEnd),
                (initiatorType +=
                  overlapTransferSize *
                  (overlapEntry < duration
                    ? 1
                    : (duration - overlapStartTime) /
                      (overlapEntry - overlapStartTime))));
            }
            --i;
            bits +=
              (8 * (transferSize + initiatorType)) / (entry.duration / 1e3);
            count++;
            if (10 < count) break;
          }
        }
        if (0 < count) return bits / count / 1e6;
      }
      return navigator.connection &&
        ((count = navigator.connection.downlink), "number" === typeof count)
        ? count
        : 5;
    }
    function getOwnerDocumentFromRootContainer(rootContainerElement) {
      return 9 === rootContainerElement.nodeType
        ? rootContainerElement
        : rootContainerElement.ownerDocument;
    }
    function getOwnHostContext(namespaceURI) {
      switch (namespaceURI) {
        case SVG_NAMESPACE:
          return HostContextNamespaceSvg;
        case MATH_NAMESPACE:
          return HostContextNamespaceMath;
        default:
          return HostContextNamespaceNone;
      }
    }
    function getChildHostContextProd(parentNamespace, type) {
      if (parentNamespace === HostContextNamespaceNone)
        switch (type) {
          case "svg":
            return HostContextNamespaceSvg;
          case "math":
            return HostContextNamespaceMath;
          default:
            return HostContextNamespaceNone;
        }
      return parentNamespace === HostContextNamespaceSvg &&
        "foreignObject" === type
        ? HostContextNamespaceNone
        : parentNamespace;
    }
    function shouldSetTextContent(type, props) {
      return (
        "textarea" === type ||
        "noscript" === type ||
        "string" === typeof props.children ||
        "number" === typeof props.children ||
        "bigint" === typeof props.children ||
        ("object" === typeof props.dangerouslySetInnerHTML &&
          null !== props.dangerouslySetInnerHTML &&
          null != props.dangerouslySetInnerHTML.__html)
      );
    }
    function shouldAttemptEagerTransition() {
      var event = window.event;
      if (event && "popstate" === event.type) {
        if (event === currentPopstateTransitionEvent) return !1;
        currentPopstateTransitionEvent = event;
        return !0;
      }
      currentPopstateTransitionEvent = null;
      return !1;
    }
    function resolveEventType() {
      var event = window.event;
      return event && event !== schedulerEvent ? event.type : null;
    }
    function resolveEventTimeStamp() {
      var event = window.event;
      return event && event !== schedulerEvent ? event.timeStamp : -1.1;
    }
    function handleErrorInNextTick(error) {
      setTimeout(function () {
        throw error;
      });
    }
    function commitMount(domElement, type, newProps) {
      switch (type) {
        case "button":
        case "input":
        case "select":
        case "textarea":
          newProps.autoFocus && domElement.focus();
          break;
        case "img":
          newProps.src
            ? (domElement.src = newProps.src)
            : newProps.srcSet && (domElement.srcset = newProps.srcSet);
      }
    }
    function commitHydratedInstance() {}
    function commitUpdate(domElement, type, oldProps, newProps) {
      updateProperties(domElement, type, oldProps, newProps);
      domElement[internalPropsKey] = newProps;
    }
    function resetTextContent(domElement) {
      setTextContent(domElement, "");
    }
    function commitTextUpdate(textInstance, oldText, newText) {
      textInstance.nodeValue = newText;
    }
    function warnForReactChildrenConflict(container) {
      if (!container.__reactWarnedAboutChildrenConflict) {
        var props = container[internalPropsKey] || null;
        if (null !== props) {
          var fiber = getInstanceFromNode(container);
          null !== fiber &&
            ("string" === typeof props.children ||
            "number" === typeof props.children
              ? ((container.__reactWarnedAboutChildrenConflict = !0),
                runWithFiberInDEV(fiber, function () {
                  console.error(
                    'Cannot use a ref on a React element as a container to `createRoot` or `createPortal` if that element also sets "children" text content using React. It should be a leaf with no children. Otherwise it\'s ambiguous which children should be used.'
                  );
                }))
              : null != props.dangerouslySetInnerHTML &&
                ((container.__reactWarnedAboutChildrenConflict = !0),
                runWithFiberInDEV(fiber, function () {
                  console.error(
                    'Cannot use a ref on a React element as a container to `createRoot` or `createPortal` if that element also sets "dangerouslySetInnerHTML" using React. It should be a leaf with no children. Otherwise it\'s ambiguous which children should be used.'
                  );
                })));
        }
      }
    }
    function isSingletonScope(type) {
      return "head" === type;
    }
    function removeChild(parentInstance, child) {
      parentInstance.removeChild(child);
    }
    function removeChildFromContainer(container, child) {
      (9 === container.nodeType
        ? container.body
        : "HTML" === container.nodeName
          ? container.ownerDocument.body
          : container
      ).removeChild(child);
    }
    function clearHydrationBoundary(parentInstance, hydrationInstance) {
      var node = hydrationInstance,
        depth = 0;
      do {
        var nextNode = node.nextSibling;
        parentInstance.removeChild(node);
        if (nextNode && 8 === nextNode.nodeType)
          if (
            ((node = nextNode.data),
            node === SUSPENSE_END_DATA || node === ACTIVITY_END_DATA)
          ) {
            if (0 === depth) {
              parentInstance.removeChild(nextNode);
              retryIfBlockedOn(hydrationInstance);
              return;
            }
            depth--;
          } else if (
            node === SUSPENSE_START_DATA ||
            node === SUSPENSE_PENDING_START_DATA ||
            node === SUSPENSE_QUEUED_START_DATA ||
            node === SUSPENSE_FALLBACK_START_DATA ||
            node === ACTIVITY_START_DATA
          )
            depth++;
          else if (node === PREAMBLE_CONTRIBUTION_HTML)
            releaseSingletonInstance(
              parentInstance.ownerDocument.documentElement
            );
          else if (node === PREAMBLE_CONTRIBUTION_HEAD) {
            node = parentInstance.ownerDocument.head;
            releaseSingletonInstance(node);
            for (var node$jscomp$0 = node.firstChild; node$jscomp$0; ) {
              var nextNode$jscomp$0 = node$jscomp$0.nextSibling,
                nodeName = node$jscomp$0.nodeName;
              node$jscomp$0[internalHoistableMarker] ||
                "SCRIPT" === nodeName ||
                "STYLE" === nodeName ||
                ("LINK" === nodeName &&
                  "stylesheet" === node$jscomp$0.rel.toLowerCase()) ||
                node.removeChild(node$jscomp$0);
              node$jscomp$0 = nextNode$jscomp$0;
            }
          } else
            node === PREAMBLE_CONTRIBUTION_BODY &&
              releaseSingletonInstance(parentInstance.ownerDocument.body);
        node = nextNode;
      } while (node);
      retryIfBlockedOn(hydrationInstance);
    }
    function hideOrUnhideDehydratedBoundary(suspenseInstance, isHidden) {
      var node = suspenseInstance;
      suspenseInstance = 0;
      do {
        var nextNode = node.nextSibling;
        1 === node.nodeType
          ? isHidden
            ? ((node._stashedDisplay = node.style.display),
              (node.style.display = "none"))
            : ((node.style.display = node._stashedDisplay || ""),
              "" === node.getAttribute("style") &&
                node.removeAttribute("style"))
          : 3 === node.nodeType &&
            (isHidden
              ? ((node._stashedText = node.nodeValue), (node.nodeValue = ""))
              : (node.nodeValue = node._stashedText || ""));
        if (nextNode && 8 === nextNode.nodeType)
          if (((node = nextNode.data), node === SUSPENSE_END_DATA))
            if (0 === suspenseInstance) break;
            else suspenseInstance--;
          else
            (node !== SUSPENSE_START_DATA &&
              node !== SUSPENSE_PENDING_START_DATA &&
              node !== SUSPENSE_QUEUED_START_DATA &&
              node !== SUSPENSE_FALLBACK_START_DATA) ||
              suspenseInstance++;
        node = nextNode;
      } while (node);
    }
    function hideDehydratedBoundary(suspenseInstance) {
      hideOrUnhideDehydratedBoundary(suspenseInstance, !0);
    }
    function hideInstance(instance) {
      instance = instance.style;
      "function" === typeof instance.setProperty
        ? instance.setProperty("display", "none", "important")
        : (instance.display = "none");
    }
    function hideTextInstance(textInstance) {
      textInstance.nodeValue = "";
    }
    function unhideDehydratedBoundary(dehydratedInstance) {
      hideOrUnhideDehydratedBoundary(dehydratedInstance, !1);
    }
    function unhideInstance(instance, props) {
      props = props[STYLE];
      props =
        void 0 !== props && null !== props && props.hasOwnProperty("display")
          ? props.display
          : null;
      instance.style.display =
        null == props || "boolean" === typeof props ? "" : ("" + props).trim();
    }
    function unhideTextInstance(textInstance, text) {
      textInstance.nodeValue = text;
    }
    function clearContainerSparingly(container) {
      var nextNode = container.firstChild;
      nextNode && 10 === nextNode.nodeType && (nextNode = nextNode.nextSibling);
      for (; nextNode; ) {
        var node = nextNode;
        nextNode = nextNode.nextSibling;
        switch (node.nodeName) {
          case "HTML":
          case "HEAD":
          case "BODY":
            clearContainerSparingly(node);
            detachDeletedInstance(node);
            continue;
          case "SCRIPT":
          case "STYLE":
            continue;
          case "LINK":
            if ("stylesheet" === node.rel.toLowerCase()) continue;
        }
        container.removeChild(node);
      }
    }
    function canHydrateInstance(instance, type, props, inRootOrSingleton) {
      for (; 1 === instance.nodeType; ) {
        var anyProps = props;
        if (instance.nodeName.toLowerCase() !== type.toLowerCase()) {
          if (
            !inRootOrSingleton &&
            ("INPUT" !== instance.nodeName || "hidden" !== instance.type)
          )
            break;
        } else if (!inRootOrSingleton)
          if ("input" === type && "hidden" === instance.type) {
            checkAttributeStringCoercion(anyProps.name, "name");
            var name = null == anyProps.name ? null : "" + anyProps.name;
            if (
              "hidden" === anyProps.type &&
              instance.getAttribute("name") === name
            )
              return instance;
          } else return instance;
        else if (!instance[internalHoistableMarker])
          switch (type) {
            case "meta":
              if (!instance.hasAttribute("itemprop")) break;
              return instance;
            case "link":
              name = instance.getAttribute("rel");
              if (
                "stylesheet" === name &&
                instance.hasAttribute("data-precedence")
              )
                break;
              else if (
                name !== anyProps.rel ||
                instance.getAttribute("href") !==
                  (null == anyProps.href || "" === anyProps.href
                    ? null
                    : anyProps.href) ||
                instance.getAttribute("crossorigin") !==
                  (null == anyProps.crossOrigin
                    ? null
                    : anyProps.crossOrigin) ||
                instance.getAttribute("title") !==
                  (null == anyProps.title ? null : anyProps.title)
              )
                break;
              return instance;
            case "style":
              if (instance.hasAttribute("data-precedence")) break;
              return instance;
            case "script":
              name = instance.getAttribute("src");
              if (
                (name !== (null == anyProps.src ? null : anyProps.src) ||
                  instance.getAttribute("type") !==
                    (null == anyProps.type ? null : anyProps.type) ||
                  instance.getAttribute("crossorigin") !==
                    (null == anyProps.crossOrigin
                      ? null
                      : anyProps.crossOrigin)) &&
                name &&
                instance.hasAttribute("async") &&
                !instance.hasAttribute("itemprop")
              )
                break;
              return instance;
            default:
              return instance;
          }
        instance = getNextHydratable(instance.nextSibling);
        if (null === instance) break;
      }
      return null;
    }
    function canHydrateTextInstance(instance, text, inRootOrSingleton) {
      if ("" === text) return null;
      for (; 3 !== instance.nodeType; ) {
        if (
          (1 !== instance.nodeType ||
            "INPUT" !== instance.nodeName ||
            "hidden" !== instance.type) &&
          !inRootOrSingleton
        )
          return null;
        instance = getNextHydratable(instance.nextSibling);
        if (null === instance) return null;
      }
      return instance;
    }
    function canHydrateHydrationBoundary(instance, inRootOrSingleton) {
      for (; 8 !== instance.nodeType; ) {
        if (
          (1 !== instance.nodeType ||
            "INPUT" !== instance.nodeName ||
            "hidden" !== instance.type) &&
          !inRootOrSingleton
        )
          return null;
        instance = getNextHydratable(instance.nextSibling);
        if (null === instance) return null;
      }
      return instance;
    }
    function isSuspenseInstancePending(instance) {
      return (
        instance.data === SUSPENSE_PENDING_START_DATA ||
        instance.data === SUSPENSE_QUEUED_START_DATA
      );
    }
    function isSuspenseInstanceFallback(instance) {
      return (
        instance.data === SUSPENSE_FALLBACK_START_DATA ||
        (instance.data === SUSPENSE_PENDING_START_DATA &&
          instance.ownerDocument.readyState !== DOCUMENT_READY_STATE_LOADING)
      );
    }
    function registerSuspenseInstanceRetry(instance, callback) {
      var ownerDocument = instance.ownerDocument;
      if (instance.data === SUSPENSE_QUEUED_START_DATA)
        instance._reactRetry = callback;
      else if (
        instance.data !== SUSPENSE_PENDING_START_DATA ||
        ownerDocument.readyState !== DOCUMENT_READY_STATE_LOADING
      )
        callback();
      else {
        var listener = function () {
          callback();
          ownerDocument.removeEventListener("DOMContentLoaded", listener);
        };
        ownerDocument.addEventListener("DOMContentLoaded", listener);
        instance._reactRetry = listener;
      }
    }
    function getNextHydratable(node) {
      for (; null != node; node = node.nextSibling) {
        var nodeType = node.nodeType;
        if (1 === nodeType || 3 === nodeType) break;
        if (8 === nodeType) {
          nodeType = node.data;
          if (
            nodeType === SUSPENSE_START_DATA ||
            nodeType === SUSPENSE_FALLBACK_START_DATA ||
            nodeType === SUSPENSE_PENDING_START_DATA ||
            nodeType === SUSPENSE_QUEUED_START_DATA ||
            nodeType === ACTIVITY_START_DATA ||
            nodeType === FORM_STATE_IS_MATCHING ||
            nodeType === FORM_STATE_IS_NOT_MATCHING
          )
            break;
          if (nodeType === SUSPENSE_END_DATA || nodeType === ACTIVITY_END_DATA)
            return null;
        }
      }
      return node;
    }
    function describeHydratableInstanceForDevWarnings(instance) {
      if (1 === instance.nodeType) {
        for (
          var JSCompiler_temp_const = instance.nodeName.toLowerCase(),
            serverDifferences = {},
            attributes = instance.attributes,
            i = 0;
          i < attributes.length;
          i++
        ) {
          var attr = attributes[i];
          serverDifferences[getPropNameFromAttributeName(attr.name)] =
            "style" === attr.name.toLowerCase()
              ? getStylesObjectFromElement(instance)
              : attr.value;
        }
        return { type: JSCompiler_temp_const, props: serverDifferences };
      }
      return 8 === instance.nodeType
        ? instance.data === ACTIVITY_START_DATA
          ? { type: "Activity", props: {} }
          : { type: "Suspense", props: {} }
        : instance.nodeValue;
    }
    function diffHydratedTextForDevWarnings(textInstance, text, parentProps) {
      return null === parentProps ||
        !0 !== parentProps[SUPPRESS_HYDRATION_WARNING]
        ? (textInstance.nodeValue === text
            ? (textInstance = null)
            : ((text = normalizeMarkupForTextOrAttribute(text)),
              (textInstance =
                normalizeMarkupForTextOrAttribute(textInstance.nodeValue) ===
                text
                  ? null
                  : textInstance.nodeValue)),
          textInstance)
        : null;
    }
    function getNextHydratableInstanceAfterHydrationBoundary(
      hydrationInstance
    ) {
      hydrationInstance = hydrationInstance.nextSibling;
      for (var depth = 0; hydrationInstance; ) {
        if (8 === hydrationInstance.nodeType) {
          var data = hydrationInstance.data;
          if (data === SUSPENSE_END_DATA || data === ACTIVITY_END_DATA) {
            if (0 === depth)
              return getNextHydratable(hydrationInstance.nextSibling);
            depth--;
          } else
            (data !== SUSPENSE_START_DATA &&
              data !== SUSPENSE_FALLBACK_START_DATA &&
              data !== SUSPENSE_PENDING_START_DATA &&
              data !== SUSPENSE_QUEUED_START_DATA &&
              data !== ACTIVITY_START_DATA) ||
              depth++;
        }
        hydrationInstance = hydrationInstance.nextSibling;
      }
      return null;
    }
    function getParentHydrationBoundary(targetInstance) {
      targetInstance = targetInstance.previousSibling;
      for (var depth = 0; targetInstance; ) {
        if (8 === targetInstance.nodeType) {
          var data = targetInstance.data;
          if (
            data === SUSPENSE_START_DATA ||
            data === SUSPENSE_FALLBACK_START_DATA ||
            data === SUSPENSE_PENDING_START_DATA ||
            data === SUSPENSE_QUEUED_START_DATA ||
            data === ACTIVITY_START_DATA
          ) {
            if (0 === depth) return targetInstance;
            depth--;
          } else
            (data !== SUSPENSE_END_DATA && data !== ACTIVITY_END_DATA) ||
              depth++;
        }
        targetInstance = targetInstance.previousSibling;
      }
      return null;
    }
    function commitHydratedContainer(container) {
      retryIfBlockedOn(container);
    }
    function commitHydratedActivityInstance(activityInstance) {
      retryIfBlockedOn(activityInstance);
    }
    function commitHydratedSuspenseInstance(suspenseInstance) {
      retryIfBlockedOn(suspenseInstance);
    }
    function resolveSingletonInstance(
      type,
      props,
      rootContainerInstance,
      hostContext,
      validateDOMNestingDev
    ) {
      validateDOMNestingDev &&
        validateDOMNesting(type, hostContext.ancestorInfo);
      props = getOwnerDocumentFromRootContainer(rootContainerInstance);
      switch (type) {
        case "html":
          type = props.documentElement;
          if (!type)
            throw Error(
              "React expected an <html> element (document.documentElement) to exist in the Document but one was not found. React never removes the documentElement for any Document it renders into so the cause is likely in some other script running on this page."
            );
          return type;
        case "head":
          type = props.head;
          if (!type)
            throw Error(
              "React expected a <head> element (document.head) to exist in the Document but one was not found. React never removes the head for any Document it renders into so the cause is likely in some other script running on this page."
            );
          return type;
        case "body":
          type = props.body;
          if (!type)
            throw Error(
              "React expected a <body> element (document.body) to exist in the Document but one was not found. React never removes the body for any Document it renders into so the cause is likely in some other script running on this page."
            );
          return type;
        default:
          throw Error(
            "resolveSingletonInstance was called with an element type that is not supported. This is a bug in React."
          );
      }
    }
    function acquireSingletonInstance(
      type,
      props,
      instance,
      internalInstanceHandle
    ) {
      if (
        !instance[internalContainerInstanceKey] &&
        getInstanceFromNode(instance)
      ) {
        var tagName = instance.tagName.toLowerCase();
        console.error(
          "You are mounting a new %s component when a previous one has not first unmounted. It is an error to render more than one %s component at a time and attributes and children of these components will likely fail in unpredictable ways. Please only render a single instance of <%s> and if you need to mount a new one, ensure any previous ones have unmounted first.",
          tagName,
          tagName,
          tagName
        );
      }
      switch (type) {
        case "html":
        case "head":
        case "body":
          break;
        default:
          console.error(
            "acquireSingletonInstance was called with an element type that is not supported. This is a bug in React."
          );
      }
      for (tagName = instance.attributes; tagName.length; )
        instance.removeAttributeNode(tagName[0]);
      setInitialProperties(instance, type, props);
      instance[internalInstanceKey] = internalInstanceHandle;
      instance[internalPropsKey] = props;
    }
    function releaseSingletonInstance(instance) {
      for (var attributes = instance.attributes; attributes.length; )
        instance.removeAttributeNode(attributes[0]);
      detachDeletedInstance(instance);
    }
    function getHoistableRoot(container) {
      return "function" === typeof container.getRootNode
        ? container.getRootNode()
        : 9 === container.nodeType
          ? container
          : container.ownerDocument;
    }
    function preconnectAs(rel, href, crossOrigin) {
      var ownerDocument = globalDocument;
      if (ownerDocument && "string" === typeof href && href) {
        var limitedEscapedHref =
          escapeSelectorAttributeValueInsideDoubleQuotes(href);
        limitedEscapedHref =
          'link[rel="' + rel + '"][href="' + limitedEscapedHref + '"]';
        "string" === typeof crossOrigin &&
          (limitedEscapedHref += '[crossorigin="' + crossOrigin + '"]');
        preconnectsSet.has(limitedEscapedHref) ||
          (preconnectsSet.add(limitedEscapedHref),
          (rel = { rel: rel, crossOrigin: crossOrigin, href: href }),
          null === ownerDocument.querySelector(limitedEscapedHref) &&
            ((href = ownerDocument.createElement("link")),
            setInitialProperties(href, "link", rel),
            markNodeAsHoistable(href),
            ownerDocument.head.appendChild(href)));
      }
    }
    function getResource(type, currentProps, pendingProps, currentResource) {
      var resourceRoot = (resourceRoot = rootInstanceStackCursor.current)
        ? getHoistableRoot(resourceRoot)
        : null;
      if (!resourceRoot)
        throw Error(
          '"resourceRoot" was expected to exist. This is a bug in React.'
        );
      switch (type) {
        case "meta":
        case "title":
          return null;
        case "style":
          return "string" === typeof pendingProps.precedence &&
            "string" === typeof pendingProps.href
            ? ((pendingProps = getStyleKey(pendingProps.href)),
              (currentProps =
                getResourcesFromRoot(resourceRoot).hoistableStyles),
              (currentResource = currentProps.get(pendingProps)),
              currentResource ||
                ((currentResource = {
                  type: "style",
                  instance: null,
                  count: 0,
                  state: null
                }),
                currentProps.set(pendingProps, currentResource)),
              currentResource)
            : { type: "void", instance: null, count: 0, state: null };
        case "link":
          if (
            "stylesheet" === pendingProps.rel &&
            "string" === typeof pendingProps.href &&
            "string" === typeof pendingProps.precedence
          ) {
            type = getStyleKey(pendingProps.href);
            var _styles = getResourcesFromRoot(resourceRoot).hoistableStyles,
              _resource = _styles.get(type);
            if (
              !_resource &&
              ((resourceRoot = resourceRoot.ownerDocument || resourceRoot),
              (_resource = {
                type: "stylesheet",
                instance: null,
                count: 0,
                state: { loading: NotLoaded, preload: null }
              }),
              _styles.set(type, _resource),
              (_styles = resourceRoot.querySelector(
                getStylesheetSelectorFromKey(type)
              )) &&
                !_styles._p &&
                ((_resource.instance = _styles),
                (_resource.state.loading = Loaded | Inserted)),
              !preloadPropsMap.has(type))
            ) {
              var preloadProps = {
                rel: "preload",
                as: "style",
                href: pendingProps.href,
                crossOrigin: pendingProps.crossOrigin,
                integrity: pendingProps.integrity,
                media: pendingProps.media,
                hrefLang: pendingProps.hrefLang,
                referrerPolicy: pendingProps.referrerPolicy
              };
              preloadPropsMap.set(type, preloadProps);
              _styles ||
                preloadStylesheet(
                  resourceRoot,
                  type,
                  preloadProps,
                  _resource.state
                );
            }
            if (currentProps && null === currentResource)
              throw (
                ((pendingProps =
                  "\n\n  - " +
                  describeLinkForResourceErrorDEV(currentProps) +
                  "\n  + " +
                  describeLinkForResourceErrorDEV(pendingProps)),
                Error(
                  "Expected <link> not to update to be updated to a stylesheet with precedence. Check the `rel`, `href`, and `precedence` props of this component. Alternatively, check whether two different <link> components render in the same slot or share the same key." +
                    pendingProps
                ))
              );
            return _resource;
          }
          if (currentProps && null !== currentResource)
            throw (
              ((pendingProps =
                "\n\n  - " +
                describeLinkForResourceErrorDEV(currentProps) +
                "\n  + " +
                describeLinkForResourceErrorDEV(pendingProps)),
              Error(
                "Expected stylesheet with precedence to not be updated to a different kind of <link>. Check the `rel`, `href`, and `precedence` props of this component. Alternatively, check whether two different <link> components render in the same slot or share the same key." +
                  pendingProps
              ))
            );
          return null;
        case "script":
          return (
            (currentProps = pendingProps.async),
            (pendingProps = pendingProps.src),
            "string" === typeof pendingProps &&
            currentProps &&
            "function" !== typeof currentProps &&
            "symbol" !== typeof currentProps
              ? ((pendingProps = getScriptKey(pendingProps)),
                (currentProps =
                  getResourcesFromRoot(resourceRoot).hoistableScripts),
                (currentResource = currentProps.get(pendingProps)),
                currentResource ||
                  ((currentResource = {
                    type: "script",
                    instance: null,
                    count: 0,
                    state: null
                  }),
                  currentProps.set(pendingProps, currentResource)),
                currentResource)
              : { type: "void", instance: null, count: 0, state: null }
          );
        default:
          throw Error(
            'getResource encountered a type it did not expect: "' +
              type +
              '". this is a bug in React.'
          );
      }
    }
    function describeLinkForResourceErrorDEV(props) {
      var describedProps = 0,
        description = "<link";
      "string" === typeof props.rel
        ? (describedProps++, (description += ' rel="' + props.rel + '"'))
        : hasOwnProperty.call(props, "rel") &&
          (describedProps++,
          (description +=
            ' rel="' +
            (null === props.rel ? "null" : "invalid type " + typeof props.rel) +
            '"'));
      "string" === typeof props.href
        ? (describedProps++, (description += ' href="' + props.href + '"'))
        : hasOwnProperty.call(props, "href") &&
          (describedProps++,
          (description +=
            ' href="' +
            (null === props.href
              ? "null"
              : "invalid type " + typeof props.href) +
            '"'));
      "string" === typeof props.precedence
        ? (describedProps++,
          (description += ' precedence="' + props.precedence + '"'))
        : hasOwnProperty.call(props, "precedence") &&
          (describedProps++,
          (description +=
            " precedence={" +
            (null === props.precedence
              ? "null"
              : "invalid type " + typeof props.precedence) +
            "}"));
      Object.getOwnPropertyNames(props).length > describedProps &&
        (description += " ...");
      return description + " />";
    }
    function getStyleKey(href) {
      return (
        'href="' + escapeSelectorAttributeValueInsideDoubleQuotes(href) + '"'
      );
    }
    function getStylesheetSelectorFromKey(key) {
      return 'link[rel="stylesheet"][' + key + "]";
    }
    function stylesheetPropsFromRawProps(rawProps) {
      return assign({}, rawProps, {
        "data-precedence": rawProps.precedence,
        precedence: null
      });
    }
    function preloadStylesheet(ownerDocument, key, preloadProps, state) {
      ownerDocument.querySelector(
        'link[rel="preload"][as="style"][' + key + "]"
      )
        ? (state.loading = Loaded)
        : ((key = ownerDocument.createElement("link")),
          (state.preload = key),
          key.addEventListener("load", function () {
            return (state.loading |= Loaded);
          }),
          key.addEventListener("error", function () {
            return (state.loading |= Errored);
          }),
          setInitialProperties(key, "link", preloadProps),
          markNodeAsHoistable(key),
          ownerDocument.head.appendChild(key));
    }
    function getScriptKey(src) {
      return (
        '[src="' + escapeSelectorAttributeValueInsideDoubleQuotes(src) + '"]'
      );
    }
    function getScriptSelectorFromKey(key) {
      return "script[async]" + key;
    }
    function acquireResource(hoistableRoot, resource, props) {
      resource.count++;
      if (null === resource.instance)
        switch (resource.type) {
          case "style":
            var instance = hoistableRoot.querySelector(
              'style[data-href~="' +
                escapeSelectorAttributeValueInsideDoubleQuotes(props.href) +
                '"]'
            );
            if (instance)
              return (
                (resource.instance = instance),
                markNodeAsHoistable(instance),
                instance
              );
            var styleProps = assign({}, props, {
              "data-href": props.href,
              "data-precedence": props.precedence,
              href: null,
              precedence: null
            });
            instance = (
              hoistableRoot.ownerDocument || hoistableRoot
            ).createElement("style");
            markNodeAsHoistable(instance);
            setInitialProperties(instance, "style", styleProps);
            insertStylesheet(instance, props.precedence, hoistableRoot);
            return (resource.instance = instance);
          case "stylesheet":
            styleProps = getStyleKey(props.href);
            var _instance = hoistableRoot.querySelector(
              getStylesheetSelectorFromKey(styleProps)
            );
            if (_instance)
              return (
                (resource.state.loading |= Inserted),
                (resource.instance = _instance),
                markNodeAsHoistable(_instance),
                _instance
              );
            instance = stylesheetPropsFromRawProps(props);
            (styleProps = preloadPropsMap.get(styleProps)) &&
              adoptPreloadPropsForStylesheet(instance, styleProps);
            _instance = (
              hoistableRoot.ownerDocument || hoistableRoot
            ).createElement("link");
            markNodeAsHoistable(_instance);
            var linkInstance = _instance;
            linkInstance._p = new Promise(function (resolve, reject) {
              linkInstance.onload = resolve;
              linkInstance.onerror = reject;
            });
            setInitialProperties(_instance, "link", instance);
            resource.state.loading |= Inserted;
            insertStylesheet(_instance, props.precedence, hoistableRoot);
            return (resource.instance = _instance);
          case "script":
            _instance = getScriptKey(props.src);
            if (
              (styleProps = hoistableRoot.querySelector(
                getScriptSelectorFromKey(_instance)
              ))
            )
              return (
                (resource.instance = styleProps),
                markNodeAsHoistable(styleProps),
                styleProps
              );
            instance = props;
            if ((styleProps = preloadPropsMap.get(_instance)))
              (instance = assign({}, props)),
                adoptPreloadPropsForScript(instance, styleProps);
            hoistableRoot = hoistableRoot.ownerDocument || hoistableRoot;
            styleProps = hoistableRoot.createElement("script");
            markNodeAsHoistable(styleProps);
            setInitialProperties(styleProps, "link", instance);
            hoistableRoot.head.appendChild(styleProps);
            return (resource.instance = styleProps);
          case "void":
            return null;
          default:
            throw Error(
              'acquireResource encountered a resource type it did not expect: "' +
                resource.type +
                '". this is a bug in React.'
            );
        }
      else
        "stylesheet" === resource.type &&
          (resource.state.loading & Inserted) === NotLoaded &&
          ((instance = resource.instance),
          (resource.state.loading |= Inserted),
          insertStylesheet(instance, props.precedence, hoistableRoot));
      return resource.instance;
    }
    function insertStylesheet(instance, precedence, root) {
      for (
        var nodes = root.querySelectorAll(
            'link[rel="stylesheet"][data-precedence],style[data-precedence]'
          ),
          last = nodes.length ? nodes[nodes.length - 1] : null,
          prior = last,
          i = 0;
        i < nodes.length;
        i++
      ) {
        var node = nodes[i];
        if (node.dataset.precedence === precedence) prior = node;
        else if (prior !== last) break;
      }
      prior
        ? prior.parentNode.insertBefore(instance, prior.nextSibling)
        : ((precedence = 9 === root.nodeType ? root.head : root),
          precedence.insertBefore(instance, precedence.firstChild));
    }
    function adoptPreloadPropsForStylesheet(stylesheetProps, preloadProps) {
      null == stylesheetProps.crossOrigin &&
        (stylesheetProps.crossOrigin = preloadProps.crossOrigin);
      null == stylesheetProps.referrerPolicy &&
        (stylesheetProps.referrerPolicy = preloadProps.referrerPolicy);
      null == stylesheetProps.title &&
        (stylesheetProps.title = preloadProps.title);
    }
    function adoptPreloadPropsForScript(scriptProps, preloadProps) {
      null == scriptProps.crossOrigin &&
        (scriptProps.crossOrigin = preloadProps.crossOrigin);
      null == scriptProps.referrerPolicy &&
        (scriptProps.referrerPolicy = preloadProps.referrerPolicy);
      null == scriptProps.integrity &&
        (scriptProps.integrity = preloadProps.integrity);
    }
    function getHydratableHoistableCache(type, keyAttribute, ownerDocument) {
      if (null === tagCaches) {
        var cache = new Map();
        var caches = (tagCaches = new Map());
        caches.set(ownerDocument, cache);
      } else
        (caches = tagCaches),
          (cache = caches.get(ownerDocument)),
          cache || ((cache = new Map()), caches.set(ownerDocument, cache));
      if (cache.has(type)) return cache;
      cache.set(type, null);
      ownerDocument = ownerDocument.getElementsByTagName(type);
      for (caches = 0; caches < ownerDocument.length; caches++) {
        var node = ownerDocument[caches];
        if (
          !(
            node[internalHoistableMarker] ||
            node[internalInstanceKey] ||
            ("link" === type && "stylesheet" === node.getAttribute("rel"))
          ) &&
          node.namespaceURI !== SVG_NAMESPACE
        ) {
          var nodeKey = node.getAttribute(keyAttribute) || "";
          nodeKey = type + nodeKey;
          var existing = cache.get(nodeKey);
          existing ? existing.push(node) : cache.set(nodeKey, [node]);
        }
      }
      return cache;
    }
    function mountHoistable(hoistableRoot, type, instance) {
      hoistableRoot = hoistableRoot.ownerDocument || hoistableRoot;
      hoistableRoot.head.insertBefore(
        instance,
        "title" === type ? hoistableRoot.querySelector("head > title") : null
      );
    }
    function isHostHoistableType(type, props, hostContext) {
      var outsideHostContainerContext =
        !hostContext.ancestorInfo.containerTagInScope;
      if (
        hostContext.context === HostContextNamespaceSvg ||
        null != props.itemProp
      )
        return (
          !outsideHostContainerContext ||
            null == props.itemProp ||
            ("meta" !== type &&
              "title" !== type &&
              "style" !== type &&
              "link" !== type &&
              "script" !== type) ||
            console.error(
              "Cannot render a <%s> outside the main document if it has an `itemProp` prop. `itemProp` suggests the tag belongs to an `itemScope` which can appear anywhere in the DOM. If you were intending for React to hoist this <%s> remove the `itemProp` prop. Otherwise, try moving this tag into the <head> or <body> of the Document.",
              type,
              type
            ),
          !1
        );
      switch (type) {
        case "meta":
        case "title":
          return !0;
        case "style":
          if (
            "string" !== typeof props.precedence ||
            "string" !== typeof props.href ||
            "" === props.href
          ) {
            outsideHostContainerContext &&
              console.error(
                'Cannot render a <style> outside the main document without knowing its precedence and a unique href key. React can hoist and deduplicate <style> tags if you provide a `precedence` prop along with an `href` prop that does not conflict with the `href` values used in any other hoisted <style> or <link rel="stylesheet" ...> tags.  Note that hoisting <style> tags is considered an advanced feature that most will not use directly. Consider moving the <style> tag to the <head> or consider adding a `precedence="default"` and `href="some unique resource identifier"`.'
              );
            break;
          }
          return !0;
        case "link":
          if (
            "string" !== typeof props.rel ||
            "string" !== typeof props.href ||
            "" === props.href ||
            props.onLoad ||
            props.onError
          ) {
            if (
              "stylesheet" === props.rel &&
              "string" === typeof props.precedence
            ) {
              type = props.href;
              var onError = props.onError,
                disabled = props.disabled;
              hostContext = [];
              props.onLoad && hostContext.push("`onLoad`");
              onError && hostContext.push("`onError`");
              null != disabled && hostContext.push("`disabled`");
              onError = propNamesListJoin(hostContext, "and");
              onError += 1 === hostContext.length ? " prop" : " props";
              disabled =
                1 === hostContext.length ? "an " + onError : "the " + onError;
              hostContext.length &&
                console.error(
                  'React encountered a <link rel="stylesheet" href="%s" ... /> with a `precedence` prop that also included %s. The presence of loading and error handlers indicates an intent to manage the stylesheet loading state from your from your Component code and React will not hoist or deduplicate this stylesheet. If your intent was to have React hoist and deduplciate this stylesheet using the `precedence` prop remove the %s, otherwise remove the `precedence` prop.',
                  type,
                  disabled,
                  onError
                );
            }
            outsideHostContainerContext &&
              ("string" !== typeof props.rel ||
              "string" !== typeof props.href ||
              "" === props.href
                ? console.error(
                    "Cannot render a <link> outside the main document without a `rel` and `href` prop. Try adding a `rel` and/or `href` prop to this <link> or moving the link into the <head> tag"
                  )
                : (props.onError || props.onLoad) &&
                  console.error(
                    "Cannot render a <link> with onLoad or onError listeners outside the main document. Try removing onLoad={...} and onError={...} or moving it into the root <head> tag or somewhere in the <body>."
                  ));
            break;
          }
          switch (props.rel) {
            case "stylesheet":
              return (
                (type = props.precedence),
                (props = props.disabled),
                "string" !== typeof type &&
                  outsideHostContainerContext &&
                  console.error(
                    'Cannot render a <link rel="stylesheet" /> outside the main document without knowing its precedence. Consider adding precedence="default" or moving it into the root <head> tag.'
                  ),
                "string" === typeof type && null == props
              );
            default:
              return !0;
          }
        case "script":
          type =
            props.async &&
            "function" !== typeof props.async &&
            "symbol" !== typeof props.async;
          if (
            !type ||
            props.onLoad ||
            props.onError ||
            !props.src ||
            "string" !== typeof props.src
          ) {
            outsideHostContainerContext &&
              (type
                ? props.onLoad || props.onError
                  ? console.error(
                      "Cannot render a <script> with onLoad or onError listeners outside the main document. Try removing onLoad={...} and onError={...} or moving it into the root <head> tag or somewhere in the <body>."
                    )
                  : console.error(
                      "Cannot render a <script> outside the main document without `async={true}` and a non-empty `src` prop. Ensure there is a valid `src` and either make the script async or move it into the root <head> tag or somewhere in the <body>."
                    )
                : console.error(
                    'Cannot render a sync or defer <script> outside the main document without knowing its order. Try adding async="" or moving it into the root <head> tag.'
                  ));
            break;
          }
          return !0;
        case "noscript":
        case "template":
          outsideHostContainerContext &&
            console.error(
              "Cannot render <%s> outside the main document. Try moving it into the root <head> tag.",
              type
            );
      }
      return !1;
    }
    function preloadResource(resource) {
      return "stylesheet" === resource.type &&
        (resource.state.loading & Settled) === NotLoaded
        ? !1
        : !0;
    }
    function suspendResource(state, hoistableRoot, resource, props) {
      if (
        "stylesheet" === resource.type &&
        ("string" !== typeof props.media ||
          !1 !== matchMedia(props.media).matches) &&
        (resource.state.loading & Inserted) === NotLoaded
      ) {
        if (null === resource.instance) {
          var key = getStyleKey(props.href),
            instance = hoistableRoot.querySelector(
              getStylesheetSelectorFromKey(key)
            );
          if (instance) {
            hoistableRoot = instance._p;
            null !== hoistableRoot &&
              "object" === typeof hoistableRoot &&
              "function" === typeof hoistableRoot.then &&
              (state.count++,
              (state = onUnsuspend.bind(state)),
              hoistableRoot.then(state, state));
            resource.state.loading |= Inserted;
            resource.instance = instance;
            markNodeAsHoistable(instance);
            return;
          }
          instance = hoistableRoot.ownerDocument || hoistableRoot;
          props = stylesheetPropsFromRawProps(props);
          (key = preloadPropsMap.get(key)) &&
            adoptPreloadPropsForStylesheet(props, key);
          instance = instance.createElement("link");
          markNodeAsHoistable(instance);
          var linkInstance = instance;
          linkInstance._p = new Promise(function (resolve, reject) {
            linkInstance.onload = resolve;
            linkInstance.onerror = reject;
          });
          setInitialProperties(instance, "link", props);
          resource.instance = instance;
        }
        null === state.stylesheets && (state.stylesheets = new Map());
        state.stylesheets.set(resource, hoistableRoot);
        (hoistableRoot = resource.state.preload) &&
          (resource.state.loading & Settled) === NotLoaded &&
          (state.count++,
          (resource = onUnsuspend.bind(state)),
          hoistableRoot.addEventListener("load", resource),
          hoistableRoot.addEventListener("error", resource));
      }
    }
    function waitForCommitToBeReady(state, timeoutOffset) {
      state.stylesheets &&
        0 === state.count &&
        insertSuspendedStylesheets(state, state.stylesheets);
      return 0 < state.count || 0 < state.imgCount
        ? function (commit) {
            var stylesheetTimer = setTimeout(function () {
              state.stylesheets &&
                insertSuspendedStylesheets(state, state.stylesheets);
              if (state.unsuspend) {
                var unsuspend = state.unsuspend;
                state.unsuspend = null;
                unsuspend();
              }
            }, SUSPENSEY_STYLESHEET_TIMEOUT + timeoutOffset);
            0 < state.imgBytes &&
              0 === estimatedBytesWithinLimit &&
              (estimatedBytesWithinLimit =
                125 * estimateBandwidth() * SUSPENSEY_IMAGE_TIME_ESTIMATE);
            var imgTimer = setTimeout(
              function () {
                state.waitingForImages = !1;
                if (
                  0 === state.count &&
                  (state.stylesheets &&
                    insertSuspendedStylesheets(state, state.stylesheets),
                  state.unsuspend)
                ) {
                  var unsuspend = state.unsuspend;
                  state.unsuspend = null;
                  unsuspend();
                }
              },
              (state.imgBytes > estimatedBytesWithinLimit
                ? 50
                : SUSPENSEY_IMAGE_TIMEOUT) + timeoutOffset
            );
            state.unsuspend = commit;
            return function () {
              state.unsuspend = null;
              clearTimeout(stylesheetTimer);
              clearTimeout(imgTimer);
            };
          }
        : null;
    }
    function onUnsuspend() {
      this.count--;
      if (0 === this.count && (0 === this.imgCount || !this.waitingForImages))
        if (this.stylesheets)
          insertSuspendedStylesheets(this, this.stylesheets);
        else if (this.unsuspend) {
          var unsuspend = this.unsuspend;
          this.unsuspend = null;
          unsuspend();
        }
    }
    function insertSuspendedStylesheets(state, resources) {
      state.stylesheets = null;
      null !== state.unsuspend &&
        (state.count++,
        (precedencesByRoot = new Map()),
        resources.forEach(insertStylesheetIntoRoot, state),
        (precedencesByRoot = null),
        onUnsuspend.call(state));
    }
    function insertStylesheetIntoRoot(root, resource) {
      if (!(resource.state.loading & Inserted)) {
        var precedences = precedencesByRoot.get(root);
        if (precedences) var last = precedences.get(LAST_PRECEDENCE);
        else {
          precedences = new Map();
          precedencesByRoot.set(root, precedences);
          for (
            var nodes = root.querySelectorAll(
                "link[data-precedence],style[data-precedence]"
              ),
              i = 0;
            i < nodes.length;
            i++
          ) {
            var node = nodes[i];
            if (
              "LINK" === node.nodeName ||
              "not all" !== node.getAttribute("media")
            )
              precedences.set(node.dataset.precedence, node), (last = node);
          }
          last && precedences.set(LAST_PRECEDENCE, last);
        }
        nodes = resource.instance;
        node = nodes.getAttribute("data-precedence");
        i = precedences.get(node) || last;
        i === last && precedences.set(LAST_PRECEDENCE, nodes);
        precedences.set(node, nodes);
        this.count++;
        last = onUnsuspend.bind(this);
        nodes.addEventListener("load", last);
        nodes.addEventListener("error", last);
        i
          ? i.parentNode.insertBefore(nodes, i.nextSibling)
          : ((root = 9 === root.nodeType ? root.head : root),
            root.insertBefore(nodes, root.firstChild));
        resource.state.loading |= Inserted;
      }
    }
    function FiberRootNode(
      containerInfo,
      tag,
      hydrate,
      identifierPrefix,
      onUncaughtError,
      onCaughtError,
      onRecoverableError,
      onDefaultTransitionIndicator,
      formState
    ) {
      this.tag = 1;
      this.containerInfo = containerInfo;
      this.pingCache = this.current = this.pendingChildren = null;
      this.timeoutHandle = noTimeout;
      this.callbackNode =
        this.next =
        this.pendingContext =
        this.context =
        this.cancelPendingCommit =
          null;
      this.callbackPriority = 0;
      this.expirationTimes = createLaneMap(-1);
      this.entangledLanes =
        this.shellSuspendCounter =
        this.errorRecoveryDisabledLanes =
        this.expiredLanes =
        this.warmLanes =
        this.pingedLanes =
        this.suspendedLanes =
        this.pendingLanes =
          0;
      this.entanglements = createLaneMap(0);
      this.hiddenUpdates = createLaneMap(null);
      this.identifierPrefix = identifierPrefix;
      this.onUncaughtError = onUncaughtError;
      this.onCaughtError = onCaughtError;
      this.onRecoverableError = onRecoverableError;
      this.pooledCache = null;
      this.pooledCacheLanes = 0;
      this.formState = formState;
      this.incompleteTransitions = new Map();
      this.passiveEffectDuration = this.effectDuration = -0;
      this.memoizedUpdaters = new Set();
      containerInfo = this.pendingUpdatersLaneMap = [];
      for (tag = 0; 31 > tag; tag++) containerInfo.push(new Set());
      this._debugRootType = hydrate ? "hydrateRoot()" : "createRoot()";
    }
    function createFiberRoot(
      containerInfo,
      tag,
      hydrate,
      initialChildren,
      hydrationCallbacks,
      isStrictMode,
      identifierPrefix,
      formState,
      onUncaughtError,
      onCaughtError,
      onRecoverableError,
      onDefaultTransitionIndicator
    ) {
      containerInfo = new FiberRootNode(
        containerInfo,
        tag,
        hydrate,
        identifierPrefix,
        onUncaughtError,
        onCaughtError,
        onRecoverableError,
        onDefaultTransitionIndicator,
        formState
      );
      tag = ConcurrentMode;
      !0 === isStrictMode && (tag |= StrictLegacyMode | StrictEffectsMode);
      tag |= ProfileMode;
      isStrictMode = createFiber(3, null, null, tag);
      containerInfo.current = isStrictMode;
      isStrictMode.stateNode = containerInfo;
      tag = createCache();
      retainCache(tag);
      containerInfo.pooledCache = tag;
      retainCache(tag);
      isStrictMode.memoizedState = {
        element: initialChildren,
        isDehydrated: hydrate,
        cache: tag
      };
      initializeUpdateQueue(isStrictMode);
      return containerInfo;
    }
    function getContextForSubtree(parentComponent) {
      if (!parentComponent) return emptyContextObject;
      parentComponent = emptyContextObject;
      return parentComponent;
    }
    function updateContainerImpl(
      rootFiber,
      lane,
      element,
      container,
      parentComponent,
      callback
    ) {
      if (
        injectedHook &&
        "function" === typeof injectedHook.onScheduleFiberRoot
      )
        try {
          injectedHook.onScheduleFiberRoot(rendererID, container, element);
        } catch (err) {
          hasLoggedError ||
            ((hasLoggedError = !0),
            console.error(
              "React instrumentation encountered an error: %o",
              err
            ));
        }
      parentComponent = getContextForSubtree(parentComponent);
      null === container.context
        ? (container.context = parentComponent)
        : (container.pendingContext = parentComponent);
      isRendering &&
        null !== current &&
        !didWarnAboutNestedUpdates &&
        ((didWarnAboutNestedUpdates = !0),
        console.error(
          "Render methods should be a pure function of props and state; triggering nested component updates from render is not allowed. If necessary, trigger nested updates in componentDidUpdate.\n\nCheck the render method of %s.",
          getComponentNameFromFiber(current) || "Unknown"
        ));
      container = createUpdate(lane);
      container.payload = { element: element };
      callback = void 0 === callback ? null : callback;
      null !== callback &&
        ("function" !== typeof callback &&
          console.error(
            "Expected the last optional `callback` argument to be a function. Instead received: %s.",
            callback
          ),
        (container.callback = callback));
      element = enqueueUpdate(rootFiber, container, lane);
      null !== element &&
        (startUpdateTimerByLane(lane, "root.render()", null),
        scheduleUpdateOnFiber(element, rootFiber, lane),
        entangleTransitions(element, rootFiber, lane));
    }
    function markRetryLaneImpl(fiber, retryLane) {
      fiber = fiber.memoizedState;
      if (null !== fiber && null !== fiber.dehydrated) {
        var a = fiber.retryLane;
        fiber.retryLane = 0 !== a && a < retryLane ? a : retryLane;
      }
    }
    function markRetryLaneIfNotHydrated(fiber, retryLane) {
      markRetryLaneImpl(fiber, retryLane);
      (fiber = fiber.alternate) && markRetryLaneImpl(fiber, retryLane);
    }
    function attemptContinuousHydration(fiber) {
      if (13 === fiber.tag || 31 === fiber.tag) {
        var root = enqueueConcurrentRenderForLane(fiber, 67108864);
        null !== root && scheduleUpdateOnFiber(root, fiber, 67108864);
        markRetryLaneIfNotHydrated(fiber, 67108864);
      }
    }
    function attemptHydrationAtCurrentPriority(fiber) {
      if (13 === fiber.tag || 31 === fiber.tag) {
        var lane = requestUpdateLane(fiber);
        lane = getBumpedLaneForHydrationByLane(lane);
        var root = enqueueConcurrentRenderForLane(fiber, lane);
        null !== root && scheduleUpdateOnFiber(root, fiber, lane);
        markRetryLaneIfNotHydrated(fiber, lane);
      }
    }
    function getCurrentFiberForDevTools() {
      return current;
    }
    function dispatchDiscreteEvent(
      domEventName,
      eventSystemFlags,
      container,
      nativeEvent
    ) {
      var prevTransition = ReactSharedInternals.T;
      ReactSharedInternals.T = null;
      var previousPriority = ReactDOMSharedInternals.p;
      try {
        (ReactDOMSharedInternals.p = DiscreteEventPriority),
          dispatchEvent(domEventName, eventSystemFlags, container, nativeEvent);
      } finally {
        (ReactDOMSharedInternals.p = previousPriority),
          (ReactSharedInternals.T = prevTransition);
      }
    }
    function dispatchContinuousEvent(
      domEventName,
      eventSystemFlags,
      container,
      nativeEvent
    ) {
      var prevTransition = ReactSharedInternals.T;
      ReactSharedInternals.T = null;
      var previousPriority = ReactDOMSharedInternals.p;
      try {
        (ReactDOMSharedInternals.p = ContinuousEventPriority),
          dispatchEvent(domEventName, eventSystemFlags, container, nativeEvent);
      } finally {
        (ReactDOMSharedInternals.p = previousPriority),
          (ReactSharedInternals.T = prevTransition);
      }
    }
    function dispatchEvent(
      domEventName,
      eventSystemFlags,
      targetContainer,
      nativeEvent
    ) {
      if (_enabled) {
        var blockedOn = findInstanceBlockingEvent(nativeEvent);
        if (null === blockedOn)
          dispatchEventForPluginEventSystem(
            domEventName,
            eventSystemFlags,
            nativeEvent,
            return_targetInst,
            targetContainer
          ),
            clearIfContinuousEvent(domEventName, nativeEvent);
        else if (
          queueIfContinuousEvent(
            blockedOn,
            domEventName,
            eventSystemFlags,
            targetContainer,
            nativeEvent
          )
        )
          nativeEvent.stopPropagation();
        else if (
          (clearIfContinuousEvent(domEventName, nativeEvent),
          eventSystemFlags & 4 &&
            -1 < discreteReplayableEvents.indexOf(domEventName))
        ) {
          for (; null !== blockedOn; ) {
            var fiber = getInstanceFromNode(blockedOn);
            if (null !== fiber)
              switch (fiber.tag) {
                case 3:
                  fiber = fiber.stateNode;
                  if (fiber.current.memoizedState.isDehydrated) {
                    var lanes = getHighestPriorityLanes(fiber.pendingLanes);
                    if (0 !== lanes) {
                      var root = fiber;
                      root.pendingLanes |= 2;
                      for (root.entangledLanes |= 2; lanes; ) {
                        var lane = 1 << (31 - clz32(lanes));
                        root.entanglements[1] |= lane;
                        lanes &= ~lane;
                      }
                      ensureRootIsScheduled(fiber);
                      (executionContext & (RenderContext | CommitContext)) ===
                        NoContext &&
                        ((workInProgressRootRenderTargetTime =
                          now$1() + RENDER_TIMEOUT_MS),
                        flushSyncWorkAcrossRoots_impl(0, !1));
                    }
                  }
                  break;
                case 31:
                case 13:
                  (root = enqueueConcurrentRenderForLane(fiber, 2)),
                    null !== root && scheduleUpdateOnFiber(root, fiber, 2),
                    flushSyncWork$1(),
                    markRetryLaneIfNotHydrated(fiber, 2);
              }
            fiber = findInstanceBlockingEvent(nativeEvent);
            null === fiber &&
              dispatchEventForPluginEventSystem(
                domEventName,
                eventSystemFlags,
                nativeEvent,
                return_targetInst,
                targetContainer
              );
            if (fiber === blockedOn) break;
            blockedOn = fiber;
          }
          null !== blockedOn && nativeEvent.stopPropagation();
        } else
          dispatchEventForPluginEventSystem(
            domEventName,
            eventSystemFlags,
            nativeEvent,
            null,
            targetContainer
          );
      }
    }
    function findInstanceBlockingEvent(nativeEvent) {
      nativeEvent = getEventTarget(nativeEvent);
      return findInstanceBlockingTarget(nativeEvent);
    }
    function findInstanceBlockingTarget(targetNode) {
      return_targetInst = null;
      targetNode = getClosestInstanceFromNode(targetNode);
      if (null !== targetNode) {
        var nearestMounted = getNearestMountedFiber(targetNode);
        if (null === nearestMounted) targetNode = null;
        else {
          var tag = nearestMounted.tag;
          if (13 === tag) {
            targetNode = getSuspenseInstanceFromFiber(nearestMounted);
            if (null !== targetNode) return targetNode;
            targetNode = null;
          } else if (31 === tag) {
            targetNode = getActivityInstanceFromFiber(nearestMounted);
            if (null !== targetNode) return targetNode;
            targetNode = null;
          } else if (3 === tag) {
            if (nearestMounted.stateNode.current.memoizedState.isDehydrated)
              return 3 === nearestMounted.tag
                ? nearestMounted.stateNode.containerInfo
                : null;
            targetNode = null;
          } else nearestMounted !== targetNode && (targetNode = null);
        }
      }
      return_targetInst = targetNode;
      return null;
    }
    function getEventPriority(domEventName) {
      switch (domEventName) {
        case "beforetoggle":
        case "cancel":
        case "click":
        case "close":
        case "contextmenu":
        case "copy":
        case "cut":
        case "auxclick":
        case "dblclick":
        case "dragend":
        case "dragstart":
        case "drop":
        case "focusin":
        case "focusout":
        case "input":
        case "invalid":
        case "keydown":
        case "keypress":
        case "keyup":
        case "mousedown":
        case "mouseup":
        case "paste":
        case "pause":
        case "play":
        case "pointercancel":
        case "pointerdown":
        case "pointerup":
        case "ratechange":
        case "reset":
        case "resize":
        case "seeked":
        case "submit":
        case "toggle":
        case "touchcancel":
        case "touchend":
        case "touchstart":
        case "volumechange":
        case "change":
        case "selectionchange":
        case "textInput":
        case "compositionstart":
        case "compositionend":
        case "compositionupdate":
        case "beforeblur":
        case "afterblur":
        case "beforeinput":
        case "blur":
        case "fullscreenchange":
        case "focus":
        case "hashchange":
        case "popstate":
        case "select":
        case "selectstart":
          return DiscreteEventPriority;
        case "drag":
        case "dragenter":
        case "dragexit":
        case "dragleave":
        case "dragover":
        case "mousemove":
        case "mouseout":
        case "mouseover":
        case "pointermove":
        case "pointerout":
        case "pointerover":
        case "scroll":
        case "touchmove":
        case "wheel":
        case "mouseenter":
        case "mouseleave":
        case "pointerenter":
        case "pointerleave":
          return ContinuousEventPriority;
        case "message":
          switch (getCurrentPriorityLevel()) {
            case ImmediatePriority:
              return DiscreteEventPriority;
            case UserBlockingPriority:
              return ContinuousEventPriority;
            case NormalPriority$1:
            case LowPriority:
              return DefaultEventPriority;
            case IdlePriority:
              return IdleEventPriority;
            default:
              return DefaultEventPriority;
          }
        default:
          return DefaultEventPriority;
      }
    }
    function clearIfContinuousEvent(domEventName, nativeEvent) {
      switch (domEventName) {
        case "focusin":
        case "focusout":
          queuedFocus = null;
          break;
        case "dragenter":
        case "dragleave":
          queuedDrag = null;
          break;
        case "mouseover":
        case "mouseout":
          queuedMouse = null;
          break;
        case "pointerover":
        case "pointerout":
          queuedPointers.delete(nativeEvent.pointerId);
          break;
        case "gotpointercapture":
        case "lostpointercapture":
          queuedPointerCaptures.delete(nativeEvent.pointerId);
      }
    }
    function accumulateOrCreateContinuousQueuedReplayableEvent(
      existingQueuedEvent,
      blockedOn,
      domEventName,
      eventSystemFlags,
      targetContainer,
      nativeEvent
    ) {
      if (
        null === existingQueuedEvent ||
        existingQueuedEvent.nativeEvent !== nativeEvent
      )
        return (
          (existingQueuedEvent = {
            blockedOn: blockedOn,
            domEventName: domEventName,
            eventSystemFlags: eventSystemFlags,
            nativeEvent: nativeEvent,
            targetContainers: [targetContainer]
          }),
          null !== blockedOn &&
            ((blockedOn = getInstanceFromNode(blockedOn)),
            null !== blockedOn && attemptContinuousHydration(blockedOn)),
          existingQueuedEvent
        );
      existingQueuedEvent.eventSystemFlags |= eventSystemFlags;
      blockedOn = existingQueuedEvent.targetContainers;
      null !== targetContainer &&
        -1 === blockedOn.indexOf(targetContainer) &&
        blockedOn.push(targetContainer);
      return existingQueuedEvent;
    }
    function queueIfContinuousEvent(
      blockedOn,
      domEventName,
      eventSystemFlags,
      targetContainer,
      nativeEvent
    ) {
      switch (domEventName) {
        case "focusin":
          return (
            (queuedFocus = accumulateOrCreateContinuousQueuedReplayableEvent(
              queuedFocus,
              blockedOn,
              domEventName,
              eventSystemFlags,
              targetContainer,
              nativeEvent
            )),
            !0
          );
        case "dragenter":
          return (
            (queuedDrag = accumulateOrCreateContinuousQueuedReplayableEvent(
              queuedDrag,
              blockedOn,
              domEventName,
              eventSystemFlags,
              targetContainer,
              nativeEvent
            )),
            !0
          );
        case "mouseover":
          return (
            (queuedMouse = accumulateOrCreateContinuousQueuedReplayableEvent(
              queuedMouse,
              blockedOn,
              domEventName,
              eventSystemFlags,
              targetContainer,
              nativeEvent
            )),
            !0
          );
        case "pointerover":
          var pointerId = nativeEvent.pointerId;
          queuedPointers.set(
            pointerId,
            accumulateOrCreateContinuousQueuedReplayableEvent(
              queuedPointers.get(pointerId) || null,
              blockedOn,
              domEventName,
              eventSystemFlags,
              targetContainer,
              nativeEvent
            )
          );
          return !0;
        case "gotpointercapture":
          return (
            (pointerId = nativeEvent.pointerId),
            queuedPointerCaptures.set(
              pointerId,
              accumulateOrCreateContinuousQueuedReplayableEvent(
                queuedPointerCaptures.get(pointerId) || null,
                blockedOn,
                domEventName,
                eventSystemFlags,
                targetContainer,
                nativeEvent
              )
            ),
            !0
          );
      }
      return !1;
    }
    function attemptExplicitHydrationTarget(queuedTarget) {
      var targetInst = getClosestInstanceFromNode(queuedTarget.target);
      if (null !== targetInst) {
        var nearestMounted = getNearestMountedFiber(targetInst);
        if (null !== nearestMounted)
          if (((targetInst = nearestMounted.tag), 13 === targetInst)) {
            if (
              ((targetInst = getSuspenseInstanceFromFiber(nearestMounted)),
              null !== targetInst)
            ) {
              queuedTarget.blockedOn = targetInst;
              runWithPriority(queuedTarget.priority, function () {
                attemptHydrationAtCurrentPriority(nearestMounted);
              });
              return;
            }
          } else if (31 === targetInst) {
            if (
              ((targetInst = getActivityInstanceFromFiber(nearestMounted)),
              null !== targetInst)
            ) {
              queuedTarget.blockedOn = targetInst;
              runWithPriority(queuedTarget.priority, function () {
                attemptHydrationAtCurrentPriority(nearestMounted);
              });
              return;
            }
          } else if (
            3 === targetInst &&
            nearestMounted.stateNode.current.memoizedState.isDehydrated
          ) {
            queuedTarget.blockedOn =
              3 === nearestMounted.tag
                ? nearestMounted.stateNode.containerInfo
                : null;
            return;
          }
      }
      queuedTarget.blockedOn = null;
    }
    function attemptReplayContinuousQueuedEvent(queuedEvent) {
      if (null !== queuedEvent.blockedOn) return !1;
      for (
        var targetContainers = queuedEvent.targetContainers;
        0 < targetContainers.length;

      ) {
        var nextBlockedOn = findInstanceBlockingEvent(queuedEvent.nativeEvent);
        if (null === nextBlockedOn) {
          nextBlockedOn = queuedEvent.nativeEvent;
          var nativeEventClone = new nextBlockedOn.constructor(
              nextBlockedOn.type,
              nextBlockedOn
            ),
            event = nativeEventClone;
          null !== currentReplayingEvent &&
            console.error(
              "Expected currently replaying event to be null. This error is likely caused by a bug in React. Please file an issue."
            );
          currentReplayingEvent = event;
          nextBlockedOn.target.dispatchEvent(nativeEventClone);
          null === currentReplayingEvent &&
            console.error(
              "Expected currently replaying event to not be null. This error is likely caused by a bug in React. Please file an issue."
            );
          currentReplayingEvent = null;
        } else
          return (
            (targetContainers = getInstanceFromNode(nextBlockedOn)),
            null !== targetContainers &&
              attemptContinuousHydration(targetContainers),
            (queuedEvent.blockedOn = nextBlockedOn),
            !1
          );
        targetContainers.shift();
      }
      return !0;
    }
    function attemptReplayContinuousQueuedEventInMap(queuedEvent, key, map) {
      attemptReplayContinuousQueuedEvent(queuedEvent) && map.delete(key);
    }
    function replayUnblockedEvents() {
      hasScheduledReplayAttempt = !1;
      null !== queuedFocus &&
        attemptReplayContinuousQueuedEvent(queuedFocus) &&
        (queuedFocus = null);
      null !== queuedDrag &&
        attemptReplayContinuousQueuedEvent(queuedDrag) &&
        (queuedDrag = null);
      null !== queuedMouse &&
        attemptReplayContinuousQueuedEvent(queuedMouse) &&
        (queuedMouse = null);
      queuedPointers.forEach(attemptReplayContinuousQueuedEventInMap);
      queuedPointerCaptures.forEach(attemptReplayContinuousQueuedEventInMap);
    }
    function scheduleCallbackIfUnblocked(queuedEvent, unblocked) {
      queuedEvent.blockedOn === unblocked &&
        ((queuedEvent.blockedOn = null),
        hasScheduledReplayAttempt ||
          ((hasScheduledReplayAttempt = !0),
          Scheduler.unstable_scheduleCallback(
            Scheduler.unstable_NormalPriority,
            replayUnblockedEvents
          )));
    }
    function scheduleReplayQueueIfNeeded(formReplayingQueue) {
      lastScheduledReplayQueue !== formReplayingQueue &&
        ((lastScheduledReplayQueue = formReplayingQueue),
        Scheduler.unstable_scheduleCallback(
          Scheduler.unstable_NormalPriority,
          function () {
            lastScheduledReplayQueue === formReplayingQueue &&
              (lastScheduledReplayQueue = null);
            for (var i = 0; i < formReplayingQueue.length; i += 3) {
              var form = formReplayingQueue[i],
                submitterOrAction = formReplayingQueue[i + 1],
                formData = formReplayingQueue[i + 2];
              if ("function" !== typeof submitterOrAction)
                if (
                  null === findInstanceBlockingTarget(submitterOrAction || form)
                )
                  continue;
                else break;
              var formInst = getInstanceFromNode(form);
              null !== formInst &&
                (formReplayingQueue.splice(i, 3),
                (i -= 3),
                (form = {
                  pending: !0,
                  data: formData,
                  method: form.method,
                  action: submitterOrAction
                }),
                Object.freeze(form),
                startHostTransition(
                  formInst,
                  form,
                  submitterOrAction,
                  formData
                ));
            }
          }
        ));
    }
    function retryIfBlockedOn(unblocked) {
      function unblock(queuedEvent) {
        return scheduleCallbackIfUnblocked(queuedEvent, unblocked);
      }
      null !== queuedFocus &&
        scheduleCallbackIfUnblocked(queuedFocus, unblocked);
      null !== queuedDrag && scheduleCallbackIfUnblocked(queuedDrag, unblocked);
      null !== queuedMouse &&
        scheduleCallbackIfUnblocked(queuedMouse, unblocked);
      queuedPointers.forEach(unblock);
      queuedPointerCaptures.forEach(unblock);
      for (var i = 0; i < queuedExplicitHydrationTargets.length; i++) {
        var queuedTarget = queuedExplicitHydrationTargets[i];
        queuedTarget.blockedOn === unblocked && (queuedTarget.blockedOn = null);
      }
      for (
        ;
        0 < queuedExplicitHydrationTargets.length &&
        ((i = queuedExplicitHydrationTargets[0]), null === i.blockedOn);

      )
        attemptExplicitHydrationTarget(i),
          null === i.blockedOn && queuedExplicitHydrationTargets.shift();
      i = (unblocked.ownerDocument || unblocked).$$reactFormReplay;
      if (null != i)
        for (queuedTarget = 0; queuedTarget < i.length; queuedTarget += 3) {
          var form = i[queuedTarget],
            submitterOrAction = i[queuedTarget + 1],
            formProps = form[internalPropsKey] || null;
          if ("function" === typeof submitterOrAction)
            formProps || scheduleReplayQueueIfNeeded(i);
          else if (formProps) {
            var action = null;
            if (
              submitterOrAction &&
              submitterOrAction.hasAttribute("formAction")
            )
              if (
                ((form = submitterOrAction),
                (formProps = submitterOrAction[internalPropsKey] || null))
              )
                action = formProps.formAction;
              else {
                if (null !== findInstanceBlockingTarget(form)) continue;
              }
            else action = formProps.action;
            "function" === typeof action
              ? (i[queuedTarget + 1] = action)
              : (i.splice(queuedTarget, 3), (queuedTarget -= 3));
            scheduleReplayQueueIfNeeded(i);
          }
        }
    }
    function defaultOnDefaultTransitionIndicator() {
      function handleNavigate(event) {
        event.canIntercept &&
          "react-transition" === event.info &&
          event.intercept({
            handler: function () {
              return new Promise(function (resolve) {
                return (pendingResolve = resolve);
              });
            },
            focusReset: "manual",
            scroll: "manual"
          });
      }
      function handleNavigateComplete() {
        null !== pendingResolve && (pendingResolve(), (pendingResolve = null));
        isCancelled || setTimeout(startFakeNavigation, 20);
      }
      function startFakeNavigation() {
        if (!isCancelled && !navigation.transition) {
          var currentEntry = navigation.currentEntry;
          currentEntry &&
            null != currentEntry.url &&
            navigation.navigate(currentEntry.url, {
              state: currentEntry.getState(),
              info: "react-transition",
              history: "replace"
            });
        }
      }
      if ("object" === typeof navigation) {
        var isCancelled = !1,
          pendingResolve = null;
        navigation.addEventListener("navigate", handleNavigate);
        navigation.addEventListener("navigatesuccess", handleNavigateComplete);
        navigation.addEventListener("navigateerror", handleNavigateComplete);
        setTimeout(startFakeNavigation, 100);
        return function () {
          isCancelled = !0;
          navigation.removeEventListener("navigate", handleNavigate);
          navigation.removeEventListener(
            "navigatesuccess",
            handleNavigateComplete
          );
          navigation.removeEventListener(
            "navigateerror",
            handleNavigateComplete
          );
          null !== pendingResolve &&
            (pendingResolve(), (pendingResolve = null));
        };
      }
    }
    function ReactDOMRoot(internalRoot) {
      this._internalRoot = internalRoot;
    }
    function ReactDOMHydrationRoot(internalRoot) {
      this._internalRoot = internalRoot;
    }
    function warnIfReactDOMContainerInDEV(container) {
      container[internalContainerInstanceKey] &&
        (container._reactRootContainer
          ? console.error(
              "You are calling ReactDOMClient.createRoot() on a container that was previously passed to ReactDOM.render(). This is not supported."
            )
          : console.error(
              "You are calling ReactDOMClient.createRoot() on a container that has already been passed to createRoot() before. Instead, call root.render() on the existing root instead if you want to update it."
            ));
    }
    "undefined" !== typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ &&
      "function" ===
        typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStart &&
      __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStart(Error());
    var Scheduler = __webpack_require__(/*! scheduler */ "./node_modules/scheduler/index.js"),
      React = __webpack_require__(/*! react */ "./node_modules/react/index.js"),
      ReactDOM = __webpack_require__(/*! react-dom */ "./node_modules/react-dom/index.js"),
      assign = Object.assign,
      REACT_LEGACY_ELEMENT_TYPE = Symbol.for("react.element"),
      REACT_ELEMENT_TYPE = Symbol.for("react.transitional.element"),
      REACT_PORTAL_TYPE = Symbol.for("react.portal"),
      REACT_FRAGMENT_TYPE = Symbol.for("react.fragment"),
      REACT_STRICT_MODE_TYPE = Symbol.for("react.strict_mode"),
      REACT_PROFILER_TYPE = Symbol.for("react.profiler"),
      REACT_CONSUMER_TYPE = Symbol.for("react.consumer"),
      REACT_CONTEXT_TYPE = Symbol.for("react.context"),
      REACT_FORWARD_REF_TYPE = Symbol.for("react.forward_ref"),
      REACT_SUSPENSE_TYPE = Symbol.for("react.suspense"),
      REACT_SUSPENSE_LIST_TYPE = Symbol.for("react.suspense_list"),
      REACT_MEMO_TYPE = Symbol.for("react.memo"),
      REACT_LAZY_TYPE = Symbol.for("react.lazy");
    Symbol.for("react.scope");
    var REACT_ACTIVITY_TYPE = Symbol.for("react.activity");
    Symbol.for("react.legacy_hidden");
    Symbol.for("react.tracing_marker");
    var REACT_MEMO_CACHE_SENTINEL = Symbol.for("react.memo_cache_sentinel");
    Symbol.for("react.view_transition");
    var MAYBE_ITERATOR_SYMBOL = Symbol.iterator,
      REACT_CLIENT_REFERENCE = Symbol.for("react.client.reference"),
      isArrayImpl = Array.isArray,
      ReactSharedInternals =
        React.__CLIENT_INTERNALS_DO_NOT_USE_OR_WARN_USERS_THEY_CANNOT_UPGRADE,
      ReactDOMSharedInternals =
        ReactDOM.__DOM_INTERNALS_DO_NOT_USE_OR_WARN_USERS_THEY_CANNOT_UPGRADE,
      NotPending = Object.freeze({
        pending: !1,
        data: null,
        method: null,
        action: null
      }),
      valueStack = [];
    var fiberStack = [];
    var index$jscomp$0 = -1,
      contextStackCursor = createCursor(null),
      contextFiberStackCursor = createCursor(null),
      rootInstanceStackCursor = createCursor(null),
      hostTransitionProviderCursor = createCursor(null),
      disabledDepth = 0,
      prevLog,
      prevInfo,
      prevWarn,
      prevError,
      prevGroup,
      prevGroupCollapsed,
      prevGroupEnd;
    disabledLog.__reactDisabledLog = !0;
    var prefix,
      suffix,
      reentry = !1;
    var componentFrameCache = new (
      "function" === typeof WeakMap ? WeakMap : Map
    )();
    var current = null,
      isRendering = !1,
      hasOwnProperty = Object.prototype.hasOwnProperty,
      scheduleCallback$3 = Scheduler.unstable_scheduleCallback,
      cancelCallback$1 = Scheduler.unstable_cancelCallback,
      shouldYield = Scheduler.unstable_shouldYield,
      requestPaint = Scheduler.unstable_requestPaint,
      now$1 = Scheduler.unstable_now,
      getCurrentPriorityLevel = Scheduler.unstable_getCurrentPriorityLevel,
      ImmediatePriority = Scheduler.unstable_ImmediatePriority,
      UserBlockingPriority = Scheduler.unstable_UserBlockingPriority,
      NormalPriority$1 = Scheduler.unstable_NormalPriority,
      LowPriority = Scheduler.unstable_LowPriority,
      IdlePriority = Scheduler.unstable_IdlePriority,
      log$1 = Scheduler.log,
      unstable_setDisableYieldValue = Scheduler.unstable_setDisableYieldValue,
      rendererID = null,
      injectedHook = null,
      hasLoggedError = !1,
      isDevToolsPresent = "undefined" !== typeof __REACT_DEVTOOLS_GLOBAL_HOOK__,
      clz32 = Math.clz32 ? Math.clz32 : clz32Fallback,
      log = Math.log,
      LN2 = Math.LN2,
      nextTransitionUpdateLane = 256,
      nextTransitionDeferredLane = 262144,
      nextRetryLane = 4194304,
      DiscreteEventPriority = 2,
      ContinuousEventPriority = 8,
      DefaultEventPriority = 32,
      IdleEventPriority = 268435456,
      randomKey = Math.random().toString(36).slice(2),
      internalInstanceKey = "__reactFiber$" + randomKey,
      internalPropsKey = "__reactProps$" + randomKey,
      internalContainerInstanceKey = "__reactContainer$" + randomKey,
      internalEventHandlersKey = "__reactEvents$" + randomKey,
      internalEventHandlerListenersKey = "__reactListeners$" + randomKey,
      internalEventHandlesSetKey = "__reactHandles$" + randomKey,
      internalRootNodeResourcesKey = "__reactResources$" + randomKey,
      internalHoistableMarker = "__reactMarker$" + randomKey,
      allNativeEvents = new Set(),
      registrationNameDependencies = {},
      possibleRegistrationNames = {},
      hasReadOnlyValue = {
        button: !0,
        checkbox: !0,
        image: !0,
        hidden: !0,
        radio: !0,
        reset: !0,
        submit: !0
      },
      VALID_ATTRIBUTE_NAME_REGEX = RegExp(
        "^[:A-Z_a-z\\u00C0-\\u00D6\\u00D8-\\u00F6\\u00F8-\\u02FF\\u0370-\\u037D\\u037F-\\u1FFF\\u200C-\\u200D\\u2070-\\u218F\\u2C00-\\u2FEF\\u3001-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFFD][:A-Z_a-z\\u00C0-\\u00D6\\u00D8-\\u00F6\\u00F8-\\u02FF\\u0370-\\u037D\\u037F-\\u1FFF\\u200C-\\u200D\\u2070-\\u218F\\u2C00-\\u2FEF\\u3001-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFFD\\-.0-9\\u00B7\\u0300-\\u036F\\u203F-\\u2040]*$"
      ),
      illegalAttributeNameCache = {},
      validatedAttributeNameCache = {},
      escapeSelectorAttributeValueInsideDoubleQuotesRegex = /[\n"\\]/g,
      didWarnValueDefaultValue$1 = !1,
      didWarnCheckedDefaultChecked = !1,
      didWarnSelectedSetOnOption = !1,
      didWarnInvalidChild = !1,
      didWarnInvalidInnerHTML = !1;
    var didWarnValueDefaultValue = !1;
    var valuePropNames = ["value", "defaultValue"],
      didWarnValDefaultVal = !1,
      needsEscaping = /["'&<>\n\t]|^\s|\s$/,
      specialTags =
        "address applet area article aside base basefont bgsound blockquote body br button caption center col colgroup dd details dir div dl dt embed fieldset figcaption figure footer form frame frameset h1 h2 h3 h4 h5 h6 head header hgroup hr html iframe img input isindex li link listing main marquee menu menuitem meta nav noembed noframes noscript object ol p param plaintext pre script section select source style summary table tbody td template textarea tfoot th thead title tr track ul wbr xmp".split(
          " "
        ),
      inScopeTags =
        "applet caption html table td th marquee object template foreignObject desc title".split(
          " "
        ),
      buttonScopeTags = inScopeTags.concat(["button"]),
      impliedEndTags = "dd dt li option optgroup p rp rt".split(" "),
      emptyAncestorInfoDev = {
        current: null,
        formTag: null,
        aTagInScope: null,
        buttonTagInScope: null,
        nobrTagInScope: null,
        pTagInButtonScope: null,
        listItemTagAutoclosing: null,
        dlItemTagAutoclosing: null,
        containerTagInScope: null,
        implicitRootScope: !1
      },
      didWarn = {},
      shorthandToLonghand = {
        animation:
          "animationDelay animationDirection animationDuration animationFillMode animationIterationCount animationName animationPlayState animationTimingFunction".split(
            " "
          ),
        background:
          "backgroundAttachment backgroundClip backgroundColor backgroundImage backgroundOrigin backgroundPositionX backgroundPositionY backgroundRepeat backgroundSize".split(
            " "
          ),
        backgroundPosition: ["backgroundPositionX", "backgroundPositionY"],
        border:
          "borderBottomColor borderBottomStyle borderBottomWidth borderImageOutset borderImageRepeat borderImageSlice borderImageSource borderImageWidth borderLeftColor borderLeftStyle borderLeftWidth borderRightColor borderRightStyle borderRightWidth borderTopColor borderTopStyle borderTopWidth".split(
            " "
          ),
        borderBlockEnd: [
          "borderBlockEndColor",
          "borderBlockEndStyle",
          "borderBlockEndWidth"
        ],
        borderBlockStart: [
          "borderBlockStartColor",
          "borderBlockStartStyle",
          "borderBlockStartWidth"
        ],
        borderBottom: [
          "borderBottomColor",
          "borderBottomStyle",
          "borderBottomWidth"
        ],
        borderColor: [
          "borderBottomColor",
          "borderLeftColor",
          "borderRightColor",
          "borderTopColor"
        ],
        borderImage: [
          "borderImageOutset",
          "borderImageRepeat",
          "borderImageSlice",
          "borderImageSource",
          "borderImageWidth"
        ],
        borderInlineEnd: [
          "borderInlineEndColor",
          "borderInlineEndStyle",
          "borderInlineEndWidth"
        ],
        borderInlineStart: [
          "borderInlineStartColor",
          "borderInlineStartStyle",
          "borderInlineStartWidth"
        ],
        borderLeft: ["borderLeftColor", "borderLeftStyle", "borderLeftWidth"],
        borderRadius: [
          "borderBottomLeftRadius",
          "borderBottomRightRadius",
          "borderTopLeftRadius",
          "borderTopRightRadius"
        ],
        borderRight: [
          "borderRightColor",
          "borderRightStyle",
          "borderRightWidth"
        ],
        borderStyle: [
          "borderBottomStyle",
          "borderLeftStyle",
          "borderRightStyle",
          "borderTopStyle"
        ],
        borderTop: ["borderTopColor", "borderTopStyle", "borderTopWidth"],
        borderWidth: [
          "borderBottomWidth",
          "borderLeftWidth",
          "borderRightWidth",
          "borderTopWidth"
        ],
        columnRule: ["columnRuleColor", "columnRuleStyle", "columnRuleWidth"],
        columns: ["columnCount", "columnWidth"],
        flex: ["flexBasis", "flexGrow", "flexShrink"],
        flexFlow: ["flexDirection", "flexWrap"],
        font: "fontFamily fontFeatureSettings fontKerning fontLanguageOverride fontSize fontSizeAdjust fontStretch fontStyle fontVariant fontVariantAlternates fontVariantCaps fontVariantEastAsian fontVariantLigatures fontVariantNumeric fontVariantPosition fontWeight lineHeight".split(
          " "
        ),
        fontVariant:
          "fontVariantAlternates fontVariantCaps fontVariantEastAsian fontVariantLigatures fontVariantNumeric fontVariantPosition".split(
            " "
          ),
        gap: ["columnGap", "rowGap"],
        grid: "gridAutoColumns gridAutoFlow gridAutoRows gridTemplateAreas gridTemplateColumns gridTemplateRows".split(
          " "
        ),
        gridArea: [
          "gridColumnEnd",
          "gridColumnStart",
          "gridRowEnd",
          "gridRowStart"
        ],
        gridColumn: ["gridColumnEnd", "gridColumnStart"],
        gridColumnGap: ["columnGap"],
        gridGap: ["columnGap", "rowGap"],
        gridRow: ["gridRowEnd", "gridRowStart"],
        gridRowGap: ["rowGap"],
        gridTemplate: [
          "gridTemplateAreas",
          "gridTemplateColumns",
          "gridTemplateRows"
        ],
        listStyle: ["listStyleImage", "listStylePosition", "listStyleType"],
        margin: ["marginBottom", "marginLeft", "marginRight", "marginTop"],
        marker: ["markerEnd", "markerMid", "markerStart"],
        mask: "maskClip maskComposite maskImage maskMode maskOrigin maskPositionX maskPositionY maskRepeat maskSize".split(
          " "
        ),
        maskPosition: ["maskPositionX", "maskPositionY"],
        outline: ["outlineColor", "outlineStyle", "outlineWidth"],
        overflow: ["overflowX", "overflowY"],
        padding: ["paddingBottom", "paddingLeft", "paddingRight", "paddingTop"],
        placeContent: ["alignContent", "justifyContent"],
        placeItems: ["alignItems", "justifyItems"],
        placeSelf: ["alignSelf", "justifySelf"],
        textDecoration: [
          "textDecorationColor",
          "textDecorationLine",
          "textDecorationStyle"
        ],
        textEmphasis: ["textEmphasisColor", "textEmphasisStyle"],
        transition: [
          "transitionDelay",
          "transitionDuration",
          "transitionProperty",
          "transitionTimingFunction"
        ],
        wordWrap: ["overflowWrap"]
      },
      uppercasePattern = /([A-Z])/g,
      msPattern$1 = /^ms-/,
      badVendoredStyleNamePattern = /^(?:webkit|moz|o)[A-Z]/,
      msPattern = /^-ms-/,
      hyphenPattern = /-(.)/g,
      badStyleValueWithSemicolonPattern = /;\s*$/,
      warnedStyleNames = {},
      warnedStyleValues = {},
      warnedForNaNValue = !1,
      warnedForInfinityValue = !1,
      unitlessNumbers = new Set(
        "animationIterationCount aspectRatio borderImageOutset borderImageSlice borderImageWidth boxFlex boxFlexGroup boxOrdinalGroup columnCount columns flex flexGrow flexPositive flexShrink flexNegative flexOrder gridArea gridRow gridRowEnd gridRowSpan gridRowStart gridColumn gridColumnEnd gridColumnSpan gridColumnStart fontWeight lineClamp lineHeight opacity order orphans scale tabSize widows zIndex zoom fillOpacity floodOpacity stopOpacity strokeDasharray strokeDashoffset strokeMiterlimit strokeOpacity strokeWidth MozAnimationIterationCount MozBoxFlex MozBoxFlexGroup MozLineClamp msAnimationIterationCount msFlex msZoom msFlexGrow msFlexNegative msFlexOrder msFlexPositive msFlexShrink msGridColumn msGridColumnSpan msGridRow msGridRowSpan WebkitAnimationIterationCount WebkitBoxFlex WebKitBoxFlexGroup WebkitBoxOrdinalGroup WebkitColumnCount WebkitColumns WebkitFlex WebkitFlexGrow WebkitFlexPositive WebkitFlexShrink WebkitLineClamp".split(
          " "
        )
      ),
      MATH_NAMESPACE = "http://www.w3.org/1998/Math/MathML",
      SVG_NAMESPACE = "http://www.w3.org/2000/svg",
      aliases = new Map([
        ["acceptCharset", "accept-charset"],
        ["htmlFor", "for"],
        ["httpEquiv", "http-equiv"],
        ["crossOrigin", "crossorigin"],
        ["accentHeight", "accent-height"],
        ["alignmentBaseline", "alignment-baseline"],
        ["arabicForm", "arabic-form"],
        ["baselineShift", "baseline-shift"],
        ["capHeight", "cap-height"],
        ["clipPath", "clip-path"],
        ["clipRule", "clip-rule"],
        ["colorInterpolation", "color-interpolation"],
        ["colorInterpolationFilters", "color-interpolation-filters"],
        ["colorProfile", "color-profile"],
        ["colorRendering", "color-rendering"],
        ["dominantBaseline", "dominant-baseline"],
        ["enableBackground", "enable-background"],
        ["fillOpacity", "fill-opacity"],
        ["fillRule", "fill-rule"],
        ["floodColor", "flood-color"],
        ["floodOpacity", "flood-opacity"],
        ["fontFamily", "font-family"],
        ["fontSize", "font-size"],
        ["fontSizeAdjust", "font-size-adjust"],
        ["fontStretch", "font-stretch"],
        ["fontStyle", "font-style"],
        ["fontVariant", "font-variant"],
        ["fontWeight", "font-weight"],
        ["glyphName", "glyph-name"],
        ["glyphOrientationHorizontal", "glyph-orientation-horizontal"],
        ["glyphOrientationVertical", "glyph-orientation-vertical"],
        ["horizAdvX", "horiz-adv-x"],
        ["horizOriginX", "horiz-origin-x"],
        ["imageRendering", "image-rendering"],
        ["letterSpacing", "letter-spacing"],
        ["lightingColor", "lighting-color"],
        ["markerEnd", "marker-end"],
        ["markerMid", "marker-mid"],
        ["markerStart", "marker-start"],
        ["overlinePosition", "overline-position"],
        ["overlineThickness", "overline-thickness"],
        ["paintOrder", "paint-order"],
        ["panose-1", "panose-1"],
        ["pointerEvents", "pointer-events"],
        ["renderingIntent", "rendering-intent"],
        ["shapeRendering", "shape-rendering"],
        ["stopColor", "stop-color"],
        ["stopOpacity", "stop-opacity"],
        ["strikethroughPosition", "strikethrough-position"],
        ["strikethroughThickness", "strikethrough-thickness"],
        ["strokeDasharray", "stroke-dasharray"],
        ["strokeDashoffset", "stroke-dashoffset"],
        ["strokeLinecap", "stroke-linecap"],
        ["strokeLinejoin", "stroke-linejoin"],
        ["strokeMiterlimit", "stroke-miterlimit"],
        ["strokeOpacity", "stroke-opacity"],
        ["strokeWidth", "stroke-width"],
        ["textAnchor", "text-anchor"],
        ["textDecoration", "text-decoration"],
        ["textRendering", "text-rendering"],
        ["transformOrigin", "transform-origin"],
        ["underlinePosition", "underline-position"],
        ["underlineThickness", "underline-thickness"],
        ["unicodeBidi", "unicode-bidi"],
        ["unicodeRange", "unicode-range"],
        ["unitsPerEm", "units-per-em"],
        ["vAlphabetic", "v-alphabetic"],
        ["vHanging", "v-hanging"],
        ["vIdeographic", "v-ideographic"],
        ["vMathematical", "v-mathematical"],
        ["vectorEffect", "vector-effect"],
        ["vertAdvY", "vert-adv-y"],
        ["vertOriginX", "vert-origin-x"],
        ["vertOriginY", "vert-origin-y"],
        ["wordSpacing", "word-spacing"],
        ["writingMode", "writing-mode"],
        ["xmlnsXlink", "xmlns:xlink"],
        ["xHeight", "x-height"]
      ]),
      possibleStandardNames = {
        accept: "accept",
        acceptcharset: "acceptCharset",
        "accept-charset": "acceptCharset",
        accesskey: "accessKey",
        action: "action",
        allowfullscreen: "allowFullScreen",
        alt: "alt",
        as: "as",
        async: "async",
        autocapitalize: "autoCapitalize",
        autocomplete: "autoComplete",
        autocorrect: "autoCorrect",
        autofocus: "autoFocus",
        autoplay: "autoPlay",
        autosave: "autoSave",
        capture: "capture",
        cellpadding: "cellPadding",
        cellspacing: "cellSpacing",
        challenge: "challenge",
        charset: "charSet",
        checked: "checked",
        children: "children",
        cite: "cite",
        class: "className",
        classid: "classID",
        classname: "className",
        cols: "cols",
        colspan: "colSpan",
        content: "content",
        contenteditable: "contentEditable",
        contextmenu: "contextMenu",
        controls: "controls",
        controlslist: "controlsList",
        coords: "coords",
        crossorigin: "crossOrigin",
        dangerouslysetinnerhtml: "dangerouslySetInnerHTML",
        data: "data",
        datetime: "dateTime",
        default: "default",
        defaultchecked: "defaultChecked",
        defaultvalue: "defaultValue",
        defer: "defer",
        dir: "dir",
        disabled: "disabled",
        disablepictureinpicture: "disablePictureInPicture",
        disableremoteplayback: "disableRemotePlayback",
        download: "download",
        draggable: "draggable",
        enctype: "encType",
        enterkeyhint: "enterKeyHint",
        fetchpriority: "fetchPriority",
        for: "htmlFor",
        form: "form",
        formmethod: "formMethod",
        formaction: "formAction",
        formenctype: "formEncType",
        formnovalidate: "formNoValidate",
        formtarget: "formTarget",
        frameborder: "frameBorder",
        headers: "headers",
        height: "height",
        hidden: "hidden",
        high: "high",
        href: "href",
        hreflang: "hrefLang",
        htmlfor: "htmlFor",
        httpequiv: "httpEquiv",
        "http-equiv": "httpEquiv",
        icon: "icon",
        id: "id",
        imagesizes: "imageSizes",
        imagesrcset: "imageSrcSet",
        inert: "inert",
        innerhtml: "innerHTML",
        inputmode: "inputMode",
        integrity: "integrity",
        is: "is",
        itemid: "itemID",
        itemprop: "itemProp",
        itemref: "itemRef",
        itemscope: "itemScope",
        itemtype: "itemType",
        keyparams: "keyParams",
        keytype: "keyType",
        kind: "kind",
        label: "label",
        lang: "lang",
        list: "list",
        loop: "loop",
        low: "low",
        manifest: "manifest",
        marginwidth: "marginWidth",
        marginheight: "marginHeight",
        max: "max",
        maxlength: "maxLength",
        media: "media",
        mediagroup: "mediaGroup",
        method: "method",
        min: "min",
        minlength: "minLength",
        multiple: "multiple",
        muted: "muted",
        name: "name",
        nomodule: "noModule",
        nonce: "nonce",
        novalidate: "noValidate",
        open: "open",
        optimum: "optimum",
        pattern: "pattern",
        placeholder: "placeholder",
        playsinline: "playsInline",
        poster: "poster",
        preload: "preload",
        profile: "profile",
        radiogroup: "radioGroup",
        readonly: "readOnly",
        referrerpolicy: "referrerPolicy",
        rel: "rel",
        required: "required",
        reversed: "reversed",
        role: "role",
        rows: "rows",
        rowspan: "rowSpan",
        sandbox: "sandbox",
        scope: "scope",
        scoped: "scoped",
        scrolling: "scrolling",
        seamless: "seamless",
        selected: "selected",
        shape: "shape",
        size: "size",
        sizes: "sizes",
        span: "span",
        spellcheck: "spellCheck",
        src: "src",
        srcdoc: "srcDoc",
        srclang: "srcLang",
        srcset: "srcSet",
        start: "start",
        step: "step",
        style: "style",
        summary: "summary",
        tabindex: "tabIndex",
        target: "target",
        title: "title",
        type: "type",
        usemap: "useMap",
        value: "value",
        width: "width",
        wmode: "wmode",
        wrap: "wrap",
        about: "about",
        accentheight: "accentHeight",
        "accent-height": "accentHeight",
        accumulate: "accumulate",
        additive: "additive",
        alignmentbaseline: "alignmentBaseline",
        "alignment-baseline": "alignmentBaseline",
        allowreorder: "allowReorder",
        alphabetic: "alphabetic",
        amplitude: "amplitude",
        arabicform: "arabicForm",
        "arabic-form": "arabicForm",
        ascent: "ascent",
        attributename: "attributeName",
        attributetype: "attributeType",
        autoreverse: "autoReverse",
        azimuth: "azimuth",
        basefrequency: "baseFrequency",
        baselineshift: "baselineShift",
        "baseline-shift": "baselineShift",
        baseprofile: "baseProfile",
        bbox: "bbox",
        begin: "begin",
        bias: "bias",
        by: "by",
        calcmode: "calcMode",
        capheight: "capHeight",
        "cap-height": "capHeight",
        clip: "clip",
        clippath: "clipPath",
        "clip-path": "clipPath",
        clippathunits: "clipPathUnits",
        cliprule: "clipRule",
        "clip-rule": "clipRule",
        color: "color",
        colorinterpolation: "colorInterpolation",
        "color-interpolation": "colorInterpolation",
        colorinterpolationfilters: "colorInterpolationFilters",
        "color-interpolation-filters": "colorInterpolationFilters",
        colorprofile: "colorProfile",
        "color-profile": "colorProfile",
        colorrendering: "colorRendering",
        "color-rendering": "colorRendering",
        contentscripttype: "contentScriptType",
        contentstyletype: "contentStyleType",
        cursor: "cursor",
        cx: "cx",
        cy: "cy",
        d: "d",
        datatype: "datatype",
        decelerate: "decelerate",
        descent: "descent",
        diffuseconstant: "diffuseConstant",
        direction: "direction",
        display: "display",
        divisor: "divisor",
        dominantbaseline: "dominantBaseline",
        "dominant-baseline": "dominantBaseline",
        dur: "dur",
        dx: "dx",
        dy: "dy",
        edgemode: "edgeMode",
        elevation: "elevation",
        enablebackground: "enableBackground",
        "enable-background": "enableBackground",
        end: "end",
        exponent: "exponent",
        externalresourcesrequired: "externalResourcesRequired",
        fill: "fill",
        fillopacity: "fillOpacity",
        "fill-opacity": "fillOpacity",
        fillrule: "fillRule",
        "fill-rule": "fillRule",
        filter: "filter",
        filterres: "filterRes",
        filterunits: "filterUnits",
        floodopacity: "floodOpacity",
        "flood-opacity": "floodOpacity",
        floodcolor: "floodColor",
        "flood-color": "floodColor",
        focusable: "focusable",
        fontfamily: "fontFamily",
        "font-family": "fontFamily",
        fontsize: "fontSize",
        "font-size": "fontSize",
        fontsizeadjust: "fontSizeAdjust",
        "font-size-adjust": "fontSizeAdjust",
        fontstretch: "fontStretch",
        "font-stretch": "fontStretch",
        fontstyle: "fontStyle",
        "font-style": "fontStyle",
        fontvariant: "fontVariant",
        "font-variant": "fontVariant",
        fontweight: "fontWeight",
        "font-weight": "fontWeight",
        format: "format",
        from: "from",
        fx: "fx",
        fy: "fy",
        g1: "g1",
        g2: "g2",
        glyphname: "glyphName",
        "glyph-name": "glyphName",
        glyphorientationhorizontal: "glyphOrientationHorizontal",
        "glyph-orientation-horizontal": "glyphOrientationHorizontal",
        glyphorientationvertical: "glyphOrientationVertical",
        "glyph-orientation-vertical": "glyphOrientationVertical",
        glyphref: "glyphRef",
        gradienttransform: "gradientTransform",
        gradientunits: "gradientUnits",
        hanging: "hanging",
        horizadvx: "horizAdvX",
        "horiz-adv-x": "horizAdvX",
        horizoriginx: "horizOriginX",
        "horiz-origin-x": "horizOriginX",
        ideographic: "ideographic",
        imagerendering: "imageRendering",
        "image-rendering": "imageRendering",
        in2: "in2",
        in: "in",
        inlist: "inlist",
        intercept: "intercept",
        k1: "k1",
        k2: "k2",
        k3: "k3",
        k4: "k4",
        k: "k",
        kernelmatrix: "kernelMatrix",
        kernelunitlength: "kernelUnitLength",
        kerning: "kerning",
        keypoints: "keyPoints",
        keysplines: "keySplines",
        keytimes: "keyTimes",
        lengthadjust: "lengthAdjust",
        letterspacing: "letterSpacing",
        "letter-spacing": "letterSpacing",
        lightingcolor: "lightingColor",
        "lighting-color": "lightingColor",
        limitingconeangle: "limitingConeAngle",
        local: "local",
        markerend: "markerEnd",
        "marker-end": "markerEnd",
        markerheight: "markerHeight",
        markermid: "markerMid",
        "marker-mid": "markerMid",
        markerstart: "markerStart",
        "marker-start": "markerStart",
        markerunits: "markerUnits",
        markerwidth: "markerWidth",
        mask: "mask",
        maskcontentunits: "maskContentUnits",
        maskunits: "maskUnits",
        mathematical: "mathematical",
        mode: "mode",
        numoctaves: "numOctaves",
        offset: "offset",
        opacity: "opacity",
        operator: "operator",
        order: "order",
        orient: "orient",
        orientation: "orientation",
        origin: "origin",
        overflow: "overflow",
        overlineposition: "overlinePosition",
        "overline-position": "overlinePosition",
        overlinethickness: "overlineThickness",
        "overline-thickness": "overlineThickness",
        paintorder: "paintOrder",
        "paint-order": "paintOrder",
        panose1: "panose1",
        "panose-1": "panose1",
        pathlength: "pathLength",
        patterncontentunits: "patternContentUnits",
        patterntransform: "patternTransform",
        patternunits: "patternUnits",
        pointerevents: "pointerEvents",
        "pointer-events": "pointerEvents",
        points: "points",
        pointsatx: "pointsAtX",
        pointsaty: "pointsAtY",
        pointsatz: "pointsAtZ",
        popover: "popover",
        popovertarget: "popoverTarget",
        popovertargetaction: "popoverTargetAction",
        prefix: "prefix",
        preservealpha: "preserveAlpha",
        preserveaspectratio: "preserveAspectRatio",
        primitiveunits: "primitiveUnits",
        property: "property",
        r: "r",
        radius: "radius",
        refx: "refX",
        refy: "refY",
        renderingintent: "renderingIntent",
        "rendering-intent": "renderingIntent",
        repeatcount: "repeatCount",
        repeatdur: "repeatDur",
        requiredextensions: "requiredExtensions",
        requiredfeatures: "requiredFeatures",
        resource: "resource",
        restart: "restart",
        result: "result",
        results: "results",
        rotate: "rotate",
        rx: "rx",
        ry: "ry",
        scale: "scale",
        security: "security",
        seed: "seed",
        shaperendering: "shapeRendering",
        "shape-rendering": "shapeRendering",
        slope: "slope",
        spacing: "spacing",
        specularconstant: "specularConstant",
        specularexponent: "specularExponent",
        speed: "speed",
        spreadmethod: "spreadMethod",
        startoffset: "startOffset",
        stddeviation: "stdDeviation",
        stemh: "stemh",
        stemv: "stemv",
        stitchtiles: "stitchTiles",
        stopcolor: "stopColor",
        "stop-color": "stopColor",
        stopopacity: "stopOpacity",
        "stop-opacity": "stopOpacity",
        strikethroughposition: "strikethroughPosition",
        "strikethrough-position": "strikethroughPosition",
        strikethroughthickness: "strikethroughThickness",
        "strikethrough-thickness": "strikethroughThickness",
        string: "string",
        stroke: "stroke",
        strokedasharray: "strokeDasharray",
        "stroke-dasharray": "strokeDasharray",
        strokedashoffset: "strokeDashoffset",
        "stroke-dashoffset": "strokeDashoffset",
        strokelinecap: "strokeLinecap",
        "stroke-linecap": "strokeLinecap",
        strokelinejoin: "strokeLinejoin",
        "stroke-linejoin": "strokeLinejoin",
        strokemiterlimit: "strokeMiterlimit",
        "stroke-miterlimit": "strokeMiterlimit",
        strokewidth: "strokeWidth",
        "stroke-width": "strokeWidth",
        strokeopacity: "strokeOpacity",
        "stroke-opacity": "strokeOpacity",
        suppresscontenteditablewarning: "suppressContentEditableWarning",
        suppresshydrationwarning: "suppressHydrationWarning",
        surfacescale: "surfaceScale",
        systemlanguage: "systemLanguage",
        tablevalues: "tableValues",
        targetx: "targetX",
        targety: "targetY",
        textanchor: "textAnchor",
        "text-anchor": "textAnchor",
        textdecoration: "textDecoration",
        "text-decoration": "textDecoration",
        textlength: "textLength",
        textrendering: "textRendering",
        "text-rendering": "textRendering",
        to: "to",
        transform: "transform",
        transformorigin: "transformOrigin",
        "transform-origin": "transformOrigin",
        typeof: "typeof",
        u1: "u1",
        u2: "u2",
        underlineposition: "underlinePosition",
        "underline-position": "underlinePosition",
        underlinethickness: "underlineThickness",
        "underline-thickness": "underlineThickness",
        unicode: "unicode",
        unicodebidi: "unicodeBidi",
        "unicode-bidi": "unicodeBidi",
        unicoderange: "unicodeRange",
        "unicode-range": "unicodeRange",
        unitsperem: "unitsPerEm",
        "units-per-em": "unitsPerEm",
        unselectable: "unselectable",
        valphabetic: "vAlphabetic",
        "v-alphabetic": "vAlphabetic",
        values: "values",
        vectoreffect: "vectorEffect",
        "vector-effect": "vectorEffect",
        version: "version",
        vertadvy: "vertAdvY",
        "vert-adv-y": "vertAdvY",
        vertoriginx: "vertOriginX",
        "vert-origin-x": "vertOriginX",
        vertoriginy: "vertOriginY",
        "vert-origin-y": "vertOriginY",
        vhanging: "vHanging",
        "v-hanging": "vHanging",
        videographic: "vIdeographic",
        "v-ideographic": "vIdeographic",
        viewbox: "viewBox",
        viewtarget: "viewTarget",
        visibility: "visibility",
        vmathematical: "vMathematical",
        "v-mathematical": "vMathematical",
        vocab: "vocab",
        widths: "widths",
        wordspacing: "wordSpacing",
        "word-spacing": "wordSpacing",
        writingmode: "writingMode",
        "writing-mode": "writingMode",
        x1: "x1",
        x2: "x2",
        x: "x",
        xchannelselector: "xChannelSelector",
        xheight: "xHeight",
        "x-height": "xHeight",
        xlinkactuate: "xlinkActuate",
        "xlink:actuate": "xlinkActuate",
        xlinkarcrole: "xlinkArcrole",
        "xlink:arcrole": "xlinkArcrole",
        xlinkhref: "xlinkHref",
        "xlink:href": "xlinkHref",
        xlinkrole: "xlinkRole",
        "xlink:role": "xlinkRole",
        xlinkshow: "xlinkShow",
        "xlink:show": "xlinkShow",
        xlinktitle: "xlinkTitle",
        "xlink:title": "xlinkTitle",
        xlinktype: "xlinkType",
        "xlink:type": "xlinkType",
        xmlbase: "xmlBase",
        "xml:base": "xmlBase",
        xmllang: "xmlLang",
        "xml:lang": "xmlLang",
        xmlns: "xmlns",
        "xml:space": "xmlSpace",
        xmlnsxlink: "xmlnsXlink",
        "xmlns:xlink": "xmlnsXlink",
        xmlspace: "xmlSpace",
        y1: "y1",
        y2: "y2",
        y: "y",
        ychannelselector: "yChannelSelector",
        z: "z",
        zoomandpan: "zoomAndPan"
      },
      ariaProperties = {
        "aria-current": 0,
        "aria-description": 0,
        "aria-details": 0,
        "aria-disabled": 0,
        "aria-hidden": 0,
        "aria-invalid": 0,
        "aria-keyshortcuts": 0,
        "aria-label": 0,
        "aria-roledescription": 0,
        "aria-autocomplete": 0,
        "aria-checked": 0,
        "aria-expanded": 0,
        "aria-haspopup": 0,
        "aria-level": 0,
        "aria-modal": 0,
        "aria-multiline": 0,
        "aria-multiselectable": 0,
        "aria-orientation": 0,
        "aria-placeholder": 0,
        "aria-pressed": 0,
        "aria-readonly": 0,
        "aria-required": 0,
        "aria-selected": 0,
        "aria-sort": 0,
        "aria-valuemax": 0,
        "aria-valuemin": 0,
        "aria-valuenow": 0,
        "aria-valuetext": 0,
        "aria-atomic": 0,
        "aria-busy": 0,
        "aria-live": 0,
        "aria-relevant": 0,
        "aria-dropeffect": 0,
        "aria-grabbed": 0,
        "aria-activedescendant": 0,
        "aria-colcount": 0,
        "aria-colindex": 0,
        "aria-colspan": 0,
        "aria-controls": 0,
        "aria-describedby": 0,
        "aria-errormessage": 0,
        "aria-flowto": 0,
        "aria-labelledby": 0,
        "aria-owns": 0,
        "aria-posinset": 0,
        "aria-rowcount": 0,
        "aria-rowindex": 0,
        "aria-rowspan": 0,
        "aria-setsize": 0,
        "aria-braillelabel": 0,
        "aria-brailleroledescription": 0,
        "aria-colindextext": 0,
        "aria-rowindextext": 0
      },
      warnedProperties$1 = {},
      rARIA$1 = RegExp(
        "^(aria)-[:A-Z_a-z\\u00C0-\\u00D6\\u00D8-\\u00F6\\u00F8-\\u02FF\\u0370-\\u037D\\u037F-\\u1FFF\\u200C-\\u200D\\u2070-\\u218F\\u2C00-\\u2FEF\\u3001-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFFD\\-.0-9\\u00B7\\u0300-\\u036F\\u203F-\\u2040]*$"
      ),
      rARIACamel$1 = RegExp(
        "^(aria)[A-Z][:A-Z_a-z\\u00C0-\\u00D6\\u00D8-\\u00F6\\u00F8-\\u02FF\\u0370-\\u037D\\u037F-\\u1FFF\\u200C-\\u200D\\u2070-\\u218F\\u2C00-\\u2FEF\\u3001-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFFD\\-.0-9\\u00B7\\u0300-\\u036F\\u203F-\\u2040]*$"
      ),
      didWarnValueNull = !1,
      warnedProperties = {},
      EVENT_NAME_REGEX = /^on./,
      INVALID_EVENT_NAME_REGEX = /^on[^A-Z]/,
      rARIA = RegExp(
        "^(aria)-[:A-Z_a-z\\u00C0-\\u00D6\\u00D8-\\u00F6\\u00F8-\\u02FF\\u0370-\\u037D\\u037F-\\u1FFF\\u200C-\\u200D\\u2070-\\u218F\\u2C00-\\u2FEF\\u3001-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFFD\\-.0-9\\u00B7\\u0300-\\u036F\\u203F-\\u2040]*$"
      ),
      rARIACamel = RegExp(
        "^(aria)[A-Z][:A-Z_a-z\\u00C0-\\u00D6\\u00D8-\\u00F6\\u00F8-\\u02FF\\u0370-\\u037D\\u037F-\\u1FFF\\u200C-\\u200D\\u2070-\\u218F\\u2C00-\\u2FEF\\u3001-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFFD\\-.0-9\\u00B7\\u0300-\\u036F\\u203F-\\u2040]*$"
      ),
      isJavaScriptProtocol =
        /^[\u0000-\u001F ]*j[\r\n\t]*a[\r\n\t]*v[\r\n\t]*a[\r\n\t]*s[\r\n\t]*c[\r\n\t]*r[\r\n\t]*i[\r\n\t]*p[\r\n\t]*t[\r\n\t]*:/i,
      currentReplayingEvent = null,
      restoreTarget = null,
      restoreQueue = null,
      isInsideEventHandler = !1,
      canUseDOM = !(
        "undefined" === typeof window ||
        "undefined" === typeof window.document ||
        "undefined" === typeof window.document.createElement
      ),
      passiveBrowserEventsSupported = !1;
    if (canUseDOM)
      try {
        var options$jscomp$0 = {};
        Object.defineProperty(options$jscomp$0, "passive", {
          get: function () {
            passiveBrowserEventsSupported = !0;
          }
        });
        window.addEventListener("test", options$jscomp$0, options$jscomp$0);
        window.removeEventListener("test", options$jscomp$0, options$jscomp$0);
      } catch (e) {
        passiveBrowserEventsSupported = !1;
      }
    var root = null,
      startText = null,
      fallbackText = null,
      EventInterface = {
        eventPhase: 0,
        bubbles: 0,
        cancelable: 0,
        timeStamp: function (event) {
          return event.timeStamp || Date.now();
        },
        defaultPrevented: 0,
        isTrusted: 0
      },
      SyntheticEvent = createSyntheticEvent(EventInterface),
      UIEventInterface = assign({}, EventInterface, { view: 0, detail: 0 }),
      SyntheticUIEvent = createSyntheticEvent(UIEventInterface),
      lastMovementX,
      lastMovementY,
      lastMouseEvent,
      MouseEventInterface = assign({}, UIEventInterface, {
        screenX: 0,
        screenY: 0,
        clientX: 0,
        clientY: 0,
        pageX: 0,
        pageY: 0,
        ctrlKey: 0,
        shiftKey: 0,
        altKey: 0,
        metaKey: 0,
        getModifierState: getEventModifierState,
        button: 0,
        buttons: 0,
        relatedTarget: function (event) {
          return void 0 === event.relatedTarget
            ? event.fromElement === event.srcElement
              ? event.toElement
              : event.fromElement
            : event.relatedTarget;
        },
        movementX: function (event) {
          if ("movementX" in event) return event.movementX;
          event !== lastMouseEvent &&
            (lastMouseEvent && "mousemove" === event.type
              ? ((lastMovementX = event.screenX - lastMouseEvent.screenX),
                (lastMovementY = event.screenY - lastMouseEvent.screenY))
              : (lastMovementY = lastMovementX = 0),
            (lastMouseEvent = event));
          return lastMovementX;
        },
        movementY: function (event) {
          return "movementY" in event ? event.movementY : lastMovementY;
        }
      }),
      SyntheticMouseEvent = createSyntheticEvent(MouseEventInterface),
      DragEventInterface = assign({}, MouseEventInterface, { dataTransfer: 0 }),
      SyntheticDragEvent = createSyntheticEvent(DragEventInterface),
      FocusEventInterface = assign({}, UIEventInterface, { relatedTarget: 0 }),
      SyntheticFocusEvent = createSyntheticEvent(FocusEventInterface),
      AnimationEventInterface = assign({}, EventInterface, {
        animationName: 0,
        elapsedTime: 0,
        pseudoElement: 0
      }),
      SyntheticAnimationEvent = createSyntheticEvent(AnimationEventInterface),
      ClipboardEventInterface = assign({}, EventInterface, {
        clipboardData: function (event) {
          return "clipboardData" in event
            ? event.clipboardData
            : window.clipboardData;
        }
      }),
      SyntheticClipboardEvent = createSyntheticEvent(ClipboardEventInterface),
      CompositionEventInterface = assign({}, EventInterface, { data: 0 }),
      SyntheticCompositionEvent = createSyntheticEvent(
        CompositionEventInterface
      ),
      SyntheticInputEvent = SyntheticCompositionEvent,
      normalizeKey = {
        Esc: "Escape",
        Spacebar: " ",
        Left: "ArrowLeft",
        Up: "ArrowUp",
        Right: "ArrowRight",
        Down: "ArrowDown",
        Del: "Delete",
        Win: "OS",
        Menu: "ContextMenu",
        Apps: "ContextMenu",
        Scroll: "ScrollLock",
        MozPrintableKey: "Unidentified"
      },
      translateToKey = {
        8: "Backspace",
        9: "Tab",
        12: "Clear",
        13: "Enter",
        16: "Shift",
        17: "Control",
        18: "Alt",
        19: "Pause",
        20: "CapsLock",
        27: "Escape",
        32: " ",
        33: "PageUp",
        34: "PageDown",
        35: "End",
        36: "Home",
        37: "ArrowLeft",
        38: "ArrowUp",
        39: "ArrowRight",
        40: "ArrowDown",
        45: "Insert",
        46: "Delete",
        112: "F1",
        113: "F2",
        114: "F3",
        115: "F4",
        116: "F5",
        117: "F6",
        118: "F7",
        119: "F8",
        120: "F9",
        121: "F10",
        122: "F11",
        123: "F12",
        144: "NumLock",
        145: "ScrollLock",
        224: "Meta"
      },
      modifierKeyToProp = {
        Alt: "altKey",
        Control: "ctrlKey",
        Meta: "metaKey",
        Shift: "shiftKey"
      },
      KeyboardEventInterface = assign({}, UIEventInterface, {
        key: function (nativeEvent) {
          if (nativeEvent.key) {
            var key = normalizeKey[nativeEvent.key] || nativeEvent.key;
            if ("Unidentified" !== key) return key;
          }
          return "keypress" === nativeEvent.type
            ? ((nativeEvent = getEventCharCode(nativeEvent)),
              13 === nativeEvent ? "Enter" : String.fromCharCode(nativeEvent))
            : "keydown" === nativeEvent.type || "keyup" === nativeEvent.type
              ? translateToKey[nativeEvent.keyCode] || "Unidentified"
              : "";
        },
        code: 0,
        location: 0,
        ctrlKey: 0,
        shiftKey: 0,
        altKey: 0,
        metaKey: 0,
        repeat: 0,
        locale: 0,
        getModifierState: getEventModifierState,
        charCode: function (event) {
          return "keypress" === event.type ? getEventCharCode(event) : 0;
        },
        keyCode: function (event) {
          return "keydown" === event.type || "keyup" === event.type
            ? event.keyCode
            : 0;
        },
        which: function (event) {
          return "keypress" === event.type
            ? getEventCharCode(event)
            : "keydown" === event.type || "keyup" === event.type
              ? event.keyCode
              : 0;
        }
      }),
      SyntheticKeyboardEvent = createSyntheticEvent(KeyboardEventInterface),
      PointerEventInterface = assign({}, MouseEventInterface, {
        pointerId: 0,
        width: 0,
        height: 0,
        pressure: 0,
        tangentialPressure: 0,
        tiltX: 0,
        tiltY: 0,
        twist: 0,
        pointerType: 0,
        isPrimary: 0
      }),
      SyntheticPointerEvent = createSyntheticEvent(PointerEventInterface),
      TouchEventInterface = assign({}, UIEventInterface, {
        touches: 0,
        targetTouches: 0,
        changedTouches: 0,
        altKey: 0,
        metaKey: 0,
        ctrlKey: 0,
        shiftKey: 0,
        getModifierState: getEventModifierState
      }),
      SyntheticTouchEvent = createSyntheticEvent(TouchEventInterface),
      TransitionEventInterface = assign({}, EventInterface, {
        propertyName: 0,
        elapsedTime: 0,
        pseudoElement: 0
      }),
      SyntheticTransitionEvent = createSyntheticEvent(TransitionEventInterface),
      WheelEventInterface = assign({}, MouseEventInterface, {
        deltaX: function (event) {
          return "deltaX" in event
            ? event.deltaX
            : "wheelDeltaX" in event
              ? -event.wheelDeltaX
              : 0;
        },
        deltaY: function (event) {
          return "deltaY" in event
            ? event.deltaY
            : "wheelDeltaY" in event
              ? -event.wheelDeltaY
              : "wheelDelta" in event
                ? -event.wheelDelta
                : 0;
        },
        deltaZ: 0,
        deltaMode: 0
      }),
      SyntheticWheelEvent = createSyntheticEvent(WheelEventInterface),
      ToggleEventInterface = assign({}, EventInterface, {
        newState: 0,
        oldState: 0
      }),
      SyntheticToggleEvent = createSyntheticEvent(ToggleEventInterface),
      END_KEYCODES = [9, 13, 27, 32],
      START_KEYCODE = 229,
      canUseCompositionEvent = canUseDOM && "CompositionEvent" in window,
      documentMode = null;
    canUseDOM &&
      "documentMode" in document &&
      (documentMode = document.documentMode);
    var canUseTextInputEvent =
        canUseDOM && "TextEvent" in window && !documentMode,
      useFallbackCompositionData =
        canUseDOM &&
        (!canUseCompositionEvent ||
          (documentMode && 8 < documentMode && 11 >= documentMode)),
      SPACEBAR_CODE = 32,
      SPACEBAR_CHAR = String.fromCharCode(SPACEBAR_CODE),
      hasSpaceKeypress = !1,
      isComposing = !1,
      supportedInputTypes = {
        color: !0,
        date: !0,
        datetime: !0,
        "datetime-local": !0,
        email: !0,
        month: !0,
        number: !0,
        password: !0,
        range: !0,
        search: !0,
        tel: !0,
        text: !0,
        time: !0,
        url: !0,
        week: !0
      },
      activeElement$1 = null,
      activeElementInst$1 = null,
      isInputEventSupported = !1;
    canUseDOM &&
      (isInputEventSupported =
        isEventSupported("input") &&
        (!document.documentMode || 9 < document.documentMode));
    var objectIs = "function" === typeof Object.is ? Object.is : is,
      skipSelectionChangeEvent =
        canUseDOM && "documentMode" in document && 11 >= document.documentMode,
      activeElement = null,
      activeElementInst = null,
      lastSelection = null,
      mouseDown = !1,
      vendorPrefixes = {
        animationend: makePrefixMap("Animation", "AnimationEnd"),
        animationiteration: makePrefixMap("Animation", "AnimationIteration"),
        animationstart: makePrefixMap("Animation", "AnimationStart"),
        transitionrun: makePrefixMap("Transition", "TransitionRun"),
        transitionstart: makePrefixMap("Transition", "TransitionStart"),
        transitioncancel: makePrefixMap("Transition", "TransitionCancel"),
        transitionend: makePrefixMap("Transition", "TransitionEnd")
      },
      prefixedEventNames = {},
      style = {};
    canUseDOM &&
      ((style = document.createElement("div").style),
      "AnimationEvent" in window ||
        (delete vendorPrefixes.animationend.animation,
        delete vendorPrefixes.animationiteration.animation,
        delete vendorPrefixes.animationstart.animation),
      "TransitionEvent" in window ||
        delete vendorPrefixes.transitionend.transition);
    var ANIMATION_END = getVendorPrefixedEventName("animationend"),
      ANIMATION_ITERATION = getVendorPrefixedEventName("animationiteration"),
      ANIMATION_START = getVendorPrefixedEventName("animationstart"),
      TRANSITION_RUN = getVendorPrefixedEventName("transitionrun"),
      TRANSITION_START = getVendorPrefixedEventName("transitionstart"),
      TRANSITION_CANCEL = getVendorPrefixedEventName("transitioncancel"),
      TRANSITION_END = getVendorPrefixedEventName("transitionend"),
      topLevelEventsToReactNames = new Map(),
      simpleEventPluginEvents =
        "abort auxClick beforeToggle cancel canPlay canPlayThrough click close contextMenu copy cut drag dragEnd dragEnter dragExit dragLeave dragOver dragStart drop durationChange emptied encrypted ended error gotPointerCapture input invalid keyDown keyPress keyUp load loadedData loadedMetadata loadStart lostPointerCapture mouseDown mouseMove mouseOut mouseOver mouseUp paste pause play playing pointerCancel pointerDown pointerMove pointerOut pointerOver pointerUp progress rateChange reset resize seeked seeking stalled submit suspend timeUpdate touchCancel touchEnd touchStart volumeChange scroll toggle touchMove waiting wheel".split(
          " "
        );
    simpleEventPluginEvents.push("scrollEnd");
    var lastResetTime = 0;
    if (
      "object" === typeof performance &&
      "function" === typeof performance.now
    ) {
      var localPerformance = performance;
      var getCurrentTime = function () {
        return localPerformance.now();
      };
    } else {
      var localDate = Date;
      getCurrentTime = function () {
        return localDate.now();
      };
    }
    var reportGlobalError =
        "function" === typeof reportError
          ? reportError
          : function (error) {
              if (
                "object" === typeof window &&
                "function" === typeof window.ErrorEvent
              ) {
                var event = new window.ErrorEvent("error", {
                  bubbles: !0,
                  cancelable: !0,
                  message:
                    "object" === typeof error &&
                    null !== error &&
                    "string" === typeof error.message
                      ? String(error.message)
                      : String(error),
                  error: error
                });
                if (!window.dispatchEvent(event)) return;
              } else if (
                "object" === typeof process &&
                "function" === typeof process.emit
              ) {
                process.emit("uncaughtException", error);
                return;
              }
              console.error(error);
            },
      OMITTED_PROP_ERROR =
        "This object has been omitted by React in the console log to avoid sending too much data from the server. Try logging smaller or more specific objects.",
      EMPTY_ARRAY = 0,
      COMPLEX_ARRAY = 1,
      PRIMITIVE_ARRAY = 2,
      ENTRIES_ARRAY = 3,
      REMOVED = "\u2013\u00a0",
      ADDED = "+\u00a0",
      UNCHANGED = "\u2007\u00a0",
      supportsUserTiming =
        "undefined" !== typeof console &&
        "function" === typeof console.timeStamp &&
        "undefined" !== typeof performance &&
        "function" === typeof performance.measure,
      COMPONENTS_TRACK = "Components \u269b",
      LANES_TRACK_GROUP = "Scheduler \u269b",
      currentTrack = "Blocking",
      alreadyWarnedForDeepEquality = !1,
      reusableComponentDevToolDetails = {
        color: "primary",
        properties: null,
        tooltipText: "",
        track: COMPONENTS_TRACK
      },
      reusableComponentOptions = {
        start: -0,
        end: -0,
        detail: { devtools: reusableComponentDevToolDetails }
      },
      resuableChangedPropsEntry = ["Changed Props", ""],
      DEEP_EQUALITY_WARNING =
        "This component received deeply equal props. It might benefit from useMemo or the React Compiler in its owner.",
      reusableDeeplyEqualPropsEntry = ["Changed Props", DEEP_EQUALITY_WARNING],
      OffscreenVisible = 1,
      OffscreenPassiveEffectsConnected = 2,
      concurrentQueues = [],
      concurrentQueuesIndex = 0,
      concurrentlyUpdatedLanes = 0,
      emptyContextObject = {};
    Object.freeze(emptyContextObject);
    var resolveFamily = null,
      failedBoundaries = null,
      NoMode = 0,
      ConcurrentMode = 1,
      ProfileMode = 2,
      StrictLegacyMode = 8,
      StrictEffectsMode = 16,
      SuspenseyImagesMode = 32;
    var hasBadMapPolyfill = !1;
    try {
      var nonExtensibleObject = Object.preventExtensions({});
      new Map([[nonExtensibleObject, null]]);
      new Set([nonExtensibleObject]);
    } catch (e$3) {
      hasBadMapPolyfill = !0;
    }
    var CapturedStacks = new WeakMap(),
      forkStack = [],
      forkStackIndex = 0,
      treeForkProvider = null,
      treeForkCount = 0,
      idStack = [],
      idStackIndex = 0,
      treeContextProvider = null,
      treeContextId = 1,
      treeContextOverflow = "",
      hydrationParentFiber = null,
      nextHydratableInstance = null,
      isHydrating = !1,
      didSuspendOrErrorDEV = !1,
      hydrationDiffRootDEV = null,
      hydrationErrors = null,
      rootOrSingletonContext = !1,
      HydrationMismatchException = Error(
        "Hydration Mismatch Exception: This is not a real error, and should not leak into userspace. If you're seeing this, it's likely a bug in React."
      ),
      valueCursor = createCursor(null);
    var rendererCursorDEV = createCursor(null);
    var rendererSigil = {};
    var currentlyRenderingFiber$1 = null,
      lastContextDependency = null,
      isDisallowedContextReadInDEV = !1,
      AbortControllerLocal =
        "undefined" !== typeof AbortController
          ? AbortController
          : function () {
              var listeners = [],
                signal = (this.signal = {
                  aborted: !1,
                  addEventListener: function (type, listener) {
                    listeners.push(listener);
                  }
                });
              this.abort = function () {
                signal.aborted = !0;
                listeners.forEach(function (listener) {
                  return listener();
                });
              };
            },
      scheduleCallback$2 = Scheduler.unstable_scheduleCallback,
      NormalPriority = Scheduler.unstable_NormalPriority,
      CacheContext = {
        $$typeof: REACT_CONTEXT_TYPE,
        Consumer: null,
        Provider: null,
        _currentValue: null,
        _currentValue2: null,
        _threadCount: 0,
        _currentRenderer: null,
        _currentRenderer2: null
      },
      now = Scheduler.unstable_now,
      createTask = console.createTask
        ? console.createTask
        : function () {
            return null;
          },
      SPAWNED_UPDATE = 1,
      PINGED_UPDATE = 2,
      renderStartTime = -0,
      commitStartTime = -0,
      commitEndTime = -0,
      commitErrors = null,
      profilerStartTime = -1.1,
      profilerEffectDuration = -0,
      componentEffectDuration = -0,
      componentEffectStartTime = -1.1,
      componentEffectEndTime = -1.1,
      componentEffectErrors = null,
      componentEffectSpawnedUpdate = !1,
      blockingClampTime = -0,
      blockingUpdateTime = -1.1,
      blockingUpdateTask = null,
      blockingUpdateType = 0,
      blockingUpdateMethodName = null,
      blockingUpdateComponentName = null,
      blockingEventTime = -1.1,
      blockingEventType = null,
      blockingEventRepeatTime = -1.1,
      blockingSuspendedTime = -1.1,
      transitionClampTime = -0,
      transitionStartTime = -1.1,
      transitionUpdateTime = -1.1,
      transitionUpdateType = 0,
      transitionUpdateTask = null,
      transitionUpdateMethodName = null,
      transitionUpdateComponentName = null,
      transitionEventTime = -1.1,
      transitionEventType = null,
      transitionEventRepeatTime = -1.1,
      transitionSuspendedTime = -1.1,
      retryClampTime = -0,
      idleClampTime = -0,
      animatingLanes = 0,
      animatingTask = null,
      yieldReason = 0,
      yieldStartTime = -1.1,
      currentUpdateIsNested = !1,
      nestedUpdateScheduled = !1,
      currentEntangledListeners = null,
      currentEntangledPendingCount = 0,
      currentEntangledLane = 0,
      currentEntangledActionThenable = null,
      prevOnStartTransitionFinish = ReactSharedInternals.S;
    ReactSharedInternals.S = function (transition, returnValue) {
      globalMostRecentTransitionTime = now$1();
      if (
        "object" === typeof returnValue &&
        null !== returnValue &&
        "function" === typeof returnValue.then
      ) {
        if (0 > transitionStartTime && 0 > transitionUpdateTime) {
          transitionStartTime = now();
          var newEventTime = resolveEventTimeStamp(),
            newEventType = resolveEventType();
          if (
            newEventTime !== transitionEventRepeatTime ||
            newEventType !== transitionEventType
          )
            transitionEventRepeatTime = -1.1;
          transitionEventTime = newEventTime;
          transitionEventType = newEventType;
        }
        entangleAsyncAction(transition, returnValue);
      }
      null !== prevOnStartTransitionFinish &&
        prevOnStartTransitionFinish(transition, returnValue);
    };
    var resumedCache = createCursor(null),
      ReactStrictModeWarnings = {
        recordUnsafeLifecycleWarnings: function () {},
        flushPendingUnsafeLifecycleWarnings: function () {},
        recordLegacyContextWarning: function () {},
        flushLegacyContextWarning: function () {},
        discardPendingWarnings: function () {}
      },
      pendingComponentWillMountWarnings = [],
      pendingUNSAFE_ComponentWillMountWarnings = [],
      pendingComponentWillReceivePropsWarnings = [],
      pendingUNSAFE_ComponentWillReceivePropsWarnings = [],
      pendingComponentWillUpdateWarnings = [],
      pendingUNSAFE_ComponentWillUpdateWarnings = [],
      didWarnAboutUnsafeLifecycles = new Set();
    ReactStrictModeWarnings.recordUnsafeLifecycleWarnings = function (
      fiber,
      instance
    ) {
      didWarnAboutUnsafeLifecycles.has(fiber.type) ||
        ("function" === typeof instance.componentWillMount &&
          !0 !== instance.componentWillMount.__suppressDeprecationWarning &&
          pendingComponentWillMountWarnings.push(fiber),
        fiber.mode & StrictLegacyMode &&
          "function" === typeof instance.UNSAFE_componentWillMount &&
          pendingUNSAFE_ComponentWillMountWarnings.push(fiber),
        "function" === typeof instance.componentWillReceiveProps &&
          !0 !==
            instance.componentWillReceiveProps.__suppressDeprecationWarning &&
          pendingComponentWillReceivePropsWarnings.push(fiber),
        fiber.mode & StrictLegacyMode &&
          "function" === typeof instance.UNSAFE_componentWillReceiveProps &&
          pendingUNSAFE_ComponentWillReceivePropsWarnings.push(fiber),
        "function" === typeof instance.componentWillUpdate &&
          !0 !== instance.componentWillUpdate.__suppressDeprecationWarning &&
          pendingComponentWillUpdateWarnings.push(fiber),
        fiber.mode & StrictLegacyMode &&
          "function" === typeof instance.UNSAFE_componentWillUpdate &&
          pendingUNSAFE_ComponentWillUpdateWarnings.push(fiber));
    };
    ReactStrictModeWarnings.flushPendingUnsafeLifecycleWarnings = function () {
      var componentWillMountUniqueNames = new Set();
      0 < pendingComponentWillMountWarnings.length &&
        (pendingComponentWillMountWarnings.forEach(function (fiber) {
          componentWillMountUniqueNames.add(
            getComponentNameFromFiber(fiber) || "Component"
          );
          didWarnAboutUnsafeLifecycles.add(fiber.type);
        }),
        (pendingComponentWillMountWarnings = []));
      var UNSAFE_componentWillMountUniqueNames = new Set();
      0 < pendingUNSAFE_ComponentWillMountWarnings.length &&
        (pendingUNSAFE_ComponentWillMountWarnings.forEach(function (fiber) {
          UNSAFE_componentWillMountUniqueNames.add(
            getComponentNameFromFiber(fiber) || "Component"
          );
          didWarnAboutUnsafeLifecycles.add(fiber.type);
        }),
        (pendingUNSAFE_ComponentWillMountWarnings = []));
      var componentWillReceivePropsUniqueNames = new Set();
      0 < pendingComponentWillReceivePropsWarnings.length &&
        (pendingComponentWillReceivePropsWarnings.forEach(function (fiber) {
          componentWillReceivePropsUniqueNames.add(
            getComponentNameFromFiber(fiber) || "Component"
          );
          didWarnAboutUnsafeLifecycles.add(fiber.type);
        }),
        (pendingComponentWillReceivePropsWarnings = []));
      var UNSAFE_componentWillReceivePropsUniqueNames = new Set();
      0 < pendingUNSAFE_ComponentWillReceivePropsWarnings.length &&
        (pendingUNSAFE_ComponentWillReceivePropsWarnings.forEach(
          function (fiber) {
            UNSAFE_componentWillReceivePropsUniqueNames.add(
              getComponentNameFromFiber(fiber) || "Component"
            );
            didWarnAboutUnsafeLifecycles.add(fiber.type);
          }
        ),
        (pendingUNSAFE_ComponentWillReceivePropsWarnings = []));
      var componentWillUpdateUniqueNames = new Set();
      0 < pendingComponentWillUpdateWarnings.length &&
        (pendingComponentWillUpdateWarnings.forEach(function (fiber) {
          componentWillUpdateUniqueNames.add(
            getComponentNameFromFiber(fiber) || "Component"
          );
          didWarnAboutUnsafeLifecycles.add(fiber.type);
        }),
        (pendingComponentWillUpdateWarnings = []));
      var UNSAFE_componentWillUpdateUniqueNames = new Set();
      0 < pendingUNSAFE_ComponentWillUpdateWarnings.length &&
        (pendingUNSAFE_ComponentWillUpdateWarnings.forEach(function (fiber) {
          UNSAFE_componentWillUpdateUniqueNames.add(
            getComponentNameFromFiber(fiber) || "Component"
          );
          didWarnAboutUnsafeLifecycles.add(fiber.type);
        }),
        (pendingUNSAFE_ComponentWillUpdateWarnings = []));
      if (0 < UNSAFE_componentWillMountUniqueNames.size) {
        var sortedNames = setToSortedString(
          UNSAFE_componentWillMountUniqueNames
        );
        console.error(
          "Using UNSAFE_componentWillMount in strict mode is not recommended and may indicate bugs in your code. See https://react.dev/link/unsafe-component-lifecycles for details.\n\n* Move code with side effects to componentDidMount, and set initial state in the constructor.\n\nPlease update the following components: %s",
          sortedNames
        );
      }
      0 < UNSAFE_componentWillReceivePropsUniqueNames.size &&
        ((sortedNames = setToSortedString(
          UNSAFE_componentWillReceivePropsUniqueNames
        )),
        console.error(
          "Using UNSAFE_componentWillReceiveProps in strict mode is not recommended and may indicate bugs in your code. See https://react.dev/link/unsafe-component-lifecycles for details.\n\n* Move data fetching code or side effects to componentDidUpdate.\n* If you're updating state whenever props change, refactor your code to use memoization techniques or move it to static getDerivedStateFromProps. Learn more at: https://react.dev/link/derived-state\n\nPlease update the following components: %s",
          sortedNames
        ));
      0 < UNSAFE_componentWillUpdateUniqueNames.size &&
        ((sortedNames = setToSortedString(
          UNSAFE_componentWillUpdateUniqueNames
        )),
        console.error(
          "Using UNSAFE_componentWillUpdate in strict mode is not recommended and may indicate bugs in your code. See https://react.dev/link/unsafe-component-lifecycles for details.\n\n* Move data fetching code or side effects to componentDidUpdate.\n\nPlease update the following components: %s",
          sortedNames
        ));
      0 < componentWillMountUniqueNames.size &&
        ((sortedNames = setToSortedString(componentWillMountUniqueNames)),
        console.warn(
          "componentWillMount has been renamed, and is not recommended for use. See https://react.dev/link/unsafe-component-lifecycles for details.\n\n* Move code with side effects to componentDidMount, and set initial state in the constructor.\n* Rename componentWillMount to UNSAFE_componentWillMount to suppress this warning in non-strict mode. In React 18.x, only the UNSAFE_ name will work. To rename all deprecated lifecycles to their new names, you can run `npx react-codemod rename-unsafe-lifecycles` in your project source folder.\n\nPlease update the following components: %s",
          sortedNames
        ));
      0 < componentWillReceivePropsUniqueNames.size &&
        ((sortedNames = setToSortedString(
          componentWillReceivePropsUniqueNames
        )),
        console.warn(
          "componentWillReceiveProps has been renamed, and is not recommended for use. See https://react.dev/link/unsafe-component-lifecycles for details.\n\n* Move data fetching code or side effects to componentDidUpdate.\n* If you're updating state whenever props change, refactor your code to use memoization techniques or move it to static getDerivedStateFromProps. Learn more at: https://react.dev/link/derived-state\n* Rename componentWillReceiveProps to UNSAFE_componentWillReceiveProps to suppress this warning in non-strict mode. In React 18.x, only the UNSAFE_ name will work. To rename all deprecated lifecycles to their new names, you can run `npx react-codemod rename-unsafe-lifecycles` in your project source folder.\n\nPlease update the following components: %s",
          sortedNames
        ));
      0 < componentWillUpdateUniqueNames.size &&
        ((sortedNames = setToSortedString(componentWillUpdateUniqueNames)),
        console.warn(
          "componentWillUpdate has been renamed, and is not recommended for use. See https://react.dev/link/unsafe-component-lifecycles for details.\n\n* Move data fetching code or side effects to componentDidUpdate.\n* Rename componentWillUpdate to UNSAFE_componentWillUpdate to suppress this warning in non-strict mode. In React 18.x, only the UNSAFE_ name will work. To rename all deprecated lifecycles to their new names, you can run `npx react-codemod rename-unsafe-lifecycles` in your project source folder.\n\nPlease update the following components: %s",
          sortedNames
        ));
    };
    var pendingLegacyContextWarning = new Map(),
      didWarnAboutLegacyContext = new Set();
    ReactStrictModeWarnings.recordLegacyContextWarning = function (
      fiber,
      instance
    ) {
      var strictRoot = null;
      for (var node = fiber; null !== node; )
        node.mode & StrictLegacyMode && (strictRoot = node),
          (node = node.return);
      null === strictRoot
        ? console.error(
            "Expected to find a StrictMode component in a strict mode tree. This error is likely caused by a bug in React. Please file an issue."
          )
        : !didWarnAboutLegacyContext.has(fiber.type) &&
          ((node = pendingLegacyContextWarning.get(strictRoot)),
          null != fiber.type.contextTypes ||
            null != fiber.type.childContextTypes ||
            (null !== instance &&
              "function" === typeof instance.getChildContext)) &&
          (void 0 === node &&
            ((node = []), pendingLegacyContextWarning.set(strictRoot, node)),
          node.push(fiber));
    };
    ReactStrictModeWarnings.flushLegacyContextWarning = function () {
      pendingLegacyContextWarning.forEach(function (fiberArray) {
        if (0 !== fiberArray.length) {
          var firstFiber = fiberArray[0],
            uniqueNames = new Set();
          fiberArray.forEach(function (fiber) {
            uniqueNames.add(getComponentNameFromFiber(fiber) || "Component");
            didWarnAboutLegacyContext.add(fiber.type);
          });
          var sortedNames = setToSortedString(uniqueNames);
          runWithFiberInDEV(firstFiber, function () {
            console.error(
              "Legacy context API has been detected within a strict-mode tree.\n\nThe old API will be supported in all 16.x releases, but applications using it should migrate to the new version.\n\nPlease update the following components: %s\n\nLearn more about this warning here: https://react.dev/link/legacy-context",
              sortedNames
            );
          });
        }
      });
    };
    ReactStrictModeWarnings.discardPendingWarnings = function () {
      pendingComponentWillMountWarnings = [];
      pendingUNSAFE_ComponentWillMountWarnings = [];
      pendingComponentWillReceivePropsWarnings = [];
      pendingUNSAFE_ComponentWillReceivePropsWarnings = [];
      pendingComponentWillUpdateWarnings = [];
      pendingUNSAFE_ComponentWillUpdateWarnings = [];
      pendingLegacyContextWarning = new Map();
    };
    var callComponent = {
        react_stack_bottom_frame: function (Component, props, secondArg) {
          var wasRendering = isRendering;
          isRendering = !0;
          try {
            return Component(props, secondArg);
          } finally {
            isRendering = wasRendering;
          }
        }
      },
      callComponentInDEV =
        callComponent.react_stack_bottom_frame.bind(callComponent),
      callRender = {
        react_stack_bottom_frame: function (instance) {
          var wasRendering = isRendering;
          isRendering = !0;
          try {
            return instance.render();
          } finally {
            isRendering = wasRendering;
          }
        }
      },
      callRenderInDEV = callRender.react_stack_bottom_frame.bind(callRender),
      callComponentDidMount = {
        react_stack_bottom_frame: function (finishedWork, instance) {
          try {
            instance.componentDidMount();
          } catch (error) {
            captureCommitPhaseError(finishedWork, finishedWork.return, error);
          }
        }
      },
      callComponentDidMountInDEV =
        callComponentDidMount.react_stack_bottom_frame.bind(
          callComponentDidMount
        ),
      callComponentDidUpdate = {
        react_stack_bottom_frame: function (
          finishedWork,
          instance,
          prevProps,
          prevState,
          snapshot
        ) {
          try {
            instance.componentDidUpdate(prevProps, prevState, snapshot);
          } catch (error) {
            captureCommitPhaseError(finishedWork, finishedWork.return, error);
          }
        }
      },
      callComponentDidUpdateInDEV =
        callComponentDidUpdate.react_stack_bottom_frame.bind(
          callComponentDidUpdate
        ),
      callComponentDidCatch = {
        react_stack_bottom_frame: function (instance, errorInfo) {
          var stack = errorInfo.stack;
          instance.componentDidCatch(errorInfo.value, {
            componentStack: null !== stack ? stack : ""
          });
        }
      },
      callComponentDidCatchInDEV =
        callComponentDidCatch.react_stack_bottom_frame.bind(
          callComponentDidCatch
        ),
      callComponentWillUnmount = {
        react_stack_bottom_frame: function (
          current,
          nearestMountedAncestor,
          instance
        ) {
          try {
            instance.componentWillUnmount();
          } catch (error) {
            captureCommitPhaseError(current, nearestMountedAncestor, error);
          }
        }
      },
      callComponentWillUnmountInDEV =
        callComponentWillUnmount.react_stack_bottom_frame.bind(
          callComponentWillUnmount
        ),
      callCreate = {
        react_stack_bottom_frame: function (effect) {
          var create = effect.create;
          effect = effect.inst;
          create = create();
          return (effect.destroy = create);
        }
      },
      callCreateInDEV = callCreate.react_stack_bottom_frame.bind(callCreate),
      callDestroy = {
        react_stack_bottom_frame: function (
          current,
          nearestMountedAncestor,
          destroy
        ) {
          try {
            destroy();
          } catch (error) {
            captureCommitPhaseError(current, nearestMountedAncestor, error);
          }
        }
      },
      callDestroyInDEV = callDestroy.react_stack_bottom_frame.bind(callDestroy),
      callLazyInit = {
        react_stack_bottom_frame: function (lazy) {
          var init = lazy._init;
          return init(lazy._payload);
        }
      },
      callLazyInitInDEV =
        callLazyInit.react_stack_bottom_frame.bind(callLazyInit),
      SuspenseException = Error(
        "Suspense Exception: This is not a real error! It's an implementation detail of `use` to interrupt the current render. You must either rethrow it immediately, or move the `use` call outside of the `try/catch` block. Capturing without rethrowing will lead to unexpected behavior.\n\nTo handle async errors, wrap your component in an error boundary, or call the promise's `.catch` method and pass the result to `use`."
      ),
      SuspenseyCommitException = Error(
        "Suspense Exception: This is not a real error, and should not leak into userspace. If you're seeing this, it's likely a bug in React."
      ),
      SuspenseActionException = Error(
        "Suspense Exception: This is not a real error! It's an implementation detail of `useActionState` to interrupt the current render. You must either rethrow it immediately, or move the `useActionState` call outside of the `try/catch` block. Capturing without rethrowing will lead to unexpected behavior.\n\nTo handle async errors, wrap your component in an error boundary."
      ),
      noopSuspenseyCommitThenable = {
        then: function () {
          console.error(
            'Internal React error: A listener was unexpectedly attached to a "noop" thenable. This is a bug in React. Please file an issue.'
          );
        }
      },
      suspendedThenable = null,
      needsToResetSuspendedThenableDEV = !1,
      thenableState$1 = null,
      thenableIndexCounter$1 = 0,
      currentDebugInfo = null,
      didWarnAboutMaps;
    var didWarnAboutGenerators = (didWarnAboutMaps = !1);
    var ownerHasKeyUseWarning = {};
    var ownerHasFunctionTypeWarning = {};
    var ownerHasSymbolTypeWarning = {};
    warnForMissingKey = function (returnFiber, workInProgress, child) {
      if (
        null !== child &&
        "object" === typeof child &&
        child._store &&
        ((!child._store.validated && null == child.key) ||
          2 === child._store.validated)
      ) {
        if ("object" !== typeof child._store)
          throw Error(
            "React Component in warnForMissingKey should have a _store. This error is likely caused by a bug in React. Please file an issue."
          );
        child._store.validated = 1;
        var componentName = getComponentNameFromFiber(returnFiber),
          componentKey = componentName || "null";
        if (!ownerHasKeyUseWarning[componentKey]) {
          ownerHasKeyUseWarning[componentKey] = !0;
          child = child._owner;
          returnFiber = returnFiber._debugOwner;
          var currentComponentErrorInfo = "";
          returnFiber &&
            "number" === typeof returnFiber.tag &&
            (componentKey = getComponentNameFromFiber(returnFiber)) &&
            (currentComponentErrorInfo =
              "\n\nCheck the render method of `" + componentKey + "`.");
          currentComponentErrorInfo ||
            (componentName &&
              (currentComponentErrorInfo =
                "\n\nCheck the top-level render call using <" +
                componentName +
                ">."));
          var childOwnerAppendix = "";
          null != child &&
            returnFiber !== child &&
            ((componentName = null),
            "number" === typeof child.tag
              ? (componentName = getComponentNameFromFiber(child))
              : "string" === typeof child.name && (componentName = child.name),
            componentName &&
              (childOwnerAppendix =
                " It was passed a child from " + componentName + "."));
          runWithFiberInDEV(workInProgress, function () {
            console.error(
              'Each child in a list should have a unique "key" prop.%s%s See https://react.dev/link/warning-keys for more information.',
              currentComponentErrorInfo,
              childOwnerAppendix
            );
          });
        }
      }
    };
    var reconcileChildFibers = createChildReconciler(!0),
      mountChildFibers = createChildReconciler(!1),
      UpdateState = 0,
      ReplaceState = 1,
      ForceUpdate = 2,
      CaptureUpdate = 3,
      hasForceUpdate = !1;
    var didWarnUpdateInsideUpdate = !1;
    var currentlyProcessingQueue = null;
    var didReadFromEntangledAsyncAction = !1,
      currentTreeHiddenStackCursor = createCursor(null),
      prevEntangledRenderLanesCursor = createCursor(0),
      suspenseHandlerStackCursor = createCursor(null),
      shellBoundary = null,
      SubtreeSuspenseContextMask = 1,
      ForceSuspenseFallback = 2,
      suspenseStackCursor = createCursor(0),
      NoFlags = 0,
      HasEffect = 1,
      Insertion = 2,
      Layout = 4,
      Passive = 8,
      didWarnUncachedGetSnapshot;
    var didWarnAboutMismatchedHooksForComponent = new Set();
    var didWarnAboutUseWrappedInTryCatch = new Set();
    var didWarnAboutAsyncClientComponent = new Set();
    var didWarnAboutUseFormState = new Set();
    var renderLanes = 0,
      currentlyRenderingFiber = null,
      currentHook = null,
      workInProgressHook = null,
      didScheduleRenderPhaseUpdate = !1,
      didScheduleRenderPhaseUpdateDuringThisPass = !1,
      shouldDoubleInvokeUserFnsInHooksDEV = !1,
      localIdCounter = 0,
      thenableIndexCounter = 0,
      thenableState = null,
      globalClientIdCounter = 0,
      RE_RENDER_LIMIT = 25,
      currentHookNameInDev = null,
      hookTypesDev = null,
      hookTypesUpdateIndexDev = -1,
      ignorePreviousDependencies = !1,
      ContextOnlyDispatcher = {
        readContext: readContext,
        use: use,
        useCallback: throwInvalidHookError,
        useContext: throwInvalidHookError,
        useEffect: throwInvalidHookError,
        useImperativeHandle: throwInvalidHookError,
        useLayoutEffect: throwInvalidHookError,
        useInsertionEffect: throwInvalidHookError,
        useMemo: throwInvalidHookError,
        useReducer: throwInvalidHookError,
        useRef: throwInvalidHookError,
        useState: throwInvalidHookError,
        useDebugValue: throwInvalidHookError,
        useDeferredValue: throwInvalidHookError,
        useTransition: throwInvalidHookError,
        useSyncExternalStore: throwInvalidHookError,
        useId: throwInvalidHookError,
        useHostTransitionStatus: throwInvalidHookError,
        useFormState: throwInvalidHookError,
        useActionState: throwInvalidHookError,
        useOptimistic: throwInvalidHookError,
        useMemoCache: throwInvalidHookError,
        useCacheRefresh: throwInvalidHookError
      };
    ContextOnlyDispatcher.useEffectEvent = throwInvalidHookError;
    var HooksDispatcherOnMountInDEV = null,
      HooksDispatcherOnMountWithHookTypesInDEV = null,
      HooksDispatcherOnUpdateInDEV = null,
      HooksDispatcherOnRerenderInDEV = null,
      InvalidNestedHooksDispatcherOnMountInDEV = null,
      InvalidNestedHooksDispatcherOnUpdateInDEV = null,
      InvalidNestedHooksDispatcherOnRerenderInDEV = null;
    HooksDispatcherOnMountInDEV = {
      readContext: function (context) {
        return readContext(context);
      },
      use: use,
      useCallback: function (callback, deps) {
        currentHookNameInDev = "useCallback";
        mountHookTypesDev();
        checkDepsAreArrayDev(deps);
        return mountCallback(callback, deps);
      },
      useContext: function (context) {
        currentHookNameInDev = "useContext";
        mountHookTypesDev();
        return readContext(context);
      },
      useEffect: function (create, deps) {
        currentHookNameInDev = "useEffect";
        mountHookTypesDev();
        checkDepsAreArrayDev(deps);
        return mountEffect(create, deps);
      },
      useImperativeHandle: function (ref, create, deps) {
        currentHookNameInDev = "useImperativeHandle";
        mountHookTypesDev();
        checkDepsAreArrayDev(deps);
        return mountImperativeHandle(ref, create, deps);
      },
      useInsertionEffect: function (create, deps) {
        currentHookNameInDev = "useInsertionEffect";
        mountHookTypesDev();
        checkDepsAreArrayDev(deps);
        mountEffectImpl(4, Insertion, create, deps);
      },
      useLayoutEffect: function (create, deps) {
        currentHookNameInDev = "useLayoutEffect";
        mountHookTypesDev();
        checkDepsAreArrayDev(deps);
        return mountLayoutEffect(create, deps);
      },
      useMemo: function (create, deps) {
        currentHookNameInDev = "useMemo";
        mountHookTypesDev();
        checkDepsAreArrayDev(deps);
        var prevDispatcher = ReactSharedInternals.H;
        ReactSharedInternals.H = InvalidNestedHooksDispatcherOnMountInDEV;
        try {
          return mountMemo(create, deps);
        } finally {
          ReactSharedInternals.H = prevDispatcher;
        }
      },
      useReducer: function (reducer, initialArg, init) {
        currentHookNameInDev = "useReducer";
        mountHookTypesDev();
        var prevDispatcher = ReactSharedInternals.H;
        ReactSharedInternals.H = InvalidNestedHooksDispatcherOnMountInDEV;
        try {
          return mountReducer(reducer, initialArg, init);
        } finally {
          ReactSharedInternals.H = prevDispatcher;
        }
      },
      useRef: function (initialValue) {
        currentHookNameInDev = "useRef";
        mountHookTypesDev();
        return mountRef(initialValue);
      },
      useState: function (initialState) {
        currentHookNameInDev = "useState";
        mountHookTypesDev();
        var prevDispatcher = ReactSharedInternals.H;
        ReactSharedInternals.H = InvalidNestedHooksDispatcherOnMountInDEV;
        try {
          return mountState(initialState);
        } finally {
          ReactSharedInternals.H = prevDispatcher;
        }
      },
      useDebugValue: function () {
        currentHookNameInDev = "useDebugValue";
        mountHookTypesDev();
      },
      useDeferredValue: function (value, initialValue) {
        currentHookNameInDev = "useDeferredValue";
        mountHookTypesDev();
        return mountDeferredValue(value, initialValue);
      },
      useTransition: function () {
        currentHookNameInDev = "useTransition";
        mountHookTypesDev();
        return mountTransition();
      },
      useSyncExternalStore: function (
        subscribe,
        getSnapshot,
        getServerSnapshot
      ) {
        currentHookNameInDev = "useSyncExternalStore";
        mountHookTypesDev();
        return mountSyncExternalStore(
          subscribe,
          getSnapshot,
          getServerSnapshot
        );
      },
      useId: function () {
        currentHookNameInDev = "useId";
        mountHookTypesDev();
        return mountId();
      },
      useFormState: function (action, initialState) {
        currentHookNameInDev = "useFormState";
        mountHookTypesDev();
        warnOnUseFormStateInDev();
        return mountActionState(action, initialState);
      },
      useActionState: function (action, initialState) {
        currentHookNameInDev = "useActionState";
        mountHookTypesDev();
        return mountActionState(action, initialState);
      },
      useOptimistic: function (passthrough) {
        currentHookNameInDev = "useOptimistic";
        mountHookTypesDev();
        return mountOptimistic(passthrough);
      },
      useHostTransitionStatus: useHostTransitionStatus,
      useMemoCache: useMemoCache,
      useCacheRefresh: function () {
        currentHookNameInDev = "useCacheRefresh";
        mountHookTypesDev();
        return mountRefresh();
      },
      useEffectEvent: function (callback) {
        currentHookNameInDev = "useEffectEvent";
        mountHookTypesDev();
        return mountEvent(callback);
      }
    };
    HooksDispatcherOnMountWithHookTypesInDEV = {
      readContext: function (context) {
        return readContext(context);
      },
      use: use,
      useCallback: function (callback, deps) {
        currentHookNameInDev = "useCallback";
        updateHookTypesDev();
        return mountCallback(callback, deps);
      },
      useContext: function (context) {
        currentHookNameInDev = "useContext";
        updateHookTypesDev();
        return readContext(context);
      },
      useEffect: function (create, deps) {
        currentHookNameInDev = "useEffect";
        updateHookTypesDev();
        return mountEffect(create, deps);
      },
      useImperativeHandle: function (ref, create, deps) {
        currentHookNameInDev = "useImperativeHandle";
        updateHookTypesDev();
        return mountImperativeHandle(ref, create, deps);
      },
      useInsertionEffect: function (create, deps) {
        currentHookNameInDev = "useInsertionEffect";
        updateHookTypesDev();
        mountEffectImpl(4, Insertion, create, deps);
      },
      useLayoutEffect: function (create, deps) {
        currentHookNameInDev = "useLayoutEffect";
        updateHookTypesDev();
        return mountLayoutEffect(create, deps);
      },
      useMemo: function (create, deps) {
        currentHookNameInDev = "useMemo";
        updateHookTypesDev();
        var prevDispatcher = ReactSharedInternals.H;
        ReactSharedInternals.H = InvalidNestedHooksDispatcherOnMountInDEV;
        try {
          return mountMemo(create, deps);
        } finally {
          ReactSharedInternals.H = prevDispatcher;
        }
      },
      useReducer: function (reducer, initialArg, init) {
        currentHookNameInDev = "useReducer";
        updateHookTypesDev();
        var prevDispatcher = ReactSharedInternals.H;
        ReactSharedInternals.H = InvalidNestedHooksDispatcherOnMountInDEV;
        try {
          return mountReducer(reducer, initialArg, init);
        } finally {
          ReactSharedInternals.H = prevDispatcher;
        }
      },
      useRef: function (initialValue) {
        currentHookNameInDev = "useRef";
        updateHookTypesDev();
        return mountRef(initialValue);
      },
      useState: function (initialState) {
        currentHookNameInDev = "useState";
        updateHookTypesDev();
        var prevDispatcher = ReactSharedInternals.H;
        ReactSharedInternals.H = InvalidNestedHooksDispatcherOnMountInDEV;
        try {
          return mountState(initialState);
        } finally {
          ReactSharedInternals.H = prevDispatcher;
        }
      },
      useDebugValue: function () {
        currentHookNameInDev = "useDebugValue";
        updateHookTypesDev();
      },
      useDeferredValue: function (value, initialValue) {
        currentHookNameInDev = "useDeferredValue";
        updateHookTypesDev();
        return mountDeferredValue(value, initialValue);
      },
      useTransition: function () {
        currentHookNameInDev = "useTransition";
        updateHookTypesDev();
        return mountTransition();
      },
      useSyncExternalStore: function (
        subscribe,
        getSnapshot,
        getServerSnapshot
      ) {
        currentHookNameInDev = "useSyncExternalStore";
        updateHookTypesDev();
        return mountSyncExternalStore(
          subscribe,
          getSnapshot,
          getServerSnapshot
        );
      },
      useId: function () {
        currentHookNameInDev = "useId";
        updateHookTypesDev();
        return mountId();
      },
      useActionState: function (action, initialState) {
        currentHookNameInDev = "useActionState";
        updateHookTypesDev();
        return mountActionState(action, initialState);
      },
      useFormState: function (action, initialState) {
        currentHookNameInDev = "useFormState";
        updateHookTypesDev();
        warnOnUseFormStateInDev();
        return mountActionState(action, initialState);
      },
      useOptimistic: function (passthrough) {
        currentHookNameInDev = "useOptimistic";
        updateHookTypesDev();
        return mountOptimistic(passthrough);
      },
      useHostTransitionStatus: useHostTransitionStatus,
      useMemoCache: useMemoCache,
      useCacheRefresh: function () {
        currentHookNameInDev = "useCacheRefresh";
        updateHookTypesDev();
        return mountRefresh();
      },
      useEffectEvent: function (callback) {
        currentHookNameInDev = "useEffectEvent";
        updateHookTypesDev();
        return mountEvent(callback);
      }
    };
    HooksDispatcherOnUpdateInDEV = {
      readContext: function (context) {
        return readContext(context);
      },
      use: use,
      useCallback: function (callback, deps) {
        currentHookNameInDev = "useCallback";
        updateHookTypesDev();
        return updateCallback(callback, deps);
      },
      useContext: function (context) {
        currentHookNameInDev = "useContext";
        updateHookTypesDev();
        return readContext(context);
      },
      useEffect: function (create, deps) {
        currentHookNameInDev = "useEffect";
        updateHookTypesDev();
        updateEffectImpl(2048, Passive, create, deps);
      },
      useImperativeHandle: function (ref, create, deps) {
        currentHookNameInDev = "useImperativeHandle";
        updateHookTypesDev();
        return updateImperativeHandle(ref, create, deps);
      },
      useInsertionEffect: function (create, deps) {
        currentHookNameInDev = "useInsertionEffect";
        updateHookTypesDev();
        return updateEffectImpl(4, Insertion, create, deps);
      },
      useLayoutEffect: function (create, deps) {
        currentHookNameInDev = "useLayoutEffect";
        updateHookTypesDev();
        return updateEffectImpl(4, Layout, create, deps);
      },
      useMemo: function (create, deps) {
        currentHookNameInDev = "useMemo";
        updateHookTypesDev();
        var prevDispatcher = ReactSharedInternals.H;
        ReactSharedInternals.H = InvalidNestedHooksDispatcherOnUpdateInDEV;
        try {
          return updateMemo(create, deps);
        } finally {
          ReactSharedInternals.H = prevDispatcher;
        }
      },
      useReducer: function (reducer, initialArg, init) {
        currentHookNameInDev = "useReducer";
        updateHookTypesDev();
        var prevDispatcher = ReactSharedInternals.H;
        ReactSharedInternals.H = InvalidNestedHooksDispatcherOnUpdateInDEV;
        try {
          return updateReducer(reducer, initialArg, init);
        } finally {
          ReactSharedInternals.H = prevDispatcher;
        }
      },
      useRef: function () {
        currentHookNameInDev = "useRef";
        updateHookTypesDev();
        return updateWorkInProgressHook().memoizedState;
      },
      useState: function () {
        currentHookNameInDev = "useState";
        updateHookTypesDev();
        var prevDispatcher = ReactSharedInternals.H;
        ReactSharedInternals.H = InvalidNestedHooksDispatcherOnUpdateInDEV;
        try {
          return updateReducer(basicStateReducer);
        } finally {
          ReactSharedInternals.H = prevDispatcher;
        }
      },
      useDebugValue: function () {
        currentHookNameInDev = "useDebugValue";
        updateHookTypesDev();
      },
      useDeferredValue: function (value, initialValue) {
        currentHookNameInDev = "useDeferredValue";
        updateHookTypesDev();
        return updateDeferredValue(value, initialValue);
      },
      useTransition: function () {
        currentHookNameInDev = "useTransition";
        updateHookTypesDev();
        return updateTransition();
      },
      useSyncExternalStore: function (
        subscribe,
        getSnapshot,
        getServerSnapshot
      ) {
        currentHookNameInDev = "useSyncExternalStore";
        updateHookTypesDev();
        return updateSyncExternalStore(
          subscribe,
          getSnapshot,
          getServerSnapshot
        );
      },
      useId: function () {
        currentHookNameInDev = "useId";
        updateHookTypesDev();
        return updateWorkInProgressHook().memoizedState;
      },
      useFormState: function (action) {
        currentHookNameInDev = "useFormState";
        updateHookTypesDev();
        warnOnUseFormStateInDev();
        return updateActionState(action);
      },
      useActionState: function (action) {
        currentHookNameInDev = "useActionState";
        updateHookTypesDev();
        return updateActionState(action);
      },
      useOptimistic: function (passthrough, reducer) {
        currentHookNameInDev = "useOptimistic";
        updateHookTypesDev();
        return updateOptimistic(passthrough, reducer);
      },
      useHostTransitionStatus: useHostTransitionStatus,
      useMemoCache: useMemoCache,
      useCacheRefresh: function () {
        currentHookNameInDev = "useCacheRefresh";
        updateHookTypesDev();
        return updateWorkInProgressHook().memoizedState;
      },
      useEffectEvent: function (callback) {
        currentHookNameInDev = "useEffectEvent";
        updateHookTypesDev();
        return updateEvent(callback);
      }
    };
    HooksDispatcherOnRerenderInDEV = {
      readContext: function (context) {
        return readContext(context);
      },
      use: use,
      useCallback: function (callback, deps) {
        currentHookNameInDev = "useCallback";
        updateHookTypesDev();
        return updateCallback(callback, deps);
      },
      useContext: function (context) {
        currentHookNameInDev = "useContext";
        updateHookTypesDev();
        return readContext(context);
      },
      useEffect: function (create, deps) {
        currentHookNameInDev = "useEffect";
        updateHookTypesDev();
        updateEffectImpl(2048, Passive, create, deps);
      },
      useImperativeHandle: function (ref, create, deps) {
        currentHookNameInDev = "useImperativeHandle";
        updateHookTypesDev();
        return updateImperativeHandle(ref, create, deps);
      },
      useInsertionEffect: function (create, deps) {
        currentHookNameInDev = "useInsertionEffect";
        updateHookTypesDev();
        return updateEffectImpl(4, Insertion, create, deps);
      },
      useLayoutEffect: function (create, deps) {
        currentHookNameInDev = "useLayoutEffect";
        updateHookTypesDev();
        return updateEffectImpl(4, Layout, create, deps);
      },
      useMemo: function (create, deps) {
        currentHookNameInDev = "useMemo";
        updateHookTypesDev();
        var prevDispatcher = ReactSharedInternals.H;
        ReactSharedInternals.H = InvalidNestedHooksDispatcherOnRerenderInDEV;
        try {
          return updateMemo(create, deps);
        } finally {
          ReactSharedInternals.H = prevDispatcher;
        }
      },
      useReducer: function (reducer, initialArg, init) {
        currentHookNameInDev = "useReducer";
        updateHookTypesDev();
        var prevDispatcher = ReactSharedInternals.H;
        ReactSharedInternals.H = InvalidNestedHooksDispatcherOnRerenderInDEV;
        try {
          return rerenderReducer(reducer, initialArg, init);
        } finally {
          ReactSharedInternals.H = prevDispatcher;
        }
      },
      useRef: function () {
        currentHookNameInDev = "useRef";
        updateHookTypesDev();
        return updateWorkInProgressHook().memoizedState;
      },
      useState: function () {
        currentHookNameInDev = "useState";
        updateHookTypesDev();
        var prevDispatcher = ReactSharedInternals.H;
        ReactSharedInternals.H = InvalidNestedHooksDispatcherOnRerenderInDEV;
        try {
          return rerenderReducer(basicStateReducer);
        } finally {
          ReactSharedInternals.H = prevDispatcher;
        }
      },
      useDebugValue: function () {
        currentHookNameInDev = "useDebugValue";
        updateHookTypesDev();
      },
      useDeferredValue: function (value, initialValue) {
        currentHookNameInDev = "useDeferredValue";
        updateHookTypesDev();
        return rerenderDeferredValue(value, initialValue);
      },
      useTransition: function () {
        currentHookNameInDev = "useTransition";
        updateHookTypesDev();
        return rerenderTransition();
      },
      useSyncExternalStore: function (
        subscribe,
        getSnapshot,
        getServerSnapshot
      ) {
        currentHookNameInDev = "useSyncExternalStore";
        updateHookTypesDev();
        return updateSyncExternalStore(
          subscribe,
          getSnapshot,
          getServerSnapshot
        );
      },
      useId: function () {
        currentHookNameInDev = "useId";
        updateHookTypesDev();
        return updateWorkInProgressHook().memoizedState;
      },
      useFormState: function (action) {
        currentHookNameInDev = "useFormState";
        updateHookTypesDev();
        warnOnUseFormStateInDev();
        return rerenderActionState(action);
      },
      useActionState: function (action) {
        currentHookNameInDev = "useActionState";
        updateHookTypesDev();
        return rerenderActionState(action);
      },
      useOptimistic: function (passthrough, reducer) {
        currentHookNameInDev = "useOptimistic";
        updateHookTypesDev();
        return rerenderOptimistic(passthrough, reducer);
      },
      useHostTransitionStatus: useHostTransitionStatus,
      useMemoCache: useMemoCache,
      useCacheRefresh: function () {
        currentHookNameInDev = "useCacheRefresh";
        updateHookTypesDev();
        return updateWorkInProgressHook().memoizedState;
      },
      useEffectEvent: function (callback) {
        currentHookNameInDev = "useEffectEvent";
        updateHookTypesDev();
        return updateEvent(callback);
      }
    };
    InvalidNestedHooksDispatcherOnMountInDEV = {
      readContext: function (context) {
        warnInvalidContextAccess();
        return readContext(context);
      },
      use: function (usable) {
        warnInvalidHookAccess();
        return use(usable);
      },
      useCallback: function (callback, deps) {
        currentHookNameInDev = "useCallback";
        warnInvalidHookAccess();
        mountHookTypesDev();
        return mountCallback(callback, deps);
      },
      useContext: function (context) {
        currentHookNameInDev = "useContext";
        warnInvalidHookAccess();
        mountHookTypesDev();
        return readContext(context);
      },
      useEffect: function (create, deps) {
        currentHookNameInDev = "useEffect";
        warnInvalidHookAccess();
        mountHookTypesDev();
        return mountEffect(create, deps);
      },
      useImperativeHandle: function (ref, create, deps) {
        currentHookNameInDev = "useImperativeHandle";
        warnInvalidHookAccess();
        mountHookTypesDev();
        return mountImperativeHandle(ref, create, deps);
      },
      useInsertionEffect: function (create, deps) {
        currentHookNameInDev = "useInsertionEffect";
        warnInvalidHookAccess();
        mountHookTypesDev();
        mountEffectImpl(4, Insertion, create, deps);
      },
      useLayoutEffect: function (create, deps) {
        currentHookNameInDev = "useLayoutEffect";
        warnInvalidHookAccess();
        mountHookTypesDev();
        return mountLayoutEffect(create, deps);
      },
      useMemo: function (create, deps) {
        currentHookNameInDev = "useMemo";
        warnInvalidHookAccess();
        mountHookTypesDev();
        var prevDispatcher = ReactSharedInternals.H;
        ReactSharedInternals.H = InvalidNestedHooksDispatcherOnMountInDEV;
        try {
          return mountMemo(create, deps);
        } finally {
          ReactSharedInternals.H = prevDispatcher;
        }
      },
      useReducer: function (reducer, initialArg, init) {
        currentHookNameInDev = "useReducer";
        warnInvalidHookAccess();
        mountHookTypesDev();
        var prevDispatcher = ReactSharedInternals.H;
        ReactSharedInternals.H = InvalidNestedHooksDispatcherOnMountInDEV;
        try {
          return mountReducer(reducer, initialArg, init);
        } finally {
          ReactSharedInternals.H = prevDispatcher;
        }
      },
      useRef: function (initialValue) {
        currentHookNameInDev = "useRef";
        warnInvalidHookAccess();
        mountHookTypesDev();
        return mountRef(initialValue);
      },
      useState: function (initialState) {
        currentHookNameInDev = "useState";
        warnInvalidHookAccess();
        mountHookTypesDev();
        var prevDispatcher = ReactSharedInternals.H;
        ReactSharedInternals.H = InvalidNestedHooksDispatcherOnMountInDEV;
        try {
          return mountState(initialState);
        } finally {
          ReactSharedInternals.H = prevDispatcher;
        }
      },
      useDebugValue: function () {
        currentHookNameInDev = "useDebugValue";
        warnInvalidHookAccess();
        mountHookTypesDev();
      },
      useDeferredValue: function (value, initialValue) {
        currentHookNameInDev = "useDeferredValue";
        warnInvalidHookAccess();
        mountHookTypesDev();
        return mountDeferredValue(value, initialValue);
      },
      useTransition: function () {
        currentHookNameInDev = "useTransition";
        warnInvalidHookAccess();
        mountHookTypesDev();
        return mountTransition();
      },
      useSyncExternalStore: function (
        subscribe,
        getSnapshot,
        getServerSnapshot
      ) {
        currentHookNameInDev = "useSyncExternalStore";
        warnInvalidHookAccess();
        mountHookTypesDev();
        return mountSyncExternalStore(
          subscribe,
          getSnapshot,
          getServerSnapshot
        );
      },
      useId: function () {
        currentHookNameInDev = "useId";
        warnInvalidHookAccess();
        mountHookTypesDev();
        return mountId();
      },
      useFormState: function (action, initialState) {
        currentHookNameInDev = "useFormState";
        warnInvalidHookAccess();
        mountHookTypesDev();
        return mountActionState(action, initialState);
      },
      useActionState: function (action, initialState) {
        currentHookNameInDev = "useActionState";
        warnInvalidHookAccess();
        mountHookTypesDev();
        return mountActionState(action, initialState);
      },
      useOptimistic: function (passthrough) {
        currentHookNameInDev = "useOptimistic";
        warnInvalidHookAccess();
        mountHookTypesDev();
        return mountOptimistic(passthrough);
      },
      useMemoCache: function (size) {
        warnInvalidHookAccess();
        return useMemoCache(size);
      },
      useHostTransitionStatus: useHostTransitionStatus,
      useCacheRefresh: function () {
        currentHookNameInDev = "useCacheRefresh";
        mountHookTypesDev();
        return mountRefresh();
      },
      useEffectEvent: function (callback) {
        currentHookNameInDev = "useEffectEvent";
        warnInvalidHookAccess();
        mountHookTypesDev();
        return mountEvent(callback);
      }
    };
    InvalidNestedHooksDispatcherOnUpdateInDEV = {
      readContext: function (context) {
        warnInvalidContextAccess();
        return readContext(context);
      },
      use: function (usable) {
        warnInvalidHookAccess();
        return use(usable);
      },
      useCallback: function (callback, deps) {
        currentHookNameInDev = "useCallback";
        warnInvalidHookAccess();
        updateHookTypesDev();
        return updateCallback(callback, deps);
      },
      useContext: function (context) {
        currentHookNameInDev = "useContext";
        warnInvalidHookAccess();
        updateHookTypesDev();
        return readContext(context);
      },
      useEffect: function (create, deps) {
        currentHookNameInDev = "useEffect";
        warnInvalidHookAccess();
        updateHookTypesDev();
        updateEffectImpl(2048, Passive, create, deps);
      },
      useImperativeHandle: function (ref, create, deps) {
        currentHookNameInDev = "useImperativeHandle";
        warnInvalidHookAccess();
        updateHookTypesDev();
        return updateImperativeHandle(ref, create, deps);
      },
      useInsertionEffect: function (create, deps) {
        currentHookNameInDev = "useInsertionEffect";
        warnInvalidHookAccess();
        updateHookTypesDev();
        return updateEffectImpl(4, Insertion, create, deps);
      },
      useLayoutEffect: function (create, deps) {
        currentHookNameInDev = "useLayoutEffect";
        warnInvalidHookAccess();
        updateHookTypesDev();
        return updateEffectImpl(4, Layout, create, deps);
      },
      useMemo: function (create, deps) {
        currentHookNameInDev = "useMemo";
        warnInvalidHookAccess();
        updateHookTypesDev();
        var prevDispatcher = ReactSharedInternals.H;
        ReactSharedInternals.H = InvalidNestedHooksDispatcherOnUpdateInDEV;
        try {
          return updateMemo(create, deps);
        } finally {
          ReactSharedInternals.H = prevDispatcher;
        }
      },
      useReducer: function (reducer, initialArg, init) {
        currentHookNameInDev = "useReducer";
        warnInvalidHookAccess();
        updateHookTypesDev();
        var prevDispatcher = ReactSharedInternals.H;
        ReactSharedInternals.H = InvalidNestedHooksDispatcherOnUpdateInDEV;
        try {
          return updateReducer(reducer, initialArg, init);
        } finally {
          ReactSharedInternals.H = prevDispatcher;
        }
      },
      useRef: function () {
        currentHookNameInDev = "useRef";
        warnInvalidHookAccess();
        updateHookTypesDev();
        return updateWorkInProgressHook().memoizedState;
      },
      useState: function () {
        currentHookNameInDev = "useState";
        warnInvalidHookAccess();
        updateHookTypesDev();
        var prevDispatcher = ReactSharedInternals.H;
        ReactSharedInternals.H = InvalidNestedHooksDispatcherOnUpdateInDEV;
        try {
          return updateReducer(basicStateReducer);
        } finally {
          ReactSharedInternals.H = prevDispatcher;
        }
      },
      useDebugValue: function () {
        currentHookNameInDev = "useDebugValue";
        warnInvalidHookAccess();
        updateHookTypesDev();
      },
      useDeferredValue: function (value, initialValue) {
        currentHookNameInDev = "useDeferredValue";
        warnInvalidHookAccess();
        updateHookTypesDev();
        return updateDeferredValue(value, initialValue);
      },
      useTransition: function () {
        currentHookNameInDev = "useTransition";
        warnInvalidHookAccess();
        updateHookTypesDev();
        return updateTransition();
      },
      useSyncExternalStore: function (
        subscribe,
        getSnapshot,
        getServerSnapshot
      ) {
        currentHookNameInDev = "useSyncExternalStore";
        warnInvalidHookAccess();
        updateHookTypesDev();
        return updateSyncExternalStore(
          subscribe,
          getSnapshot,
          getServerSnapshot
        );
      },
      useId: function () {
        currentHookNameInDev = "useId";
        warnInvalidHookAccess();
        updateHookTypesDev();
        return updateWorkInProgressHook().memoizedState;
      },
      useFormState: function (action) {
        currentHookNameInDev = "useFormState";
        warnInvalidHookAccess();
        updateHookTypesDev();
        return updateActionState(action);
      },
      useActionState: function (action) {
        currentHookNameInDev = "useActionState";
        warnInvalidHookAccess();
        updateHookTypesDev();
        return updateActionState(action);
      },
      useOptimistic: function (passthrough, reducer) {
        currentHookNameInDev = "useOptimistic";
        warnInvalidHookAccess();
        updateHookTypesDev();
        return updateOptimistic(passthrough, reducer);
      },
      useMemoCache: function (size) {
        warnInvalidHookAccess();
        return useMemoCache(size);
      },
      useHostTransitionStatus: useHostTransitionStatus,
      useCacheRefresh: function () {
        currentHookNameInDev = "useCacheRefresh";
        updateHookTypesDev();
        return updateWorkInProgressHook().memoizedState;
      },
      useEffectEvent: function (callback) {
        currentHookNameInDev = "useEffectEvent";
        warnInvalidHookAccess();
        updateHookTypesDev();
        return updateEvent(callback);
      }
    };
    InvalidNestedHooksDispatcherOnRerenderInDEV = {
      readContext: function (context) {
        warnInvalidContextAccess();
        return readContext(context);
      },
      use: function (usable) {
        warnInvalidHookAccess();
        return use(usable);
      },
      useCallback: function (callback, deps) {
        currentHookNameInDev = "useCallback";
        warnInvalidHookAccess();
        updateHookTypesDev();
        return updateCallback(callback, deps);
      },
      useContext: function (context) {
        currentHookNameInDev = "useContext";
        warnInvalidHookAccess();
        updateHookTypesDev();
        return readContext(context);
      },
      useEffect: function (create, deps) {
        currentHookNameInDev = "useEffect";
        warnInvalidHookAccess();
        updateHookTypesDev();
        updateEffectImpl(2048, Passive, create, deps);
      },
      useImperativeHandle: function (ref, create, deps) {
        currentHookNameInDev = "useImperativeHandle";
        warnInvalidHookAccess();
        updateHookTypesDev();
        return updateImperativeHandle(ref, create, deps);
      },
      useInsertionEffect: function (create, deps) {
        currentHookNameInDev = "useInsertionEffect";
        warnInvalidHookAccess();
        updateHookTypesDev();
        return updateEffectImpl(4, Insertion, create, deps);
      },
      useLayoutEffect: function (create, deps) {
        currentHookNameInDev = "useLayoutEffect";
        warnInvalidHookAccess();
        updateHookTypesDev();
        return updateEffectImpl(4, Layout, create, deps);
      },
      useMemo: function (create, deps) {
        currentHookNameInDev = "useMemo";
        warnInvalidHookAccess();
        updateHookTypesDev();
        var prevDispatcher = ReactSharedInternals.H;
        ReactSharedInternals.H = InvalidNestedHooksDispatcherOnUpdateInDEV;
        try {
          return updateMemo(create, deps);
        } finally {
          ReactSharedInternals.H = prevDispatcher;
        }
      },
      useReducer: function (reducer, initialArg, init) {
        currentHookNameInDev = "useReducer";
        warnInvalidHookAccess();
        updateHookTypesDev();
        var prevDispatcher = ReactSharedInternals.H;
        ReactSharedInternals.H = InvalidNestedHooksDispatcherOnUpdateInDEV;
        try {
          return rerenderReducer(reducer, initialArg, init);
        } finally {
          ReactSharedInternals.H = prevDispatcher;
        }
      },
      useRef: function () {
        currentHookNameInDev = "useRef";
        warnInvalidHookAccess();
        updateHookTypesDev();
        return updateWorkInProgressHook().memoizedState;
      },
      useState: function () {
        currentHookNameInDev = "useState";
        warnInvalidHookAccess();
        updateHookTypesDev();
        var prevDispatcher = ReactSharedInternals.H;
        ReactSharedInternals.H = InvalidNestedHooksDispatcherOnUpdateInDEV;
        try {
          return rerenderReducer(basicStateReducer);
        } finally {
          ReactSharedInternals.H = prevDispatcher;
        }
      },
      useDebugValue: function () {
        currentHookNameInDev = "useDebugValue";
        warnInvalidHookAccess();
        updateHookTypesDev();
      },
      useDeferredValue: function (value, initialValue) {
        currentHookNameInDev = "useDeferredValue";
        warnInvalidHookAccess();
        updateHookTypesDev();
        return rerenderDeferredValue(value, initialValue);
      },
      useTransition: function () {
        currentHookNameInDev = "useTransition";
        warnInvalidHookAccess();
        updateHookTypesDev();
        return rerenderTransition();
      },
      useSyncExternalStore: function (
        subscribe,
        getSnapshot,
        getServerSnapshot
      ) {
        currentHookNameInDev = "useSyncExternalStore";
        warnInvalidHookAccess();
        updateHookTypesDev();
        return updateSyncExternalStore(
          subscribe,
          getSnapshot,
          getServerSnapshot
        );
      },
      useId: function () {
        currentHookNameInDev = "useId";
        warnInvalidHookAccess();
        updateHookTypesDev();
        return updateWorkInProgressHook().memoizedState;
      },
      useFormState: function (action) {
        currentHookNameInDev = "useFormState";
        warnInvalidHookAccess();
        updateHookTypesDev();
        return rerenderActionState(action);
      },
      useActionState: function (action) {
        currentHookNameInDev = "useActionState";
        warnInvalidHookAccess();
        updateHookTypesDev();
        return rerenderActionState(action);
      },
      useOptimistic: function (passthrough, reducer) {
        currentHookNameInDev = "useOptimistic";
        warnInvalidHookAccess();
        updateHookTypesDev();
        return rerenderOptimistic(passthrough, reducer);
      },
      useMemoCache: function (size) {
        warnInvalidHookAccess();
        return useMemoCache(size);
      },
      useHostTransitionStatus: useHostTransitionStatus,
      useCacheRefresh: function () {
        currentHookNameInDev = "useCacheRefresh";
        updateHookTypesDev();
        return updateWorkInProgressHook().memoizedState;
      },
      useEffectEvent: function (callback) {
        currentHookNameInDev = "useEffectEvent";
        warnInvalidHookAccess();
        updateHookTypesDev();
        return updateEvent(callback);
      }
    };
    var fakeInternalInstance = {};
    var didWarnAboutStateAssignmentForComponent = new Set();
    var didWarnAboutUninitializedState = new Set();
    var didWarnAboutGetSnapshotBeforeUpdateWithoutDidUpdate = new Set();
    var didWarnAboutLegacyLifecyclesAndDerivedState = new Set();
    var didWarnAboutDirectlyAssigningPropsToState = new Set();
    var didWarnAboutUndefinedDerivedState = new Set();
    var didWarnAboutContextTypes$1 = new Set();
    var didWarnAboutChildContextTypes = new Set();
    var didWarnAboutInvalidateContextType = new Set();
    var didWarnOnInvalidCallback = new Set();
    Object.freeze(fakeInternalInstance);
    var classComponentUpdater = {
        enqueueSetState: function (inst, payload, callback) {
          inst = inst._reactInternals;
          var lane = requestUpdateLane(inst),
            update = createUpdate(lane);
          update.payload = payload;
          void 0 !== callback &&
            null !== callback &&
            (warnOnInvalidCallback(callback), (update.callback = callback));
          payload = enqueueUpdate(inst, update, lane);
          null !== payload &&
            (startUpdateTimerByLane(lane, "this.setState()", inst),
            scheduleUpdateOnFiber(payload, inst, lane),
            entangleTransitions(payload, inst, lane));
        },
        enqueueReplaceState: function (inst, payload, callback) {
          inst = inst._reactInternals;
          var lane = requestUpdateLane(inst),
            update = createUpdate(lane);
          update.tag = ReplaceState;
          update.payload = payload;
          void 0 !== callback &&
            null !== callback &&
            (warnOnInvalidCallback(callback), (update.callback = callback));
          payload = enqueueUpdate(inst, update, lane);
          null !== payload &&
            (startUpdateTimerByLane(lane, "this.replaceState()", inst),
            scheduleUpdateOnFiber(payload, inst, lane),
            entangleTransitions(payload, inst, lane));
        },
        enqueueForceUpdate: function (inst, callback) {
          inst = inst._reactInternals;
          var lane = requestUpdateLane(inst),
            update = createUpdate(lane);
          update.tag = ForceUpdate;
          void 0 !== callback &&
            null !== callback &&
            (warnOnInvalidCallback(callback), (update.callback = callback));
          callback = enqueueUpdate(inst, update, lane);
          null !== callback &&
            (startUpdateTimerByLane(lane, "this.forceUpdate()", inst),
            scheduleUpdateOnFiber(callback, inst, lane),
            entangleTransitions(callback, inst, lane));
        }
      },
      componentName = null,
      errorBoundaryName = null,
      SelectiveHydrationException = Error(
        "This is not a real error. It's an implementation detail of React's selective hydration feature. If this leaks into userspace, it's a bug in React. Please file an issue."
      ),
      didReceiveUpdate = !1;
    var didWarnAboutBadClass = {};
    var didWarnAboutContextTypeOnFunctionComponent = {};
    var didWarnAboutContextTypes = {};
    var didWarnAboutGetDerivedStateOnFunctionComponent = {};
    var didWarnAboutReassigningProps = !1;
    var didWarnAboutRevealOrder = {};
    var didWarnAboutTailOptions = {};
    var SUSPENDED_MARKER = {
        dehydrated: null,
        treeContext: null,
        retryLane: 0,
        hydrationErrors: null
      },
      hasWarnedAboutUsingNoValuePropOnContextProvider = !1,
      didWarnAboutUndefinedSnapshotBeforeUpdate = null;
    didWarnAboutUndefinedSnapshotBeforeUpdate = new Set();
    var offscreenSubtreeIsHidden = !1,
      offscreenSubtreeWasHidden = !1,
      needsFormReset = !1,
      PossiblyWeakSet = "function" === typeof WeakSet ? WeakSet : Set,
      nextEffect = null,
      inProgressLanes = null,
      inProgressRoot = null,
      hostParent = null,
      hostParentIsContainer = !1,
      currentHoistableRoot = null,
      inHydratedSubtree = !1,
      suspenseyCommitFlag = 8192,
      DefaultAsyncDispatcher = {
        getCacheForType: function (resourceType) {
          var cache = readContext(CacheContext),
            cacheForType = cache.data.get(resourceType);
          void 0 === cacheForType &&
            ((cacheForType = resourceType()),
            cache.data.set(resourceType, cacheForType));
          return cacheForType;
        },
        cacheSignal: function () {
          return readContext(CacheContext).controller.signal;
        },
        getOwner: function () {
          return current;
        }
      };
    if ("function" === typeof Symbol && Symbol.for) {
      var symbolFor = Symbol.for;
      symbolFor("selector.component");
      symbolFor("selector.has_pseudo_class");
      symbolFor("selector.role");
      symbolFor("selector.test_id");
      symbolFor("selector.text");
    }
    var commitHooks = [],
      PossiblyWeakMap = "function" === typeof WeakMap ? WeakMap : Map,
      NoContext = 0,
      RenderContext = 2,
      CommitContext = 4,
      RootInProgress = 0,
      RootFatalErrored = 1,
      RootErrored = 2,
      RootSuspended = 3,
      RootSuspendedWithDelay = 4,
      RootSuspendedAtTheShell = 6,
      RootCompleted = 5,
      executionContext = NoContext,
      workInProgressRoot = null,
      workInProgress = null,
      workInProgressRootRenderLanes = 0,
      NotSuspended = 0,
      SuspendedOnError = 1,
      SuspendedOnData = 2,
      SuspendedOnImmediate = 3,
      SuspendedOnInstance = 4,
      SuspendedOnInstanceAndReadyToContinue = 5,
      SuspendedOnDeprecatedThrowPromise = 6,
      SuspendedAndReadyToContinue = 7,
      SuspendedOnHydration = 8,
      SuspendedOnAction = 9,
      workInProgressSuspendedReason = NotSuspended,
      workInProgressThrownValue = null,
      workInProgressRootDidSkipSuspendedSiblings = !1,
      workInProgressRootIsPrerendering = !1,
      workInProgressRootDidAttachPingListener = !1,
      entangledRenderLanes = 0,
      workInProgressRootExitStatus = RootInProgress,
      workInProgressRootSkippedLanes = 0,
      workInProgressRootInterleavedUpdatedLanes = 0,
      workInProgressRootPingedLanes = 0,
      workInProgressDeferredLane = 0,
      workInProgressSuspendedRetryLanes = 0,
      workInProgressRootConcurrentErrors = null,
      workInProgressRootRecoverableErrors = null,
      workInProgressRootDidIncludeRecursiveRenderUpdate = !1,
      globalMostRecentFallbackTime = 0,
      globalMostRecentTransitionTime = 0,
      FALLBACK_THROTTLE_MS = 300,
      workInProgressRootRenderTargetTime = Infinity,
      RENDER_TIMEOUT_MS = 500,
      workInProgressTransitions = null,
      workInProgressUpdateTask = null,
      legacyErrorBoundariesThatAlreadyFailed = null,
      IMMEDIATE_COMMIT = 0,
      ABORTED_VIEW_TRANSITION_COMMIT = 1,
      DELAYED_PASSIVE_COMMIT = 2,
      ANIMATION_STARTED_COMMIT = 3,
      NO_PENDING_EFFECTS = 0,
      PENDING_MUTATION_PHASE = 1,
      PENDING_LAYOUT_PHASE = 2,
      PENDING_AFTER_MUTATION_PHASE = 3,
      PENDING_SPAWNED_WORK = 4,
      PENDING_PASSIVE_PHASE = 5,
      pendingEffectsStatus = 0,
      pendingEffectsRoot = null,
      pendingFinishedWork = null,
      pendingEffectsLanes = 0,
      pendingEffectsRemainingLanes = 0,
      pendingEffectsRenderEndTime = -0,
      pendingPassiveTransitions = null,
      pendingRecoverableErrors = null,
      pendingSuspendedCommitReason = null,
      pendingDelayedCommitReason = IMMEDIATE_COMMIT,
      pendingSuspendedViewTransitionReason = null,
      NESTED_UPDATE_LIMIT = 50,
      nestedUpdateCount = 0,
      rootWithNestedUpdates = null,
      isFlushingPassiveEffects = !1,
      didScheduleUpdateDuringPassiveEffects = !1,
      NESTED_PASSIVE_UPDATE_LIMIT = 50,
      nestedPassiveUpdateCount = 0,
      rootWithPassiveNestedUpdates = null,
      isRunningInsertionEffect = !1,
      didWarnStateUpdateForNotYetMountedComponent = null,
      didWarnAboutUpdateInRender = !1;
    var didWarnAboutUpdateInRenderForAnotherComponent = new Set();
    var fakeActCallbackNode$1 = {},
      firstScheduledRoot = null,
      lastScheduledRoot = null,
      didScheduleMicrotask = !1,
      didScheduleMicrotask_act = !1,
      mightHavePendingSyncWork = !1,
      isFlushingWork = !1,
      currentEventTransitionLane = 0,
      fakeActCallbackNode = {};
    (function () {
      for (var i = 0; i < simpleEventPluginEvents.length; i++) {
        var eventName = simpleEventPluginEvents[i],
          domEventName = eventName.toLowerCase();
        eventName = eventName[0].toUpperCase() + eventName.slice(1);
        registerSimpleEvent(domEventName, "on" + eventName);
      }
      registerSimpleEvent(ANIMATION_END, "onAnimationEnd");
      registerSimpleEvent(ANIMATION_ITERATION, "onAnimationIteration");
      registerSimpleEvent(ANIMATION_START, "onAnimationStart");
      registerSimpleEvent("dblclick", "onDoubleClick");
      registerSimpleEvent("focusin", "onFocus");
      registerSimpleEvent("focusout", "onBlur");
      registerSimpleEvent(TRANSITION_RUN, "onTransitionRun");
      registerSimpleEvent(TRANSITION_START, "onTransitionStart");
      registerSimpleEvent(TRANSITION_CANCEL, "onTransitionCancel");
      registerSimpleEvent(TRANSITION_END, "onTransitionEnd");
    })();
    registerDirectEvent("onMouseEnter", ["mouseout", "mouseover"]);
    registerDirectEvent("onMouseLeave", ["mouseout", "mouseover"]);
    registerDirectEvent("onPointerEnter", ["pointerout", "pointerover"]);
    registerDirectEvent("onPointerLeave", ["pointerout", "pointerover"]);
    registerTwoPhaseEvent(
      "onChange",
      "change click focusin focusout input keydown keyup selectionchange".split(
        " "
      )
    );
    registerTwoPhaseEvent(
      "onSelect",
      "focusout contextmenu dragend focusin keydown keyup mousedown mouseup selectionchange".split(
        " "
      )
    );
    registerTwoPhaseEvent("onBeforeInput", [
      "compositionend",
      "keypress",
      "textInput",
      "paste"
    ]);
    registerTwoPhaseEvent(
      "onCompositionEnd",
      "compositionend focusout keydown keypress keyup mousedown".split(" ")
    );
    registerTwoPhaseEvent(
      "onCompositionStart",
      "compositionstart focusout keydown keypress keyup mousedown".split(" ")
    );
    registerTwoPhaseEvent(
      "onCompositionUpdate",
      "compositionupdate focusout keydown keypress keyup mousedown".split(" ")
    );
    var mediaEventTypes =
        "abort canplay canplaythrough durationchange emptied encrypted ended error loadeddata loadedmetadata loadstart pause play playing progress ratechange resize seeked seeking stalled suspend timeupdate volumechange waiting".split(
          " "
        ),
      nonDelegatedEvents = new Set(
        "beforetoggle cancel close invalid load scroll scrollend toggle"
          .split(" ")
          .concat(mediaEventTypes)
      ),
      listeningMarker = "_reactListening" + Math.random().toString(36).slice(2),
      didWarnControlledToUncontrolled = !1,
      didWarnUncontrolledToControlled = !1,
      didWarnFormActionType = !1,
      didWarnFormActionName = !1,
      didWarnFormActionTarget = !1,
      didWarnFormActionMethod = !1,
      didWarnPopoverTargetObject = !1;
    var didWarnForNewBooleanPropsWithEmptyValue = {};
    var NORMALIZE_NEWLINES_REGEX = /\r\n?/g,
      NORMALIZE_NULL_AND_REPLACEMENT_REGEX = /\u0000|\uFFFD/g,
      xlinkNamespace = "http://www.w3.org/1999/xlink",
      xmlNamespace = "http://www.w3.org/XML/1998/namespace",
      EXPECTED_FORM_ACTION_URL =
        "javascript:throw new Error('React form unexpectedly submitted.')",
      SUPPRESS_HYDRATION_WARNING = "suppressHydrationWarning",
      ACTIVITY_START_DATA = "&",
      ACTIVITY_END_DATA = "/&",
      SUSPENSE_START_DATA = "$",
      SUSPENSE_END_DATA = "/$",
      SUSPENSE_PENDING_START_DATA = "$?",
      SUSPENSE_QUEUED_START_DATA = "$~",
      SUSPENSE_FALLBACK_START_DATA = "$!",
      PREAMBLE_CONTRIBUTION_HTML = "html",
      PREAMBLE_CONTRIBUTION_BODY = "body",
      PREAMBLE_CONTRIBUTION_HEAD = "head",
      FORM_STATE_IS_MATCHING = "F!",
      FORM_STATE_IS_NOT_MATCHING = "F",
      DOCUMENT_READY_STATE_LOADING = "loading",
      STYLE = "style",
      HostContextNamespaceNone = 0,
      HostContextNamespaceSvg = 1,
      HostContextNamespaceMath = 2,
      eventsEnabled = null,
      selectionInformation = null,
      warnedUnknownTags = { dialog: !0, webview: !0 },
      currentPopstateTransitionEvent = null,
      schedulerEvent = void 0,
      scheduleTimeout = "function" === typeof setTimeout ? setTimeout : void 0,
      cancelTimeout =
        "function" === typeof clearTimeout ? clearTimeout : void 0,
      noTimeout = -1,
      localPromise = "function" === typeof Promise ? Promise : void 0,
      scheduleMicrotask =
        "function" === typeof queueMicrotask
          ? queueMicrotask
          : "undefined" !== typeof localPromise
            ? function (callback) {
                return localPromise
                  .resolve(null)
                  .then(callback)
                  .catch(handleErrorInNextTick);
              }
            : scheduleTimeout,
      previousHydratableOnEnteringScopedSingleton = null,
      NotLoaded = 0,
      Loaded = 1,
      Errored = 2,
      Settled = 3,
      Inserted = 4,
      preloadPropsMap = new Map(),
      preconnectsSet = new Set(),
      previousDispatcher = ReactDOMSharedInternals.d;
    ReactDOMSharedInternals.d = {
      f: function () {
        var previousWasRendering = previousDispatcher.f(),
          wasRendering = flushSyncWork$1();
        return previousWasRendering || wasRendering;
      },
      r: function (form) {
        var formInst = getInstanceFromNode(form);
        null !== formInst && 5 === formInst.tag && "form" === formInst.type
          ? requestFormReset$1(formInst)
          : previousDispatcher.r(form);
      },
      D: function (href) {
        previousDispatcher.D(href);
        preconnectAs("dns-prefetch", href, null);
      },
      C: function (href, crossOrigin) {
        previousDispatcher.C(href, crossOrigin);
        preconnectAs("preconnect", href, crossOrigin);
      },
      L: function (href, as, options) {
        previousDispatcher.L(href, as, options);
        var ownerDocument = globalDocument;
        if (ownerDocument && href && as) {
          var preloadSelector =
            'link[rel="preload"][as="' +
            escapeSelectorAttributeValueInsideDoubleQuotes(as) +
            '"]';
          "image" === as
            ? options && options.imageSrcSet
              ? ((preloadSelector +=
                  '[imagesrcset="' +
                  escapeSelectorAttributeValueInsideDoubleQuotes(
                    options.imageSrcSet
                  ) +
                  '"]'),
                "string" === typeof options.imageSizes &&
                  (preloadSelector +=
                    '[imagesizes="' +
                    escapeSelectorAttributeValueInsideDoubleQuotes(
                      options.imageSizes
                    ) +
                    '"]'))
              : (preloadSelector +=
                  '[href="' +
                  escapeSelectorAttributeValueInsideDoubleQuotes(href) +
                  '"]')
            : (preloadSelector +=
                '[href="' +
                escapeSelectorAttributeValueInsideDoubleQuotes(href) +
                '"]');
          var key = preloadSelector;
          switch (as) {
            case "style":
              key = getStyleKey(href);
              break;
            case "script":
              key = getScriptKey(href);
          }
          preloadPropsMap.has(key) ||
            ((href = assign(
              {
                rel: "preload",
                href:
                  "image" === as && options && options.imageSrcSet
                    ? void 0
                    : href,
                as: as
              },
              options
            )),
            preloadPropsMap.set(key, href),
            null !== ownerDocument.querySelector(preloadSelector) ||
              ("style" === as &&
                ownerDocument.querySelector(
                  getStylesheetSelectorFromKey(key)
                )) ||
              ("script" === as &&
                ownerDocument.querySelector(getScriptSelectorFromKey(key))) ||
              ((as = ownerDocument.createElement("link")),
              setInitialProperties(as, "link", href),
              markNodeAsHoistable(as),
              ownerDocument.head.appendChild(as)));
        }
      },
      m: function (href, options) {
        previousDispatcher.m(href, options);
        var ownerDocument = globalDocument;
        if (ownerDocument && href) {
          var as =
              options && "string" === typeof options.as ? options.as : "script",
            preloadSelector =
              'link[rel="modulepreload"][as="' +
              escapeSelectorAttributeValueInsideDoubleQuotes(as) +
              '"][href="' +
              escapeSelectorAttributeValueInsideDoubleQuotes(href) +
              '"]',
            key = preloadSelector;
          switch (as) {
            case "audioworklet":
            case "paintworklet":
            case "serviceworker":
            case "sharedworker":
            case "worker":
            case "script":
              key = getScriptKey(href);
          }
          if (
            !preloadPropsMap.has(key) &&
            ((href = assign({ rel: "modulepreload", href: href }, options)),
            preloadPropsMap.set(key, href),
            null === ownerDocument.querySelector(preloadSelector))
          ) {
            switch (as) {
              case "audioworklet":
              case "paintworklet":
              case "serviceworker":
              case "sharedworker":
              case "worker":
              case "script":
                if (ownerDocument.querySelector(getScriptSelectorFromKey(key)))
                  return;
            }
            as = ownerDocument.createElement("link");
            setInitialProperties(as, "link", href);
            markNodeAsHoistable(as);
            ownerDocument.head.appendChild(as);
          }
        }
      },
      X: function (src, options) {
        previousDispatcher.X(src, options);
        var ownerDocument = globalDocument;
        if (ownerDocument && src) {
          var scripts = getResourcesFromRoot(ownerDocument).hoistableScripts,
            key = getScriptKey(src),
            resource = scripts.get(key);
          resource ||
            ((resource = ownerDocument.querySelector(
              getScriptSelectorFromKey(key)
            )),
            resource ||
              ((src = assign({ src: src, async: !0 }, options)),
              (options = preloadPropsMap.get(key)) &&
                adoptPreloadPropsForScript(src, options),
              (resource = ownerDocument.createElement("script")),
              markNodeAsHoistable(resource),
              setInitialProperties(resource, "link", src),
              ownerDocument.head.appendChild(resource)),
            (resource = {
              type: "script",
              instance: resource,
              count: 1,
              state: null
            }),
            scripts.set(key, resource));
        }
      },
      S: function (href, precedence, options) {
        previousDispatcher.S(href, precedence, options);
        var ownerDocument = globalDocument;
        if (ownerDocument && href) {
          var styles = getResourcesFromRoot(ownerDocument).hoistableStyles,
            key = getStyleKey(href);
          precedence = precedence || "default";
          var resource = styles.get(key);
          if (!resource) {
            var state = { loading: NotLoaded, preload: null };
            if (
              (resource = ownerDocument.querySelector(
                getStylesheetSelectorFromKey(key)
              ))
            )
              state.loading = Loaded | Inserted;
            else {
              href = assign(
                {
                  rel: "stylesheet",
                  href: href,
                  "data-precedence": precedence
                },
                options
              );
              (options = preloadPropsMap.get(key)) &&
                adoptPreloadPropsForStylesheet(href, options);
              var link = (resource = ownerDocument.createElement("link"));
              markNodeAsHoistable(link);
              setInitialProperties(link, "link", href);
              link._p = new Promise(function (resolve, reject) {
                link.onload = resolve;
                link.onerror = reject;
              });
              link.addEventListener("load", function () {
                state.loading |= Loaded;
              });
              link.addEventListener("error", function () {
                state.loading |= Errored;
              });
              state.loading |= Inserted;
              insertStylesheet(resource, precedence, ownerDocument);
            }
            resource = {
              type: "stylesheet",
              instance: resource,
              count: 1,
              state: state
            };
            styles.set(key, resource);
          }
        }
      },
      M: function (src, options) {
        previousDispatcher.M(src, options);
        var ownerDocument = globalDocument;
        if (ownerDocument && src) {
          var scripts = getResourcesFromRoot(ownerDocument).hoistableScripts,
            key = getScriptKey(src),
            resource = scripts.get(key);
          resource ||
            ((resource = ownerDocument.querySelector(
              getScriptSelectorFromKey(key)
            )),
            resource ||
              ((src = assign({ src: src, async: !0, type: "module" }, options)),
              (options = preloadPropsMap.get(key)) &&
                adoptPreloadPropsForScript(src, options),
              (resource = ownerDocument.createElement("script")),
              markNodeAsHoistable(resource),
              setInitialProperties(resource, "link", src),
              ownerDocument.head.appendChild(resource)),
            (resource = {
              type: "script",
              instance: resource,
              count: 1,
              state: null
            }),
            scripts.set(key, resource));
        }
      }
    };
    var globalDocument = "undefined" === typeof document ? null : document,
      tagCaches = null,
      SUSPENSEY_STYLESHEET_TIMEOUT = 6e4,
      SUSPENSEY_IMAGE_TIMEOUT = 800,
      SUSPENSEY_IMAGE_TIME_ESTIMATE = 500,
      estimatedBytesWithinLimit = 0,
      LAST_PRECEDENCE = null,
      precedencesByRoot = null,
      NotPendingTransition = NotPending,
      HostTransitionContext = {
        $$typeof: REACT_CONTEXT_TYPE,
        Provider: null,
        Consumer: null,
        _currentValue: NotPendingTransition,
        _currentValue2: NotPendingTransition,
        _threadCount: 0
      },
      badgeFormat = "%c%s%c",
      badgeStyle =
        "background: #e6e6e6;background: light-dark(rgba(0,0,0,0.1), rgba(255,255,255,0.25));color: #000000;color: light-dark(#000000, #ffffff);border-radius: 2px",
      resetStyle = "",
      pad = " ",
      bind = Function.prototype.bind;
    var didWarnAboutNestedUpdates = !1;
    var overrideHookState = null,
      overrideHookStateDeletePath = null,
      overrideHookStateRenamePath = null,
      overrideProps = null,
      overridePropsDeletePath = null,
      overridePropsRenamePath = null,
      scheduleUpdate = null,
      scheduleRetry = null,
      setErrorHandler = null,
      setSuspenseHandler = null;
    overrideHookState = function (fiber, id, path, value) {
      id = findHook(fiber, id);
      null !== id &&
        ((path = copyWithSetImpl(id.memoizedState, path, 0, value)),
        (id.memoizedState = path),
        (id.baseState = path),
        (fiber.memoizedProps = assign({}, fiber.memoizedProps)),
        (path = enqueueConcurrentRenderForLane(fiber, 2)),
        null !== path && scheduleUpdateOnFiber(path, fiber, 2));
    };
    overrideHookStateDeletePath = function (fiber, id, path) {
      id = findHook(fiber, id);
      null !== id &&
        ((path = copyWithDeleteImpl(id.memoizedState, path, 0)),
        (id.memoizedState = path),
        (id.baseState = path),
        (fiber.memoizedProps = assign({}, fiber.memoizedProps)),
        (path = enqueueConcurrentRenderForLane(fiber, 2)),
        null !== path && scheduleUpdateOnFiber(path, fiber, 2));
    };
    overrideHookStateRenamePath = function (fiber, id, oldPath, newPath) {
      id = findHook(fiber, id);
      null !== id &&
        ((oldPath = copyWithRename(id.memoizedState, oldPath, newPath)),
        (id.memoizedState = oldPath),
        (id.baseState = oldPath),
        (fiber.memoizedProps = assign({}, fiber.memoizedProps)),
        (oldPath = enqueueConcurrentRenderForLane(fiber, 2)),
        null !== oldPath && scheduleUpdateOnFiber(oldPath, fiber, 2));
    };
    overrideProps = function (fiber, path, value) {
      fiber.pendingProps = copyWithSetImpl(fiber.memoizedProps, path, 0, value);
      fiber.alternate && (fiber.alternate.pendingProps = fiber.pendingProps);
      path = enqueueConcurrentRenderForLane(fiber, 2);
      null !== path && scheduleUpdateOnFiber(path, fiber, 2);
    };
    overridePropsDeletePath = function (fiber, path) {
      fiber.pendingProps = copyWithDeleteImpl(fiber.memoizedProps, path, 0);
      fiber.alternate && (fiber.alternate.pendingProps = fiber.pendingProps);
      path = enqueueConcurrentRenderForLane(fiber, 2);
      null !== path && scheduleUpdateOnFiber(path, fiber, 2);
    };
    overridePropsRenamePath = function (fiber, oldPath, newPath) {
      fiber.pendingProps = copyWithRename(
        fiber.memoizedProps,
        oldPath,
        newPath
      );
      fiber.alternate && (fiber.alternate.pendingProps = fiber.pendingProps);
      oldPath = enqueueConcurrentRenderForLane(fiber, 2);
      null !== oldPath && scheduleUpdateOnFiber(oldPath, fiber, 2);
    };
    scheduleUpdate = function (fiber) {
      var root = enqueueConcurrentRenderForLane(fiber, 2);
      null !== root && scheduleUpdateOnFiber(root, fiber, 2);
    };
    scheduleRetry = function (fiber) {
      var lane = claimNextRetryLane(),
        root = enqueueConcurrentRenderForLane(fiber, lane);
      null !== root && scheduleUpdateOnFiber(root, fiber, lane);
    };
    setErrorHandler = function (newShouldErrorImpl) {
      shouldErrorImpl = newShouldErrorImpl;
    };
    setSuspenseHandler = function (newShouldSuspendImpl) {
      shouldSuspendImpl = newShouldSuspendImpl;
    };
    var _enabled = !0,
      return_targetInst = null,
      hasScheduledReplayAttempt = !1,
      queuedFocus = null,
      queuedDrag = null,
      queuedMouse = null,
      queuedPointers = new Map(),
      queuedPointerCaptures = new Map(),
      queuedExplicitHydrationTargets = [],
      discreteReplayableEvents =
        "mousedown mouseup touchcancel touchend touchstart auxclick dblclick pointercancel pointerdown pointerup dragend dragstart drop compositionend compositionstart keydown keypress keyup input textInput copy cut paste click change contextmenu reset".split(
          " "
        ),
      lastScheduledReplayQueue = null;
    ReactDOMHydrationRoot.prototype.render = ReactDOMRoot.prototype.render =
      function (children) {
        var root = this._internalRoot;
        if (null === root) throw Error("Cannot update an unmounted root.");
        var args = arguments;
        "function" === typeof args[1]
          ? console.error(
              "does not support the second callback argument. To execute a side effect after rendering, declare it in a component body with useEffect()."
            )
          : isValidContainer(args[1])
            ? console.error(
                "You passed a container to the second argument of root.render(...). You don't need to pass it again since you already passed it to create the root."
              )
            : "undefined" !== typeof args[1] &&
              console.error(
                "You passed a second argument to root.render(...) but it only accepts one argument."
              );
        args = children;
        var current = root.current,
          lane = requestUpdateLane(current);
        updateContainerImpl(current, lane, args, root, null, null);
      };
    ReactDOMHydrationRoot.prototype.unmount = ReactDOMRoot.prototype.unmount =
      function () {
        var args = arguments;
        "function" === typeof args[0] &&
          console.error(
            "does not support a callback argument. To execute a side effect after rendering, declare it in a component body with useEffect()."
          );
        args = this._internalRoot;
        if (null !== args) {
          this._internalRoot = null;
          var container = args.containerInfo;
          (executionContext & (RenderContext | CommitContext)) !== NoContext &&
            console.error(
              "Attempted to synchronously unmount a root while React was already rendering. React cannot finish unmounting the root until the current render has completed, which may lead to a race condition."
            );
          updateContainerImpl(args.current, 2, null, args, null, null);
          flushSyncWork$1();
          container[internalContainerInstanceKey] = null;
        }
      };
    ReactDOMHydrationRoot.prototype.unstable_scheduleHydration = function (
      target
    ) {
      if (target) {
        var updatePriority = resolveUpdatePriority();
        target = { blockedOn: null, target: target, priority: updatePriority };
        for (
          var i = 0;
          i < queuedExplicitHydrationTargets.length &&
          0 !== updatePriority &&
          updatePriority < queuedExplicitHydrationTargets[i].priority;
          i++
        );
        queuedExplicitHydrationTargets.splice(i, 0, target);
        0 === i && attemptExplicitHydrationTarget(target);
      }
    };
    (function () {
      var isomorphicReactPackageVersion = React.version;
      if ("19.2.3" !== isomorphicReactPackageVersion)
        throw Error(
          'Incompatible React versions: The "react" and "react-dom" packages must have the exact same version. Instead got:\n  - react:      ' +
            (isomorphicReactPackageVersion +
              "\n  - react-dom:  19.2.3\nLearn more: https://react.dev/warnings/version-mismatch")
        );
    })();
    ("function" === typeof Map &&
      null != Map.prototype &&
      "function" === typeof Map.prototype.forEach &&
      "function" === typeof Set &&
      null != Set.prototype &&
      "function" === typeof Set.prototype.clear &&
      "function" === typeof Set.prototype.forEach) ||
      console.error(
        "React depends on Map and Set built-in types. Make sure that you load a polyfill in older browsers. https://react.dev/link/react-polyfills"
      );
    ReactDOMSharedInternals.findDOMNode = function (componentOrElement) {
      var fiber = componentOrElement._reactInternals;
      if (void 0 === fiber) {
        if ("function" === typeof componentOrElement.render)
          throw Error("Unable to find node on an unmounted component.");
        componentOrElement = Object.keys(componentOrElement).join(",");
        throw Error(
          "Argument appears to not be a ReactComponent. Keys: " +
            componentOrElement
        );
      }
      componentOrElement = findCurrentFiberUsingSlowPath(fiber);
      componentOrElement =
        null !== componentOrElement
          ? findCurrentHostFiberImpl(componentOrElement)
          : null;
      componentOrElement =
        null === componentOrElement ? null : componentOrElement.stateNode;
      return componentOrElement;
    };
    if (
      !(function () {
        var internals = {
          bundleType: 1,
          version: "19.2.3",
          rendererPackageName: "react-dom",
          currentDispatcherRef: ReactSharedInternals,
          reconcilerVersion: "19.2.3"
        };
        internals.overrideHookState = overrideHookState;
        internals.overrideHookStateDeletePath = overrideHookStateDeletePath;
        internals.overrideHookStateRenamePath = overrideHookStateRenamePath;
        internals.overrideProps = overrideProps;
        internals.overridePropsDeletePath = overridePropsDeletePath;
        internals.overridePropsRenamePath = overridePropsRenamePath;
        internals.scheduleUpdate = scheduleUpdate;
        internals.scheduleRetry = scheduleRetry;
        internals.setErrorHandler = setErrorHandler;
        internals.setSuspenseHandler = setSuspenseHandler;
        internals.scheduleRefresh = scheduleRefresh;
        internals.scheduleRoot = scheduleRoot;
        internals.setRefreshHandler = setRefreshHandler;
        internals.getCurrentFiber = getCurrentFiberForDevTools;
        return injectInternals(internals);
      })() &&
      canUseDOM &&
      window.top === window.self &&
      ((-1 < navigator.userAgent.indexOf("Chrome") &&
        -1 === navigator.userAgent.indexOf("Edge")) ||
        -1 < navigator.userAgent.indexOf("Firefox"))
    ) {
      var protocol = window.location.protocol;
      /^(https?|file):$/.test(protocol) &&
        console.info(
          "%cDownload the React DevTools for a better development experience: https://react.dev/link/react-devtools" +
            ("file:" === protocol
              ? "\nYou might need to use a local HTTP server (instead of file://): https://react.dev/link/react-devtools-faq"
              : ""),
          "font-weight:bold"
        );
    }
    exports.createRoot = function (container, options) {
      if (!isValidContainer(container))
        throw Error("Target container is not a DOM element.");
      warnIfReactDOMContainerInDEV(container);
      var isStrictMode = !1,
        identifierPrefix = "",
        onUncaughtError = defaultOnUncaughtError,
        onCaughtError = defaultOnCaughtError,
        onRecoverableError = defaultOnRecoverableError;
      null !== options &&
        void 0 !== options &&
        (options.hydrate
          ? console.warn(
              "hydrate through createRoot is deprecated. Use ReactDOMClient.hydrateRoot(container, <App />) instead."
            )
          : "object" === typeof options &&
            null !== options &&
            options.$$typeof === REACT_ELEMENT_TYPE &&
            console.error(
              "You passed a JSX element to createRoot. You probably meant to call root.render instead. Example usage:\n\n  let root = createRoot(domContainer);\n  root.render(<App />);"
            ),
        !0 === options.unstable_strictMode && (isStrictMode = !0),
        void 0 !== options.identifierPrefix &&
          (identifierPrefix = options.identifierPrefix),
        void 0 !== options.onUncaughtError &&
          (onUncaughtError = options.onUncaughtError),
        void 0 !== options.onCaughtError &&
          (onCaughtError = options.onCaughtError),
        void 0 !== options.onRecoverableError &&
          (onRecoverableError = options.onRecoverableError));
      options = createFiberRoot(
        container,
        1,
        !1,
        null,
        null,
        isStrictMode,
        identifierPrefix,
        null,
        onUncaughtError,
        onCaughtError,
        onRecoverableError,
        defaultOnDefaultTransitionIndicator
      );
      container[internalContainerInstanceKey] = options.current;
      listenToAllSupportedEvents(container);
      return new ReactDOMRoot(options);
    };
    exports.hydrateRoot = function (container, initialChildren, options) {
      if (!isValidContainer(container))
        throw Error("Target container is not a DOM element.");
      warnIfReactDOMContainerInDEV(container);
      void 0 === initialChildren &&
        console.error(
          "Must provide initial children as second argument to hydrateRoot. Example usage: hydrateRoot(domContainer, <App />)"
        );
      var isStrictMode = !1,
        identifierPrefix = "",
        onUncaughtError = defaultOnUncaughtError,
        onCaughtError = defaultOnCaughtError,
        onRecoverableError = defaultOnRecoverableError,
        formState = null;
      null !== options &&
        void 0 !== options &&
        (!0 === options.unstable_strictMode && (isStrictMode = !0),
        void 0 !== options.identifierPrefix &&
          (identifierPrefix = options.identifierPrefix),
        void 0 !== options.onUncaughtError &&
          (onUncaughtError = options.onUncaughtError),
        void 0 !== options.onCaughtError &&
          (onCaughtError = options.onCaughtError),
        void 0 !== options.onRecoverableError &&
          (onRecoverableError = options.onRecoverableError),
        void 0 !== options.formState && (formState = options.formState));
      initialChildren = createFiberRoot(
        container,
        1,
        !0,
        initialChildren,
        null != options ? options : null,
        isStrictMode,
        identifierPrefix,
        formState,
        onUncaughtError,
        onCaughtError,
        onRecoverableError,
        defaultOnDefaultTransitionIndicator
      );
      initialChildren.context = getContextForSubtree(null);
      options = initialChildren.current;
      isStrictMode = requestUpdateLane(options);
      isStrictMode = getBumpedLaneForHydrationByLane(isStrictMode);
      identifierPrefix = createUpdate(isStrictMode);
      identifierPrefix.callback = null;
      enqueueUpdate(options, identifierPrefix, isStrictMode);
      startUpdateTimerByLane(isStrictMode, "hydrateRoot()", null);
      options = isStrictMode;
      initialChildren.current.lanes = options;
      markRootUpdated$1(initialChildren, options);
      ensureRootIsScheduled(initialChildren);
      container[internalContainerInstanceKey] = initialChildren.current;
      listenToAllSupportedEvents(container);
      return new ReactDOMHydrationRoot(initialChildren);
    };
    exports.version = "19.2.3";
    "undefined" !== typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ &&
      "function" ===
        typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStop &&
      __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStop(Error());
  })();


/***/ },

/***/ "./node_modules/react-dom/cjs/react-dom.development.js"
/*!*************************************************************!*\
  !*** ./node_modules/react-dom/cjs/react-dom.development.js ***!
  \*************************************************************/
(__unused_webpack_module, exports, __webpack_require__) {

/**
 * @license React
 * react-dom.development.js
 *
 * Copyright (c) Meta Platforms, Inc. and affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */


 true &&
  (function () {
    function noop() {}
    function testStringCoercion(value) {
      return "" + value;
    }
    function createPortal$1(children, containerInfo, implementation) {
      var key =
        3 < arguments.length && void 0 !== arguments[3] ? arguments[3] : null;
      try {
        testStringCoercion(key);
        var JSCompiler_inline_result = !1;
      } catch (e) {
        JSCompiler_inline_result = !0;
      }
      JSCompiler_inline_result &&
        (console.error(
          "The provided key is an unsupported type %s. This value must be coerced to a string before using it here.",
          ("function" === typeof Symbol &&
            Symbol.toStringTag &&
            key[Symbol.toStringTag]) ||
            key.constructor.name ||
            "Object"
        ),
        testStringCoercion(key));
      return {
        $$typeof: REACT_PORTAL_TYPE,
        key: null == key ? null : "" + key,
        children: children,
        containerInfo: containerInfo,
        implementation: implementation
      };
    }
    function getCrossOriginStringAs(as, input) {
      if ("font" === as) return "";
      if ("string" === typeof input)
        return "use-credentials" === input ? input : "";
    }
    function getValueDescriptorExpectingObjectForWarning(thing) {
      return null === thing
        ? "`null`"
        : void 0 === thing
          ? "`undefined`"
          : "" === thing
            ? "an empty string"
            : 'something with type "' + typeof thing + '"';
    }
    function getValueDescriptorExpectingEnumForWarning(thing) {
      return null === thing
        ? "`null`"
        : void 0 === thing
          ? "`undefined`"
          : "" === thing
            ? "an empty string"
            : "string" === typeof thing
              ? JSON.stringify(thing)
              : "number" === typeof thing
                ? "`" + thing + "`"
                : 'something with type "' + typeof thing + '"';
    }
    function resolveDispatcher() {
      var dispatcher = ReactSharedInternals.H;
      null === dispatcher &&
        console.error(
          "Invalid hook call. Hooks can only be called inside of the body of a function component. This could happen for one of the following reasons:\n1. You might have mismatching versions of React and the renderer (such as React DOM)\n2. You might be breaking the Rules of Hooks\n3. You might have more than one copy of React in the same app\nSee https://react.dev/link/invalid-hook-call for tips about how to debug and fix this problem."
        );
      return dispatcher;
    }
    "undefined" !== typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ &&
      "function" ===
        typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStart &&
      __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStart(Error());
    var React = __webpack_require__(/*! react */ "./node_modules/react/index.js"),
      Internals = {
        d: {
          f: noop,
          r: function () {
            throw Error(
              "Invalid form element. requestFormReset must be passed a form that was rendered by React."
            );
          },
          D: noop,
          C: noop,
          L: noop,
          m: noop,
          X: noop,
          S: noop,
          M: noop
        },
        p: 0,
        findDOMNode: null
      },
      REACT_PORTAL_TYPE = Symbol.for("react.portal"),
      ReactSharedInternals =
        React.__CLIENT_INTERNALS_DO_NOT_USE_OR_WARN_USERS_THEY_CANNOT_UPGRADE;
    ("function" === typeof Map &&
      null != Map.prototype &&
      "function" === typeof Map.prototype.forEach &&
      "function" === typeof Set &&
      null != Set.prototype &&
      "function" === typeof Set.prototype.clear &&
      "function" === typeof Set.prototype.forEach) ||
      console.error(
        "React depends on Map and Set built-in types. Make sure that you load a polyfill in older browsers. https://reactjs.org/link/react-polyfills"
      );
    exports.__DOM_INTERNALS_DO_NOT_USE_OR_WARN_USERS_THEY_CANNOT_UPGRADE =
      Internals;
    exports.createPortal = function (children, container) {
      var key =
        2 < arguments.length && void 0 !== arguments[2] ? arguments[2] : null;
      if (
        !container ||
        (1 !== container.nodeType &&
          9 !== container.nodeType &&
          11 !== container.nodeType)
      )
        throw Error("Target container is not a DOM element.");
      return createPortal$1(children, container, null, key);
    };
    exports.flushSync = function (fn) {
      var previousTransition = ReactSharedInternals.T,
        previousUpdatePriority = Internals.p;
      try {
        if (((ReactSharedInternals.T = null), (Internals.p = 2), fn))
          return fn();
      } finally {
        (ReactSharedInternals.T = previousTransition),
          (Internals.p = previousUpdatePriority),
          Internals.d.f() &&
            console.error(
              "flushSync was called from inside a lifecycle method. React cannot flush when React is already rendering. Consider moving this call to a scheduler task or micro task."
            );
      }
    };
    exports.preconnect = function (href, options) {
      "string" === typeof href && href
        ? null != options && "object" !== typeof options
          ? console.error(
              "ReactDOM.preconnect(): Expected the `options` argument (second) to be an object but encountered %s instead. The only supported option at this time is `crossOrigin` which accepts a string.",
              getValueDescriptorExpectingEnumForWarning(options)
            )
          : null != options &&
            "string" !== typeof options.crossOrigin &&
            console.error(
              "ReactDOM.preconnect(): Expected the `crossOrigin` option (second argument) to be a string but encountered %s instead. Try removing this option or passing a string value instead.",
              getValueDescriptorExpectingObjectForWarning(options.crossOrigin)
            )
        : console.error(
            "ReactDOM.preconnect(): Expected the `href` argument (first) to be a non-empty string but encountered %s instead.",
            getValueDescriptorExpectingObjectForWarning(href)
          );
      "string" === typeof href &&
        (options
          ? ((options = options.crossOrigin),
            (options =
              "string" === typeof options
                ? "use-credentials" === options
                  ? options
                  : ""
                : void 0))
          : (options = null),
        Internals.d.C(href, options));
    };
    exports.prefetchDNS = function (href) {
      if ("string" !== typeof href || !href)
        console.error(
          "ReactDOM.prefetchDNS(): Expected the `href` argument (first) to be a non-empty string but encountered %s instead.",
          getValueDescriptorExpectingObjectForWarning(href)
        );
      else if (1 < arguments.length) {
        var options = arguments[1];
        "object" === typeof options && options.hasOwnProperty("crossOrigin")
          ? console.error(
              "ReactDOM.prefetchDNS(): Expected only one argument, `href`, but encountered %s as a second argument instead. This argument is reserved for future options and is currently disallowed. It looks like the you are attempting to set a crossOrigin property for this DNS lookup hint. Browsers do not perform DNS queries using CORS and setting this attribute on the resource hint has no effect. Try calling ReactDOM.prefetchDNS() with just a single string argument, `href`.",
              getValueDescriptorExpectingEnumForWarning(options)
            )
          : console.error(
              "ReactDOM.prefetchDNS(): Expected only one argument, `href`, but encountered %s as a second argument instead. This argument is reserved for future options and is currently disallowed. Try calling ReactDOM.prefetchDNS() with just a single string argument, `href`.",
              getValueDescriptorExpectingEnumForWarning(options)
            );
      }
      "string" === typeof href && Internals.d.D(href);
    };
    exports.preinit = function (href, options) {
      "string" === typeof href && href
        ? null == options || "object" !== typeof options
          ? console.error(
              "ReactDOM.preinit(): Expected the `options` argument (second) to be an object with an `as` property describing the type of resource to be preinitialized but encountered %s instead.",
              getValueDescriptorExpectingEnumForWarning(options)
            )
          : "style" !== options.as &&
            "script" !== options.as &&
            console.error(
              'ReactDOM.preinit(): Expected the `as` property in the `options` argument (second) to contain a valid value describing the type of resource to be preinitialized but encountered %s instead. Valid values for `as` are "style" and "script".',
              getValueDescriptorExpectingEnumForWarning(options.as)
            )
        : console.error(
            "ReactDOM.preinit(): Expected the `href` argument (first) to be a non-empty string but encountered %s instead.",
            getValueDescriptorExpectingObjectForWarning(href)
          );
      if (
        "string" === typeof href &&
        options &&
        "string" === typeof options.as
      ) {
        var as = options.as,
          crossOrigin = getCrossOriginStringAs(as, options.crossOrigin),
          integrity =
            "string" === typeof options.integrity ? options.integrity : void 0,
          fetchPriority =
            "string" === typeof options.fetchPriority
              ? options.fetchPriority
              : void 0;
        "style" === as
          ? Internals.d.S(
              href,
              "string" === typeof options.precedence
                ? options.precedence
                : void 0,
              {
                crossOrigin: crossOrigin,
                integrity: integrity,
                fetchPriority: fetchPriority
              }
            )
          : "script" === as &&
            Internals.d.X(href, {
              crossOrigin: crossOrigin,
              integrity: integrity,
              fetchPriority: fetchPriority,
              nonce: "string" === typeof options.nonce ? options.nonce : void 0
            });
      }
    };
    exports.preinitModule = function (href, options) {
      var encountered = "";
      ("string" === typeof href && href) ||
        (encountered +=
          " The `href` argument encountered was " +
          getValueDescriptorExpectingObjectForWarning(href) +
          ".");
      void 0 !== options && "object" !== typeof options
        ? (encountered +=
            " The `options` argument encountered was " +
            getValueDescriptorExpectingObjectForWarning(options) +
            ".")
        : options &&
          "as" in options &&
          "script" !== options.as &&
          (encountered +=
            " The `as` option encountered was " +
            getValueDescriptorExpectingEnumForWarning(options.as) +
            ".");
      if (encountered)
        console.error(
          "ReactDOM.preinitModule(): Expected up to two arguments, a non-empty `href` string and, optionally, an `options` object with a valid `as` property.%s",
          encountered
        );
      else
        switch (
          ((encountered =
            options && "string" === typeof options.as ? options.as : "script"),
          encountered)
        ) {
          case "script":
            break;
          default:
            (encountered =
              getValueDescriptorExpectingEnumForWarning(encountered)),
              console.error(
                'ReactDOM.preinitModule(): Currently the only supported "as" type for this function is "script" but received "%s" instead. This warning was generated for `href` "%s". In the future other module types will be supported, aligning with the import-attributes proposal. Learn more here: (https://github.com/tc39/proposal-import-attributes)',
                encountered,
                href
              );
        }
      if ("string" === typeof href)
        if ("object" === typeof options && null !== options) {
          if (null == options.as || "script" === options.as)
            (encountered = getCrossOriginStringAs(
              options.as,
              options.crossOrigin
            )),
              Internals.d.M(href, {
                crossOrigin: encountered,
                integrity:
                  "string" === typeof options.integrity
                    ? options.integrity
                    : void 0,
                nonce:
                  "string" === typeof options.nonce ? options.nonce : void 0
              });
        } else null == options && Internals.d.M(href);
    };
    exports.preload = function (href, options) {
      var encountered = "";
      ("string" === typeof href && href) ||
        (encountered +=
          " The `href` argument encountered was " +
          getValueDescriptorExpectingObjectForWarning(href) +
          ".");
      null == options || "object" !== typeof options
        ? (encountered +=
            " The `options` argument encountered was " +
            getValueDescriptorExpectingObjectForWarning(options) +
            ".")
        : ("string" === typeof options.as && options.as) ||
          (encountered +=
            " The `as` option encountered was " +
            getValueDescriptorExpectingObjectForWarning(options.as) +
            ".");
      encountered &&
        console.error(
          'ReactDOM.preload(): Expected two arguments, a non-empty `href` string and an `options` object with an `as` property valid for a `<link rel="preload" as="..." />` tag.%s',
          encountered
        );
      if (
        "string" === typeof href &&
        "object" === typeof options &&
        null !== options &&
        "string" === typeof options.as
      ) {
        encountered = options.as;
        var crossOrigin = getCrossOriginStringAs(
          encountered,
          options.crossOrigin
        );
        Internals.d.L(href, encountered, {
          crossOrigin: crossOrigin,
          integrity:
            "string" === typeof options.integrity ? options.integrity : void 0,
          nonce: "string" === typeof options.nonce ? options.nonce : void 0,
          type: "string" === typeof options.type ? options.type : void 0,
          fetchPriority:
            "string" === typeof options.fetchPriority
              ? options.fetchPriority
              : void 0,
          referrerPolicy:
            "string" === typeof options.referrerPolicy
              ? options.referrerPolicy
              : void 0,
          imageSrcSet:
            "string" === typeof options.imageSrcSet
              ? options.imageSrcSet
              : void 0,
          imageSizes:
            "string" === typeof options.imageSizes
              ? options.imageSizes
              : void 0,
          media: "string" === typeof options.media ? options.media : void 0
        });
      }
    };
    exports.preloadModule = function (href, options) {
      var encountered = "";
      ("string" === typeof href && href) ||
        (encountered +=
          " The `href` argument encountered was " +
          getValueDescriptorExpectingObjectForWarning(href) +
          ".");
      void 0 !== options && "object" !== typeof options
        ? (encountered +=
            " The `options` argument encountered was " +
            getValueDescriptorExpectingObjectForWarning(options) +
            ".")
        : options &&
          "as" in options &&
          "string" !== typeof options.as &&
          (encountered +=
            " The `as` option encountered was " +
            getValueDescriptorExpectingObjectForWarning(options.as) +
            ".");
      encountered &&
        console.error(
          'ReactDOM.preloadModule(): Expected two arguments, a non-empty `href` string and, optionally, an `options` object with an `as` property valid for a `<link rel="modulepreload" as="..." />` tag.%s',
          encountered
        );
      "string" === typeof href &&
        (options
          ? ((encountered = getCrossOriginStringAs(
              options.as,
              options.crossOrigin
            )),
            Internals.d.m(href, {
              as:
                "string" === typeof options.as && "script" !== options.as
                  ? options.as
                  : void 0,
              crossOrigin: encountered,
              integrity:
                "string" === typeof options.integrity
                  ? options.integrity
                  : void 0
            }))
          : Internals.d.m(href));
    };
    exports.requestFormReset = function (form) {
      Internals.d.r(form);
    };
    exports.unstable_batchedUpdates = function (fn, a) {
      return fn(a);
    };
    exports.useFormState = function (action, initialState, permalink) {
      return resolveDispatcher().useFormState(action, initialState, permalink);
    };
    exports.useFormStatus = function () {
      return resolveDispatcher().useHostTransitionStatus();
    };
    exports.version = "19.2.3";
    "undefined" !== typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ &&
      "function" ===
        typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStop &&
      __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStop(Error());
  })();


/***/ },

/***/ "./node_modules/react-dom/client.js"
/*!******************************************!*\
  !*** ./node_modules/react-dom/client.js ***!
  \******************************************/
(module, __unused_webpack_exports, __webpack_require__) {



function checkDCE() {
  /* global __REACT_DEVTOOLS_GLOBAL_HOOK__ */
  if (
    typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ === 'undefined' ||
    typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.checkDCE !== 'function'
  ) {
    return;
  }
  if (true) {
    // This branch is unreachable because this function is only called
    // in production, but the condition is true only in development.
    // Therefore if the branch is still here, dead code elimination wasn't
    // properly applied.
    // Don't change the message. React DevTools relies on it. Also make sure
    // this message doesn't occur elsewhere in this function, or it will cause
    // a false positive.
    throw new Error('^_^');
  }
  // removed by dead control flow

}

if (false) // removed by dead control flow
{} else {
  module.exports = __webpack_require__(/*! ./cjs/react-dom-client.development.js */ "./node_modules/react-dom/cjs/react-dom-client.development.js");
}


/***/ },

/***/ "./node_modules/react-dom/index.js"
/*!*****************************************!*\
  !*** ./node_modules/react-dom/index.js ***!
  \*****************************************/
(module, __unused_webpack_exports, __webpack_require__) {



function checkDCE() {
  /* global __REACT_DEVTOOLS_GLOBAL_HOOK__ */
  if (
    typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ === 'undefined' ||
    typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.checkDCE !== 'function'
  ) {
    return;
  }
  if (true) {
    // This branch is unreachable because this function is only called
    // in production, but the condition is true only in development.
    // Therefore if the branch is still here, dead code elimination wasn't
    // properly applied.
    // Don't change the message. React DevTools relies on it. Also make sure
    // this message doesn't occur elsewhere in this function, or it will cause
    // a false positive.
    throw new Error('^_^');
  }
  // removed by dead control flow

}

if (false) // removed by dead control flow
{} else {
  module.exports = __webpack_require__(/*! ./cjs/react-dom.development.js */ "./node_modules/react-dom/cjs/react-dom.development.js");
}


/***/ },

/***/ "./node_modules/react/cjs/react-jsx-runtime.development.js"
/*!*****************************************************************!*\
  !*** ./node_modules/react/cjs/react-jsx-runtime.development.js ***!
  \*****************************************************************/
(__unused_webpack_module, exports, __webpack_require__) {

/**
 * @license React
 * react-jsx-runtime.development.js
 *
 * Copyright (c) Meta Platforms, Inc. and affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */


 true &&
  (function () {
    function getComponentNameFromType(type) {
      if (null == type) return null;
      if ("function" === typeof type)
        return type.$$typeof === REACT_CLIENT_REFERENCE
          ? null
          : type.displayName || type.name || null;
      if ("string" === typeof type) return type;
      switch (type) {
        case REACT_FRAGMENT_TYPE:
          return "Fragment";
        case REACT_PROFILER_TYPE:
          return "Profiler";
        case REACT_STRICT_MODE_TYPE:
          return "StrictMode";
        case REACT_SUSPENSE_TYPE:
          return "Suspense";
        case REACT_SUSPENSE_LIST_TYPE:
          return "SuspenseList";
        case REACT_ACTIVITY_TYPE:
          return "Activity";
      }
      if ("object" === typeof type)
        switch (
          ("number" === typeof type.tag &&
            console.error(
              "Received an unexpected object in getComponentNameFromType(). This is likely a bug in React. Please file an issue."
            ),
          type.$$typeof)
        ) {
          case REACT_PORTAL_TYPE:
            return "Portal";
          case REACT_CONTEXT_TYPE:
            return type.displayName || "Context";
          case REACT_CONSUMER_TYPE:
            return (type._context.displayName || "Context") + ".Consumer";
          case REACT_FORWARD_REF_TYPE:
            var innerType = type.render;
            type = type.displayName;
            type ||
              ((type = innerType.displayName || innerType.name || ""),
              (type = "" !== type ? "ForwardRef(" + type + ")" : "ForwardRef"));
            return type;
          case REACT_MEMO_TYPE:
            return (
              (innerType = type.displayName || null),
              null !== innerType
                ? innerType
                : getComponentNameFromType(type.type) || "Memo"
            );
          case REACT_LAZY_TYPE:
            innerType = type._payload;
            type = type._init;
            try {
              return getComponentNameFromType(type(innerType));
            } catch (x) {}
        }
      return null;
    }
    function testStringCoercion(value) {
      return "" + value;
    }
    function checkKeyStringCoercion(value) {
      try {
        testStringCoercion(value);
        var JSCompiler_inline_result = !1;
      } catch (e) {
        JSCompiler_inline_result = !0;
      }
      if (JSCompiler_inline_result) {
        JSCompiler_inline_result = console;
        var JSCompiler_temp_const = JSCompiler_inline_result.error;
        var JSCompiler_inline_result$jscomp$0 =
          ("function" === typeof Symbol &&
            Symbol.toStringTag &&
            value[Symbol.toStringTag]) ||
          value.constructor.name ||
          "Object";
        JSCompiler_temp_const.call(
          JSCompiler_inline_result,
          "The provided key is an unsupported type %s. This value must be coerced to a string before using it here.",
          JSCompiler_inline_result$jscomp$0
        );
        return testStringCoercion(value);
      }
    }
    function getTaskName(type) {
      if (type === REACT_FRAGMENT_TYPE) return "<>";
      if (
        "object" === typeof type &&
        null !== type &&
        type.$$typeof === REACT_LAZY_TYPE
      )
        return "<...>";
      try {
        var name = getComponentNameFromType(type);
        return name ? "<" + name + ">" : "<...>";
      } catch (x) {
        return "<...>";
      }
    }
    function getOwner() {
      var dispatcher = ReactSharedInternals.A;
      return null === dispatcher ? null : dispatcher.getOwner();
    }
    function UnknownOwner() {
      return Error("react-stack-top-frame");
    }
    function hasValidKey(config) {
      if (hasOwnProperty.call(config, "key")) {
        var getter = Object.getOwnPropertyDescriptor(config, "key").get;
        if (getter && getter.isReactWarning) return !1;
      }
      return void 0 !== config.key;
    }
    function defineKeyPropWarningGetter(props, displayName) {
      function warnAboutAccessingKey() {
        specialPropKeyWarningShown ||
          ((specialPropKeyWarningShown = !0),
          console.error(
            "%s: `key` is not a prop. Trying to access it will result in `undefined` being returned. If you need to access the same value within the child component, you should pass it as a different prop. (https://react.dev/link/special-props)",
            displayName
          ));
      }
      warnAboutAccessingKey.isReactWarning = !0;
      Object.defineProperty(props, "key", {
        get: warnAboutAccessingKey,
        configurable: !0
      });
    }
    function elementRefGetterWithDeprecationWarning() {
      var componentName = getComponentNameFromType(this.type);
      didWarnAboutElementRef[componentName] ||
        ((didWarnAboutElementRef[componentName] = !0),
        console.error(
          "Accessing element.ref was removed in React 19. ref is now a regular prop. It will be removed from the JSX Element type in a future release."
        ));
      componentName = this.props.ref;
      return void 0 !== componentName ? componentName : null;
    }
    function ReactElement(type, key, props, owner, debugStack, debugTask) {
      var refProp = props.ref;
      type = {
        $$typeof: REACT_ELEMENT_TYPE,
        type: type,
        key: key,
        props: props,
        _owner: owner
      };
      null !== (void 0 !== refProp ? refProp : null)
        ? Object.defineProperty(type, "ref", {
            enumerable: !1,
            get: elementRefGetterWithDeprecationWarning
          })
        : Object.defineProperty(type, "ref", { enumerable: !1, value: null });
      type._store = {};
      Object.defineProperty(type._store, "validated", {
        configurable: !1,
        enumerable: !1,
        writable: !0,
        value: 0
      });
      Object.defineProperty(type, "_debugInfo", {
        configurable: !1,
        enumerable: !1,
        writable: !0,
        value: null
      });
      Object.defineProperty(type, "_debugStack", {
        configurable: !1,
        enumerable: !1,
        writable: !0,
        value: debugStack
      });
      Object.defineProperty(type, "_debugTask", {
        configurable: !1,
        enumerable: !1,
        writable: !0,
        value: debugTask
      });
      Object.freeze && (Object.freeze(type.props), Object.freeze(type));
      return type;
    }
    function jsxDEVImpl(
      type,
      config,
      maybeKey,
      isStaticChildren,
      debugStack,
      debugTask
    ) {
      var children = config.children;
      if (void 0 !== children)
        if (isStaticChildren)
          if (isArrayImpl(children)) {
            for (
              isStaticChildren = 0;
              isStaticChildren < children.length;
              isStaticChildren++
            )
              validateChildKeys(children[isStaticChildren]);
            Object.freeze && Object.freeze(children);
          } else
            console.error(
              "React.jsx: Static children should always be an array. You are likely explicitly calling React.jsxs or React.jsxDEV. Use the Babel transform instead."
            );
        else validateChildKeys(children);
      if (hasOwnProperty.call(config, "key")) {
        children = getComponentNameFromType(type);
        var keys = Object.keys(config).filter(function (k) {
          return "key" !== k;
        });
        isStaticChildren =
          0 < keys.length
            ? "{key: someKey, " + keys.join(": ..., ") + ": ...}"
            : "{key: someKey}";
        didWarnAboutKeySpread[children + isStaticChildren] ||
          ((keys =
            0 < keys.length ? "{" + keys.join(": ..., ") + ": ...}" : "{}"),
          console.error(
            'A props object containing a "key" prop is being spread into JSX:\n  let props = %s;\n  <%s {...props} />\nReact keys must be passed directly to JSX without using spread:\n  let props = %s;\n  <%s key={someKey} {...props} />',
            isStaticChildren,
            children,
            keys,
            children
          ),
          (didWarnAboutKeySpread[children + isStaticChildren] = !0));
      }
      children = null;
      void 0 !== maybeKey &&
        (checkKeyStringCoercion(maybeKey), (children = "" + maybeKey));
      hasValidKey(config) &&
        (checkKeyStringCoercion(config.key), (children = "" + config.key));
      if ("key" in config) {
        maybeKey = {};
        for (var propName in config)
          "key" !== propName && (maybeKey[propName] = config[propName]);
      } else maybeKey = config;
      children &&
        defineKeyPropWarningGetter(
          maybeKey,
          "function" === typeof type
            ? type.displayName || type.name || "Unknown"
            : type
        );
      return ReactElement(
        type,
        children,
        maybeKey,
        getOwner(),
        debugStack,
        debugTask
      );
    }
    function validateChildKeys(node) {
      isValidElement(node)
        ? node._store && (node._store.validated = 1)
        : "object" === typeof node &&
          null !== node &&
          node.$$typeof === REACT_LAZY_TYPE &&
          ("fulfilled" === node._payload.status
            ? isValidElement(node._payload.value) &&
              node._payload.value._store &&
              (node._payload.value._store.validated = 1)
            : node._store && (node._store.validated = 1));
    }
    function isValidElement(object) {
      return (
        "object" === typeof object &&
        null !== object &&
        object.$$typeof === REACT_ELEMENT_TYPE
      );
    }
    var React = __webpack_require__(/*! react */ "./node_modules/react/index.js"),
      REACT_ELEMENT_TYPE = Symbol.for("react.transitional.element"),
      REACT_PORTAL_TYPE = Symbol.for("react.portal"),
      REACT_FRAGMENT_TYPE = Symbol.for("react.fragment"),
      REACT_STRICT_MODE_TYPE = Symbol.for("react.strict_mode"),
      REACT_PROFILER_TYPE = Symbol.for("react.profiler"),
      REACT_CONSUMER_TYPE = Symbol.for("react.consumer"),
      REACT_CONTEXT_TYPE = Symbol.for("react.context"),
      REACT_FORWARD_REF_TYPE = Symbol.for("react.forward_ref"),
      REACT_SUSPENSE_TYPE = Symbol.for("react.suspense"),
      REACT_SUSPENSE_LIST_TYPE = Symbol.for("react.suspense_list"),
      REACT_MEMO_TYPE = Symbol.for("react.memo"),
      REACT_LAZY_TYPE = Symbol.for("react.lazy"),
      REACT_ACTIVITY_TYPE = Symbol.for("react.activity"),
      REACT_CLIENT_REFERENCE = Symbol.for("react.client.reference"),
      ReactSharedInternals =
        React.__CLIENT_INTERNALS_DO_NOT_USE_OR_WARN_USERS_THEY_CANNOT_UPGRADE,
      hasOwnProperty = Object.prototype.hasOwnProperty,
      isArrayImpl = Array.isArray,
      createTask = console.createTask
        ? console.createTask
        : function () {
            return null;
          };
    React = {
      react_stack_bottom_frame: function (callStackForError) {
        return callStackForError();
      }
    };
    var specialPropKeyWarningShown;
    var didWarnAboutElementRef = {};
    var unknownOwnerDebugStack = React.react_stack_bottom_frame.bind(
      React,
      UnknownOwner
    )();
    var unknownOwnerDebugTask = createTask(getTaskName(UnknownOwner));
    var didWarnAboutKeySpread = {};
    exports.Fragment = REACT_FRAGMENT_TYPE;
    exports.jsx = function (type, config, maybeKey) {
      var trackActualOwner =
        1e4 > ReactSharedInternals.recentlyCreatedOwnerStacks++;
      return jsxDEVImpl(
        type,
        config,
        maybeKey,
        !1,
        trackActualOwner
          ? Error("react-stack-top-frame")
          : unknownOwnerDebugStack,
        trackActualOwner ? createTask(getTaskName(type)) : unknownOwnerDebugTask
      );
    };
    exports.jsxs = function (type, config, maybeKey) {
      var trackActualOwner =
        1e4 > ReactSharedInternals.recentlyCreatedOwnerStacks++;
      return jsxDEVImpl(
        type,
        config,
        maybeKey,
        !0,
        trackActualOwner
          ? Error("react-stack-top-frame")
          : unknownOwnerDebugStack,
        trackActualOwner ? createTask(getTaskName(type)) : unknownOwnerDebugTask
      );
    };
  })();


/***/ },

/***/ "./node_modules/react/cjs/react.development.js"
/*!*****************************************************!*\
  !*** ./node_modules/react/cjs/react.development.js ***!
  \*****************************************************/
(module, exports, __webpack_require__) {

/* module decorator */ module = __webpack_require__.nmd(module);
/**
 * @license React
 * react.development.js
 *
 * Copyright (c) Meta Platforms, Inc. and affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */


 true &&
  (function () {
    function defineDeprecationWarning(methodName, info) {
      Object.defineProperty(Component.prototype, methodName, {
        get: function () {
          console.warn(
            "%s(...) is deprecated in plain JavaScript React classes. %s",
            info[0],
            info[1]
          );
        }
      });
    }
    function getIteratorFn(maybeIterable) {
      if (null === maybeIterable || "object" !== typeof maybeIterable)
        return null;
      maybeIterable =
        (MAYBE_ITERATOR_SYMBOL && maybeIterable[MAYBE_ITERATOR_SYMBOL]) ||
        maybeIterable["@@iterator"];
      return "function" === typeof maybeIterable ? maybeIterable : null;
    }
    function warnNoop(publicInstance, callerName) {
      publicInstance =
        ((publicInstance = publicInstance.constructor) &&
          (publicInstance.displayName || publicInstance.name)) ||
        "ReactClass";
      var warningKey = publicInstance + "." + callerName;
      didWarnStateUpdateForUnmountedComponent[warningKey] ||
        (console.error(
          "Can't call %s on a component that is not yet mounted. This is a no-op, but it might indicate a bug in your application. Instead, assign to `this.state` directly or define a `state = {};` class property with the desired state in the %s component.",
          callerName,
          publicInstance
        ),
        (didWarnStateUpdateForUnmountedComponent[warningKey] = !0));
    }
    function Component(props, context, updater) {
      this.props = props;
      this.context = context;
      this.refs = emptyObject;
      this.updater = updater || ReactNoopUpdateQueue;
    }
    function ComponentDummy() {}
    function PureComponent(props, context, updater) {
      this.props = props;
      this.context = context;
      this.refs = emptyObject;
      this.updater = updater || ReactNoopUpdateQueue;
    }
    function noop() {}
    function testStringCoercion(value) {
      return "" + value;
    }
    function checkKeyStringCoercion(value) {
      try {
        testStringCoercion(value);
        var JSCompiler_inline_result = !1;
      } catch (e) {
        JSCompiler_inline_result = !0;
      }
      if (JSCompiler_inline_result) {
        JSCompiler_inline_result = console;
        var JSCompiler_temp_const = JSCompiler_inline_result.error;
        var JSCompiler_inline_result$jscomp$0 =
          ("function" === typeof Symbol &&
            Symbol.toStringTag &&
            value[Symbol.toStringTag]) ||
          value.constructor.name ||
          "Object";
        JSCompiler_temp_const.call(
          JSCompiler_inline_result,
          "The provided key is an unsupported type %s. This value must be coerced to a string before using it here.",
          JSCompiler_inline_result$jscomp$0
        );
        return testStringCoercion(value);
      }
    }
    function getComponentNameFromType(type) {
      if (null == type) return null;
      if ("function" === typeof type)
        return type.$$typeof === REACT_CLIENT_REFERENCE
          ? null
          : type.displayName || type.name || null;
      if ("string" === typeof type) return type;
      switch (type) {
        case REACT_FRAGMENT_TYPE:
          return "Fragment";
        case REACT_PROFILER_TYPE:
          return "Profiler";
        case REACT_STRICT_MODE_TYPE:
          return "StrictMode";
        case REACT_SUSPENSE_TYPE:
          return "Suspense";
        case REACT_SUSPENSE_LIST_TYPE:
          return "SuspenseList";
        case REACT_ACTIVITY_TYPE:
          return "Activity";
      }
      if ("object" === typeof type)
        switch (
          ("number" === typeof type.tag &&
            console.error(
              "Received an unexpected object in getComponentNameFromType(). This is likely a bug in React. Please file an issue."
            ),
          type.$$typeof)
        ) {
          case REACT_PORTAL_TYPE:
            return "Portal";
          case REACT_CONTEXT_TYPE:
            return type.displayName || "Context";
          case REACT_CONSUMER_TYPE:
            return (type._context.displayName || "Context") + ".Consumer";
          case REACT_FORWARD_REF_TYPE:
            var innerType = type.render;
            type = type.displayName;
            type ||
              ((type = innerType.displayName || innerType.name || ""),
              (type = "" !== type ? "ForwardRef(" + type + ")" : "ForwardRef"));
            return type;
          case REACT_MEMO_TYPE:
            return (
              (innerType = type.displayName || null),
              null !== innerType
                ? innerType
                : getComponentNameFromType(type.type) || "Memo"
            );
          case REACT_LAZY_TYPE:
            innerType = type._payload;
            type = type._init;
            try {
              return getComponentNameFromType(type(innerType));
            } catch (x) {}
        }
      return null;
    }
    function getTaskName(type) {
      if (type === REACT_FRAGMENT_TYPE) return "<>";
      if (
        "object" === typeof type &&
        null !== type &&
        type.$$typeof === REACT_LAZY_TYPE
      )
        return "<...>";
      try {
        var name = getComponentNameFromType(type);
        return name ? "<" + name + ">" : "<...>";
      } catch (x) {
        return "<...>";
      }
    }
    function getOwner() {
      var dispatcher = ReactSharedInternals.A;
      return null === dispatcher ? null : dispatcher.getOwner();
    }
    function UnknownOwner() {
      return Error("react-stack-top-frame");
    }
    function hasValidKey(config) {
      if (hasOwnProperty.call(config, "key")) {
        var getter = Object.getOwnPropertyDescriptor(config, "key").get;
        if (getter && getter.isReactWarning) return !1;
      }
      return void 0 !== config.key;
    }
    function defineKeyPropWarningGetter(props, displayName) {
      function warnAboutAccessingKey() {
        specialPropKeyWarningShown ||
          ((specialPropKeyWarningShown = !0),
          console.error(
            "%s: `key` is not a prop. Trying to access it will result in `undefined` being returned. If you need to access the same value within the child component, you should pass it as a different prop. (https://react.dev/link/special-props)",
            displayName
          ));
      }
      warnAboutAccessingKey.isReactWarning = !0;
      Object.defineProperty(props, "key", {
        get: warnAboutAccessingKey,
        configurable: !0
      });
    }
    function elementRefGetterWithDeprecationWarning() {
      var componentName = getComponentNameFromType(this.type);
      didWarnAboutElementRef[componentName] ||
        ((didWarnAboutElementRef[componentName] = !0),
        console.error(
          "Accessing element.ref was removed in React 19. ref is now a regular prop. It will be removed from the JSX Element type in a future release."
        ));
      componentName = this.props.ref;
      return void 0 !== componentName ? componentName : null;
    }
    function ReactElement(type, key, props, owner, debugStack, debugTask) {
      var refProp = props.ref;
      type = {
        $$typeof: REACT_ELEMENT_TYPE,
        type: type,
        key: key,
        props: props,
        _owner: owner
      };
      null !== (void 0 !== refProp ? refProp : null)
        ? Object.defineProperty(type, "ref", {
            enumerable: !1,
            get: elementRefGetterWithDeprecationWarning
          })
        : Object.defineProperty(type, "ref", { enumerable: !1, value: null });
      type._store = {};
      Object.defineProperty(type._store, "validated", {
        configurable: !1,
        enumerable: !1,
        writable: !0,
        value: 0
      });
      Object.defineProperty(type, "_debugInfo", {
        configurable: !1,
        enumerable: !1,
        writable: !0,
        value: null
      });
      Object.defineProperty(type, "_debugStack", {
        configurable: !1,
        enumerable: !1,
        writable: !0,
        value: debugStack
      });
      Object.defineProperty(type, "_debugTask", {
        configurable: !1,
        enumerable: !1,
        writable: !0,
        value: debugTask
      });
      Object.freeze && (Object.freeze(type.props), Object.freeze(type));
      return type;
    }
    function cloneAndReplaceKey(oldElement, newKey) {
      newKey = ReactElement(
        oldElement.type,
        newKey,
        oldElement.props,
        oldElement._owner,
        oldElement._debugStack,
        oldElement._debugTask
      );
      oldElement._store &&
        (newKey._store.validated = oldElement._store.validated);
      return newKey;
    }
    function validateChildKeys(node) {
      isValidElement(node)
        ? node._store && (node._store.validated = 1)
        : "object" === typeof node &&
          null !== node &&
          node.$$typeof === REACT_LAZY_TYPE &&
          ("fulfilled" === node._payload.status
            ? isValidElement(node._payload.value) &&
              node._payload.value._store &&
              (node._payload.value._store.validated = 1)
            : node._store && (node._store.validated = 1));
    }
    function isValidElement(object) {
      return (
        "object" === typeof object &&
        null !== object &&
        object.$$typeof === REACT_ELEMENT_TYPE
      );
    }
    function escape(key) {
      var escaperLookup = { "=": "=0", ":": "=2" };
      return (
        "$" +
        key.replace(/[=:]/g, function (match) {
          return escaperLookup[match];
        })
      );
    }
    function getElementKey(element, index) {
      return "object" === typeof element &&
        null !== element &&
        null != element.key
        ? (checkKeyStringCoercion(element.key), escape("" + element.key))
        : index.toString(36);
    }
    function resolveThenable(thenable) {
      switch (thenable.status) {
        case "fulfilled":
          return thenable.value;
        case "rejected":
          throw thenable.reason;
        default:
          switch (
            ("string" === typeof thenable.status
              ? thenable.then(noop, noop)
              : ((thenable.status = "pending"),
                thenable.then(
                  function (fulfilledValue) {
                    "pending" === thenable.status &&
                      ((thenable.status = "fulfilled"),
                      (thenable.value = fulfilledValue));
                  },
                  function (error) {
                    "pending" === thenable.status &&
                      ((thenable.status = "rejected"),
                      (thenable.reason = error));
                  }
                )),
            thenable.status)
          ) {
            case "fulfilled":
              return thenable.value;
            case "rejected":
              throw thenable.reason;
          }
      }
      throw thenable;
    }
    function mapIntoArray(children, array, escapedPrefix, nameSoFar, callback) {
      var type = typeof children;
      if ("undefined" === type || "boolean" === type) children = null;
      var invokeCallback = !1;
      if (null === children) invokeCallback = !0;
      else
        switch (type) {
          case "bigint":
          case "string":
          case "number":
            invokeCallback = !0;
            break;
          case "object":
            switch (children.$$typeof) {
              case REACT_ELEMENT_TYPE:
              case REACT_PORTAL_TYPE:
                invokeCallback = !0;
                break;
              case REACT_LAZY_TYPE:
                return (
                  (invokeCallback = children._init),
                  mapIntoArray(
                    invokeCallback(children._payload),
                    array,
                    escapedPrefix,
                    nameSoFar,
                    callback
                  )
                );
            }
        }
      if (invokeCallback) {
        invokeCallback = children;
        callback = callback(invokeCallback);
        var childKey =
          "" === nameSoFar ? "." + getElementKey(invokeCallback, 0) : nameSoFar;
        isArrayImpl(callback)
          ? ((escapedPrefix = ""),
            null != childKey &&
              (escapedPrefix =
                childKey.replace(userProvidedKeyEscapeRegex, "$&/") + "/"),
            mapIntoArray(callback, array, escapedPrefix, "", function (c) {
              return c;
            }))
          : null != callback &&
            (isValidElement(callback) &&
              (null != callback.key &&
                ((invokeCallback && invokeCallback.key === callback.key) ||
                  checkKeyStringCoercion(callback.key)),
              (escapedPrefix = cloneAndReplaceKey(
                callback,
                escapedPrefix +
                  (null == callback.key ||
                  (invokeCallback && invokeCallback.key === callback.key)
                    ? ""
                    : ("" + callback.key).replace(
                        userProvidedKeyEscapeRegex,
                        "$&/"
                      ) + "/") +
                  childKey
              )),
              "" !== nameSoFar &&
                null != invokeCallback &&
                isValidElement(invokeCallback) &&
                null == invokeCallback.key &&
                invokeCallback._store &&
                !invokeCallback._store.validated &&
                (escapedPrefix._store.validated = 2),
              (callback = escapedPrefix)),
            array.push(callback));
        return 1;
      }
      invokeCallback = 0;
      childKey = "" === nameSoFar ? "." : nameSoFar + ":";
      if (isArrayImpl(children))
        for (var i = 0; i < children.length; i++)
          (nameSoFar = children[i]),
            (type = childKey + getElementKey(nameSoFar, i)),
            (invokeCallback += mapIntoArray(
              nameSoFar,
              array,
              escapedPrefix,
              type,
              callback
            ));
      else if (((i = getIteratorFn(children)), "function" === typeof i))
        for (
          i === children.entries &&
            (didWarnAboutMaps ||
              console.warn(
                "Using Maps as children is not supported. Use an array of keyed ReactElements instead."
              ),
            (didWarnAboutMaps = !0)),
            children = i.call(children),
            i = 0;
          !(nameSoFar = children.next()).done;

        )
          (nameSoFar = nameSoFar.value),
            (type = childKey + getElementKey(nameSoFar, i++)),
            (invokeCallback += mapIntoArray(
              nameSoFar,
              array,
              escapedPrefix,
              type,
              callback
            ));
      else if ("object" === type) {
        if ("function" === typeof children.then)
          return mapIntoArray(
            resolveThenable(children),
            array,
            escapedPrefix,
            nameSoFar,
            callback
          );
        array = String(children);
        throw Error(
          "Objects are not valid as a React child (found: " +
            ("[object Object]" === array
              ? "object with keys {" + Object.keys(children).join(", ") + "}"
              : array) +
            "). If you meant to render a collection of children, use an array instead."
        );
      }
      return invokeCallback;
    }
    function mapChildren(children, func, context) {
      if (null == children) return children;
      var result = [],
        count = 0;
      mapIntoArray(children, result, "", "", function (child) {
        return func.call(context, child, count++);
      });
      return result;
    }
    function lazyInitializer(payload) {
      if (-1 === payload._status) {
        var ioInfo = payload._ioInfo;
        null != ioInfo && (ioInfo.start = ioInfo.end = performance.now());
        ioInfo = payload._result;
        var thenable = ioInfo();
        thenable.then(
          function (moduleObject) {
            if (0 === payload._status || -1 === payload._status) {
              payload._status = 1;
              payload._result = moduleObject;
              var _ioInfo = payload._ioInfo;
              null != _ioInfo && (_ioInfo.end = performance.now());
              void 0 === thenable.status &&
                ((thenable.status = "fulfilled"),
                (thenable.value = moduleObject));
            }
          },
          function (error) {
            if (0 === payload._status || -1 === payload._status) {
              payload._status = 2;
              payload._result = error;
              var _ioInfo2 = payload._ioInfo;
              null != _ioInfo2 && (_ioInfo2.end = performance.now());
              void 0 === thenable.status &&
                ((thenable.status = "rejected"), (thenable.reason = error));
            }
          }
        );
        ioInfo = payload._ioInfo;
        if (null != ioInfo) {
          ioInfo.value = thenable;
          var displayName = thenable.displayName;
          "string" === typeof displayName && (ioInfo.name = displayName);
        }
        -1 === payload._status &&
          ((payload._status = 0), (payload._result = thenable));
      }
      if (1 === payload._status)
        return (
          (ioInfo = payload._result),
          void 0 === ioInfo &&
            console.error(
              "lazy: Expected the result of a dynamic import() call. Instead received: %s\n\nYour code should look like: \n  const MyComponent = lazy(() => import('./MyComponent'))\n\nDid you accidentally put curly braces around the import?",
              ioInfo
            ),
          "default" in ioInfo ||
            console.error(
              "lazy: Expected the result of a dynamic import() call. Instead received: %s\n\nYour code should look like: \n  const MyComponent = lazy(() => import('./MyComponent'))",
              ioInfo
            ),
          ioInfo.default
        );
      throw payload._result;
    }
    function resolveDispatcher() {
      var dispatcher = ReactSharedInternals.H;
      null === dispatcher &&
        console.error(
          "Invalid hook call. Hooks can only be called inside of the body of a function component. This could happen for one of the following reasons:\n1. You might have mismatching versions of React and the renderer (such as React DOM)\n2. You might be breaking the Rules of Hooks\n3. You might have more than one copy of React in the same app\nSee https://react.dev/link/invalid-hook-call for tips about how to debug and fix this problem."
        );
      return dispatcher;
    }
    function releaseAsyncTransition() {
      ReactSharedInternals.asyncTransitions--;
    }
    function enqueueTask(task) {
      if (null === enqueueTaskImpl)
        try {
          var requireString = ("require" + Math.random()).slice(0, 7);
          enqueueTaskImpl = (module && module[requireString]).call(
            module,
            "timers"
          ).setImmediate;
        } catch (_err) {
          enqueueTaskImpl = function (callback) {
            !1 === didWarnAboutMessageChannel &&
              ((didWarnAboutMessageChannel = !0),
              "undefined" === typeof MessageChannel &&
                console.error(
                  "This browser does not have a MessageChannel implementation, so enqueuing tasks via await act(async () => ...) will fail. Please file an issue at https://github.com/facebook/react/issues if you encounter this warning."
                ));
            var channel = new MessageChannel();
            channel.port1.onmessage = callback;
            channel.port2.postMessage(void 0);
          };
        }
      return enqueueTaskImpl(task);
    }
    function aggregateErrors(errors) {
      return 1 < errors.length && "function" === typeof AggregateError
        ? new AggregateError(errors)
        : errors[0];
    }
    function popActScope(prevActQueue, prevActScopeDepth) {
      prevActScopeDepth !== actScopeDepth - 1 &&
        console.error(
          "You seem to have overlapping act() calls, this is not supported. Be sure to await previous act() calls before making a new one. "
        );
      actScopeDepth = prevActScopeDepth;
    }
    function recursivelyFlushAsyncActWork(returnValue, resolve, reject) {
      var queue = ReactSharedInternals.actQueue;
      if (null !== queue)
        if (0 !== queue.length)
          try {
            flushActQueue(queue);
            enqueueTask(function () {
              return recursivelyFlushAsyncActWork(returnValue, resolve, reject);
            });
            return;
          } catch (error) {
            ReactSharedInternals.thrownErrors.push(error);
          }
        else ReactSharedInternals.actQueue = null;
      0 < ReactSharedInternals.thrownErrors.length
        ? ((queue = aggregateErrors(ReactSharedInternals.thrownErrors)),
          (ReactSharedInternals.thrownErrors.length = 0),
          reject(queue))
        : resolve(returnValue);
    }
    function flushActQueue(queue) {
      if (!isFlushing) {
        isFlushing = !0;
        var i = 0;
        try {
          for (; i < queue.length; i++) {
            var callback = queue[i];
            do {
              ReactSharedInternals.didUsePromise = !1;
              var continuation = callback(!1);
              if (null !== continuation) {
                if (ReactSharedInternals.didUsePromise) {
                  queue[i] = callback;
                  queue.splice(0, i);
                  return;
                }
                callback = continuation;
              } else break;
            } while (1);
          }
          queue.length = 0;
        } catch (error) {
          queue.splice(0, i + 1), ReactSharedInternals.thrownErrors.push(error);
        } finally {
          isFlushing = !1;
        }
      }
    }
    "undefined" !== typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ &&
      "function" ===
        typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStart &&
      __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStart(Error());
    var REACT_ELEMENT_TYPE = Symbol.for("react.transitional.element"),
      REACT_PORTAL_TYPE = Symbol.for("react.portal"),
      REACT_FRAGMENT_TYPE = Symbol.for("react.fragment"),
      REACT_STRICT_MODE_TYPE = Symbol.for("react.strict_mode"),
      REACT_PROFILER_TYPE = Symbol.for("react.profiler"),
      REACT_CONSUMER_TYPE = Symbol.for("react.consumer"),
      REACT_CONTEXT_TYPE = Symbol.for("react.context"),
      REACT_FORWARD_REF_TYPE = Symbol.for("react.forward_ref"),
      REACT_SUSPENSE_TYPE = Symbol.for("react.suspense"),
      REACT_SUSPENSE_LIST_TYPE = Symbol.for("react.suspense_list"),
      REACT_MEMO_TYPE = Symbol.for("react.memo"),
      REACT_LAZY_TYPE = Symbol.for("react.lazy"),
      REACT_ACTIVITY_TYPE = Symbol.for("react.activity"),
      MAYBE_ITERATOR_SYMBOL = Symbol.iterator,
      didWarnStateUpdateForUnmountedComponent = {},
      ReactNoopUpdateQueue = {
        isMounted: function () {
          return !1;
        },
        enqueueForceUpdate: function (publicInstance) {
          warnNoop(publicInstance, "forceUpdate");
        },
        enqueueReplaceState: function (publicInstance) {
          warnNoop(publicInstance, "replaceState");
        },
        enqueueSetState: function (publicInstance) {
          warnNoop(publicInstance, "setState");
        }
      },
      assign = Object.assign,
      emptyObject = {};
    Object.freeze(emptyObject);
    Component.prototype.isReactComponent = {};
    Component.prototype.setState = function (partialState, callback) {
      if (
        "object" !== typeof partialState &&
        "function" !== typeof partialState &&
        null != partialState
      )
        throw Error(
          "takes an object of state variables to update or a function which returns an object of state variables."
        );
      this.updater.enqueueSetState(this, partialState, callback, "setState");
    };
    Component.prototype.forceUpdate = function (callback) {
      this.updater.enqueueForceUpdate(this, callback, "forceUpdate");
    };
    var deprecatedAPIs = {
      isMounted: [
        "isMounted",
        "Instead, make sure to clean up subscriptions and pending requests in componentWillUnmount to prevent memory leaks."
      ],
      replaceState: [
        "replaceState",
        "Refactor your code to use setState instead (see https://github.com/facebook/react/issues/3236)."
      ]
    };
    for (fnName in deprecatedAPIs)
      deprecatedAPIs.hasOwnProperty(fnName) &&
        defineDeprecationWarning(fnName, deprecatedAPIs[fnName]);
    ComponentDummy.prototype = Component.prototype;
    deprecatedAPIs = PureComponent.prototype = new ComponentDummy();
    deprecatedAPIs.constructor = PureComponent;
    assign(deprecatedAPIs, Component.prototype);
    deprecatedAPIs.isPureReactComponent = !0;
    var isArrayImpl = Array.isArray,
      REACT_CLIENT_REFERENCE = Symbol.for("react.client.reference"),
      ReactSharedInternals = {
        H: null,
        A: null,
        T: null,
        S: null,
        actQueue: null,
        asyncTransitions: 0,
        isBatchingLegacy: !1,
        didScheduleLegacyUpdate: !1,
        didUsePromise: !1,
        thrownErrors: [],
        getCurrentStack: null,
        recentlyCreatedOwnerStacks: 0
      },
      hasOwnProperty = Object.prototype.hasOwnProperty,
      createTask = console.createTask
        ? console.createTask
        : function () {
            return null;
          };
    deprecatedAPIs = {
      react_stack_bottom_frame: function (callStackForError) {
        return callStackForError();
      }
    };
    var specialPropKeyWarningShown, didWarnAboutOldJSXRuntime;
    var didWarnAboutElementRef = {};
    var unknownOwnerDebugStack = deprecatedAPIs.react_stack_bottom_frame.bind(
      deprecatedAPIs,
      UnknownOwner
    )();
    var unknownOwnerDebugTask = createTask(getTaskName(UnknownOwner));
    var didWarnAboutMaps = !1,
      userProvidedKeyEscapeRegex = /\/+/g,
      reportGlobalError =
        "function" === typeof reportError
          ? reportError
          : function (error) {
              if (
                "object" === typeof window &&
                "function" === typeof window.ErrorEvent
              ) {
                var event = new window.ErrorEvent("error", {
                  bubbles: !0,
                  cancelable: !0,
                  message:
                    "object" === typeof error &&
                    null !== error &&
                    "string" === typeof error.message
                      ? String(error.message)
                      : String(error),
                  error: error
                });
                if (!window.dispatchEvent(event)) return;
              } else if (
                "object" === typeof process &&
                "function" === typeof process.emit
              ) {
                process.emit("uncaughtException", error);
                return;
              }
              console.error(error);
            },
      didWarnAboutMessageChannel = !1,
      enqueueTaskImpl = null,
      actScopeDepth = 0,
      didWarnNoAwaitAct = !1,
      isFlushing = !1,
      queueSeveralMicrotasks =
        "function" === typeof queueMicrotask
          ? function (callback) {
              queueMicrotask(function () {
                return queueMicrotask(callback);
              });
            }
          : enqueueTask;
    deprecatedAPIs = Object.freeze({
      __proto__: null,
      c: function (size) {
        return resolveDispatcher().useMemoCache(size);
      }
    });
    var fnName = {
      map: mapChildren,
      forEach: function (children, forEachFunc, forEachContext) {
        mapChildren(
          children,
          function () {
            forEachFunc.apply(this, arguments);
          },
          forEachContext
        );
      },
      count: function (children) {
        var n = 0;
        mapChildren(children, function () {
          n++;
        });
        return n;
      },
      toArray: function (children) {
        return (
          mapChildren(children, function (child) {
            return child;
          }) || []
        );
      },
      only: function (children) {
        if (!isValidElement(children))
          throw Error(
            "React.Children.only expected to receive a single React element child."
          );
        return children;
      }
    };
    exports.Activity = REACT_ACTIVITY_TYPE;
    exports.Children = fnName;
    exports.Component = Component;
    exports.Fragment = REACT_FRAGMENT_TYPE;
    exports.Profiler = REACT_PROFILER_TYPE;
    exports.PureComponent = PureComponent;
    exports.StrictMode = REACT_STRICT_MODE_TYPE;
    exports.Suspense = REACT_SUSPENSE_TYPE;
    exports.__CLIENT_INTERNALS_DO_NOT_USE_OR_WARN_USERS_THEY_CANNOT_UPGRADE =
      ReactSharedInternals;
    exports.__COMPILER_RUNTIME = deprecatedAPIs;
    exports.act = function (callback) {
      var prevActQueue = ReactSharedInternals.actQueue,
        prevActScopeDepth = actScopeDepth;
      actScopeDepth++;
      var queue = (ReactSharedInternals.actQueue =
          null !== prevActQueue ? prevActQueue : []),
        didAwaitActCall = !1;
      try {
        var result = callback();
      } catch (error) {
        ReactSharedInternals.thrownErrors.push(error);
      }
      if (0 < ReactSharedInternals.thrownErrors.length)
        throw (
          (popActScope(prevActQueue, prevActScopeDepth),
          (callback = aggregateErrors(ReactSharedInternals.thrownErrors)),
          (ReactSharedInternals.thrownErrors.length = 0),
          callback)
        );
      if (
        null !== result &&
        "object" === typeof result &&
        "function" === typeof result.then
      ) {
        var thenable = result;
        queueSeveralMicrotasks(function () {
          didAwaitActCall ||
            didWarnNoAwaitAct ||
            ((didWarnNoAwaitAct = !0),
            console.error(
              "You called act(async () => ...) without await. This could lead to unexpected testing behaviour, interleaving multiple act calls and mixing their scopes. You should - await act(async () => ...);"
            ));
        });
        return {
          then: function (resolve, reject) {
            didAwaitActCall = !0;
            thenable.then(
              function (returnValue) {
                popActScope(prevActQueue, prevActScopeDepth);
                if (0 === prevActScopeDepth) {
                  try {
                    flushActQueue(queue),
                      enqueueTask(function () {
                        return recursivelyFlushAsyncActWork(
                          returnValue,
                          resolve,
                          reject
                        );
                      });
                  } catch (error$0) {
                    ReactSharedInternals.thrownErrors.push(error$0);
                  }
                  if (0 < ReactSharedInternals.thrownErrors.length) {
                    var _thrownError = aggregateErrors(
                      ReactSharedInternals.thrownErrors
                    );
                    ReactSharedInternals.thrownErrors.length = 0;
                    reject(_thrownError);
                  }
                } else resolve(returnValue);
              },
              function (error) {
                popActScope(prevActQueue, prevActScopeDepth);
                0 < ReactSharedInternals.thrownErrors.length
                  ? ((error = aggregateErrors(
                      ReactSharedInternals.thrownErrors
                    )),
                    (ReactSharedInternals.thrownErrors.length = 0),
                    reject(error))
                  : reject(error);
              }
            );
          }
        };
      }
      var returnValue$jscomp$0 = result;
      popActScope(prevActQueue, prevActScopeDepth);
      0 === prevActScopeDepth &&
        (flushActQueue(queue),
        0 !== queue.length &&
          queueSeveralMicrotasks(function () {
            didAwaitActCall ||
              didWarnNoAwaitAct ||
              ((didWarnNoAwaitAct = !0),
              console.error(
                "A component suspended inside an `act` scope, but the `act` call was not awaited. When testing React components that depend on asynchronous data, you must await the result:\n\nawait act(() => ...)"
              ));
          }),
        (ReactSharedInternals.actQueue = null));
      if (0 < ReactSharedInternals.thrownErrors.length)
        throw (
          ((callback = aggregateErrors(ReactSharedInternals.thrownErrors)),
          (ReactSharedInternals.thrownErrors.length = 0),
          callback)
        );
      return {
        then: function (resolve, reject) {
          didAwaitActCall = !0;
          0 === prevActScopeDepth
            ? ((ReactSharedInternals.actQueue = queue),
              enqueueTask(function () {
                return recursivelyFlushAsyncActWork(
                  returnValue$jscomp$0,
                  resolve,
                  reject
                );
              }))
            : resolve(returnValue$jscomp$0);
        }
      };
    };
    exports.cache = function (fn) {
      return function () {
        return fn.apply(null, arguments);
      };
    };
    exports.cacheSignal = function () {
      return null;
    };
    exports.captureOwnerStack = function () {
      var getCurrentStack = ReactSharedInternals.getCurrentStack;
      return null === getCurrentStack ? null : getCurrentStack();
    };
    exports.cloneElement = function (element, config, children) {
      if (null === element || void 0 === element)
        throw Error(
          "The argument must be a React element, but you passed " +
            element +
            "."
        );
      var props = assign({}, element.props),
        key = element.key,
        owner = element._owner;
      if (null != config) {
        var JSCompiler_inline_result;
        a: {
          if (
            hasOwnProperty.call(config, "ref") &&
            (JSCompiler_inline_result = Object.getOwnPropertyDescriptor(
              config,
              "ref"
            ).get) &&
            JSCompiler_inline_result.isReactWarning
          ) {
            JSCompiler_inline_result = !1;
            break a;
          }
          JSCompiler_inline_result = void 0 !== config.ref;
        }
        JSCompiler_inline_result && (owner = getOwner());
        hasValidKey(config) &&
          (checkKeyStringCoercion(config.key), (key = "" + config.key));
        for (propName in config)
          !hasOwnProperty.call(config, propName) ||
            "key" === propName ||
            "__self" === propName ||
            "__source" === propName ||
            ("ref" === propName && void 0 === config.ref) ||
            (props[propName] = config[propName]);
      }
      var propName = arguments.length - 2;
      if (1 === propName) props.children = children;
      else if (1 < propName) {
        JSCompiler_inline_result = Array(propName);
        for (var i = 0; i < propName; i++)
          JSCompiler_inline_result[i] = arguments[i + 2];
        props.children = JSCompiler_inline_result;
      }
      props = ReactElement(
        element.type,
        key,
        props,
        owner,
        element._debugStack,
        element._debugTask
      );
      for (key = 2; key < arguments.length; key++)
        validateChildKeys(arguments[key]);
      return props;
    };
    exports.createContext = function (defaultValue) {
      defaultValue = {
        $$typeof: REACT_CONTEXT_TYPE,
        _currentValue: defaultValue,
        _currentValue2: defaultValue,
        _threadCount: 0,
        Provider: null,
        Consumer: null
      };
      defaultValue.Provider = defaultValue;
      defaultValue.Consumer = {
        $$typeof: REACT_CONSUMER_TYPE,
        _context: defaultValue
      };
      defaultValue._currentRenderer = null;
      defaultValue._currentRenderer2 = null;
      return defaultValue;
    };
    exports.createElement = function (type, config, children) {
      for (var i = 2; i < arguments.length; i++)
        validateChildKeys(arguments[i]);
      i = {};
      var key = null;
      if (null != config)
        for (propName in (didWarnAboutOldJSXRuntime ||
          !("__self" in config) ||
          "key" in config ||
          ((didWarnAboutOldJSXRuntime = !0),
          console.warn(
            "Your app (or one of its dependencies) is using an outdated JSX transform. Update to the modern JSX transform for faster performance: https://react.dev/link/new-jsx-transform"
          )),
        hasValidKey(config) &&
          (checkKeyStringCoercion(config.key), (key = "" + config.key)),
        config))
          hasOwnProperty.call(config, propName) &&
            "key" !== propName &&
            "__self" !== propName &&
            "__source" !== propName &&
            (i[propName] = config[propName]);
      var childrenLength = arguments.length - 2;
      if (1 === childrenLength) i.children = children;
      else if (1 < childrenLength) {
        for (
          var childArray = Array(childrenLength), _i = 0;
          _i < childrenLength;
          _i++
        )
          childArray[_i] = arguments[_i + 2];
        Object.freeze && Object.freeze(childArray);
        i.children = childArray;
      }
      if (type && type.defaultProps)
        for (propName in ((childrenLength = type.defaultProps), childrenLength))
          void 0 === i[propName] && (i[propName] = childrenLength[propName]);
      key &&
        defineKeyPropWarningGetter(
          i,
          "function" === typeof type
            ? type.displayName || type.name || "Unknown"
            : type
        );
      var propName = 1e4 > ReactSharedInternals.recentlyCreatedOwnerStacks++;
      return ReactElement(
        type,
        key,
        i,
        getOwner(),
        propName ? Error("react-stack-top-frame") : unknownOwnerDebugStack,
        propName ? createTask(getTaskName(type)) : unknownOwnerDebugTask
      );
    };
    exports.createRef = function () {
      var refObject = { current: null };
      Object.seal(refObject);
      return refObject;
    };
    exports.forwardRef = function (render) {
      null != render && render.$$typeof === REACT_MEMO_TYPE
        ? console.error(
            "forwardRef requires a render function but received a `memo` component. Instead of forwardRef(memo(...)), use memo(forwardRef(...))."
          )
        : "function" !== typeof render
          ? console.error(
              "forwardRef requires a render function but was given %s.",
              null === render ? "null" : typeof render
            )
          : 0 !== render.length &&
            2 !== render.length &&
            console.error(
              "forwardRef render functions accept exactly two parameters: props and ref. %s",
              1 === render.length
                ? "Did you forget to use the ref parameter?"
                : "Any additional parameter will be undefined."
            );
      null != render &&
        null != render.defaultProps &&
        console.error(
          "forwardRef render functions do not support defaultProps. Did you accidentally pass a React component?"
        );
      var elementType = { $$typeof: REACT_FORWARD_REF_TYPE, render: render },
        ownName;
      Object.defineProperty(elementType, "displayName", {
        enumerable: !1,
        configurable: !0,
        get: function () {
          return ownName;
        },
        set: function (name) {
          ownName = name;
          render.name ||
            render.displayName ||
            (Object.defineProperty(render, "name", { value: name }),
            (render.displayName = name));
        }
      });
      return elementType;
    };
    exports.isValidElement = isValidElement;
    exports.lazy = function (ctor) {
      ctor = { _status: -1, _result: ctor };
      var lazyType = {
          $$typeof: REACT_LAZY_TYPE,
          _payload: ctor,
          _init: lazyInitializer
        },
        ioInfo = {
          name: "lazy",
          start: -1,
          end: -1,
          value: null,
          owner: null,
          debugStack: Error("react-stack-top-frame"),
          debugTask: console.createTask ? console.createTask("lazy()") : null
        };
      ctor._ioInfo = ioInfo;
      lazyType._debugInfo = [{ awaited: ioInfo }];
      return lazyType;
    };
    exports.memo = function (type, compare) {
      null == type &&
        console.error(
          "memo: The first argument must be a component. Instead received: %s",
          null === type ? "null" : typeof type
        );
      compare = {
        $$typeof: REACT_MEMO_TYPE,
        type: type,
        compare: void 0 === compare ? null : compare
      };
      var ownName;
      Object.defineProperty(compare, "displayName", {
        enumerable: !1,
        configurable: !0,
        get: function () {
          return ownName;
        },
        set: function (name) {
          ownName = name;
          type.name ||
            type.displayName ||
            (Object.defineProperty(type, "name", { value: name }),
            (type.displayName = name));
        }
      });
      return compare;
    };
    exports.startTransition = function (scope) {
      var prevTransition = ReactSharedInternals.T,
        currentTransition = {};
      currentTransition._updatedFibers = new Set();
      ReactSharedInternals.T = currentTransition;
      try {
        var returnValue = scope(),
          onStartTransitionFinish = ReactSharedInternals.S;
        null !== onStartTransitionFinish &&
          onStartTransitionFinish(currentTransition, returnValue);
        "object" === typeof returnValue &&
          null !== returnValue &&
          "function" === typeof returnValue.then &&
          (ReactSharedInternals.asyncTransitions++,
          returnValue.then(releaseAsyncTransition, releaseAsyncTransition),
          returnValue.then(noop, reportGlobalError));
      } catch (error) {
        reportGlobalError(error);
      } finally {
        null === prevTransition &&
          currentTransition._updatedFibers &&
          ((scope = currentTransition._updatedFibers.size),
          currentTransition._updatedFibers.clear(),
          10 < scope &&
            console.warn(
              "Detected a large number of updates inside startTransition. If this is due to a subscription please re-write it to use React provided hooks. Otherwise concurrent mode guarantees are off the table."
            )),
          null !== prevTransition &&
            null !== currentTransition.types &&
            (null !== prevTransition.types &&
              prevTransition.types !== currentTransition.types &&
              console.error(
                "We expected inner Transitions to have transferred the outer types set and that you cannot add to the outer Transition while inside the inner.This is a bug in React."
              ),
            (prevTransition.types = currentTransition.types)),
          (ReactSharedInternals.T = prevTransition);
      }
    };
    exports.unstable_useCacheRefresh = function () {
      return resolveDispatcher().useCacheRefresh();
    };
    exports.use = function (usable) {
      return resolveDispatcher().use(usable);
    };
    exports.useActionState = function (action, initialState, permalink) {
      return resolveDispatcher().useActionState(
        action,
        initialState,
        permalink
      );
    };
    exports.useCallback = function (callback, deps) {
      return resolveDispatcher().useCallback(callback, deps);
    };
    exports.useContext = function (Context) {
      var dispatcher = resolveDispatcher();
      Context.$$typeof === REACT_CONSUMER_TYPE &&
        console.error(
          "Calling useContext(Context.Consumer) is not supported and will cause bugs. Did you mean to call useContext(Context) instead?"
        );
      return dispatcher.useContext(Context);
    };
    exports.useDebugValue = function (value, formatterFn) {
      return resolveDispatcher().useDebugValue(value, formatterFn);
    };
    exports.useDeferredValue = function (value, initialValue) {
      return resolveDispatcher().useDeferredValue(value, initialValue);
    };
    exports.useEffect = function (create, deps) {
      null == create &&
        console.warn(
          "React Hook useEffect requires an effect callback. Did you forget to pass a callback to the hook?"
        );
      return resolveDispatcher().useEffect(create, deps);
    };
    exports.useEffectEvent = function (callback) {
      return resolveDispatcher().useEffectEvent(callback);
    };
    exports.useId = function () {
      return resolveDispatcher().useId();
    };
    exports.useImperativeHandle = function (ref, create, deps) {
      return resolveDispatcher().useImperativeHandle(ref, create, deps);
    };
    exports.useInsertionEffect = function (create, deps) {
      null == create &&
        console.warn(
          "React Hook useInsertionEffect requires an effect callback. Did you forget to pass a callback to the hook?"
        );
      return resolveDispatcher().useInsertionEffect(create, deps);
    };
    exports.useLayoutEffect = function (create, deps) {
      null == create &&
        console.warn(
          "React Hook useLayoutEffect requires an effect callback. Did you forget to pass a callback to the hook?"
        );
      return resolveDispatcher().useLayoutEffect(create, deps);
    };
    exports.useMemo = function (create, deps) {
      return resolveDispatcher().useMemo(create, deps);
    };
    exports.useOptimistic = function (passthrough, reducer) {
      return resolveDispatcher().useOptimistic(passthrough, reducer);
    };
    exports.useReducer = function (reducer, initialArg, init) {
      return resolveDispatcher().useReducer(reducer, initialArg, init);
    };
    exports.useRef = function (initialValue) {
      return resolveDispatcher().useRef(initialValue);
    };
    exports.useState = function (initialState) {
      return resolveDispatcher().useState(initialState);
    };
    exports.useSyncExternalStore = function (
      subscribe,
      getSnapshot,
      getServerSnapshot
    ) {
      return resolveDispatcher().useSyncExternalStore(
        subscribe,
        getSnapshot,
        getServerSnapshot
      );
    };
    exports.useTransition = function () {
      return resolveDispatcher().useTransition();
    };
    exports.version = "19.2.3";
    "undefined" !== typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ &&
      "function" ===
        typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStop &&
      __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStop(Error());
  })();


/***/ },

/***/ "./node_modules/react/index.js"
/*!*************************************!*\
  !*** ./node_modules/react/index.js ***!
  \*************************************/
(module, __unused_webpack_exports, __webpack_require__) {



if (false) // removed by dead control flow
{} else {
  module.exports = __webpack_require__(/*! ./cjs/react.development.js */ "./node_modules/react/cjs/react.development.js");
}


/***/ },

/***/ "./node_modules/react/jsx-runtime.js"
/*!*******************************************!*\
  !*** ./node_modules/react/jsx-runtime.js ***!
  \*******************************************/
(module, __unused_webpack_exports, __webpack_require__) {



if (false) // removed by dead control flow
{} else {
  module.exports = __webpack_require__(/*! ./cjs/react-jsx-runtime.development.js */ "./node_modules/react/cjs/react-jsx-runtime.development.js");
}


/***/ },

/***/ "./node_modules/scheduler/cjs/scheduler.development.js"
/*!*************************************************************!*\
  !*** ./node_modules/scheduler/cjs/scheduler.development.js ***!
  \*************************************************************/
(__unused_webpack_module, exports) {

/**
 * @license React
 * scheduler.development.js
 *
 * Copyright (c) Meta Platforms, Inc. and affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */


 true &&
  (function () {
    function performWorkUntilDeadline() {
      needsPaint = !1;
      if (isMessageLoopRunning) {
        var currentTime = exports.unstable_now();
        startTime = currentTime;
        var hasMoreWork = !0;
        try {
          a: {
            isHostCallbackScheduled = !1;
            isHostTimeoutScheduled &&
              ((isHostTimeoutScheduled = !1),
              localClearTimeout(taskTimeoutID),
              (taskTimeoutID = -1));
            isPerformingWork = !0;
            var previousPriorityLevel = currentPriorityLevel;
            try {
              b: {
                advanceTimers(currentTime);
                for (
                  currentTask = peek(taskQueue);
                  null !== currentTask &&
                  !(
                    currentTask.expirationTime > currentTime &&
                    shouldYieldToHost()
                  );

                ) {
                  var callback = currentTask.callback;
                  if ("function" === typeof callback) {
                    currentTask.callback = null;
                    currentPriorityLevel = currentTask.priorityLevel;
                    var continuationCallback = callback(
                      currentTask.expirationTime <= currentTime
                    );
                    currentTime = exports.unstable_now();
                    if ("function" === typeof continuationCallback) {
                      currentTask.callback = continuationCallback;
                      advanceTimers(currentTime);
                      hasMoreWork = !0;
                      break b;
                    }
                    currentTask === peek(taskQueue) && pop(taskQueue);
                    advanceTimers(currentTime);
                  } else pop(taskQueue);
                  currentTask = peek(taskQueue);
                }
                if (null !== currentTask) hasMoreWork = !0;
                else {
                  var firstTimer = peek(timerQueue);
                  null !== firstTimer &&
                    requestHostTimeout(
                      handleTimeout,
                      firstTimer.startTime - currentTime
                    );
                  hasMoreWork = !1;
                }
              }
              break a;
            } finally {
              (currentTask = null),
                (currentPriorityLevel = previousPriorityLevel),
                (isPerformingWork = !1);
            }
            hasMoreWork = void 0;
          }
        } finally {
          hasMoreWork
            ? schedulePerformWorkUntilDeadline()
            : (isMessageLoopRunning = !1);
        }
      }
    }
    function push(heap, node) {
      var index = heap.length;
      heap.push(node);
      a: for (; 0 < index; ) {
        var parentIndex = (index - 1) >>> 1,
          parent = heap[parentIndex];
        if (0 < compare(parent, node))
          (heap[parentIndex] = node),
            (heap[index] = parent),
            (index = parentIndex);
        else break a;
      }
    }
    function peek(heap) {
      return 0 === heap.length ? null : heap[0];
    }
    function pop(heap) {
      if (0 === heap.length) return null;
      var first = heap[0],
        last = heap.pop();
      if (last !== first) {
        heap[0] = last;
        a: for (
          var index = 0, length = heap.length, halfLength = length >>> 1;
          index < halfLength;

        ) {
          var leftIndex = 2 * (index + 1) - 1,
            left = heap[leftIndex],
            rightIndex = leftIndex + 1,
            right = heap[rightIndex];
          if (0 > compare(left, last))
            rightIndex < length && 0 > compare(right, left)
              ? ((heap[index] = right),
                (heap[rightIndex] = last),
                (index = rightIndex))
              : ((heap[index] = left),
                (heap[leftIndex] = last),
                (index = leftIndex));
          else if (rightIndex < length && 0 > compare(right, last))
            (heap[index] = right),
              (heap[rightIndex] = last),
              (index = rightIndex);
          else break a;
        }
      }
      return first;
    }
    function compare(a, b) {
      var diff = a.sortIndex - b.sortIndex;
      return 0 !== diff ? diff : a.id - b.id;
    }
    function advanceTimers(currentTime) {
      for (var timer = peek(timerQueue); null !== timer; ) {
        if (null === timer.callback) pop(timerQueue);
        else if (timer.startTime <= currentTime)
          pop(timerQueue),
            (timer.sortIndex = timer.expirationTime),
            push(taskQueue, timer);
        else break;
        timer = peek(timerQueue);
      }
    }
    function handleTimeout(currentTime) {
      isHostTimeoutScheduled = !1;
      advanceTimers(currentTime);
      if (!isHostCallbackScheduled)
        if (null !== peek(taskQueue))
          (isHostCallbackScheduled = !0),
            isMessageLoopRunning ||
              ((isMessageLoopRunning = !0), schedulePerformWorkUntilDeadline());
        else {
          var firstTimer = peek(timerQueue);
          null !== firstTimer &&
            requestHostTimeout(
              handleTimeout,
              firstTimer.startTime - currentTime
            );
        }
    }
    function shouldYieldToHost() {
      return needsPaint
        ? !0
        : exports.unstable_now() - startTime < frameInterval
          ? !1
          : !0;
    }
    function requestHostTimeout(callback, ms) {
      taskTimeoutID = localSetTimeout(function () {
        callback(exports.unstable_now());
      }, ms);
    }
    "undefined" !== typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ &&
      "function" ===
        typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStart &&
      __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStart(Error());
    exports.unstable_now = void 0;
    if (
      "object" === typeof performance &&
      "function" === typeof performance.now
    ) {
      var localPerformance = performance;
      exports.unstable_now = function () {
        return localPerformance.now();
      };
    } else {
      var localDate = Date,
        initialTime = localDate.now();
      exports.unstable_now = function () {
        return localDate.now() - initialTime;
      };
    }
    var taskQueue = [],
      timerQueue = [],
      taskIdCounter = 1,
      currentTask = null,
      currentPriorityLevel = 3,
      isPerformingWork = !1,
      isHostCallbackScheduled = !1,
      isHostTimeoutScheduled = !1,
      needsPaint = !1,
      localSetTimeout = "function" === typeof setTimeout ? setTimeout : null,
      localClearTimeout =
        "function" === typeof clearTimeout ? clearTimeout : null,
      localSetImmediate =
        "undefined" !== typeof setImmediate ? setImmediate : null,
      isMessageLoopRunning = !1,
      taskTimeoutID = -1,
      frameInterval = 5,
      startTime = -1;
    if ("function" === typeof localSetImmediate)
      var schedulePerformWorkUntilDeadline = function () {
        localSetImmediate(performWorkUntilDeadline);
      };
    else if ("undefined" !== typeof MessageChannel) {
      var channel = new MessageChannel(),
        port = channel.port2;
      channel.port1.onmessage = performWorkUntilDeadline;
      schedulePerformWorkUntilDeadline = function () {
        port.postMessage(null);
      };
    } else
      schedulePerformWorkUntilDeadline = function () {
        localSetTimeout(performWorkUntilDeadline, 0);
      };
    exports.unstable_IdlePriority = 5;
    exports.unstable_ImmediatePriority = 1;
    exports.unstable_LowPriority = 4;
    exports.unstable_NormalPriority = 3;
    exports.unstable_Profiling = null;
    exports.unstable_UserBlockingPriority = 2;
    exports.unstable_cancelCallback = function (task) {
      task.callback = null;
    };
    exports.unstable_forceFrameRate = function (fps) {
      0 > fps || 125 < fps
        ? console.error(
            "forceFrameRate takes a positive int between 0 and 125, forcing frame rates higher than 125 fps is not supported"
          )
        : (frameInterval = 0 < fps ? Math.floor(1e3 / fps) : 5);
    };
    exports.unstable_getCurrentPriorityLevel = function () {
      return currentPriorityLevel;
    };
    exports.unstable_next = function (eventHandler) {
      switch (currentPriorityLevel) {
        case 1:
        case 2:
        case 3:
          var priorityLevel = 3;
          break;
        default:
          priorityLevel = currentPriorityLevel;
      }
      var previousPriorityLevel = currentPriorityLevel;
      currentPriorityLevel = priorityLevel;
      try {
        return eventHandler();
      } finally {
        currentPriorityLevel = previousPriorityLevel;
      }
    };
    exports.unstable_requestPaint = function () {
      needsPaint = !0;
    };
    exports.unstable_runWithPriority = function (priorityLevel, eventHandler) {
      switch (priorityLevel) {
        case 1:
        case 2:
        case 3:
        case 4:
        case 5:
          break;
        default:
          priorityLevel = 3;
      }
      var previousPriorityLevel = currentPriorityLevel;
      currentPriorityLevel = priorityLevel;
      try {
        return eventHandler();
      } finally {
        currentPriorityLevel = previousPriorityLevel;
      }
    };
    exports.unstable_scheduleCallback = function (
      priorityLevel,
      callback,
      options
    ) {
      var currentTime = exports.unstable_now();
      "object" === typeof options && null !== options
        ? ((options = options.delay),
          (options =
            "number" === typeof options && 0 < options
              ? currentTime + options
              : currentTime))
        : (options = currentTime);
      switch (priorityLevel) {
        case 1:
          var timeout = -1;
          break;
        case 2:
          timeout = 250;
          break;
        case 5:
          timeout = 1073741823;
          break;
        case 4:
          timeout = 1e4;
          break;
        default:
          timeout = 5e3;
      }
      timeout = options + timeout;
      priorityLevel = {
        id: taskIdCounter++,
        callback: callback,
        priorityLevel: priorityLevel,
        startTime: options,
        expirationTime: timeout,
        sortIndex: -1
      };
      options > currentTime
        ? ((priorityLevel.sortIndex = options),
          push(timerQueue, priorityLevel),
          null === peek(taskQueue) &&
            priorityLevel === peek(timerQueue) &&
            (isHostTimeoutScheduled
              ? (localClearTimeout(taskTimeoutID), (taskTimeoutID = -1))
              : (isHostTimeoutScheduled = !0),
            requestHostTimeout(handleTimeout, options - currentTime)))
        : ((priorityLevel.sortIndex = timeout),
          push(taskQueue, priorityLevel),
          isHostCallbackScheduled ||
            isPerformingWork ||
            ((isHostCallbackScheduled = !0),
            isMessageLoopRunning ||
              ((isMessageLoopRunning = !0),
              schedulePerformWorkUntilDeadline())));
      return priorityLevel;
    };
    exports.unstable_shouldYield = shouldYieldToHost;
    exports.unstable_wrapCallback = function (callback) {
      var parentPriorityLevel = currentPriorityLevel;
      return function () {
        var previousPriorityLevel = currentPriorityLevel;
        currentPriorityLevel = parentPriorityLevel;
        try {
          return callback.apply(this, arguments);
        } finally {
          currentPriorityLevel = previousPriorityLevel;
        }
      };
    };
    "undefined" !== typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ &&
      "function" ===
        typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStop &&
      __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStop(Error());
  })();


/***/ },

/***/ "./node_modules/scheduler/index.js"
/*!*****************************************!*\
  !*** ./node_modules/scheduler/index.js ***!
  \*****************************************/
(module, __unused_webpack_exports, __webpack_require__) {



if (false) // removed by dead control flow
{} else {
  module.exports = __webpack_require__(/*! ./cjs/scheduler.development.js */ "./node_modules/scheduler/cjs/scheduler.development.js");
}


/***/ },

/***/ "./node_modules/seedrandom/index.js"
/*!******************************************!*\
  !*** ./node_modules/seedrandom/index.js ***!
  \******************************************/
(module, __unused_webpack_exports, __webpack_require__) {

// A library of seedable RNGs implemented in Javascript.
//
// Usage:
//
// var seedrandom = require('seedrandom');
// var random = seedrandom(1); // or any seed.
// var x = random();       // 0 <= x < 1.  Every bit is random.
// var x = random.quick(); // 0 <= x < 1.  32 bits of randomness.

// alea, a 53-bit multiply-with-carry generator by Johannes BaagÃ¸e.
// Period: ~2^116
// Reported to pass all BigCrush tests.
var alea = __webpack_require__(/*! ./lib/alea */ "./node_modules/seedrandom/lib/alea.js");

// xor128, a pure xor-shift generator by George Marsaglia.
// Period: 2^128-1.
// Reported to fail: MatrixRank and LinearComp.
var xor128 = __webpack_require__(/*! ./lib/xor128 */ "./node_modules/seedrandom/lib/xor128.js");

// xorwow, George Marsaglia's 160-bit xor-shift combined plus weyl.
// Period: 2^192-2^32
// Reported to fail: CollisionOver, SimpPoker, and LinearComp.
var xorwow = __webpack_require__(/*! ./lib/xorwow */ "./node_modules/seedrandom/lib/xorwow.js");

// xorshift7, by FranÃ§ois Panneton and Pierre L'ecuyer, takes
// a different approach: it adds robustness by allowing more shifts
// than Marsaglia's original three.  It is a 7-shift generator
// with 256 bits, that passes BigCrush with no systmatic failures.
// Period 2^256-1.
// No systematic BigCrush failures reported.
var xorshift7 = __webpack_require__(/*! ./lib/xorshift7 */ "./node_modules/seedrandom/lib/xorshift7.js");

// xor4096, by Richard Brent, is a 4096-bit xor-shift with a
// very long period that also adds a Weyl generator. It also passes
// BigCrush with no systematic failures.  Its long period may
// be useful if you have many generators and need to avoid
// collisions.
// Period: 2^4128-2^32.
// No systematic BigCrush failures reported.
var xor4096 = __webpack_require__(/*! ./lib/xor4096 */ "./node_modules/seedrandom/lib/xor4096.js");

// Tyche-i, by Samuel Neves and Filipe Araujo, is a bit-shifting random
// number generator derived from ChaCha, a modern stream cipher.
// https://eden.dei.uc.pt/~sneves/pubs/2011-snfa2.pdf
// Period: ~2^127
// No systematic BigCrush failures reported.
var tychei = __webpack_require__(/*! ./lib/tychei */ "./node_modules/seedrandom/lib/tychei.js");

// The original ARC4-based prng included in this library.
// Period: ~2^1600
var sr = __webpack_require__(/*! ./seedrandom */ "./node_modules/seedrandom/seedrandom.js");

sr.alea = alea;
sr.xor128 = xor128;
sr.xorwow = xorwow;
sr.xorshift7 = xorshift7;
sr.xor4096 = xor4096;
sr.tychei = tychei;

module.exports = sr;


/***/ },

/***/ "./node_modules/seedrandom/lib/alea.js"
/*!*********************************************!*\
  !*** ./node_modules/seedrandom/lib/alea.js ***!
  \*********************************************/
(module, exports, __webpack_require__) {

/* module decorator */ module = __webpack_require__.nmd(module);
var __WEBPACK_AMD_DEFINE_RESULT__;// A port of an algorithm by Johannes BaagÃ¸e <baagoe@baagoe.com>, 2010
// http://baagoe.com/en/RandomMusings/javascript/
// https://github.com/nquinlan/better-random-numbers-for-javascript-mirror
// Original work is under MIT license -

// Copyright (C) 2010 by Johannes BaagÃ¸e <baagoe@baagoe.org>
//
// Permission is hereby granted, free of charge, to any person obtaining a copy
// of this software and associated documentation files (the "Software"), to deal
// in the Software without restriction, including without limitation the rights
// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
// copies of the Software, and to permit persons to whom the Software is
// furnished to do so, subject to the following conditions:
//
// The above copyright notice and this permission notice shall be included in
// all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
// THE SOFTWARE.



(function(global, module, define) {

function Alea(seed) {
  var me = this, mash = Mash();

  me.next = function() {
    var t = 2091639 * me.s0 + me.c * 2.3283064365386963e-10; // 2^-32
    me.s0 = me.s1;
    me.s1 = me.s2;
    return me.s2 = t - (me.c = t | 0);
  };

  // Apply the seeding algorithm from Baagoe.
  me.c = 1;
  me.s0 = mash(' ');
  me.s1 = mash(' ');
  me.s2 = mash(' ');
  me.s0 -= mash(seed);
  if (me.s0 < 0) { me.s0 += 1; }
  me.s1 -= mash(seed);
  if (me.s1 < 0) { me.s1 += 1; }
  me.s2 -= mash(seed);
  if (me.s2 < 0) { me.s2 += 1; }
  mash = null;
}

function copy(f, t) {
  t.c = f.c;
  t.s0 = f.s0;
  t.s1 = f.s1;
  t.s2 = f.s2;
  return t;
}

function impl(seed, opts) {
  var xg = new Alea(seed),
      state = opts && opts.state,
      prng = xg.next;
  prng.int32 = function() { return (xg.next() * 0x100000000) | 0; }
  prng.double = function() {
    return prng() + (prng() * 0x200000 | 0) * 1.1102230246251565e-16; // 2^-53
  };
  prng.quick = prng;
  if (state) {
    if (typeof(state) == 'object') copy(state, xg);
    prng.state = function() { return copy(xg, {}); }
  }
  return prng;
}

function Mash() {
  var n = 0xefc8249d;

  var mash = function(data) {
    data = String(data);
    for (var i = 0; i < data.length; i++) {
      n += data.charCodeAt(i);
      var h = 0.02519603282416938 * n;
      n = h >>> 0;
      h -= n;
      h *= n;
      n = h >>> 0;
      h -= n;
      n += h * 0x100000000; // 2^32
    }
    return (n >>> 0) * 2.3283064365386963e-10; // 2^-32
  };

  return mash;
}


if (module && module.exports) {
  module.exports = impl;
} else if (__webpack_require__.amdD && __webpack_require__.amdO) {
  !(__WEBPACK_AMD_DEFINE_RESULT__ = (function() { return impl; }).call(exports, __webpack_require__, exports, module),
		__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));
} else {
  this.alea = impl;
}

})(
  this,
   true && module,    // present in node.js
  __webpack_require__.amdD   // present with an AMD loader
);




/***/ },

/***/ "./node_modules/seedrandom/lib/tychei.js"
/*!***********************************************!*\
  !*** ./node_modules/seedrandom/lib/tychei.js ***!
  \***********************************************/
(module, exports, __webpack_require__) {

/* module decorator */ module = __webpack_require__.nmd(module);
var __WEBPACK_AMD_DEFINE_RESULT__;// A Javascript implementaion of the "Tyche-i" prng algorithm by
// Samuel Neves and Filipe Araujo.
// See https://eden.dei.uc.pt/~sneves/pubs/2011-snfa2.pdf

(function(global, module, define) {

function XorGen(seed) {
  var me = this, strseed = '';

  // Set up generator function.
  me.next = function() {
    var b = me.b, c = me.c, d = me.d, a = me.a;
    b = (b << 25) ^ (b >>> 7) ^ c;
    c = (c - d) | 0;
    d = (d << 24) ^ (d >>> 8) ^ a;
    a = (a - b) | 0;
    me.b = b = (b << 20) ^ (b >>> 12) ^ c;
    me.c = c = (c - d) | 0;
    me.d = (d << 16) ^ (c >>> 16) ^ a;
    return me.a = (a - b) | 0;
  };

  /* The following is non-inverted tyche, which has better internal
   * bit diffusion, but which is about 25% slower than tyche-i in JS.
  me.next = function() {
    var a = me.a, b = me.b, c = me.c, d = me.d;
    a = (me.a + me.b | 0) >>> 0;
    d = me.d ^ a; d = d << 16 ^ d >>> 16;
    c = me.c + d | 0;
    b = me.b ^ c; b = b << 12 ^ d >>> 20;
    me.a = a = a + b | 0;
    d = d ^ a; me.d = d = d << 8 ^ d >>> 24;
    me.c = c = c + d | 0;
    b = b ^ c;
    return me.b = (b << 7 ^ b >>> 25);
  }
  */

  me.a = 0;
  me.b = 0;
  me.c = 2654435769 | 0;
  me.d = 1367130551;

  if (seed === Math.floor(seed)) {
    // Integer seed.
    me.a = (seed / 0x100000000) | 0;
    me.b = seed | 0;
  } else {
    // String seed.
    strseed += seed;
  }

  // Mix in string seed, then discard an initial batch of 64 values.
  for (var k = 0; k < strseed.length + 20; k++) {
    me.b ^= strseed.charCodeAt(k) | 0;
    me.next();
  }
}

function copy(f, t) {
  t.a = f.a;
  t.b = f.b;
  t.c = f.c;
  t.d = f.d;
  return t;
};

function impl(seed, opts) {
  var xg = new XorGen(seed),
      state = opts && opts.state,
      prng = function() { return (xg.next() >>> 0) / 0x100000000; };
  prng.double = function() {
    do {
      var top = xg.next() >>> 11,
          bot = (xg.next() >>> 0) / 0x100000000,
          result = (top + bot) / (1 << 21);
    } while (result === 0);
    return result;
  };
  prng.int32 = xg.next;
  prng.quick = prng;
  if (state) {
    if (typeof(state) == 'object') copy(state, xg);
    prng.state = function() { return copy(xg, {}); }
  }
  return prng;
}

if (module && module.exports) {
  module.exports = impl;
} else if (__webpack_require__.amdD && __webpack_require__.amdO) {
  !(__WEBPACK_AMD_DEFINE_RESULT__ = (function() { return impl; }).call(exports, __webpack_require__, exports, module),
		__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));
} else {
  this.tychei = impl;
}

})(
  this,
   true && module,    // present in node.js
  __webpack_require__.amdD   // present with an AMD loader
);




/***/ },

/***/ "./node_modules/seedrandom/lib/xor128.js"
/*!***********************************************!*\
  !*** ./node_modules/seedrandom/lib/xor128.js ***!
  \***********************************************/
(module, exports, __webpack_require__) {

/* module decorator */ module = __webpack_require__.nmd(module);
var __WEBPACK_AMD_DEFINE_RESULT__;// A Javascript implementaion of the "xor128" prng algorithm by
// George Marsaglia.  See http://www.jstatsoft.org/v08/i14/paper

(function(global, module, define) {

function XorGen(seed) {
  var me = this, strseed = '';

  me.x = 0;
  me.y = 0;
  me.z = 0;
  me.w = 0;

  // Set up generator function.
  me.next = function() {
    var t = me.x ^ (me.x << 11);
    me.x = me.y;
    me.y = me.z;
    me.z = me.w;
    return me.w ^= (me.w >>> 19) ^ t ^ (t >>> 8);
  };

  if (seed === (seed | 0)) {
    // Integer seed.
    me.x = seed;
  } else {
    // String seed.
    strseed += seed;
  }

  // Mix in string seed, then discard an initial batch of 64 values.
  for (var k = 0; k < strseed.length + 64; k++) {
    me.x ^= strseed.charCodeAt(k) | 0;
    me.next();
  }
}

function copy(f, t) {
  t.x = f.x;
  t.y = f.y;
  t.z = f.z;
  t.w = f.w;
  return t;
}

function impl(seed, opts) {
  var xg = new XorGen(seed),
      state = opts && opts.state,
      prng = function() { return (xg.next() >>> 0) / 0x100000000; };
  prng.double = function() {
    do {
      var top = xg.next() >>> 11,
          bot = (xg.next() >>> 0) / 0x100000000,
          result = (top + bot) / (1 << 21);
    } while (result === 0);
    return result;
  };
  prng.int32 = xg.next;
  prng.quick = prng;
  if (state) {
    if (typeof(state) == 'object') copy(state, xg);
    prng.state = function() { return copy(xg, {}); }
  }
  return prng;
}

if (module && module.exports) {
  module.exports = impl;
} else if (__webpack_require__.amdD && __webpack_require__.amdO) {
  !(__WEBPACK_AMD_DEFINE_RESULT__ = (function() { return impl; }).call(exports, __webpack_require__, exports, module),
		__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));
} else {
  this.xor128 = impl;
}

})(
  this,
   true && module,    // present in node.js
  __webpack_require__.amdD   // present with an AMD loader
);




/***/ },

/***/ "./node_modules/seedrandom/lib/xor4096.js"
/*!************************************************!*\
  !*** ./node_modules/seedrandom/lib/xor4096.js ***!
  \************************************************/
(module, exports, __webpack_require__) {

/* module decorator */ module = __webpack_require__.nmd(module);
var __WEBPACK_AMD_DEFINE_RESULT__;// A Javascript implementaion of Richard Brent's Xorgens xor4096 algorithm.
//
// This fast non-cryptographic random number generator is designed for
// use in Monte-Carlo algorithms. It combines a long-period xorshift
// generator with a Weyl generator, and it passes all common batteries
// of stasticial tests for randomness while consuming only a few nanoseconds
// for each prng generated.  For background on the generator, see Brent's
// paper: "Some long-period random number generators using shifts and xors."
// http://arxiv.org/pdf/1004.3115v1.pdf
//
// Usage:
//
// var xor4096 = require('xor4096');
// random = xor4096(1);                        // Seed with int32 or string.
// assert.equal(random(), 0.1520436450538547); // (0, 1) range, 53 bits.
// assert.equal(random.int32(), 1806534897);   // signed int32, 32 bits.
//
// For nonzero numeric keys, this impelementation provides a sequence
// identical to that by Brent's xorgens 3 implementaion in C.  This
// implementation also provides for initalizing the generator with
// string seeds, or for saving and restoring the state of the generator.
//
// On Chrome, this prng benchmarks about 2.1 times slower than
// Javascript's built-in Math.random().

(function(global, module, define) {

function XorGen(seed) {
  var me = this;

  // Set up generator function.
  me.next = function() {
    var w = me.w,
        X = me.X, i = me.i, t, v;
    // Update Weyl generator.
    me.w = w = (w + 0x61c88647) | 0;
    // Update xor generator.
    v = X[(i + 34) & 127];
    t = X[i = ((i + 1) & 127)];
    v ^= v << 13;
    t ^= t << 17;
    v ^= v >>> 15;
    t ^= t >>> 12;
    // Update Xor generator array state.
    v = X[i] = v ^ t;
    me.i = i;
    // Result is the combination.
    return (v + (w ^ (w >>> 16))) | 0;
  };

  function init(me, seed) {
    var t, v, i, j, w, X = [], limit = 128;
    if (seed === (seed | 0)) {
      // Numeric seeds initialize v, which is used to generates X.
      v = seed;
      seed = null;
    } else {
      // String seeds are mixed into v and X one character at a time.
      seed = seed + '\0';
      v = 0;
      limit = Math.max(limit, seed.length);
    }
    // Initialize circular array and weyl value.
    for (i = 0, j = -32; j < limit; ++j) {
      // Put the unicode characters into the array, and shuffle them.
      if (seed) v ^= seed.charCodeAt((j + 32) % seed.length);
      // After 32 shuffles, take v as the starting w value.
      if (j === 0) w = v;
      v ^= v << 10;
      v ^= v >>> 15;
      v ^= v << 4;
      v ^= v >>> 13;
      if (j >= 0) {
        w = (w + 0x61c88647) | 0;     // Weyl.
        t = (X[j & 127] ^= (v + w));  // Combine xor and weyl to init array.
        i = (0 == t) ? i + 1 : 0;     // Count zeroes.
      }
    }
    // We have detected all zeroes; make the key nonzero.
    if (i >= 128) {
      X[(seed && seed.length || 0) & 127] = -1;
    }
    // Run the generator 512 times to further mix the state before using it.
    // Factoring this as a function slows the main generator, so it is just
    // unrolled here.  The weyl generator is not advanced while warming up.
    i = 127;
    for (j = 4 * 128; j > 0; --j) {
      v = X[(i + 34) & 127];
      t = X[i = ((i + 1) & 127)];
      v ^= v << 13;
      t ^= t << 17;
      v ^= v >>> 15;
      t ^= t >>> 12;
      X[i] = v ^ t;
    }
    // Storing state as object members is faster than using closure variables.
    me.w = w;
    me.X = X;
    me.i = i;
  }

  init(me, seed);
}

function copy(f, t) {
  t.i = f.i;
  t.w = f.w;
  t.X = f.X.slice();
  return t;
};

function impl(seed, opts) {
  if (seed == null) seed = +(new Date);
  var xg = new XorGen(seed),
      state = opts && opts.state,
      prng = function() { return (xg.next() >>> 0) / 0x100000000; };
  prng.double = function() {
    do {
      var top = xg.next() >>> 11,
          bot = (xg.next() >>> 0) / 0x100000000,
          result = (top + bot) / (1 << 21);
    } while (result === 0);
    return result;
  };
  prng.int32 = xg.next;
  prng.quick = prng;
  if (state) {
    if (state.X) copy(state, xg);
    prng.state = function() { return copy(xg, {}); }
  }
  return prng;
}

if (module && module.exports) {
  module.exports = impl;
} else if (__webpack_require__.amdD && __webpack_require__.amdO) {
  !(__WEBPACK_AMD_DEFINE_RESULT__ = (function() { return impl; }).call(exports, __webpack_require__, exports, module),
		__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));
} else {
  this.xor4096 = impl;
}

})(
  this,                                     // window object or global
   true && module,    // present in node.js
  __webpack_require__.amdD   // present with an AMD loader
);


/***/ },

/***/ "./node_modules/seedrandom/lib/xorshift7.js"
/*!**************************************************!*\
  !*** ./node_modules/seedrandom/lib/xorshift7.js ***!
  \**************************************************/
(module, exports, __webpack_require__) {

/* module decorator */ module = __webpack_require__.nmd(module);
var __WEBPACK_AMD_DEFINE_RESULT__;// A Javascript implementaion of the "xorshift7" algorithm by
// FranÃ§ois Panneton and Pierre L'ecuyer:
// "On the Xorgshift Random Number Generators"
// http://saluc.engr.uconn.edu/refs/crypto/rng/panneton05onthexorshift.pdf

(function(global, module, define) {

function XorGen(seed) {
  var me = this;

  // Set up generator function.
  me.next = function() {
    // Update xor generator.
    var X = me.x, i = me.i, t, v, w;
    t = X[i]; t ^= (t >>> 7); v = t ^ (t << 24);
    t = X[(i + 1) & 7]; v ^= t ^ (t >>> 10);
    t = X[(i + 3) & 7]; v ^= t ^ (t >>> 3);
    t = X[(i + 4) & 7]; v ^= t ^ (t << 7);
    t = X[(i + 7) & 7]; t = t ^ (t << 13); v ^= t ^ (t << 9);
    X[i] = v;
    me.i = (i + 1) & 7;
    return v;
  };

  function init(me, seed) {
    var j, w, X = [];

    if (seed === (seed | 0)) {
      // Seed state array using a 32-bit integer.
      w = X[0] = seed;
    } else {
      // Seed state using a string.
      seed = '' + seed;
      for (j = 0; j < seed.length; ++j) {
        X[j & 7] = (X[j & 7] << 15) ^
            (seed.charCodeAt(j) + X[(j + 1) & 7] << 13);
      }
    }
    // Enforce an array length of 8, not all zeroes.
    while (X.length < 8) X.push(0);
    for (j = 0; j < 8 && X[j] === 0; ++j);
    if (j == 8) w = X[7] = -1; else w = X[j];

    me.x = X;
    me.i = 0;

    // Discard an initial 256 values.
    for (j = 256; j > 0; --j) {
      me.next();
    }
  }

  init(me, seed);
}

function copy(f, t) {
  t.x = f.x.slice();
  t.i = f.i;
  return t;
}

function impl(seed, opts) {
  if (seed == null) seed = +(new Date);
  var xg = new XorGen(seed),
      state = opts && opts.state,
      prng = function() { return (xg.next() >>> 0) / 0x100000000; };
  prng.double = function() {
    do {
      var top = xg.next() >>> 11,
          bot = (xg.next() >>> 0) / 0x100000000,
          result = (top + bot) / (1 << 21);
    } while (result === 0);
    return result;
  };
  prng.int32 = xg.next;
  prng.quick = prng;
  if (state) {
    if (state.x) copy(state, xg);
    prng.state = function() { return copy(xg, {}); }
  }
  return prng;
}

if (module && module.exports) {
  module.exports = impl;
} else if (__webpack_require__.amdD && __webpack_require__.amdO) {
  !(__WEBPACK_AMD_DEFINE_RESULT__ = (function() { return impl; }).call(exports, __webpack_require__, exports, module),
		__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));
} else {
  this.xorshift7 = impl;
}

})(
  this,
   true && module,    // present in node.js
  __webpack_require__.amdD   // present with an AMD loader
);



/***/ },

/***/ "./node_modules/seedrandom/lib/xorwow.js"
/*!***********************************************!*\
  !*** ./node_modules/seedrandom/lib/xorwow.js ***!
  \***********************************************/
(module, exports, __webpack_require__) {

/* module decorator */ module = __webpack_require__.nmd(module);
var __WEBPACK_AMD_DEFINE_RESULT__;// A Javascript implementaion of the "xorwow" prng algorithm by
// George Marsaglia.  See http://www.jstatsoft.org/v08/i14/paper

(function(global, module, define) {

function XorGen(seed) {
  var me = this, strseed = '';

  // Set up generator function.
  me.next = function() {
    var t = (me.x ^ (me.x >>> 2));
    me.x = me.y; me.y = me.z; me.z = me.w; me.w = me.v;
    return (me.d = (me.d + 362437 | 0)) +
       (me.v = (me.v ^ (me.v << 4)) ^ (t ^ (t << 1))) | 0;
  };

  me.x = 0;
  me.y = 0;
  me.z = 0;
  me.w = 0;
  me.v = 0;

  if (seed === (seed | 0)) {
    // Integer seed.
    me.x = seed;
  } else {
    // String seed.
    strseed += seed;
  }

  // Mix in string seed, then discard an initial batch of 64 values.
  for (var k = 0; k < strseed.length + 64; k++) {
    me.x ^= strseed.charCodeAt(k) | 0;
    if (k == strseed.length) {
      me.d = me.x << 10 ^ me.x >>> 4;
    }
    me.next();
  }
}

function copy(f, t) {
  t.x = f.x;
  t.y = f.y;
  t.z = f.z;
  t.w = f.w;
  t.v = f.v;
  t.d = f.d;
  return t;
}

function impl(seed, opts) {
  var xg = new XorGen(seed),
      state = opts && opts.state,
      prng = function() { return (xg.next() >>> 0) / 0x100000000; };
  prng.double = function() {
    do {
      var top = xg.next() >>> 11,
          bot = (xg.next() >>> 0) / 0x100000000,
          result = (top + bot) / (1 << 21);
    } while (result === 0);
    return result;
  };
  prng.int32 = xg.next;
  prng.quick = prng;
  if (state) {
    if (typeof(state) == 'object') copy(state, xg);
    prng.state = function() { return copy(xg, {}); }
  }
  return prng;
}

if (module && module.exports) {
  module.exports = impl;
} else if (__webpack_require__.amdD && __webpack_require__.amdO) {
  !(__WEBPACK_AMD_DEFINE_RESULT__ = (function() { return impl; }).call(exports, __webpack_require__, exports, module),
		__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));
} else {
  this.xorwow = impl;
}

})(
  this,
   true && module,    // present in node.js
  __webpack_require__.amdD   // present with an AMD loader
);




/***/ },

/***/ "./node_modules/seedrandom/seedrandom.js"
/*!***********************************************!*\
  !*** ./node_modules/seedrandom/seedrandom.js ***!
  \***********************************************/
(module, exports, __webpack_require__) {

var __WEBPACK_AMD_DEFINE_RESULT__;/*
Copyright 2019 David Bau.

Permission is hereby granted, free of charge, to any person obtaining
a copy of this software and associated documentation files (the
"Software"), to deal in the Software without restriction, including
without limitation the rights to use, copy, modify, merge, publish,
distribute, sublicense, and/or sell copies of the Software, and to
permit persons to whom the Software is furnished to do so, subject to
the following conditions:

The above copyright notice and this permission notice shall be
included in all copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.
IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY
CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT,
TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE
SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.

*/

(function (global, pool, math) {
//
// The following constants are related to IEEE 754 limits.
//

var width = 256,        // each RC4 output is 0 <= x < 256
    chunks = 6,         // at least six RC4 outputs for each double
    digits = 52,        // there are 52 significant digits in a double
    rngname = 'random', // rngname: name for Math.random and Math.seedrandom
    startdenom = math.pow(width, chunks),
    significance = math.pow(2, digits),
    overflow = significance * 2,
    mask = width - 1,
    nodecrypto;         // node.js crypto module, initialized at the bottom.

//
// seedrandom()
// This is the seedrandom function described above.
//
function seedrandom(seed, options, callback) {
  var key = [];
  options = (options == true) ? { entropy: true } : (options || {});

  // Flatten the seed string or build one from local entropy if needed.
  var shortseed = mixkey(flatten(
    options.entropy ? [seed, tostring(pool)] :
    (seed == null) ? autoseed() : seed, 3), key);

  // Use the seed to initialize an ARC4 generator.
  var arc4 = new ARC4(key);

  // This function returns a random double in [0, 1) that contains
  // randomness in every bit of the mantissa of the IEEE 754 value.
  var prng = function() {
    var n = arc4.g(chunks),             // Start with a numerator n < 2 ^ 48
        d = startdenom,                 //   and denominator d = 2 ^ 48.
        x = 0;                          //   and no 'extra last byte'.
    while (n < significance) {          // Fill up all significant digits by
      n = (n + x) * width;              //   shifting numerator and
      d *= width;                       //   denominator and generating a
      x = arc4.g(1);                    //   new least-significant-byte.
    }
    while (n >= overflow) {             // To avoid rounding up, before adding
      n /= 2;                           //   last byte, shift everything
      d /= 2;                           //   right using integer math until
      x >>>= 1;                         //   we have exactly the desired bits.
    }
    return (n + x) / d;                 // Form the number within [0, 1).
  };

  prng.int32 = function() { return arc4.g(4) | 0; }
  prng.quick = function() { return arc4.g(4) / 0x100000000; }
  prng.double = prng;

  // Mix the randomness into accumulated entropy.
  mixkey(tostring(arc4.S), pool);

  // Calling convention: what to return as a function of prng, seed, is_math.
  return (options.pass || callback ||
      function(prng, seed, is_math_call, state) {
        if (state) {
          // Load the arc4 state from the given state if it has an S array.
          if (state.S) { copy(state, arc4); }
          // Only provide the .state method if requested via options.state.
          prng.state = function() { return copy(arc4, {}); }
        }

        // If called as a method of Math (Math.seedrandom()), mutate
        // Math.random because that is how seedrandom.js has worked since v1.0.
        if (is_math_call) { math[rngname] = prng; return seed; }

        // Otherwise, it is a newer calling convention, so return the
        // prng directly.
        else return prng;
      })(
  prng,
  shortseed,
  'global' in options ? options.global : (this == math),
  options.state);
}

//
// ARC4
//
// An ARC4 implementation.  The constructor takes a key in the form of
// an array of at most (width) integers that should be 0 <= x < (width).
//
// The g(count) method returns a pseudorandom integer that concatenates
// the next (count) outputs from ARC4.  Its return value is a number x
// that is in the range 0 <= x < (width ^ count).
//
function ARC4(key) {
  var t, keylen = key.length,
      me = this, i = 0, j = me.i = me.j = 0, s = me.S = [];

  // The empty key [] is treated as [0].
  if (!keylen) { key = [keylen++]; }

  // Set up S using the standard key scheduling algorithm.
  while (i < width) {
    s[i] = i++;
  }
  for (i = 0; i < width; i++) {
    s[i] = s[j = mask & (j + key[i % keylen] + (t = s[i]))];
    s[j] = t;
  }

  // The "g" method returns the next (count) outputs as one number.
  (me.g = function(count) {
    // Using instance members instead of closure state nearly doubles speed.
    var t, r = 0,
        i = me.i, j = me.j, s = me.S;
    while (count--) {
      t = s[i = mask & (i + 1)];
      r = r * width + s[mask & ((s[i] = s[j = mask & (j + t)]) + (s[j] = t))];
    }
    me.i = i; me.j = j;
    return r;
    // For robust unpredictability, the function call below automatically
    // discards an initial batch of values.  This is called RC4-drop[256].
    // See http://google.com/search?q=rsa+fluhrer+response&btnI
  })(width);
}

//
// copy()
// Copies internal state of ARC4 to or from a plain object.
//
function copy(f, t) {
  t.i = f.i;
  t.j = f.j;
  t.S = f.S.slice();
  return t;
};

//
// flatten()
// Converts an object tree to nested arrays of strings.
//
function flatten(obj, depth) {
  var result = [], typ = (typeof obj), prop;
  if (depth && typ == 'object') {
    for (prop in obj) {
      try { result.push(flatten(obj[prop], depth - 1)); } catch (e) {}
    }
  }
  return (result.length ? result : typ == 'string' ? obj : obj + '\0');
}

//
// mixkey()
// Mixes a string seed into a key that is an array of integers, and
// returns a shortened string seed that is equivalent to the result key.
//
function mixkey(seed, key) {
  var stringseed = seed + '', smear, j = 0;
  while (j < stringseed.length) {
    key[mask & j] =
      mask & ((smear ^= key[mask & j] * 19) + stringseed.charCodeAt(j++));
  }
  return tostring(key);
}

//
// autoseed()
// Returns an object for autoseeding, using window.crypto and Node crypto
// module if available.
//
function autoseed() {
  try {
    var out;
    if (nodecrypto && (out = nodecrypto.randomBytes)) {
      // The use of 'out' to remember randomBytes makes tight minified code.
      out = out(width);
    } else {
      out = new Uint8Array(width);
      (global.crypto || global.msCrypto).getRandomValues(out);
    }
    return tostring(out);
  } catch (e) {
    var browser = global.navigator,
        plugins = browser && browser.plugins;
    return [+new Date, global, plugins, global.screen, tostring(pool)];
  }
}

//
// tostring()
// Converts an array of charcodes to a string
//
function tostring(a) {
  return String.fromCharCode.apply(0, a);
}

//
// When seedrandom.js is loaded, we immediately mix a few bits
// from the built-in RNG into the entropy pool.  Because we do
// not want to interfere with deterministic PRNG state later,
// seedrandom will not call math.random on its own again after
// initialization.
//
mixkey(math.random(), pool);

//
// Nodejs and AMD support: export the implementation as a module using
// either convention.
//
if ( true && module.exports) {
  module.exports = seedrandom;
  // When in node.js, try using crypto package for autoseeding.
  try {
    nodecrypto = __webpack_require__(/*! crypto */ "?d4c0");
  } catch (ex) {}
} else if (true) {
  !(__WEBPACK_AMD_DEFINE_RESULT__ = (function() { return seedrandom; }).call(exports, __webpack_require__, exports, module),
		__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));
} else // removed by dead control flow
{}


// End anonymous scope, and pass initial values.
})(
  // global: `self` in browsers (including strict mode and web workers),
  // otherwise `this` in Node and other environments
  (typeof self !== 'undefined') ? self : this,
  [],     // pool: entropy pool starts empty
  Math    // math: package containing random, pow, and seedrandom
);


/***/ },

/***/ "./node_modules/sillytavern-utils-lib/dist/character-utils.js"
/*!********************************************************************!*\
  !*** ./node_modules/sillytavern-utils-lib/dist/character-utils.js ***!
  \********************************************************************/
(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   CustomError: () => (/* binding */ c),
/* harmony export */   createCharacter: () => (/* binding */ f),
/* harmony export */   saveCharacter: () => (/* binding */ w)
/* harmony export */ });
var h = Object.defineProperty;
var p = (e, t, a) => t in e ? h(e, t, { enumerable: !0, configurable: !0, writable: !0, value: a }) : e[t] = a;
var n = (e, t, a) => p(e, typeof t != "symbol" ? t + "" : t, a);
class c extends Error {
  constructor(a, s) {
    super(a);
    n(this, "data");
    this.data = s;
  }
  toString() {
    return this.message;
  }
}
async function f(e, t) {
  const a = SillyTavern.getContext(), s = new FormData();
  s.append("avatar", new Blob([JSON.stringify(e)], { type: "application/json" }), "character.json"), s.append("file_type", "json");
  const r = a.getRequestHeaders();
  delete r["Content-Type"];
  const o = await fetch("/api/characters/import", {
    method: "POST",
    headers: r,
    body: s,
    cache: "no-cache"
  });
  if (!o.ok)
    throw new c(o.statusText, o);
  t && await a.getCharacters();
}
async function w(e, t) {
  var o;
  const a = SillyTavern.getContext();
  if (!e.avatar)
    throw new Error("`data.avatar` (character filename) is required to save character attributes.");
  e == null || delete e.json_data, (o = e == null ? void 0 : e.data) == null || delete o.json_data;
  const s = a.getRequestHeaders(), r = await fetch("/api/characters/merge-attributes", {
    method: "POST",
    headers: s,
    body: JSON.stringify(e),
    cache: "no-cache"
  });
  if (!r.ok) {
    const i = await r.json().catch(() => ({ message: r.statusText }));
    throw new c(i.message || `Request failed with status ${r.status}`, r);
  }
  t && await a.getCharacters();
}



/***/ },

/***/ "./node_modules/sillytavern-utils-lib/dist/config.js"
/*!***********************************************************!*\
  !*** ./node_modules/sillytavern-utils-lib/dist/config.js ***!
  \***********************************************************/
(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   STPopup: () => (/* reexport safe */ _popup_js__WEBPACK_IMPORTED_MODULE_14__.Popup),
/* harmony export */   SlashCommandEnumValue: () => (/* reexport safe */ _slash_commands_SlashCommandEnumValue_js__WEBPACK_IMPORTED_MODULE_13__.SlashCommandEnumValue),
/* harmony export */   WI_METADATA_KEY: () => (/* reexport safe */ _world_info_js__WEBPACK_IMPORTED_MODULE_2__.METADATA_KEY),
/* harmony export */   characters: () => (/* reexport safe */ _script_js__WEBPACK_IMPORTED_MODULE_1__.characters),
/* harmony export */   commonEnumProviders: () => (/* reexport safe */ _slash_commands_SlashCommandCommonEnumsProvider_js__WEBPACK_IMPORTED_MODULE_12__.commonEnumProviders),
/* harmony export */   depth_prompt_depth_default: () => (/* reexport safe */ _script_js__WEBPACK_IMPORTED_MODULE_1__.depth_prompt_depth_default),
/* harmony export */   depth_prompt_role_default: () => (/* reexport safe */ _script_js__WEBPACK_IMPORTED_MODULE_1__.depth_prompt_role_default),
/* harmony export */   dialogPolyfill: () => (/* reexport safe */ _lib_dialog_polyfill_esm_js__WEBPACK_IMPORTED_MODULE_15__["default"]),
/* harmony export */   enumIcons: () => (/* reexport safe */ _slash_commands_SlashCommandCommonEnumsProvider_js__WEBPACK_IMPORTED_MODULE_12__.enumIcons),
/* harmony export */   enumTypes: () => (/* reexport safe */ _slash_commands_SlashCommandEnumValue_js__WEBPACK_IMPORTED_MODULE_13__.enumTypes),
/* harmony export */   extension_prompt_types: () => (/* reexport safe */ _script_js__WEBPACK_IMPORTED_MODULE_1__.extension_prompt_types),
/* harmony export */   fixToastrForDialogs: () => (/* reexport safe */ _popup_js__WEBPACK_IMPORTED_MODULE_14__.fixToastrForDialogs),
/* harmony export */   groups: () => (/* reexport safe */ _group_chats_js__WEBPACK_IMPORTED_MODULE_9__.groups),
/* harmony export */   is_group_generating: () => (/* reexport safe */ _group_chats_js__WEBPACK_IMPORTED_MODULE_9__.is_group_generating),
/* harmony export */   main_api: () => (/* reexport safe */ _script_js__WEBPACK_IMPORTED_MODULE_1__.main_api),
/* harmony export */   name1: () => (/* reexport safe */ _script_js__WEBPACK_IMPORTED_MODULE_1__.name1),
/* harmony export */   name2: () => (/* reexport safe */ _script_js__WEBPACK_IMPORTED_MODULE_1__.name2),
/* harmony export */   persona_description_positions: () => (/* reexport safe */ _power_user_js__WEBPACK_IMPORTED_MODULE_0__.persona_description_positions),
/* harmony export */   regex_placement: () => (/* reexport safe */ _regex_engine_js__WEBPACK_IMPORTED_MODULE_10__.regex_placement),
/* harmony export */   removeFromArray: () => (/* reexport safe */ _utils_js__WEBPACK_IMPORTED_MODULE_11__.removeFromArray),
/* harmony export */   runAfterAnimation: () => (/* reexport safe */ _utils_js__WEBPACK_IMPORTED_MODULE_11__.runAfterAnimation),
/* harmony export */   selected_group: () => (/* reexport safe */ _group_chats_js__WEBPACK_IMPORTED_MODULE_9__.selected_group),
/* harmony export */   selected_world_info: () => (/* reexport safe */ _world_info_js__WEBPACK_IMPORTED_MODULE_2__.selected_world_info),
/* harmony export */   sendChatMessage: () => (/* binding */ Pt),
/* harmony export */   st_appendFileContent: () => (/* binding */ vt),
/* harmony export */   st_baseChatReplace: () => (/* binding */ lt),
/* harmony export */   st_createNewWorldInfo: () => (/* binding */ wt),
/* harmony export */   st_createWorldInfoEntry: () => (/* binding */ At),
/* harmony export */   st_echo: () => (/* binding */ it),
/* harmony export */   st_formatInstructModeExamples: () => (/* binding */ ut),
/* harmony export */   st_formatInstructModeSystemPrompt: () => (/* binding */ ct),
/* harmony export */   st_formatWorldInfo: () => (/* binding */ Ct),
/* harmony export */   st_getAuthorNote: () => (/* binding */ dt),
/* harmony export */   st_getCharaFilename: () => (/* binding */ It),
/* harmony export */   st_getGlobalVariable: () => (/* binding */ Wt),
/* harmony export */   st_getGroupDepthPrompts: () => (/* binding */ gt),
/* harmony export */   st_getLocalVariable: () => (/* binding */ Tt),
/* harmony export */   st_getMaxContextSize: () => (/* binding */ pt),
/* harmony export */   st_getPromptPosition: () => (/* binding */ bt),
/* harmony export */   st_getPromptRole: () => (/* binding */ _t),
/* harmony export */   st_getRegexedString: () => (/* binding */ yt),
/* harmony export */   st_hideChatMessageRange: () => (/* binding */ Nt),
/* harmony export */   st_parseMesExamples: () => (/* binding */ mt),
/* harmony export */   st_prepareOpenAIMessages: () => (/* binding */ xt),
/* harmony export */   st_renderStoryString: () => (/* binding */ ft),
/* harmony export */   st_runCommandCallback: () => (/* binding */ q),
/* harmony export */   st_runRegexScript: () => (/* binding */ St),
/* harmony export */   st_setGlobalVariable: () => (/* binding */ Rt),
/* harmony export */   st_setLocalVariable: () => (/* binding */ Et),
/* harmony export */   st_setOpenAIMessageExamples: () => (/* binding */ Mt),
/* harmony export */   st_setOpenAIMessages: () => (/* binding */ ht),
/* harmony export */   st_updateMessageBlock: () => (/* binding */ Ft),
/* harmony export */   systemUserName: () => (/* reexport safe */ _script_js__WEBPACK_IMPORTED_MODULE_1__.systemUserName),
/* harmony export */   system_avatar: () => (/* reexport safe */ _script_js__WEBPACK_IMPORTED_MODULE_1__.system_avatar),
/* harmony export */   this_chid: () => (/* reexport safe */ _script_js__WEBPACK_IMPORTED_MODULE_1__.this_chid),
/* harmony export */   user_avatar: () => (/* reexport safe */ _personas_js__WEBPACK_IMPORTED_MODULE_4__.user_avatar),
/* harmony export */   wi_anchor_position: () => (/* reexport safe */ _world_info_js__WEBPACK_IMPORTED_MODULE_2__.wi_anchor_position),
/* harmony export */   world_info: () => (/* reexport safe */ _world_info_js__WEBPACK_IMPORTED_MODULE_2__.world_info),
/* harmony export */   world_info_include_names: () => (/* reexport safe */ _world_info_js__WEBPACK_IMPORTED_MODULE_2__.world_info_include_names),
/* harmony export */   world_names: () => (/* reexport safe */ _world_info_js__WEBPACK_IMPORTED_MODULE_2__.world_names)
/* harmony export */ });
/* harmony import */ var _power_user_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../../../power-user.js */ "../../../../power-user.js");
/* harmony import */ var _script_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../../../../script.js */ "../../../../../script.js");
/* harmony import */ var _world_info_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../../../world-info.js */ "../../../../world-info.js");
/* harmony import */ var _slash_commands_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../../../../slash-commands.js */ "../../../../slash-commands.js");
/* harmony import */ var _personas_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../../../../personas.js */ "../../../../personas.js");
/* harmony import */ var _instruct_mode_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../../../../instruct-mode.js */ "../../../../instruct-mode.js");
/* harmony import */ var _chats_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ../../../../chats.js */ "../../../../chats.js");
/* harmony import */ var _openai_js__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ../../../../openai.js */ "../../../../openai.js");
/* harmony import */ var _authors_note_js__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ../../../../authors-note.js */ "../../../../authors-note.js");
/* harmony import */ var _group_chats_js__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ../../../../group-chats.js */ "../../../../group-chats.js");
/* harmony import */ var _regex_engine_js__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! ../../../regex/engine.js */ "../../../regex/engine.js");
/* harmony import */ var _utils_js__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(/*! ../../../../utils.js */ "../../../../utils.js");
/* harmony import */ var _slash_commands_SlashCommandCommonEnumsProvider_js__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__(/*! ../../../../slash-commands/SlashCommandCommonEnumsProvider.js */ "../../../../slash-commands/SlashCommandCommonEnumsProvider.js");
/* harmony import */ var _slash_commands_SlashCommandEnumValue_js__WEBPACK_IMPORTED_MODULE_13__ = __webpack_require__(/*! ../../../../slash-commands/SlashCommandEnumValue.js */ "../../../../slash-commands/SlashCommandEnumValue.js");
/* harmony import */ var _popup_js__WEBPACK_IMPORTED_MODULE_14__ = __webpack_require__(/*! ../../../../popup.js */ "../../../../popup.js");
/* harmony import */ var _lib_dialog_polyfill_esm_js__WEBPACK_IMPORTED_MODULE_15__ = __webpack_require__(/*! ../../../../../lib/dialog-polyfill.esm.js */ "../../../../../lib/dialog-polyfill.esm.js");























async function q(t, ...e) {
  await SillyTavern.getContext().SlashCommandParser.commands[t].callback(...e);
}
async function it(t, e, { escapeHtml: r = !0 } = {}) {
  await q("echo", { severity: t, escapeHtml: (!!r).toString() }, e);
}
function pt(t) {
  return (0,_script_js__WEBPACK_IMPORTED_MODULE_1__.getMaxContextSize)(t);
}
function mt(t, e) {
  return (0,_script_js__WEBPACK_IMPORTED_MODULE_1__.parseMesExamples)(t, e);
}
function lt(t, e, r) {
  return (0,_script_js__WEBPACK_IMPORTED_MODULE_1__.baseChatReplace)(t, e, r);
}
function ut(t, e, r) {
  return (0,_instruct_mode_js__WEBPACK_IMPORTED_MODULE_5__.formatInstructModeExamples)(t, e, r);
}
function ct(t, e) {
  return (0,_instruct_mode_js__WEBPACK_IMPORTED_MODULE_5__.formatInstructModeSystemPrompt)(t, e);
}
function ft(t, {
  customStoryString: e,
  customInstructSettings: r
} = {}) {
  return (0,_power_user_js__WEBPACK_IMPORTED_MODULE_0__.renderStoryString)(t, { customStoryString: e, customInstructSettings: r });
}
function _t(t) {
  return (0,_openai_js__WEBPACK_IMPORTED_MODULE_7__.getPromptRole)(t);
}
function dt() {
  return {
    prompt: _script_js__WEBPACK_IMPORTED_MODULE_1__.chat_metadata[_authors_note_js__WEBPACK_IMPORTED_MODULE_8__.metadata_keys.prompt],
    interval: _script_js__WEBPACK_IMPORTED_MODULE_1__.chat_metadata[_authors_note_js__WEBPACK_IMPORTED_MODULE_8__.metadata_keys.interval],
    position: _script_js__WEBPACK_IMPORTED_MODULE_1__.chat_metadata[_authors_note_js__WEBPACK_IMPORTED_MODULE_8__.metadata_keys.position],
    depth: _script_js__WEBPACK_IMPORTED_MODULE_1__.chat_metadata[_authors_note_js__WEBPACK_IMPORTED_MODULE_8__.metadata_keys.depth],
    role: _script_js__WEBPACK_IMPORTED_MODULE_1__.chat_metadata[_authors_note_js__WEBPACK_IMPORTED_MODULE_8__.metadata_keys.role]
  };
}
function gt(t, e) {
  return (0,_group_chats_js__WEBPACK_IMPORTED_MODULE_9__.getGroupDepthPrompts)(t, e);
}
function xt({
  name2: t,
  charDescription: e,
  charPersonality: r,
  Scenario: a,
  worldInfoBefore: n,
  worldInfoAfter: s,
  bias: i,
  type: m,
  quietPrompt: l,
  quietImage: u,
  extensionPrompts: c,
  cyclePrompt: f,
  systemPromptOverride: _,
  jailbreakPromptOverride: d,
  personaDescription: g,
  messages: x,
  messageExamples: h
}, M) {
  return (0,_openai_js__WEBPACK_IMPORTED_MODULE_7__.prepareOpenAIMessages)(
    {
      name2: t,
      charDescription: e,
      charPersonality: r,
      Scenario: a,
      worldInfoBefore: n,
      worldInfoAfter: s,
      bias: i,
      type: m,
      quietPrompt: l,
      quietImage: u,
      cyclePrompt: f,
      systemPromptOverride: _,
      jailbreakPromptOverride: d,
      personaDescription: g,
      extensionPrompts: c,
      messages: x,
      messageExamples: h
    },
    M
  );
}
function ht(t) {
  return (0,_openai_js__WEBPACK_IMPORTED_MODULE_7__.setOpenAIMessages)(t);
}
function Mt(t) {
  return (0,_openai_js__WEBPACK_IMPORTED_MODULE_7__.setOpenAIMessageExamples)(t);
}
function yt(t, e, {
  characterOverride: r,
  isMarkdown: a,
  isPrompt: n,
  isEdit: s,
  depth: i
}) {
  return (0,_regex_engine_js__WEBPACK_IMPORTED_MODULE_10__.getRegexedString)(t, e, { characterOverride: r, isMarkdown: a, isPrompt: n, isEdit: s, depth: i });
}
function St(t, e, { characterOverride: r = null } = {}) {
  return (0,_regex_engine_js__WEBPACK_IMPORTED_MODULE_10__.runRegexScript)(t, e, { characterOverride: r });
}
async function vt(t, e) {
  return await (0,_chats_js__WEBPACK_IMPORTED_MODULE_6__.appendFileContent)(t, e);
}
function Ct(t, {
  wiFormat: e
} = {}) {
  return (0,_openai_js__WEBPACK_IMPORTED_MODULE_7__.formatWorldInfo)(t, { wiFormat: e });
}
function bt(t) {
  return (0,_openai_js__WEBPACK_IMPORTED_MODULE_7__.getPromptPosition)(t);
}
function It(t, {
  manualAvatarKey: e
} = {}) {
  return (0,_utils_js__WEBPACK_IMPORTED_MODULE_11__.getCharaFilename)(t, { manualAvatarKey: e });
}
function At(t, e) {
  return (0,_world_info_js__WEBPACK_IMPORTED_MODULE_2__.createWorldInfoEntry)(t, e);
}
async function wt(t, { interactive: e = !1 } = {}) {
  return await (0,_world_info_js__WEBPACK_IMPORTED_MODULE_2__.createNewWorldInfo)(t, { interactive: e });
}
async function Pt(t, e, r, a, n) {
  if (e === "user")
    await (0,_script_js__WEBPACK_IMPORTED_MODULE_1__.sendMessageAsUser)(t, null, n, !1, r ?? _script_js__WEBPACK_IMPORTED_MODULE_1__.name1, _personas_js__WEBPACK_IMPORTED_MODULE_4__.user_avatar ?? a);
  else if (e === "assistant") {
    const s = r ?? _script_js__WEBPACK_IMPORTED_MODULE_1__.name2, i = a ?? SillyTavern.getContext().characters[_script_js__WEBPACK_IMPORTED_MODULE_1__.this_chid].avatar;
    await (0,_slash_commands_js__WEBPACK_IMPORTED_MODULE_3__.sendMessageAs)({ name: s, at: n, avatar: i }, t);
  } else
    await (0,_slash_commands_js__WEBPACK_IMPORTED_MODULE_3__.sendNarratorMessage)({ name: r, at: n }, t);
}
function Et(t, e) {
  _script_js__WEBPACK_IMPORTED_MODULE_1__.chat_metadata.variables || (_script_js__WEBPACK_IMPORTED_MODULE_1__.chat_metadata.variables = {}), _script_js__WEBPACK_IMPORTED_MODULE_1__.chat_metadata.variables[t] = e;
}
function Tt(t) {
  var e, r;
  return (r = (e = _script_js__WEBPACK_IMPORTED_MODULE_1__.chat_metadata) == null ? void 0 : e.variables) == null ? void 0 : r[t];
}
function Rt(t, e) {
  const r = SillyTavern.getContext();
  r.extensionSettings.variables.global[t] = e;
}
function Wt(t) {
  return SillyTavern.getContext().extensionSettings.variables.global[t];
}
function Ft(t, e, { rerenderMessage: r = !0 } = {}) {
  (0,_script_js__WEBPACK_IMPORTED_MODULE_1__.updateMessageBlock)(t, e, { rerenderMessage: r });
}
async function Nt(t, e, r) {
  await (0,_chats_js__WEBPACK_IMPORTED_MODULE_6__.hideChatMessageRange)(t, e, r);
}



/***/ },

/***/ "./node_modules/sillytavern-utils-lib/dist/extension-settings-manager.js"
/*!*******************************************************************************!*\
  !*** ./node_modules/sillytavern-utils-lib/dist/extension-settings-manager.js ***!
  \*******************************************************************************/
(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   ExtensionSettingsManager: () => (/* binding */ m)
/* harmony export */ });
var S = Object.defineProperty;
var d = (c, o, a) => o in c ? S(c, o, { enumerable: !0, configurable: !0, writable: !0, value: a }) : c[o] = a;
var u = (c, o, a) => d(c, typeof o != "symbol" ? o + "" : o, a);
class m {
  constructor(o, a) {
    u(this, "settingsKey");
    u(this, "defaultSettings");
    this.settingsKey = o, this.defaultSettings = a;
  }
  /**
   * If defaultSettings has "version" and "formatVersion" properties, they will be used to track version and format version changes.
   *
   * For example, if you want to show a notification when a new version is released, you can check "result.version.changed".
   *
   * @param [options={}]
   * @param [options.strategy='recursive'] - 'recursive' will migrate old settings with the default settings.
   *
   * For complex settings, you can specify a custom migration strategy. For example, if you change the field name from "old" to "new", you can use:
   * @example
   * [
   *   {
   *     from: 'FORMAT-0.1.0',
   *     to: 'FORMAT-0.1.1',
   *     action: (previous) => {
   *       const data = {
   *         ...previous,
   *         new: previous.old,
   *       };
   *       delete data.old;
   *       return data;
   *     },
   *   },
   * ]
   */
  async initializeSettings(o = {}) {
    const { strategy: a = "recursive" } = o, l = this.defaultSettings.version, g = this.defaultSettings.formatVersion, e = SillyTavern.getContext().extensionSettings[this.settingsKey], h = {
      version: {
        changed: !1,
        new: l ?? ""
      },
      formatVersion: {
        changed: !1,
        new: g ?? ""
      },
      oldSettings: null,
      newSettings: this.defaultSettings
    };
    if (!e)
      return SillyTavern.getContext().extensionSettings[this.settingsKey] = this.defaultSettings, this.saveSettings(), h;
    const s = {
      ...h,
      oldSettings: structuredClone(e),
      version: {
        changed: !1,
        old: e.version,
        new: e.version
      },
      formatVersion: {
        changed: !1,
        old: e.formatVersion,
        new: e.formatVersion
      }
    };
    if (a === "recursive") {
      let f = function(i, n) {
        let r = !1;
        for (const t of Object.keys(n))
          i[t] === void 0 ? (i[t] = n[t], r = !0) : typeof n[t] == "object" && n[t] !== null && (i[t] = i[t] || {}, f(i[t], n[t]) && (r = !0));
        return r;
      };
      l && e.version !== l && (s.version.changed = !0, s.version.new = l, e.version = l), g && g !== "*" && e.formatVersion !== g && (s.formatVersion.changed = !0, s.formatVersion.new = g, e.formatVersion = g), (f(e, this.defaultSettings) || s.version.changed || s.formatVersion.changed) && this.saveSettings();
    } else if (Array.isArray(a)) {
      l && !e.version && (e.version = l, s.version.changed = !0, s.version.new = l), g && !e.formatVersion && (e.formatVersion = g, s.formatVersion.changed = !0, s.formatVersion.new = g);
      let f = structuredClone(e), i = e.formatVersion;
      try {
        let n;
        do {
          n = !1;
          let r = a.find((t) => t.from === i);
          if (r && r.to > i)
            f = await r.action(f), i = r.to, f.formatVersion = r.to, n = !0;
          else
            for (const t of a)
              if (t.from === "*" && t.to > i && i !== t.to) {
                f = await t.action(f), i = t.to, f.formatVersion = t.to, n = !0;
                break;
              }
        } while (n);
        if (i !== e.formatVersion) {
          s.formatVersion.changed = !0, s.formatVersion.new = i;
          const r = this.defaultSettings.version;
          r && (f.version = r);
        }
        if (s.formatVersion.changed) {
          for (const r of Object.keys(e))
            delete e[r];
          Object.assign(e, f), this.saveSettings();
        }
      } catch (n) {
        throw console.error("Failed to apply version changes:", n), new Error(`Version migration failed: ${n instanceof Error ? n.message : n}`, {
          cause: n
        });
      }
    }
    return s.newSettings = e, s;
  }
  getSettings() {
    return SillyTavern.getContext().extensionSettings[this.settingsKey];
  }
  updateSetting(o, a) {
    SillyTavern.getContext().extensionSettings[this.settingsKey][o] = a, this.saveSettings();
  }
  saveSettings() {
    SillyTavern.getContext().saveSettingsDebounced();
  }
  resetSettings() {
    SillyTavern.getContext().extensionSettings[this.settingsKey] = this.defaultSettings, this.saveSettings();
  }
}



/***/ },

/***/ "./node_modules/sillytavern-utils-lib/dist/fancy-dropdown.js"
/*!*******************************************************************!*\
  !*** ./node_modules/sillytavern-utils-lib/dist/fancy-dropdown.js ***!
  \*******************************************************************/
(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   buildFancyDropdown: () => (/* binding */ K)
/* harmony export */ });
/* harmony import */ var fuse_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! fuse.js */ "./node_modules/fuse.js/dist/fuse.mjs");

function K(E, s = {}) {
  const d = typeof E == "string" ? document.querySelector(E) : E;
  if (!d)
    throw new Error(`Could not find container: ${E}`);
  const j = s.placeholderText || "Select items...", M = s.closeOnSelect ?? !1, u = s.enableSearch ?? !1, N = s.multiple ?? !0, q = s.searchPlaceholderText || "Search...", J = s.searchNoResultsText || "No results found", R = s.searchDebounceMs ?? 200;
  let c = [...s.initialList || []];
  d.innerHTML = "", d.classList.add("fancy-dropdown-container"), Object.assign(d.style, {
    position: "relative",
    userSelect: "none"
    // Note: 'user-select' becomes 'userSelect'
  });
  const x = document.createElement("div");
  x.className = "fancy-dropdown-trigger", Object.assign(x.style, {
    padding: "8px 12px",
    border: "1px solid var(--border-color)",
    backgroundColor: "var(--bg-color)",
    color: "var(--text-color)",
    borderRadius: "4px",
    cursor: "pointer",
    display: "flex",
    alignItems: "center",
    justifyContent: "space-between"
  });
  const S = document.createElement("span");
  S.className = "fancy-dropdown-trigger-text", S.textContent = j;
  const b = document.createElement("i");
  b.className = "fas fa-chevron-down", b.style.marginLeft = "8px", x.append(S, b), d.append(x);
  const f = document.createElement("div");
  f.className = "fancy-dropdown-list", Object.assign(f.style, {
    position: "absolute",
    top: "100%",
    left: "0",
    right: "0",
    maxHeight: "300px",
    display: "none",
    // Hidden by default
    zIndex: "1050",
    border: "1px solid var(--border-color)",
    borderTop: "none",
    backgroundColor: "var(--bg-color-popup, var(--bg-color-secondary, var(--greyCAIbg, var(--grey30))))",
    color: "var(--text-color)",
    borderRadius: "0 0 4px 4px",
    boxShadow: "0 4px 8px var(--black50a)",
    overflowY: "auto"
  }), d.append(f);
  let n = null, O = null, g = null, L = null;
  u && (O = document.createElement("div"), O.className = "fancy-dropdown-search-wrapper", Object.assign(O.style, {
    padding: "8px",
    borderBottom: "1px solid var(--border-color)",
    // Separator
    position: "sticky",
    // Keep search bar visible while scrolling options
    top: "0",
    // Stick to the top of the list container
    backgroundColor: "inherit"
    // Inherit background from list
  }), n = document.createElement("input"), n.type = "text", n.className = "fancy-dropdown-search-input", n.placeholder = q, Object.assign(n.style, {
    width: "100%",
    padding: "6px 10px",
    border: "1px solid var(--border-color)",
    borderRadius: "3px",
    boxSizing: "border-box",
    // Include padding/border in width
    backgroundColor: "var(--bg-color)",
    // Use main bg for input
    color: "var(--text-color)"
  }), n.addEventListener("click", (e) => e.stopPropagation()), O.append(n), f.append(O), g = document.createElement("div"), g.className = "fancy-dropdown-no-results", g.textContent = J, Object.assign(g.style, {
    padding: "8px 12px",
    textAlign: "center",
    color: "var(--text-color-secondary, var(--grey50))",
    // Dimmer text color
    display: "none"
    // Hidden initially
  }), f.append(g));
  let y = !1, T = null;
  const F = (e) => typeof e == "string" ? e : e.label, v = (e) => typeof e == "string" ? e : e.value;
  let t = (s.initialValues || []).filter(
    (e) => c.some((a) => v(a) === e)
  );
  const I = () => {
    var r, o;
    if (!u) return;
    const e = {
      // Default Fuse.js options - allow overriding
      includeScore: !1,
      threshold: 0.4,
      isCaseSensitive: !1,
      findAllMatches: !0,
      ...s.searchFuseOptions || {},
      // Ensure keys handle both string and object types if not overridden
      keys: ((r = s.searchFuseOptions) == null ? void 0 : r.keys) || [
        { name: "label", weight: 0.7 },
        { name: "value", weight: 0.3 }
      ]
    }, a = c.map(
      (l) => typeof l == "string" ? { value: l, label: l } : l
    );
    !((o = s.searchFuseOptions) != null && o.keys) && c.every((l) => typeof l == "string") && (e.keys = ["label"]), T = new fuse_js__WEBPACK_IMPORTED_MODULE_0__["default"](a, e);
  }, z = () => {
    if (t.length === 0)
      S.textContent = j;
    else if (t.length === 1) {
      const e = t[0], a = c.find((o) => v(o) === e), r = a ? F(a) : e;
      S.textContent = r;
    } else
      S.textContent = `${t.length} items selected`;
  }, h = (e) => {
    let a = !1;
    f.querySelectorAll(".fancy-dropdown-item").forEach((o) => {
      const l = o.dataset.value, i = t.includes(l), p = o.querySelector(".checkmark");
      i ? (o.classList.add("selected"), p && (p.style.display = "inline-block")) : (o.classList.remove("selected"), p && (p.style.display = "none")), e !== void 0 ? e.includes(l) ? (o.style.display = "flex", a = !0) : o.style.display = "none" : (o.style.display = "flex", a = !0);
    }), u && g && (e !== void 0 && !a ? g.style.display = "block" : g.style.display = "none"), z();
  }, m = (e) => {
    if (!u || !T) {
      h();
      return;
    }
    const a = e.trim();
    if (a === "") {
      h(void 0);
      return;
    }
    const o = T.search(a).map((l) => l.item.value);
    h(o);
  }, $ = () => {
    n && (L && clearTimeout(L), L = window.setTimeout(() => {
      n && m(n.value);
    }, R));
  }, P = () => {
    y || (y = !0, f.style.display = "block", b.classList.remove("fa-chevron-down"), b.classList.add("fa-chevron-up"), u && n && setTimeout(() => n == null ? void 0 : n.focus(), 50));
  }, C = () => {
    y && (y = !1, f.style.display = "none", u && n && (n.value = "", m("")), b.classList.remove("fa-chevron-up"), b.classList.add("fa-chevron-down"), L && clearTimeout(L));
  };
  x.addEventListener("click", (e) => {
    e.stopPropagation(), y ? C() : P();
  }), document.addEventListener("click", (e) => {
    y && d && !d.contains(e.target) && C();
  }), u && n && n.addEventListener("input", $);
  const A = (e, a) => {
    const r = v(e), o = F(e), l = document.createElement("div");
    l.className = "fancy-dropdown-item", l.dataset.value = r, Object.assign(l.style, {
      padding: "8px 12px",
      cursor: "pointer",
      display: "flex",
      alignItems: "center",
      justifyContent: "space-between"
    }), l.addEventListener("mouseenter", () => {
      l.style.backgroundColor = "var(--hover-color, var(--white20a))";
    }), l.addEventListener("mouseleave", () => {
      l.style.backgroundColor = "";
    });
    const i = document.createElement("span");
    i.textContent = o, l.append(i);
    const p = document.createElement("i");
    return p.className = "checkmark fa-solid fa-check", Object.assign(p.style, {
      marginLeft: "8px",
      display: a ? "inline-block" : "none"
    }), l.append(p), l.addEventListener("click", function(D) {
      D.stopPropagation();
      const V = D.currentTarget.dataset.value, B = [...t];
      let k;
      N ? t.includes(V) ? k = t.filter((w) => w !== V) : k = [...t, V] : t.includes(V) ? k = [] : k = [V], (async () => {
        if (s.onBeforeSelection)
          try {
            if (!await Promise.resolve(s.onBeforeSelection(B, k)))
              return !1;
          } catch (w) {
            return console.error("onBeforeSelection callback failed:", w), !1;
          }
        return !0;
      })().then((w) => {
        w && (t = k, u && n && n.value.trim() !== "" ? m(n.value) : h(void 0), s.onSelectChange && Promise.resolve(s.onSelectChange(B, t)).catch(
          (H) => console.error("onSelectChange callback failed:", H)
        ), M && C());
      });
    }), g ? f.insertBefore(l, g) : f.append(l), l;
  };
  return c.length > 0 && c.forEach((e) => {
    const a = v(e);
    A(e, t.includes(a));
  }), I(), h(), {
    container: d,
    // Expose the main container element
    dropdownTrigger: x,
    // Expose trigger element
    dropdownList: f,
    // Expose list element
    getValues: () => [...t],
    setValues: (e) => {
      const a = [...t];
      t = [...e.filter((l) => c.some((i) => v(i) === l))], u && n && n.value !== "" ? (n.value = "", m("")) : h(), JSON.stringify(a.sort()) !== JSON.stringify(t.sort()) && s.onSelectChange && Promise.resolve(s.onSelectChange(a, t)).catch(
        (l) => console.error("onSelectChange callback failed:", l)
      );
    },
    getOptions: () => c.map((e) => typeof e == "string" ? { value: e, label: e } : e),
    addOption: (e, a = !1) => {
      const r = v(e);
      if (c.some((i) => v(i) === r)) return;
      c.push(e), A(e, a), I();
      let o = !1;
      const l = [...t];
      a && !t.includes(r) ? (N ? t.push(r) : t = [r], o = !0) : a && !N && t.length > 0 && t[0] !== r && (t = [r], o = !0), u && n && n.value !== "" ? m(n.value) : h(), o && s.onSelectChange && Promise.resolve(s.onSelectChange(l, t)).catch(
        (i) => console.error("onSelectChange callback failed:", i)
      );
    },
    removeOption: (e) => {
      const a = c.length;
      if (c = c.filter((p) => v(p) !== e), c.length === a) return;
      let r = !1;
      const o = [...t], l = t.indexOf(e);
      l > -1 && (t.splice(l, 1), r = !0);
      const i = f.querySelector(
        `.fancy-dropdown-item[data-value="${e}"]`
      );
      i == null || i.remove(), I(), u && n && n.value !== "" ? m(n.value) : h(), r && s.onSelectChange && Promise.resolve(s.onSelectChange(o, t)).catch(
        (p) => console.error("onSelectChange callback failed:", p)
      );
    },
    selectAll: () => {
      if (!N) return;
      const e = [...t], a = c.map(v);
      t = [.../* @__PURE__ */ new Set([...t, ...a])];
      const r = JSON.stringify(e.sort()) !== JSON.stringify(t.sort());
      u && n && n.value !== "" ? m(n.value) : h(), r && s.onSelectChange && Promise.resolve(s.onSelectChange(e, t)).catch(
        (o) => console.error("onSelectChange callback failed:", o)
      );
    },
    deselectAll: () => {
      const e = [...t];
      t.length > 0 && (t = [], u && n && n.value !== "" ? m(n.value) : h(), s.onSelectChange && Promise.resolve(s.onSelectChange(e, t)).catch(
        (a) => console.error("onSelectChange callback failed:", a)
      ));
    },
    disable: () => {
      d.style.pointerEvents = "none", d.style.opacity = "0.6", y && C();
    },
    enable: () => {
      d.style.pointerEvents = "auto", d.style.opacity = "1";
    },
    open: P,
    close: C,
    toggle: () => y ? C() : P()
  };
}



/***/ },

/***/ "./node_modules/sillytavern-utils-lib/dist/generate.js"
/*!*************************************************************!*\
  !*** ./node_modules/sillytavern-utils-lib/dist/generate.js ***!
  \*************************************************************/
(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   Generator: () => (/* binding */ M)
/* harmony export */ });
var d = Object.defineProperty;
var w = (l, t, e) => t in l ? d(l, t, { enumerable: !0, configurable: !0, writable: !0, value: e }) : l[t] = e;
var u = (l, t, e) => w(l, typeof t != "symbol" ? t + "" : t, e);
class M {
  constructor() {
    u(this, "requestMap");
    this.requestMap = /* @__PURE__ */ new Map();
  }
  async abortRequest(t) {
    var a;
    const e = this.requestMap.get(t);
    if (e) {
      if (e.abortController)
        try {
          e.abortController.abort();
        } catch {
        }
      (a = e.options) != null && a.onFinish && await e.options.onFinish(t), this.requestMap.delete(t);
    }
  }
  /**
   * @returns return value is not important because request would be finished anyway. So use "options".
   */
  async generateRequest(t, e) {
    var h;
    const a = SillyTavern.getContext(), r = a.uuidv4(), n = ((h = t == null ? void 0 : t.custom) == null ? void 0 : h.stream) ?? !1;
    if (this.requestMap.set(r, {
      abortController: e == null ? void 0 : e.abortController,
      isStream: n,
      options: e
    }), n)
      try {
        const c = await a.ConnectionManagerRequestService.sendRequest(
          t.profileId,
          t.prompt,
          t.maxTokens,
          t.custom,
          t.overridePayload
        );
        e != null && e.onStart && await e.onStart(r);
        let f;
        for await (const i of c())
          f = i, e != null && e.onEntry && await e.onEntry(r, i);
        e != null && e.onFinish && await e.onFinish(r, f);
      } catch (c) {
        e != null && e.onFinish && await e.onFinish(r, void 0, c);
      } finally {
        this.requestMap.delete(r);
      }
    else
      try {
        e != null && e.onStart && await e.onStart(r);
        const c = await a.ConnectionManagerRequestService.sendRequest(
          t.profileId,
          t.prompt,
          t.maxTokens,
          t.custom,
          t.overridePayload
        );
        this.requestMap.get(r) && (e != null && e.onEntry && await e.onEntry(r, c), e != null && e.onFinish && await e.onFinish(r, c));
      } catch (c) {
        e != null && e.onFinish && await e.onFinish(r, void 0, c);
      } finally {
        this.requestMap.delete(r);
      }
    return r;
  }
  getActiveRequest(t) {
    var e;
    return (e = this.requestMap.get(t)) == null ? void 0 : e.abortController;
  }
  getAllActiveRequests() {
    const t = /* @__PURE__ */ new Map();
    for (const [e, a] of this.requestMap)
      t.set(e, a.abortController);
    return t;
  }
}



/***/ },

/***/ "./node_modules/sillytavern-utils-lib/dist/index.js"
/*!**********************************************************!*\
  !*** ./node_modules/sillytavern-utils-lib/dist/index.js ***!
  \**********************************************************/
(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   ExtensionSettingsManager: () => (/* reexport safe */ _extension_settings_manager_js__WEBPACK_IMPORTED_MODULE_1__.ExtensionSettingsManager),
/* harmony export */   Generator: () => (/* reexport safe */ _generate_js__WEBPACK_IMPORTED_MODULE_3__.Generator),
/* harmony export */   applyWorldInfoEntry: () => (/* reexport safe */ _world_info_utils_js__WEBPACK_IMPORTED_MODULE_7__.applyWorldInfoEntry),
/* harmony export */   buildFancyDropdown: () => (/* reexport safe */ _fancy_dropdown_js__WEBPACK_IMPORTED_MODULE_2__.buildFancyDropdown),
/* harmony export */   buildPresetSelect: () => (/* reexport safe */ _preset_select_js__WEBPACK_IMPORTED_MODULE_4__.buildPresetSelect),
/* harmony export */   buildPrompt: () => (/* reexport safe */ _prompt_builder_js__WEBPACK_IMPORTED_MODULE_5__.buildPrompt),
/* harmony export */   buildSortableList: () => (/* reexport safe */ _sortable_list_js__WEBPACK_IMPORTED_MODULE_6__.buildSortableList),
/* harmony export */   createCharacter: () => (/* reexport safe */ _character_utils_js__WEBPACK_IMPORTED_MODULE_0__.createCharacter),
/* harmony export */   getWorldInfo: () => (/* reexport safe */ _world_info_utils_js__WEBPACK_IMPORTED_MODULE_7__.getWorldInfo),
/* harmony export */   getWorldInfos: () => (/* reexport safe */ _world_info_utils_js__WEBPACK_IMPORTED_MODULE_7__.getWorldInfos),
/* harmony export */   saveCharacter: () => (/* reexport safe */ _character_utils_js__WEBPACK_IMPORTED_MODULE_0__.saveCharacter)
/* harmony export */ });
/* harmony import */ var _character_utils_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./character-utils.js */ "./node_modules/sillytavern-utils-lib/dist/character-utils.js");
/* harmony import */ var _extension_settings_manager_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./extension-settings-manager.js */ "./node_modules/sillytavern-utils-lib/dist/extension-settings-manager.js");
/* harmony import */ var _fancy_dropdown_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./fancy-dropdown.js */ "./node_modules/sillytavern-utils-lib/dist/fancy-dropdown.js");
/* harmony import */ var _generate_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./generate.js */ "./node_modules/sillytavern-utils-lib/dist/generate.js");
/* harmony import */ var _preset_select_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./preset-select.js */ "./node_modules/sillytavern-utils-lib/dist/preset-select.js");
/* harmony import */ var _prompt_builder_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./prompt-builder.js */ "./node_modules/sillytavern-utils-lib/dist/prompt-builder.js");
/* harmony import */ var _sortable_list_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./sortable-list.js */ "./node_modules/sillytavern-utils-lib/dist/sortable-list.js");
/* harmony import */ var _world_info_utils_js__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./world-info-utils.js */ "./node_modules/sillytavern-utils-lib/dist/world-info-utils.js");











/***/ },

/***/ "./node_modules/sillytavern-utils-lib/dist/preset-select.js"
/*!******************************************************************!*\
  !*** ./node_modules/sillytavern-utils-lib/dist/preset-select.js ***!
  \******************************************************************/
(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   buildPresetSelect: () => (/* binding */ A)
/* harmony export */ });
/* harmony import */ var _config_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./config.js */ "./node_modules/sillytavern-utils-lib/dist/config.js");

function A(y, e = {}) {
  var x;
  const C = SillyTavern.getContext(), P = e.readOnlyValues || [], a = document.querySelector(y);
  if (!a)
    throw new Error(`Could not find preset select: ${y}`);
  const i = (t) => e.label ? e.label(t) : t, u = document.createElement("div");
  u.className = "preset-select-container", u.style.display = "flex", u.style.alignItems = "center";
  const g = (t) => P.includes(t);
  if ((x = a.parentNode) == null || x.insertBefore(u, a), u.appendChild(a), e.initialList && e.initialList.length > 0) {
    a.innerHTML = "";
    const t = (r) => typeof r == "string" ? r : r.value;
    for (const r of e.initialList) {
      const c = document.createElement("option"), n = t(r);
      c.value = n, c.textContent = i(n), g(n) && (c.dataset.readonly = "true"), a.appendChild(c);
    }
  }
  if (e.initialValue) {
    const t = Array.from(a.options).find((r) => r.value === e.initialValue);
    t && (a.value = t.value);
  }
  let m = a.value;
  if (a.addEventListener("change", async () => {
    const t = a.value;
    e.onSelectChange && m !== t && await e.onSelectChange(m, t), m = t;
  }), e.create) {
    const t = document.createElement("i");
    t.className = "menu_button fa-solid fa-file-circle-plus";
    const r = i("");
    t.title = `Create a new ${r}`, t.setAttribute("data-i18n", `[title]Create a new ${r}`), t.addEventListener("click", async () => {
      var f, h, d;
      (f = e.create) != null && f.onPopupOpen && await e.create.onPopupOpen();
      const c = i(""), n = await C.Popup.show.input(
        `Create a new ${c}`,
        `Please enter a name for the new ${c}:`,
        ""
      );
      if (n === null || n.trim() === "") return;
      let l = n.trim();
      if (Array.from(a.options).some((p) => p.value === l)) {
        await (0,_config_js__WEBPACK_IMPORTED_MODULE_0__.st_echo)("warning", `A ${i(l)} with this name already exists.`);
        return;
      }
      if ((h = e.create) != null && h.onBeforeCreate && !await e.create.onBeforeCreate(l))
        return;
      if ((d = e.create) != null && d.onAfterCreate) {
        const p = await e.create.onAfterCreate(l);
        typeof p == "string" && (l = p);
      }
      const w = document.createElement("option");
      w.value = l, w.textContent = i(l), a.appendChild(w);
      const s = a.value;
      a.value = l, e.onSelectChange && s !== l && await e.onSelectChange(s, l), m = l;
    }), u.appendChild(t);
  }
  if (e.rename) {
    const t = document.createElement("i");
    t.className = "menu_button fa-solid fa-pencil";
    const r = i("");
    t.title = `Rename a ${r}`, t.setAttribute("data-i18n", `[title]Rename a ${r}`), t.addEventListener("click", async () => {
      var s, f, h;
      if (a.selectedIndex === -1) {
        await (0,_config_js__WEBPACK_IMPORTED_MODULE_0__.st_echo)("warning", `Please select a ${i("")} to rename.`);
        return;
      }
      const c = a.options[a.selectedIndex];
      let n = c.value;
      if (g(n)) {
        await (0,_config_js__WEBPACK_IMPORTED_MODULE_0__.st_echo)("warning", `This ${i(n)} cannot be renamed as it is read-only.`);
        return;
      }
      (s = e.rename) != null && s.onPopupOpen && await e.rename.onPopupOpen();
      const l = await C.Popup.show.input(
        `Rename ${i(n)}`,
        `Please enter a new name for "${n}":`,
        n
      );
      if (l === null || l.trim() === "" || l === n) return;
      let o = l.trim();
      if (Array.from(a.options).some(
        (d) => d.value === o && d !== c
      )) {
        await (0,_config_js__WEBPACK_IMPORTED_MODULE_0__.st_echo)("warning", `A ${i(o)} with this name already exists.`);
        return;
      }
      if (!((f = e.rename) != null && f.onBeforeRename && !await e.rename.onBeforeRename(n, o))) {
        if ((h = e.rename) != null && h.onAfterRename) {
          const d = await e.rename.onAfterRename(n, o);
          typeof d == "string" && (o = d);
        }
        c.value = o, c.textContent = i(o), n === m && (m = o), e.onSelectChange && a.value === o && await e.onSelectChange(n, o);
      }
    }), u.appendChild(t);
  }
  if (e.delete) {
    const t = document.createElement("i");
    t.className = "menu_button fa-solid fa-trash-can";
    const r = i("");
    t.title = `Delete a ${r}`, t.setAttribute("data-i18n", `[title]Delete a ${r}`), t.addEventListener("click", async () => {
      var h, d, p;
      if (a.selectedIndex === -1) {
        await (0,_config_js__WEBPACK_IMPORTED_MODULE_0__.st_echo)("warning", `Please select a ${i("")} to delete.`);
        return;
      }
      const c = a.options[a.selectedIndex], n = c.value, l = a.selectedIndex;
      if (g(n)) {
        await (0,_config_js__WEBPACK_IMPORTED_MODULE_0__.st_echo)("warning", `This ${i(n)} cannot be deleted as it is read-only.`);
        return;
      }
      if ((h = e.delete) != null && h.onPopupOpen && await e.delete.onPopupOpen(), !await C.Popup.show.confirm(
        `Delete ${i(n)}`,
        `Are you sure you want to delete "${n}"?`
      ) || (d = e.delete) != null && d.onBeforeDelete && !await e.delete.onBeforeDelete(n))
        return;
      const w = n;
      let s = -1, f;
      a.options.length > 1 && (s = l < a.options.length - 1 ? l : l - 1, f = a.options[s].value), a.removeChild(c), s >= 0 ? (a.selectedIndex = s, m = f, e.onSelectChange && await e.onSelectChange(w, f)) : (e.onSelectChange && await e.onSelectChange(w, void 0), m = void 0), (p = e.delete) != null && p.onAfterDelete && await e.delete.onAfterDelete(w);
    }), u.appendChild(t);
  }
  return {
    select: a,
    container: u
  };
}



/***/ },

/***/ "./node_modules/sillytavern-utils-lib/dist/prompt-builder.js"
/*!*******************************************************************!*\
  !*** ./node_modules/sillytavern-utils-lib/dist/prompt-builder.js ***!
  \*******************************************************************/
(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   buildPrompt: () => (/* binding */ ce)
/* harmony export */ });
/* harmony import */ var _config_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./config.js */ "./node_modules/sillytavern-utils-lib/dist/config.js");
/* harmony import */ var _tokenizer_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./tokenizer.js */ "./node_modules/sillytavern-utils-lib/dist/tokenizer.js");
/* harmony import */ var _regex_engine_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../../regex/engine.js */ "../../../regex/engine.js");
/* harmony import */ var _world_info_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../../../../world-info.js */ "../../../../world-info.js");
/* harmony import */ var _script_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../../../../../script.js */ "../../../../../script.js");
/* harmony import */ var _power_user_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../../../../power-user.js */ "../../../../power-user.js");
/* harmony import */ var _group_chats_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ../../../../group-chats.js */ "../../../../group-chats.js");
var It = Object.defineProperty;
var Dt = (l, s, o) => s in l ? It(l, s, { enumerable: !0, configurable: !0, writable: !0, value: o }) : l[s] = o;
var U = (l, s, o) => Dt(l, typeof s != "symbol" ? s + "" : s, o);







class Yt {
  constructor(s) {
    U(this, "messages", []);
    U(this, "tokenizer");
    U(this, "maxContext");
    U(this, "currentTokenCount", 0);
    this.tokenizer = new _tokenizer_js__WEBPACK_IMPORTED_MODULE_1__.Tokenizer(), this.maxContext = s;
  }
  getTokenCount(s) {
    var o, m;
    return s.content ? ((m = (o = s.source) == null ? void 0 : o.extra) == null ? void 0 : m.token_count) ?? this.tokenizer.encode(s.content).length : 0;
  }
  canFit(s) {
    return this.currentTokenCount + this.getTokenCount(s) <= this.maxContext;
  }
  add(s) {
    if (!s.content) return !0;
    const o = this.getTokenCount(s);
    return this.currentTokenCount + o > this.maxContext ? !1 : (this.messages.push(s), this.currentTokenCount += o, !0);
  }
  addFront(s) {
    if (!s.content) return !0;
    const o = this.getTokenCount(s);
    return this.currentTokenCount + o > this.maxContext ? !1 : (this.messages.unshift(s), this.currentTokenCount += o, !0);
  }
  addMany(s) {
    const o = s.filter((c) => c.content), m = o.map((c) => this.getTokenCount(c)), D = m.reduce((c, h) => c + h, 0);
    if (this.currentTokenCount + D <= this.maxContext)
      return this.messages.push(...o), this.currentTokenCount += D, !0;
    let E = 0;
    const u = [];
    for (let c = o.length - 1; c >= 0; c--) {
      const h = o[c], O = m[c];
      if (this.currentTokenCount + E + O <= this.maxContext)
        u.unshift(h), E += O;
      else
        break;
    }
    return u.length > 0 && (this.messages.push(...u), this.currentTokenCount += E), u.length === o.length;
  }
  insert(s, o) {
    if (!o.content) return !0;
    const m = this.getTokenCount(o);
    return this.currentTokenCount + m > this.maxContext ? !1 : (this.messages.splice(s, 0, o), this.currentTokenCount += m, !0);
  }
  getMessages() {
    return this.messages;
  }
}
async function ce(l, {
  targetCharacterId: s,
  presetName: o,
  instructName: m,
  contextName: D,
  syspromptName: E,
  maxContext: u,
  includeNames: c,
  ignoreCharacterFields: h,
  ignoreAuthorNote: O,
  ignoreWorldInfo: Y,
  messageIndexesBetween: C
} = {}) {
  var st, it, at, pt, ct, lt, ut, mt, ft, dt, gt, ht, _t, Pt;
  if (!["textgenerationwebui", "openai"].includes(l))
    throw new Error("Unsupported API");
  const n = SillyTavern.getContext();
  let { description: G, personality: Q, persona: Z, scenario: J, mesExamples: wt, system: _, jailbreak: bt } = h ? {
    description: "",
    personality: "",
    persona: "",
    scenario: "",
    mesExamples: "",
    system: "",
    jailbreak: ""
  } : n.getCharacterCardFields({
    chid: s
  });
  const S = l === "textgenerationwebui" ? (st = n.getPresetManager("instruct")) == null ? void 0 : st.getCompletionPresetByName(m) : void 0, K = !!(S != null && S.enabled);
  let P = (0,_config_js__WEBPACK_IMPORTED_MODULE_0__.st_parseMesExamples)(wt, K);
  function vt() {
    var e, p;
    if (typeof u == "number")
      return u;
    if (!u)
      return (0,_config_js__WEBPACK_IMPORTED_MODULE_0__.st_getMaxContextSize)();
    if (u === "active" || !o)
      return (0,_config_js__WEBPACK_IMPORTED_MODULE_0__.st_getMaxContextSize)();
    if (typeof u == "number")
      return u;
    let t;
    if (l === "textgenerationwebui") {
      const r = (e = n.getPresetManager("textgenerationwebui")) == null ? void 0 : e.getCompletionPresetByName(o);
      t = r == null ? void 0 : r.max_length;
    } else {
      const r = (p = n.getPresetManager("openai")) == null ? void 0 : p.getCompletionPresetByName(o);
      t = r == null ? void 0 : r.openai_max_context;
    }
    return typeof t == "number" ? t : (0,_config_js__WEBPACK_IMPORTED_MODULE_0__.st_getMaxContextSize)();
  }
  let y = [];
  const L = vt();
  if (L <= 0)
    return { result: [], warnings: y };
  const a = new Yt(L), Et = n.ToolManager.isToolCallingSupported(), tt = (C == null ? void 0 : C.start) ?? 0, et = C != null && C.end ? C.end + 1 : void 0;
  let k = tt === -1 && et === 0 ? [] : n.chat.slice(tt, et).filter((t) => {
    var e;
    return !t.is_system || Et && Array.isArray((e = t.extra) == null ? void 0 : e.tool_invocations);
  });
  k = await Promise.all(
    k.map(async (t, e) => {
      var $, j;
      let p = t.mes, r = t.is_user ? _regex_engine_js__WEBPACK_IMPORTED_MODULE_2__.regex_placement.USER_INPUT : _regex_engine_js__WEBPACK_IMPORTED_MODULE_2__.regex_placement.AI_OUTPUT, i = { isPrompt: !0, depth: k.length - e - 1 }, f = (0,_config_js__WEBPACK_IMPORTED_MODULE_0__.st_getRegexedString)(p, r, i);
      return f = await (0,_config_js__WEBPACK_IMPORTED_MODULE_0__.st_appendFileContent)(t, f), ($ = t == null ? void 0 : t.extra) != null && $.append_title && ((j = t == null ? void 0 : t.extra) != null && j.title) && (f = `${f}

${t.extra.title}`), {
        ...t,
        mes: f,
        index: e
      };
    })
  );
  const Ot = k.map((t) => _world_info_js__WEBPACK_IMPORTED_MODULE_3__.world_info_include_names ? `${t.name}: ${t.mes}` : t.mes).reverse(), { worldInfoString: Zt, worldInfoBefore: B, worldInfoAfter: F, worldInfoExamples: St, worldInfoDepth: At, anBefore: ot, anAfter: nt } = Y ? {
    worldInfoString: "",
    worldInfoBefore: "",
    worldInfoAfter: "",
    worldInfoExamples: [],
    worldInfoDepth: [],
    anBefore: [],
    anAfter: []
  } : await n.getWorldInfoPrompt(Ot, L, !1);
  for (const t of St) {
    const e = t.content;
    if (e.length === 0)
      continue;
    const p = (0,_config_js__WEBPACK_IMPORTED_MODULE_0__.st_baseChatReplace)(e, _script_js__WEBPACK_IMPORTED_MODULE_4__.name1, _script_js__WEBPACK_IMPORTED_MODULE_4__.name2), r = (0,_config_js__WEBPACK_IMPORTED_MODULE_0__.st_parseMesExamples)(p, K);
    t.position === _world_info_js__WEBPACK_IMPORTED_MODULE_3__.wi_anchor_position.before ? P.unshift(...r) : P.push(...r);
  }
  function rt() {
    const t = [];
    for (let e = k.length - 1; e >= 0; e--) {
      const p = k[e], r = p.name === "System" && !p.is_user ? "system" : p.is_user ? "user" : "assistant";
      t.unshift({
        role: r,
        content: c && r != "system" ? `${p.name}: ${p.mes}` : p.mes,
        source: p
      });
    }
    a.addMany(t);
  }
  if (l === "textgenerationwebui") {
    const t = [...P];
    P && (P = (0,_config_js__WEBPACK_IMPORTED_MODULE_0__.st_formatInstructModeExamples)(P, _script_js__WEBPACK_IMPORTED_MODULE_4__.name1, _script_js__WEBPACK_IMPORTED_MODULE_4__.name2));
    const e = (it = n.getPresetManager("sysprompt")) == null ? void 0 : it.getCompletionPresetByName(E);
    e && (_ = n.powerUserSettings.prefer_character_prompt && _ ? _ : (0,_config_js__WEBPACK_IMPORTED_MODULE_0__.st_baseChatReplace)(e.content, _script_js__WEBPACK_IMPORTED_MODULE_4__.name1, _script_js__WEBPACK_IMPORTED_MODULE_4__.name2), _ = K ? (0,_config_js__WEBPACK_IMPORTED_MODULE_0__.st_formatInstructModeSystemPrompt)(
      n.substituteParams(_, _script_js__WEBPACK_IMPORTED_MODULE_4__.name1, _script_js__WEBPACK_IMPORTED_MODULE_4__.name2, e.content),
      S
    ) : _);
    const p = {
      description: G,
      personality: Q,
      persona: n.powerUserSettings.persona_description_position == _power_user_js__WEBPACK_IMPORTED_MODULE_5__.persona_description_positions.IN_PROMPT ? Z : "",
      scenario: J,
      system: _,
      char: _script_js__WEBPACK_IMPORTED_MODULE_4__.name2,
      user: _script_js__WEBPACK_IMPORTED_MODULE_4__.name1,
      wiBefore: B,
      wiAfter: F,
      loreBefore: B,
      loreAfter: F,
      mesExamples: P.join(""),
      mesExamplesRaw: t.join("")
    }, r = (at = n.getPresetManager("context")) == null ? void 0 : at.getCompletionPresetByName(D);
    let i = (0,_config_js__WEBPACK_IMPORTED_MODULE_0__.st_renderStoryString)(p, {
      customInstructSettings: S,
      customStoryString: r == null ? void 0 : r.story_string
    });
    i && a.add({ role: "system", content: i, ignoreInstruct: !0 }), rt();
  } else {
    let t = function(g) {
      const M = d.find((V) => V.identifier === g);
      if (M)
        return M;
      const yt = i.prompts.find((V) => V.identifier === g);
      if (yt)
        return yt;
    }, e = (0,_config_js__WEBPACK_IMPORTED_MODULE_0__.st_setOpenAIMessages)(k), p = (0,_config_js__WEBPACK_IMPORTED_MODULE_0__.st_setOpenAIMessageExamples)(P);
    async function r() {
      let [g, M] = await (0,_config_js__WEBPACK_IMPORTED_MODULE_0__.st_prepareOpenAIMessages)(
        {
          name2: _script_js__WEBPACK_IMPORTED_MODULE_4__.name2,
          charDescription: G,
          charPersonality: Q,
          Scenario: J,
          worldInfoBefore: B,
          worldInfoAfter: F,
          extensionPrompts: n.extensionPrompts,
          bias: "",
          type: "normal",
          quietPrompt: void 0,
          quietImage: void 0,
          cyclePrompt: "",
          systemPromptOverride: _,
          jailbreakPromptOverride: bt,
          personaDescription: Z,
          messages: e,
          messageExamples: p
        },
        !1
      );
      a.addMany(g);
    }
    if (!o)
      return y.push("No preset name provided. Using default preset."), await r(), { result: a.getMessages(), warnings: y };
    const i = (pt = n.getPresetManager("openai")) == null ? void 0 : pt.getCompletionPresetByName(o);
    if (!i)
      return console.warn(`Preset not found: ${o}. Using current preset.`), y.push(`Preset not found: ${o}. Using current preset.`), r(), { result: a.getMessages(), warnings: y };
    let f = (ct = i.prompt_order) == null ? void 0 : ct.find((g) => g.character_id === _script_js__WEBPACK_IMPORTED_MODULE_4__.this_chid);
    if (!f && i.prompt_order && i.prompt_order.length > 0 && (f = i.prompt_order[i.prompt_order.length - 1]), !f)
      return console.warn(`No prompt order found for preset: ${o}. Using current preset.`), y.push(`No prompt order found for preset: ${o}. Using current preset.`), r(), { result: a.getMessages(), warnings: y };
    const $ = J && i.scenario_format ? n.substituteParams(i.scenario_format) : "", j = Q && i.personality_format ? n.substituteParams(i.personality_format) : "", Nt = n.substituteParams(i.group_nudge_prompt), Ut = i.impersonation_prompt ? n.substituteParams(i.impersonation_prompt) : "", d = [];
    Y || d.push(
      {
        role: "system",
        content: (0,_config_js__WEBPACK_IMPORTED_MODULE_0__.st_formatWorldInfo)(B, { wiFormat: i.wi_format }),
        identifier: "worldInfoBefore"
      },
      {
        role: "system",
        content: (0,_config_js__WEBPACK_IMPORTED_MODULE_0__.st_formatWorldInfo)(F, { wiFormat: i.wi_format }),
        identifier: "worldInfoAfter"
      }
    ), h || d.push(
      { role: "system", content: G, identifier: "charDescription" },
      { role: "system", content: j, identifier: "charPersonality" },
      { role: "system", content: $, identifier: "scenario" }
    ), d.push(
      { role: "system", content: Ut, identifier: "impersonate" },
      { role: "system", content: Nt, identifier: "groupNudge" }
    );
    const A = n.extensionPrompts["1_memory"];
    A && A.value && d.push({
      role: (0,_config_js__WEBPACK_IMPORTED_MODULE_0__.st_getPromptRole)(A.role),
      content: A.value,
      identifier: "summary",
      position: (0,_config_js__WEBPACK_IMPORTED_MODULE_0__.st_getPromptPosition)(A.position)
    });
    const R = n.extensionPrompts["2_floating_prompt"];
    !O && R && R.value && d.push({
      role: (0,_config_js__WEBPACK_IMPORTED_MODULE_0__.st_getPromptRole)(R.role),
      content: R.value,
      identifier: "authorsNote",
      position: (0,_config_js__WEBPACK_IMPORTED_MODULE_0__.st_getPromptPosition)(R.position)
    });
    const z = n.extensionPrompts["3_vectors"];
    z && z.value && d.push({
      role: "system",
      content: z.value,
      identifier: "vectorsMemory",
      position: (0,_config_js__WEBPACK_IMPORTED_MODULE_0__.st_getPromptPosition)(z.position)
    });
    const N = n.extensionPrompts["4_vectors_data_bank"];
    N && N.value && d.push({
      role: (0,_config_js__WEBPACK_IMPORTED_MODULE_0__.st_getPromptRole)(N.role),
      content: N.value,
      identifier: "vectorsDataBank",
      position: (0,_config_js__WEBPACK_IMPORTED_MODULE_0__.st_getPromptPosition)(N.position)
    });
    const H = n.extensionPrompts.chromadb;
    H && H.value && d.push({
      role: "system",
      content: H.value,
      identifier: "smartContext",
      position: (0,_config_js__WEBPACK_IMPORTED_MODULE_0__.st_getPromptPosition)(H.position)
    }), !h && n.powerUserSettings.persona_description && n.powerUserSettings.persona_description_position === _power_user_js__WEBPACK_IMPORTED_MODULE_5__.persona_description_positions.IN_PROMPT && d.push({
      role: "system",
      content: n.powerUserSettings.persona_description,
      identifier: "personaDescription"
    }), f.order.forEach((g) => {
      if (!g.enabled)
        return;
      const M = t(g.identifier);
      if (M && M.content) {
        a.add({
          role: M.role ?? "system",
          content: n.substituteParams(M.content)
        });
        return;
      }
      g.identifier === "chatHistory" && rt();
    });
  }
  const Rt = [
    "1_memory",
    "2_floating_prompt",
    "3_vectors",
    "4_vectors_data_bank",
    "chromadb",
    "PERSONA_DESCRIPTION",
    "QUIET_PROMPT",
    "DEPTH_PROMPT"
  ];
  for (const t in n.extensionPrompts)
    if (Object.hasOwn(n.extensionPrompts, t)) {
      const e = n.extensionPrompts[t];
      if (Rt.includes(t) || !n.extensionPrompts[t].value || ![_script_js__WEBPACK_IMPORTED_MODULE_4__.extension_prompt_types.BEFORE_PROMPT, _script_js__WEBPACK_IMPORTED_MODULE_4__.extension_prompt_types.IN_PROMPT].includes(e.position) || typeof e.filter == "function" && !await e.filter()) continue;
      const r = {
        role: (0,_config_js__WEBPACK_IMPORTED_MODULE_0__.st_getPromptRole)(e.role) ?? "system",
        content: e.value
      };
      if (e.position === _script_js__WEBPACK_IMPORTED_MODULE_4__.extension_prompt_types.BEFORE_PROMPT)
        a.insert(e.depth, r);
      else if (e.position === _script_js__WEBPACK_IMPORTED_MODULE_4__.extension_prompt_types.IN_PROMPT) {
        const i = a.getMessages();
        a.insert(i.length - e.depth, r);
      }
    }
  for (const t of At) {
    const e = a.getMessages();
    a.insert(e.length - t.depth, {
      role: (0,_config_js__WEBPACK_IMPORTED_MODULE_0__.st_getPromptRole)(t.role),
      content: t.entries.join(`
`)
    });
  }
  if (!h) {
    const t = (0,_config_js__WEBPACK_IMPORTED_MODULE_0__.st_getGroupDepthPrompts)(_group_chats_js__WEBPACK_IMPORTED_MODULE_6__.selected_group, Number(_script_js__WEBPACK_IMPORTED_MODULE_4__.this_chid));
    if (_group_chats_js__WEBPACK_IMPORTED_MODULE_6__.selected_group && Array.isArray(t) && t.length > 0)
      t.filter((e) => e.text).forEach((e, p) => {
        const r = a.getMessages();
        a.insert(r.length - e.depth, { role: e.role, content: e.text });
      });
    else {
      const e = (0,_config_js__WEBPACK_IMPORTED_MODULE_0__.st_baseChatReplace)(
        (dt = (ft = (mt = (ut = (lt = n.characters[_script_js__WEBPACK_IMPORTED_MODULE_4__.this_chid]) == null ? void 0 : lt.data) == null ? void 0 : ut.extensions) == null ? void 0 : mt.depth_prompt) == null ? void 0 : ft.prompt) == null ? void 0 : dt.trim(),
        _script_js__WEBPACK_IMPORTED_MODULE_4__.name1,
        _script_js__WEBPACK_IMPORTED_MODULE_4__.name2
      ) || "";
      if (e) {
        const p = _script_js__WEBPACK_IMPORTED_MODULE_4__.depth_prompt_depth_default, r = ((Pt = (_t = (ht = (gt = n.characters[_script_js__WEBPACK_IMPORTED_MODULE_4__.this_chid]) == null ? void 0 : gt.data) == null ? void 0 : ht.extensions) == null ? void 0 : _t.depth_prompt) == null ? void 0 : Pt.role) ?? _script_js__WEBPACK_IMPORTED_MODULE_4__.depth_prompt_role_default, i = a.getMessages();
        a.insert(i.length - p, {
          role: (0,_config_js__WEBPACK_IMPORTED_MODULE_0__.st_getPromptRole)(r),
          content: e
        });
      }
    }
  }
  let x = -1;
  if (!O) {
    const t = (0,_config_js__WEBPACK_IMPORTED_MODULE_0__.st_getAuthorNote)();
    if (t.prompt) {
      t.prompt = (0,_config_js__WEBPACK_IMPORTED_MODULE_0__.st_baseChatReplace)(t.prompt, _script_js__WEBPACK_IMPORTED_MODULE_4__.name1, _script_js__WEBPACK_IMPORTED_MODULE_4__.name2);
      const e = { role: (0,_config_js__WEBPACK_IMPORTED_MODULE_0__.st_getPromptRole)(t.role), content: t.prompt };
      switch (t.position) {
        case _script_js__WEBPACK_IMPORTED_MODULE_4__.extension_prompt_types.IN_PROMPT:
          a.insert(1, e), x = 1;
          break;
        case _script_js__WEBPACK_IMPORTED_MODULE_4__.extension_prompt_types.IN_CHAT:
          x = a.getMessages().length - t.depth, a.insert(x, e);
          break;
        case _script_js__WEBPACK_IMPORTED_MODULE_4__.extension_prompt_types.BEFORE_PROMPT:
          a.addFront(e), x = 0;
          break;
      }
    }
  }
  return x >= 0 && (ot.length > 0 && (a.insert(x, { role: "system", content: ot.join(`
`) }), x++), nt.length > 0 && a.insert(x + 1, { role: "system", content: nt.join(`
`) })), { result: a.getMessages(), warnings: y };
}



/***/ },

/***/ "./node_modules/sillytavern-utils-lib/dist/sortable-list.js"
/*!******************************************************************!*\
  !*** ./node_modules/sillytavern-utils-lib/dist/sortable-list.js ***!
  \******************************************************************/
(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   buildSortableList: () => (/* binding */ N)
/* harmony export */ });
/* harmony import */ var sortablejs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! sortablejs */ "./node_modules/sortablejs/modular/sortable.esm.js");

function N(p, c = {}) {
  const m = typeof p == "string" ? document.querySelector(p) : p;
  if (!m)
    throw new Error(`Could not find container: ${p}`);
  const h = c.showToggleButton ?? !1, v = c.showDeleteButton ?? !1, S = c.showSelectInput ?? !1;
  let r = [...c.initialList || []], f = null;
  m.innerHTML = "", m.classList.add("sortable-list-container");
  const g = document.createElement("ul");
  g.className = "sortable-list", Object.assign(g.style, {
    listStyle: "none",
    padding: "0",
    margin: "0"
  }), m.appendChild(g);
  const L = (t) => r.find((e) => e.id === t), x = (t) => g.querySelector(`li[data-id="${t}"]`), C = (t) => {
    const e = document.createElement("li");
    e.className = "sortable-list-item", e.dataset.id = t.id, Object.assign(e.style, {
      display: "flex",
      alignItems: "center",
      padding: "8px 12px",
      border: "1px solid var(--SmartThemeBorderColor, #ccc)",
      color: "var(--SmartThemeBodyColor, #333)",
      marginBottom: "2px"
    });
    const l = document.createElement("span");
    l.className = "drag-handle", l.innerHTML = '<i class="fas fa-bars"></i>', Object.assign(l.style, {
      cursor: "grab",
      marginRight: "10px",
      color: "var(--SmartThemeBodyColor, #555)",
      flexShrink: "0"
    }), e.appendChild(l);
    const o = document.createElement("span");
    o.className = "item-label", o.style.flexGrow = "1", o.style.marginRight = "10px", o.style.overflow = "hidden", o.style.textOverflow = "ellipsis", o.style.whiteSpace = "nowrap", c.renderLabel ? c.renderLabel(o, t) : o.textContent = t.label, e.appendChild(o);
    const a = "10px", s = t.showSelect ?? !0, i = t.canSelect ?? !0;
    let d = null;
    if (S && s)
      if (i) {
        if (d = document.createElement("select"), d.className = "select-input text_pole", d.style.marginRight = a, d.style.flexShrink = "0", d.style.width = "unset", t.selectOptions && t.selectOptions.length > 0)
          t.selectOptions.forEach((n) => {
            const u = document.createElement("option");
            u.value = n.value, u.textContent = n.label, n.value === t.selectValue && (u.selected = !0), d.appendChild(u);
          });
        else {
          const n = document.createElement("option");
          n.textContent = "--", n.disabled = !0, n.selected = !0, d.appendChild(n), d.disabled = !0;
        }
        d.addEventListener("change", (n) => {
          n.stopPropagation(), k(t.id, n);
        }), e.appendChild(d);
      } else {
        const n = document.createElement("span");
        n.style.marginRight = a, n.style.display = "inline-block", n.style.flexShrink = "0", e.appendChild(n);
      }
    else if (S && !s) {
      const n = document.createElement("span");
      n.style.marginRight = a, n.style.display = "inline-block", n.style.flexShrink = "0", e.appendChild(n);
    }
    const b = t.canToggle ?? !0;
    if (h && b) {
      const n = document.createElement("span");
      n.className = "toggle-button", n.innerHTML = `<i class="fas ${t.enabled ? "fa-toggle-on" : "fa-toggle-off"}"></i>`, Object.assign(n.style, {
        cursor: "pointer",
        marginRight: a,
        fontSize: "1.2em",
        color: t.enabled ? "var(--success-color, #4CAF50)" : "var(--SmartThemeBodyColor, #555)",
        flexShrink: "0"
        // Prevent shrinking
        // Optional: width: '24px', textAlign: 'center' for alignment
      }), n.addEventListener("click", (u) => {
        u.stopPropagation(), O(t.id);
      }), e.appendChild(n);
    } else if (h && !b) {
      const n = document.createElement("span");
      n.style.marginRight = a, n.style.display = "inline-block", n.style.flexShrink = "0", e.appendChild(n);
    }
    const y = t.canDelete ?? !0;
    if (v && y) {
      const n = document.createElement("span");
      n.className = "delete-button", n.innerHTML = '<i class="fas fa-trash-can"></i>', Object.assign(n.style, {
        cursor: "pointer",
        color: "var(--error-color, #f44336)",
        // No margin needed if it's the last element
        flexShrink: "0"
        // Prevent shrinking
        // Optional: width: '18px', textAlign: 'center' for alignment
      }), n.addEventListener("click", (u) => {
        u.stopPropagation(), T(t.id);
      }), e.appendChild(n);
    } else if (v && !y) {
      const n = document.createElement("span");
      n.style.display = "inline-block", n.style.flexShrink = "0", e.appendChild(n);
    }
    return h && (e.style.opacity = t.enabled ? "1" : "0.6"), e;
  }, E = () => {
    g.innerHTML = "", r.forEach((t) => {
      const e = C(t);
      g.appendChild(e);
    });
  }, I = (t, e = {}) => {
    const l = L(t), o = x(t);
    if (!l || !o) return;
    if ("label" in e && c.renderLabel || "selectOptions" in e || "showSelect" in e || "canSelect" in e || "canToggle" in e || "canDelete" in e) {
      const s = C(l);
      o.replaceWith(s);
      return;
    }
    if ("label" in e && !c.renderLabel) {
      const s = o.querySelector(".item-label");
      s && (s.textContent = l.label);
    }
    if ("selectValue" in e && S) {
      const s = o.querySelector(".select-input");
      s && (s.value = l.selectValue ?? "");
    }
    if ("enabled" in e && h && (l.canToggle ?? !0)) {
      const s = o.querySelector(".toggle-button i"), i = o.querySelector(".toggle-button");
      s && (s.className = `fas ${l.enabled ? "fa-toggle-on" : "fa-toggle-off"}`), i && (i.style.color = l.enabled ? "var(--success-color, #4CAF50)" : "var(--SmartThemeBodyColor, #555)");
    }
    if ("enabled" in e && h) {
      o.style.opacity = l.enabled ? "1" : "0.6";
      const s = o.querySelector(".select-input");
      s && (s.disabled = !l.enabled || !(l.canSelect ?? !0));
    }
  }, O = async (t) => {
    const e = r.findIndex((s) => s.id === t);
    if (e === -1 || !(r[e].canToggle ?? !0)) return;
    const l = r[e], o = !l.enabled;
    if (c.onToggle)
      try {
        await Promise.resolve(c.onToggle(t, o));
      } catch (s) {
        console.error("onToggle callback failed:", s);
        return;
      }
    const a = { enabled: o };
    r[e] = { ...l, ...a }, I(t, a);
  }, T = async (t) => {
    var o;
    const e = r.findIndex((a) => a.id === t);
    if (e === -1 || !(r[e].canDelete ?? !0)) return;
    let l = !0;
    if (c.onDelete)
      try {
        l = await Promise.resolve(c.onDelete(t));
      } catch (a) {
        console.error("onDelete callback failed:", a), l = !1;
      }
    l && (r.splice(e, 1), (o = x(t)) == null || o.remove());
  }, k = async (t, e) => {
    const l = r.findIndex((d) => d.id === t);
    if (l === -1 || !(r[l].canSelect ?? !0)) return;
    const o = r[l], a = e.target, s = a.value;
    if (c.onSelectChange)
      try {
        await Promise.resolve(c.onSelectChange(t, s));
      } catch (d) {
        console.error("onSelectChange callback failed:", d), a.value = o.selectValue ?? "";
        return;
      }
    const i = { selectValue: s };
    r[l] = { ...o, ...i };
  }, w = () => {
    f && f.destroy();
    const t = {
      handle: ".drag-handle",
      animation: 150,
      ghostClass: "sortable-ghost",
      chosenClass: "sortable-chosen",
      dragClass: "sortable-drag",
      filter: ".select-input, .toggle-button, .delete-button",
      // Prevent drag on controls
      preventOnFilter: !1,
      onEnd: (e) => {
        const { oldIndex: l, newIndex: o } = e;
        if (l === void 0 || o === void 0 || l === o)
          return;
        const a = Array.from(g.children).map((i) => i.dataset.id).filter((i) => i !== void 0);
        r.sort((i, d) => {
          const b = a.indexOf(i.id), y = a.indexOf(d.id);
          return b - y;
        });
        const s = r.map((i) => i.id);
        c.onOrderChange && Promise.resolve(c.onOrderChange(s)).catch(
          (i) => console.error("onOrderChange callback failed:", i)
        );
      },
      ...c.sortableJsOptions || {}
    };
    f = sortablejs__WEBPACK_IMPORTED_MODULE_0__["default"].create(g, t);
  };
  return E(), w(), {
    /** Gets the current list of items with their data. */
    getList: () => [...r],
    /** Gets the current order of item IDs. */
    getOrder: () => r.map((t) => t.id),
    /** Adds a new item to the list. */
    addItem: (t, e) => {
      if (r.some((s) => s.id === t.id)) {
        console.warn(`SortableList: Item with ID "${t.id}" already exists. Skipping add.`);
        return;
      }
      const l = e === void 0 || e < 0 || e > r.length ? r.length : e;
      r.splice(l, 0, t);
      const o = C(t), a = g.children[l];
      g.insertBefore(o, a ?? null);
    },
    removeItem: (t) => {
      var l;
      const e = r.findIndex((o) => o.id === t);
      e > -1 && (r.splice(e, 1), (l = x(t)) == null || l.remove());
    },
    /** Updates the data and visuals for an existing item. */
    updateItem: (t, e) => {
      const l = r.findIndex((o) => o.id === t);
      if (l > -1) {
        const o = r[l];
        "id" in e && (console.warn("SortableList: Cannot change item ID via updateItem."), delete e.id), r[l] = { ...o, ...e }, I(t, e);
      }
    },
    /** Replaces the entire list content. */
    setList: (t) => {
      r = [...t], E(), w();
    },
    /** Destroys the SortableJS instance and removes elements. */
    destroy: () => {
      f && (f.destroy(), f = null), m.innerHTML = "", m.classList.remove("sortable-list-container"), r = [];
    },
    /** Gets the underlying SortableJS instance for advanced manipulation (use with caution). */
    getSortableInstance: () => f
  };
}



/***/ },

/***/ "./node_modules/sillytavern-utils-lib/dist/tokenizer.js"
/*!**************************************************************!*\
  !*** ./node_modules/sillytavern-utils-lib/dist/tokenizer.js ***!
  \**************************************************************/
(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   Tokenizer: () => (/* binding */ t)
/* harmony export */ });
class t {
  /**
   * Encodes a string into a sequence of tokens using a simple heuristic.
   * This is a placeholder for a real tokenizer.
   */
  encode(e) {
    const n = Math.ceil(e.length / 4);
    return new Array(n).fill(" ");
  }
  /**
   * Decodes a sequence of tokens back into a string.
   * This is a placeholder and doesn't actually decode.
   */
  decode(e) {
    return e.join("");
  }
}



/***/ },

/***/ "./node_modules/sillytavern-utils-lib/dist/world-info-utils.js"
/*!*********************************************************************!*\
  !*** ./node_modules/sillytavern-utils-lib/dist/world-info-utils.js ***!
  \*********************************************************************/
(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   applyWorldInfoEntry: () => (/* binding */ A),
/* harmony export */   getWorldInfo: () => (/* binding */ C),
/* harmony export */   getWorldInfos: () => (/* binding */ k)
/* harmony export */ });
/* harmony import */ var _config_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./config.js */ "./node_modules/sillytavern-utils-lib/dist/config.js");
/* harmony import */ var _world_info_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../../../world-info.js */ "../../../../world-info.js");


async function k(s, i, u) {
  var l, h, I;
  function c(o) {
    return s.includes("all") || s.includes(o);
  }
  const r = SillyTavern.getContext();
  let t = {};
  const a = i ? _world_info_js__WEBPACK_IMPORTED_MODULE_1__.selected_world_info : _world_info_js__WEBPACK_IMPORTED_MODULE_1__.world_names;
  if (c("global") && (a != null && a.length))
    for (const o of a) {
      const e = await C(o);
      e && (t[o] || (t[o] = []), Object.values(e).forEach((f) => {
        t[o].push(f);
      }));
    }
  if (c("chat")) {
    const o = r.chatMetadata[_world_info_js__WEBPACK_IMPORTED_MODULE_1__.METADATA_KEY];
    if (o && !t[o]) {
      t[o] = [];
      const e = await r.loadWorldInfo(o);
      e && Object.values(e.entries).forEach((f) => {
        t[o].push(f);
      });
    }
  }
  if (c("character") && u) {
    const o = r.characters[u];
    let e = /* @__PURE__ */ new Set();
    const f = (h = (l = o == null ? void 0 : o.data) == null ? void 0 : l.extensions) == null ? void 0 : h.world;
    f && e.add(f);
    const m = (0,_config_js__WEBPACK_IMPORTED_MODULE_0__.st_getCharaFilename)(u), y = (I = _world_info_js__WEBPACK_IMPORTED_MODULE_1__.world_info.charLore) == null ? void 0 : I.find((d) => d.name === m);
    y && (e = /* @__PURE__ */ new Set([...e, ...y.extraBooks]));
    for (const d of e) {
      const b = await r.loadWorldInfo(d);
      !b || t[d] || (t[d] = [], Object.values(b.entries).forEach((v) => {
        t[d].push(v);
      }));
    }
  }
  if (c("persona")) {
    const o = r.powerUserSettings.persona_description_lorebook;
    if (o && !t[o]) {
      t[o] = [];
      const e = await r.loadWorldInfo(o);
      e && Object.values(e.entries).forEach((f) => {
        t[o].push(f);
      });
    }
  }
  return t;
}
async function A({
  entry: s,
  selectedWorldName: i,
  skipSave: u = !1,
  skipReload: c = !1,
  operation: r = "auto"
}) {
  const t = SillyTavern.getContext(), a = await t.loadWorldInfo(i);
  if (!a)
    throw new Error("Failed to load world info");
  const w = Object.values(a.entries), p = w.length > 0 ? w[w.length - 1] : void 0;
  let n;
  if (r === "update" || r === "auto") {
    const l = Object.values(a.entries).find((h) => h.uid === s.uid);
    if (l)
      (r === "auto" || r === "update") && (n = l);
    else if (r === "update")
      throw new Error("Entry not found for update operation");
  }
  const E = n ? "update" : "add";
  if (!n) {
    if (n = (0,_config_js__WEBPACK_IMPORTED_MODULE_0__.st_createWorldInfoEntry)(i, a), !n)
      throw new Error("Failed to create entry");
    if (p) {
      const l = n.uid;
      Object.assign(n, p), n.uid = l;
    }
  }
  return n.key = s.key, n.content = s.content, n.comment = s.comment, u || await t.saveWorldInfo(i, a), c || t.reloadWorldInfoEditor(i, !0), {
    entry: n,
    operation: E
  };
}
async function C(s) {
  const i = await SillyTavern.getContext().loadWorldInfo(s);
  return i ? Object.values(i.entries) : null;
}



/***/ },

/***/ "./node_modules/sortablejs/modular/sortable.esm.js"
/*!*********************************************************!*\
  !*** ./node_modules/sortablejs/modular/sortable.esm.js ***!
  \*********************************************************/
(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   MultiDrag: () => (/* binding */ MultiDragPlugin),
/* harmony export */   Sortable: () => (/* binding */ Sortable),
/* harmony export */   Swap: () => (/* binding */ SwapPlugin),
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/**!
 * Sortable 1.15.6
 * @author	RubaXa   <trash@rubaxa.org>
 * @author	owenm    <owen23355@gmail.com>
 * @license MIT
 */
function ownKeys(object, enumerableOnly) {
  var keys = Object.keys(object);
  if (Object.getOwnPropertySymbols) {
    var symbols = Object.getOwnPropertySymbols(object);
    if (enumerableOnly) {
      symbols = symbols.filter(function (sym) {
        return Object.getOwnPropertyDescriptor(object, sym).enumerable;
      });
    }
    keys.push.apply(keys, symbols);
  }
  return keys;
}
function _objectSpread2(target) {
  for (var i = 1; i < arguments.length; i++) {
    var source = arguments[i] != null ? arguments[i] : {};
    if (i % 2) {
      ownKeys(Object(source), true).forEach(function (key) {
        _defineProperty(target, key, source[key]);
      });
    } else if (Object.getOwnPropertyDescriptors) {
      Object.defineProperties(target, Object.getOwnPropertyDescriptors(source));
    } else {
      ownKeys(Object(source)).forEach(function (key) {
        Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
      });
    }
  }
  return target;
}
function _typeof(obj) {
  "@babel/helpers - typeof";

  if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") {
    _typeof = function (obj) {
      return typeof obj;
    };
  } else {
    _typeof = function (obj) {
      return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj;
    };
  }
  return _typeof(obj);
}
function _defineProperty(obj, key, value) {
  if (key in obj) {
    Object.defineProperty(obj, key, {
      value: value,
      enumerable: true,
      configurable: true,
      writable: true
    });
  } else {
    obj[key] = value;
  }
  return obj;
}
function _extends() {
  _extends = Object.assign || function (target) {
    for (var i = 1; i < arguments.length; i++) {
      var source = arguments[i];
      for (var key in source) {
        if (Object.prototype.hasOwnProperty.call(source, key)) {
          target[key] = source[key];
        }
      }
    }
    return target;
  };
  return _extends.apply(this, arguments);
}
function _objectWithoutPropertiesLoose(source, excluded) {
  if (source == null) return {};
  var target = {};
  var sourceKeys = Object.keys(source);
  var key, i;
  for (i = 0; i < sourceKeys.length; i++) {
    key = sourceKeys[i];
    if (excluded.indexOf(key) >= 0) continue;
    target[key] = source[key];
  }
  return target;
}
function _objectWithoutProperties(source, excluded) {
  if (source == null) return {};
  var target = _objectWithoutPropertiesLoose(source, excluded);
  var key, i;
  if (Object.getOwnPropertySymbols) {
    var sourceSymbolKeys = Object.getOwnPropertySymbols(source);
    for (i = 0; i < sourceSymbolKeys.length; i++) {
      key = sourceSymbolKeys[i];
      if (excluded.indexOf(key) >= 0) continue;
      if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue;
      target[key] = source[key];
    }
  }
  return target;
}
function _toConsumableArray(arr) {
  return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _unsupportedIterableToArray(arr) || _nonIterableSpread();
}
function _arrayWithoutHoles(arr) {
  if (Array.isArray(arr)) return _arrayLikeToArray(arr);
}
function _iterableToArray(iter) {
  if (typeof Symbol !== "undefined" && iter[Symbol.iterator] != null || iter["@@iterator"] != null) return Array.from(iter);
}
function _unsupportedIterableToArray(o, minLen) {
  if (!o) return;
  if (typeof o === "string") return _arrayLikeToArray(o, minLen);
  var n = Object.prototype.toString.call(o).slice(8, -1);
  if (n === "Object" && o.constructor) n = o.constructor.name;
  if (n === "Map" || n === "Set") return Array.from(o);
  if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen);
}
function _arrayLikeToArray(arr, len) {
  if (len == null || len > arr.length) len = arr.length;
  for (var i = 0, arr2 = new Array(len); i < len; i++) arr2[i] = arr[i];
  return arr2;
}
function _nonIterableSpread() {
  throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
}

var version = "1.15.6";

function userAgent(pattern) {
  if (typeof window !== 'undefined' && window.navigator) {
    return !! /*@__PURE__*/navigator.userAgent.match(pattern);
  }
}
var IE11OrLess = userAgent(/(?:Trident.*rv[ :]?11\.|msie|iemobile|Windows Phone)/i);
var Edge = userAgent(/Edge/i);
var FireFox = userAgent(/firefox/i);
var Safari = userAgent(/safari/i) && !userAgent(/chrome/i) && !userAgent(/android/i);
var IOS = userAgent(/iP(ad|od|hone)/i);
var ChromeForAndroid = userAgent(/chrome/i) && userAgent(/android/i);

var captureMode = {
  capture: false,
  passive: false
};
function on(el, event, fn) {
  el.addEventListener(event, fn, !IE11OrLess && captureMode);
}
function off(el, event, fn) {
  el.removeEventListener(event, fn, !IE11OrLess && captureMode);
}
function matches( /**HTMLElement*/el, /**String*/selector) {
  if (!selector) return;
  selector[0] === '>' && (selector = selector.substring(1));
  if (el) {
    try {
      if (el.matches) {
        return el.matches(selector);
      } else if (el.msMatchesSelector) {
        return el.msMatchesSelector(selector);
      } else if (el.webkitMatchesSelector) {
        return el.webkitMatchesSelector(selector);
      }
    } catch (_) {
      return false;
    }
  }
  return false;
}
function getParentOrHost(el) {
  return el.host && el !== document && el.host.nodeType ? el.host : el.parentNode;
}
function closest( /**HTMLElement*/el, /**String*/selector, /**HTMLElement*/ctx, includeCTX) {
  if (el) {
    ctx = ctx || document;
    do {
      if (selector != null && (selector[0] === '>' ? el.parentNode === ctx && matches(el, selector) : matches(el, selector)) || includeCTX && el === ctx) {
        return el;
      }
      if (el === ctx) break;
      /* jshint boss:true */
    } while (el = getParentOrHost(el));
  }
  return null;
}
var R_SPACE = /\s+/g;
function toggleClass(el, name, state) {
  if (el && name) {
    if (el.classList) {
      el.classList[state ? 'add' : 'remove'](name);
    } else {
      var className = (' ' + el.className + ' ').replace(R_SPACE, ' ').replace(' ' + name + ' ', ' ');
      el.className = (className + (state ? ' ' + name : '')).replace(R_SPACE, ' ');
    }
  }
}
function css(el, prop, val) {
  var style = el && el.style;
  if (style) {
    if (val === void 0) {
      if (document.defaultView && document.defaultView.getComputedStyle) {
        val = document.defaultView.getComputedStyle(el, '');
      } else if (el.currentStyle) {
        val = el.currentStyle;
      }
      return prop === void 0 ? val : val[prop];
    } else {
      if (!(prop in style) && prop.indexOf('webkit') === -1) {
        prop = '-webkit-' + prop;
      }
      style[prop] = val + (typeof val === 'string' ? '' : 'px');
    }
  }
}
function matrix(el, selfOnly) {
  var appliedTransforms = '';
  if (typeof el === 'string') {
    appliedTransforms = el;
  } else {
    do {
      var transform = css(el, 'transform');
      if (transform && transform !== 'none') {
        appliedTransforms = transform + ' ' + appliedTransforms;
      }
      /* jshint boss:true */
    } while (!selfOnly && (el = el.parentNode));
  }
  var matrixFn = window.DOMMatrix || window.WebKitCSSMatrix || window.CSSMatrix || window.MSCSSMatrix;
  /*jshint -W056 */
  return matrixFn && new matrixFn(appliedTransforms);
}
function find(ctx, tagName, iterator) {
  if (ctx) {
    var list = ctx.getElementsByTagName(tagName),
      i = 0,
      n = list.length;
    if (iterator) {
      for (; i < n; i++) {
        iterator(list[i], i);
      }
    }
    return list;
  }
  return [];
}
function getWindowScrollingElement() {
  var scrollingElement = document.scrollingElement;
  if (scrollingElement) {
    return scrollingElement;
  } else {
    return document.documentElement;
  }
}

/**
 * Returns the "bounding client rect" of given element
 * @param  {HTMLElement} el                       The element whose boundingClientRect is wanted
 * @param  {[Boolean]} relativeToContainingBlock  Whether the rect should be relative to the containing block of (including) the container
 * @param  {[Boolean]} relativeToNonStaticParent  Whether the rect should be relative to the relative parent of (including) the contaienr
 * @param  {[Boolean]} undoScale                  Whether the container's scale() should be undone
 * @param  {[HTMLElement]} container              The parent the element will be placed in
 * @return {Object}                               The boundingClientRect of el, with specified adjustments
 */
function getRect(el, relativeToContainingBlock, relativeToNonStaticParent, undoScale, container) {
  if (!el.getBoundingClientRect && el !== window) return;
  var elRect, top, left, bottom, right, height, width;
  if (el !== window && el.parentNode && el !== getWindowScrollingElement()) {
    elRect = el.getBoundingClientRect();
    top = elRect.top;
    left = elRect.left;
    bottom = elRect.bottom;
    right = elRect.right;
    height = elRect.height;
    width = elRect.width;
  } else {
    top = 0;
    left = 0;
    bottom = window.innerHeight;
    right = window.innerWidth;
    height = window.innerHeight;
    width = window.innerWidth;
  }
  if ((relativeToContainingBlock || relativeToNonStaticParent) && el !== window) {
    // Adjust for translate()
    container = container || el.parentNode;

    // solves #1123 (see: https://stackoverflow.com/a/37953806/6088312)
    // Not needed on <= IE11
    if (!IE11OrLess) {
      do {
        if (container && container.getBoundingClientRect && (css(container, 'transform') !== 'none' || relativeToNonStaticParent && css(container, 'position') !== 'static')) {
          var containerRect = container.getBoundingClientRect();

          // Set relative to edges of padding box of container
          top -= containerRect.top + parseInt(css(container, 'border-top-width'));
          left -= containerRect.left + parseInt(css(container, 'border-left-width'));
          bottom = top + elRect.height;
          right = left + elRect.width;
          break;
        }
        /* jshint boss:true */
      } while (container = container.parentNode);
    }
  }
  if (undoScale && el !== window) {
    // Adjust for scale()
    var elMatrix = matrix(container || el),
      scaleX = elMatrix && elMatrix.a,
      scaleY = elMatrix && elMatrix.d;
    if (elMatrix) {
      top /= scaleY;
      left /= scaleX;
      width /= scaleX;
      height /= scaleY;
      bottom = top + height;
      right = left + width;
    }
  }
  return {
    top: top,
    left: left,
    bottom: bottom,
    right: right,
    width: width,
    height: height
  };
}

/**
 * Checks if a side of an element is scrolled past a side of its parents
 * @param  {HTMLElement}  el           The element who's side being scrolled out of view is in question
 * @param  {String}       elSide       Side of the element in question ('top', 'left', 'right', 'bottom')
 * @param  {String}       parentSide   Side of the parent in question ('top', 'left', 'right', 'bottom')
 * @return {HTMLElement}               The parent scroll element that the el's side is scrolled past, or null if there is no such element
 */
function isScrolledPast(el, elSide, parentSide) {
  var parent = getParentAutoScrollElement(el, true),
    elSideVal = getRect(el)[elSide];

  /* jshint boss:true */
  while (parent) {
    var parentSideVal = getRect(parent)[parentSide],
      visible = void 0;
    if (parentSide === 'top' || parentSide === 'left') {
      visible = elSideVal >= parentSideVal;
    } else {
      visible = elSideVal <= parentSideVal;
    }
    if (!visible) return parent;
    if (parent === getWindowScrollingElement()) break;
    parent = getParentAutoScrollElement(parent, false);
  }
  return false;
}

/**
 * Gets nth child of el, ignoring hidden children, sortable's elements (does not ignore clone if it's visible)
 * and non-draggable elements
 * @param  {HTMLElement} el       The parent element
 * @param  {Number} childNum      The index of the child
 * @param  {Object} options       Parent Sortable's options
 * @return {HTMLElement}          The child at index childNum, or null if not found
 */
function getChild(el, childNum, options, includeDragEl) {
  var currentChild = 0,
    i = 0,
    children = el.children;
  while (i < children.length) {
    if (children[i].style.display !== 'none' && children[i] !== Sortable.ghost && (includeDragEl || children[i] !== Sortable.dragged) && closest(children[i], options.draggable, el, false)) {
      if (currentChild === childNum) {
        return children[i];
      }
      currentChild++;
    }
    i++;
  }
  return null;
}

/**
 * Gets the last child in the el, ignoring ghostEl or invisible elements (clones)
 * @param  {HTMLElement} el       Parent element
 * @param  {selector} selector    Any other elements that should be ignored
 * @return {HTMLElement}          The last child, ignoring ghostEl
 */
function lastChild(el, selector) {
  var last = el.lastElementChild;
  while (last && (last === Sortable.ghost || css(last, 'display') === 'none' || selector && !matches(last, selector))) {
    last = last.previousElementSibling;
  }
  return last || null;
}

/**
 * Returns the index of an element within its parent for a selected set of
 * elements
 * @param  {HTMLElement} el
 * @param  {selector} selector
 * @return {number}
 */
function index(el, selector) {
  var index = 0;
  if (!el || !el.parentNode) {
    return -1;
  }

  /* jshint boss:true */
  while (el = el.previousElementSibling) {
    if (el.nodeName.toUpperCase() !== 'TEMPLATE' && el !== Sortable.clone && (!selector || matches(el, selector))) {
      index++;
    }
  }
  return index;
}

/**
 * Returns the scroll offset of the given element, added with all the scroll offsets of parent elements.
 * The value is returned in real pixels.
 * @param  {HTMLElement} el
 * @return {Array}             Offsets in the format of [left, top]
 */
function getRelativeScrollOffset(el) {
  var offsetLeft = 0,
    offsetTop = 0,
    winScroller = getWindowScrollingElement();
  if (el) {
    do {
      var elMatrix = matrix(el),
        scaleX = elMatrix.a,
        scaleY = elMatrix.d;
      offsetLeft += el.scrollLeft * scaleX;
      offsetTop += el.scrollTop * scaleY;
    } while (el !== winScroller && (el = el.parentNode));
  }
  return [offsetLeft, offsetTop];
}

/**
 * Returns the index of the object within the given array
 * @param  {Array} arr   Array that may or may not hold the object
 * @param  {Object} obj  An object that has a key-value pair unique to and identical to a key-value pair in the object you want to find
 * @return {Number}      The index of the object in the array, or -1
 */
function indexOfObject(arr, obj) {
  for (var i in arr) {
    if (!arr.hasOwnProperty(i)) continue;
    for (var key in obj) {
      if (obj.hasOwnProperty(key) && obj[key] === arr[i][key]) return Number(i);
    }
  }
  return -1;
}
function getParentAutoScrollElement(el, includeSelf) {
  // skip to window
  if (!el || !el.getBoundingClientRect) return getWindowScrollingElement();
  var elem = el;
  var gotSelf = false;
  do {
    // we don't need to get elem css if it isn't even overflowing in the first place (performance)
    if (elem.clientWidth < elem.scrollWidth || elem.clientHeight < elem.scrollHeight) {
      var elemCSS = css(elem);
      if (elem.clientWidth < elem.scrollWidth && (elemCSS.overflowX == 'auto' || elemCSS.overflowX == 'scroll') || elem.clientHeight < elem.scrollHeight && (elemCSS.overflowY == 'auto' || elemCSS.overflowY == 'scroll')) {
        if (!elem.getBoundingClientRect || elem === document.body) return getWindowScrollingElement();
        if (gotSelf || includeSelf) return elem;
        gotSelf = true;
      }
    }
    /* jshint boss:true */
  } while (elem = elem.parentNode);
  return getWindowScrollingElement();
}
function extend(dst, src) {
  if (dst && src) {
    for (var key in src) {
      if (src.hasOwnProperty(key)) {
        dst[key] = src[key];
      }
    }
  }
  return dst;
}
function isRectEqual(rect1, rect2) {
  return Math.round(rect1.top) === Math.round(rect2.top) && Math.round(rect1.left) === Math.round(rect2.left) && Math.round(rect1.height) === Math.round(rect2.height) && Math.round(rect1.width) === Math.round(rect2.width);
}
var _throttleTimeout;
function throttle(callback, ms) {
  return function () {
    if (!_throttleTimeout) {
      var args = arguments,
        _this = this;
      if (args.length === 1) {
        callback.call(_this, args[0]);
      } else {
        callback.apply(_this, args);
      }
      _throttleTimeout = setTimeout(function () {
        _throttleTimeout = void 0;
      }, ms);
    }
  };
}
function cancelThrottle() {
  clearTimeout(_throttleTimeout);
  _throttleTimeout = void 0;
}
function scrollBy(el, x, y) {
  el.scrollLeft += x;
  el.scrollTop += y;
}
function clone(el) {
  var Polymer = window.Polymer;
  var $ = window.jQuery || window.Zepto;
  if (Polymer && Polymer.dom) {
    return Polymer.dom(el).cloneNode(true);
  } else if ($) {
    return $(el).clone(true)[0];
  } else {
    return el.cloneNode(true);
  }
}
function setRect(el, rect) {
  css(el, 'position', 'absolute');
  css(el, 'top', rect.top);
  css(el, 'left', rect.left);
  css(el, 'width', rect.width);
  css(el, 'height', rect.height);
}
function unsetRect(el) {
  css(el, 'position', '');
  css(el, 'top', '');
  css(el, 'left', '');
  css(el, 'width', '');
  css(el, 'height', '');
}
function getChildContainingRectFromElement(container, options, ghostEl) {
  var rect = {};
  Array.from(container.children).forEach(function (child) {
    var _rect$left, _rect$top, _rect$right, _rect$bottom;
    if (!closest(child, options.draggable, container, false) || child.animated || child === ghostEl) return;
    var childRect = getRect(child);
    rect.left = Math.min((_rect$left = rect.left) !== null && _rect$left !== void 0 ? _rect$left : Infinity, childRect.left);
    rect.top = Math.min((_rect$top = rect.top) !== null && _rect$top !== void 0 ? _rect$top : Infinity, childRect.top);
    rect.right = Math.max((_rect$right = rect.right) !== null && _rect$right !== void 0 ? _rect$right : -Infinity, childRect.right);
    rect.bottom = Math.max((_rect$bottom = rect.bottom) !== null && _rect$bottom !== void 0 ? _rect$bottom : -Infinity, childRect.bottom);
  });
  rect.width = rect.right - rect.left;
  rect.height = rect.bottom - rect.top;
  rect.x = rect.left;
  rect.y = rect.top;
  return rect;
}
var expando = 'Sortable' + new Date().getTime();

function AnimationStateManager() {
  var animationStates = [],
    animationCallbackId;
  return {
    captureAnimationState: function captureAnimationState() {
      animationStates = [];
      if (!this.options.animation) return;
      var children = [].slice.call(this.el.children);
      children.forEach(function (child) {
        if (css(child, 'display') === 'none' || child === Sortable.ghost) return;
        animationStates.push({
          target: child,
          rect: getRect(child)
        });
        var fromRect = _objectSpread2({}, animationStates[animationStates.length - 1].rect);

        // If animating: compensate for current animation
        if (child.thisAnimationDuration) {
          var childMatrix = matrix(child, true);
          if (childMatrix) {
            fromRect.top -= childMatrix.f;
            fromRect.left -= childMatrix.e;
          }
        }
        child.fromRect = fromRect;
      });
    },
    addAnimationState: function addAnimationState(state) {
      animationStates.push(state);
    },
    removeAnimationState: function removeAnimationState(target) {
      animationStates.splice(indexOfObject(animationStates, {
        target: target
      }), 1);
    },
    animateAll: function animateAll(callback) {
      var _this = this;
      if (!this.options.animation) {
        clearTimeout(animationCallbackId);
        if (typeof callback === 'function') callback();
        return;
      }
      var animating = false,
        animationTime = 0;
      animationStates.forEach(function (state) {
        var time = 0,
          target = state.target,
          fromRect = target.fromRect,
          toRect = getRect(target),
          prevFromRect = target.prevFromRect,
          prevToRect = target.prevToRect,
          animatingRect = state.rect,
          targetMatrix = matrix(target, true);
        if (targetMatrix) {
          // Compensate for current animation
          toRect.top -= targetMatrix.f;
          toRect.left -= targetMatrix.e;
        }
        target.toRect = toRect;
        if (target.thisAnimationDuration) {
          // Could also check if animatingRect is between fromRect and toRect
          if (isRectEqual(prevFromRect, toRect) && !isRectEqual(fromRect, toRect) &&
          // Make sure animatingRect is on line between toRect & fromRect
          (animatingRect.top - toRect.top) / (animatingRect.left - toRect.left) === (fromRect.top - toRect.top) / (fromRect.left - toRect.left)) {
            // If returning to same place as started from animation and on same axis
            time = calculateRealTime(animatingRect, prevFromRect, prevToRect, _this.options);
          }
        }

        // if fromRect != toRect: animate
        if (!isRectEqual(toRect, fromRect)) {
          target.prevFromRect = fromRect;
          target.prevToRect = toRect;
          if (!time) {
            time = _this.options.animation;
          }
          _this.animate(target, animatingRect, toRect, time);
        }
        if (time) {
          animating = true;
          animationTime = Math.max(animationTime, time);
          clearTimeout(target.animationResetTimer);
          target.animationResetTimer = setTimeout(function () {
            target.animationTime = 0;
            target.prevFromRect = null;
            target.fromRect = null;
            target.prevToRect = null;
            target.thisAnimationDuration = null;
          }, time);
          target.thisAnimationDuration = time;
        }
      });
      clearTimeout(animationCallbackId);
      if (!animating) {
        if (typeof callback === 'function') callback();
      } else {
        animationCallbackId = setTimeout(function () {
          if (typeof callback === 'function') callback();
        }, animationTime);
      }
      animationStates = [];
    },
    animate: function animate(target, currentRect, toRect, duration) {
      if (duration) {
        css(target, 'transition', '');
        css(target, 'transform', '');
        var elMatrix = matrix(this.el),
          scaleX = elMatrix && elMatrix.a,
          scaleY = elMatrix && elMatrix.d,
          translateX = (currentRect.left - toRect.left) / (scaleX || 1),
          translateY = (currentRect.top - toRect.top) / (scaleY || 1);
        target.animatingX = !!translateX;
        target.animatingY = !!translateY;
        css(target, 'transform', 'translate3d(' + translateX + 'px,' + translateY + 'px,0)');
        this.forRepaintDummy = repaint(target); // repaint

        css(target, 'transition', 'transform ' + duration + 'ms' + (this.options.easing ? ' ' + this.options.easing : ''));
        css(target, 'transform', 'translate3d(0,0,0)');
        typeof target.animated === 'number' && clearTimeout(target.animated);
        target.animated = setTimeout(function () {
          css(target, 'transition', '');
          css(target, 'transform', '');
          target.animated = false;
          target.animatingX = false;
          target.animatingY = false;
        }, duration);
      }
    }
  };
}
function repaint(target) {
  return target.offsetWidth;
}
function calculateRealTime(animatingRect, fromRect, toRect, options) {
  return Math.sqrt(Math.pow(fromRect.top - animatingRect.top, 2) + Math.pow(fromRect.left - animatingRect.left, 2)) / Math.sqrt(Math.pow(fromRect.top - toRect.top, 2) + Math.pow(fromRect.left - toRect.left, 2)) * options.animation;
}

var plugins = [];
var defaults = {
  initializeByDefault: true
};
var PluginManager = {
  mount: function mount(plugin) {
    // Set default static properties
    for (var option in defaults) {
      if (defaults.hasOwnProperty(option) && !(option in plugin)) {
        plugin[option] = defaults[option];
      }
    }
    plugins.forEach(function (p) {
      if (p.pluginName === plugin.pluginName) {
        throw "Sortable: Cannot mount plugin ".concat(plugin.pluginName, " more than once");
      }
    });
    plugins.push(plugin);
  },
  pluginEvent: function pluginEvent(eventName, sortable, evt) {
    var _this = this;
    this.eventCanceled = false;
    evt.cancel = function () {
      _this.eventCanceled = true;
    };
    var eventNameGlobal = eventName + 'Global';
    plugins.forEach(function (plugin) {
      if (!sortable[plugin.pluginName]) return;
      // Fire global events if it exists in this sortable
      if (sortable[plugin.pluginName][eventNameGlobal]) {
        sortable[plugin.pluginName][eventNameGlobal](_objectSpread2({
          sortable: sortable
        }, evt));
      }

      // Only fire plugin event if plugin is enabled in this sortable,
      // and plugin has event defined
      if (sortable.options[plugin.pluginName] && sortable[plugin.pluginName][eventName]) {
        sortable[plugin.pluginName][eventName](_objectSpread2({
          sortable: sortable
        }, evt));
      }
    });
  },
  initializePlugins: function initializePlugins(sortable, el, defaults, options) {
    plugins.forEach(function (plugin) {
      var pluginName = plugin.pluginName;
      if (!sortable.options[pluginName] && !plugin.initializeByDefault) return;
      var initialized = new plugin(sortable, el, sortable.options);
      initialized.sortable = sortable;
      initialized.options = sortable.options;
      sortable[pluginName] = initialized;

      // Add default options from plugin
      _extends(defaults, initialized.defaults);
    });
    for (var option in sortable.options) {
      if (!sortable.options.hasOwnProperty(option)) continue;
      var modified = this.modifyOption(sortable, option, sortable.options[option]);
      if (typeof modified !== 'undefined') {
        sortable.options[option] = modified;
      }
    }
  },
  getEventProperties: function getEventProperties(name, sortable) {
    var eventProperties = {};
    plugins.forEach(function (plugin) {
      if (typeof plugin.eventProperties !== 'function') return;
      _extends(eventProperties, plugin.eventProperties.call(sortable[plugin.pluginName], name));
    });
    return eventProperties;
  },
  modifyOption: function modifyOption(sortable, name, value) {
    var modifiedValue;
    plugins.forEach(function (plugin) {
      // Plugin must exist on the Sortable
      if (!sortable[plugin.pluginName]) return;

      // If static option listener exists for this option, call in the context of the Sortable's instance of this plugin
      if (plugin.optionListeners && typeof plugin.optionListeners[name] === 'function') {
        modifiedValue = plugin.optionListeners[name].call(sortable[plugin.pluginName], value);
      }
    });
    return modifiedValue;
  }
};

function dispatchEvent(_ref) {
  var sortable = _ref.sortable,
    rootEl = _ref.rootEl,
    name = _ref.name,
    targetEl = _ref.targetEl,
    cloneEl = _ref.cloneEl,
    toEl = _ref.toEl,
    fromEl = _ref.fromEl,
    oldIndex = _ref.oldIndex,
    newIndex = _ref.newIndex,
    oldDraggableIndex = _ref.oldDraggableIndex,
    newDraggableIndex = _ref.newDraggableIndex,
    originalEvent = _ref.originalEvent,
    putSortable = _ref.putSortable,
    extraEventProperties = _ref.extraEventProperties;
  sortable = sortable || rootEl && rootEl[expando];
  if (!sortable) return;
  var evt,
    options = sortable.options,
    onName = 'on' + name.charAt(0).toUpperCase() + name.substr(1);
  // Support for new CustomEvent feature
  if (window.CustomEvent && !IE11OrLess && !Edge) {
    evt = new CustomEvent(name, {
      bubbles: true,
      cancelable: true
    });
  } else {
    evt = document.createEvent('Event');
    evt.initEvent(name, true, true);
  }
  evt.to = toEl || rootEl;
  evt.from = fromEl || rootEl;
  evt.item = targetEl || rootEl;
  evt.clone = cloneEl;
  evt.oldIndex = oldIndex;
  evt.newIndex = newIndex;
  evt.oldDraggableIndex = oldDraggableIndex;
  evt.newDraggableIndex = newDraggableIndex;
  evt.originalEvent = originalEvent;
  evt.pullMode = putSortable ? putSortable.lastPutMode : undefined;
  var allEventProperties = _objectSpread2(_objectSpread2({}, extraEventProperties), PluginManager.getEventProperties(name, sortable));
  for (var option in allEventProperties) {
    evt[option] = allEventProperties[option];
  }
  if (rootEl) {
    rootEl.dispatchEvent(evt);
  }
  if (options[onName]) {
    options[onName].call(sortable, evt);
  }
}

var _excluded = ["evt"];
var pluginEvent = function pluginEvent(eventName, sortable) {
  var _ref = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {},
    originalEvent = _ref.evt,
    data = _objectWithoutProperties(_ref, _excluded);
  PluginManager.pluginEvent.bind(Sortable)(eventName, sortable, _objectSpread2({
    dragEl: dragEl,
    parentEl: parentEl,
    ghostEl: ghostEl,
    rootEl: rootEl,
    nextEl: nextEl,
    lastDownEl: lastDownEl,
    cloneEl: cloneEl,
    cloneHidden: cloneHidden,
    dragStarted: moved,
    putSortable: putSortable,
    activeSortable: Sortable.active,
    originalEvent: originalEvent,
    oldIndex: oldIndex,
    oldDraggableIndex: oldDraggableIndex,
    newIndex: newIndex,
    newDraggableIndex: newDraggableIndex,
    hideGhostForTarget: _hideGhostForTarget,
    unhideGhostForTarget: _unhideGhostForTarget,
    cloneNowHidden: function cloneNowHidden() {
      cloneHidden = true;
    },
    cloneNowShown: function cloneNowShown() {
      cloneHidden = false;
    },
    dispatchSortableEvent: function dispatchSortableEvent(name) {
      _dispatchEvent({
        sortable: sortable,
        name: name,
        originalEvent: originalEvent
      });
    }
  }, data));
};
function _dispatchEvent(info) {
  dispatchEvent(_objectSpread2({
    putSortable: putSortable,
    cloneEl: cloneEl,
    targetEl: dragEl,
    rootEl: rootEl,
    oldIndex: oldIndex,
    oldDraggableIndex: oldDraggableIndex,
    newIndex: newIndex,
    newDraggableIndex: newDraggableIndex
  }, info));
}
var dragEl,
  parentEl,
  ghostEl,
  rootEl,
  nextEl,
  lastDownEl,
  cloneEl,
  cloneHidden,
  oldIndex,
  newIndex,
  oldDraggableIndex,
  newDraggableIndex,
  activeGroup,
  putSortable,
  awaitingDragStarted = false,
  ignoreNextClick = false,
  sortables = [],
  tapEvt,
  touchEvt,
  lastDx,
  lastDy,
  tapDistanceLeft,
  tapDistanceTop,
  moved,
  lastTarget,
  lastDirection,
  pastFirstInvertThresh = false,
  isCircumstantialInvert = false,
  targetMoveDistance,
  // For positioning ghost absolutely
  ghostRelativeParent,
  ghostRelativeParentInitialScroll = [],
  // (left, top)

  _silent = false,
  savedInputChecked = [];

/** @const */
var documentExists = typeof document !== 'undefined',
  PositionGhostAbsolutely = IOS,
  CSSFloatProperty = Edge || IE11OrLess ? 'cssFloat' : 'float',
  // This will not pass for IE9, because IE9 DnD only works on anchors
  supportDraggable = documentExists && !ChromeForAndroid && !IOS && 'draggable' in document.createElement('div'),
  supportCssPointerEvents = function () {
    if (!documentExists) return;
    // false when <= IE11
    if (IE11OrLess) {
      return false;
    }
    var el = document.createElement('x');
    el.style.cssText = 'pointer-events:auto';
    return el.style.pointerEvents === 'auto';
  }(),
  _detectDirection = function _detectDirection(el, options) {
    var elCSS = css(el),
      elWidth = parseInt(elCSS.width) - parseInt(elCSS.paddingLeft) - parseInt(elCSS.paddingRight) - parseInt(elCSS.borderLeftWidth) - parseInt(elCSS.borderRightWidth),
      child1 = getChild(el, 0, options),
      child2 = getChild(el, 1, options),
      firstChildCSS = child1 && css(child1),
      secondChildCSS = child2 && css(child2),
      firstChildWidth = firstChildCSS && parseInt(firstChildCSS.marginLeft) + parseInt(firstChildCSS.marginRight) + getRect(child1).width,
      secondChildWidth = secondChildCSS && parseInt(secondChildCSS.marginLeft) + parseInt(secondChildCSS.marginRight) + getRect(child2).width;
    if (elCSS.display === 'flex') {
      return elCSS.flexDirection === 'column' || elCSS.flexDirection === 'column-reverse' ? 'vertical' : 'horizontal';
    }
    if (elCSS.display === 'grid') {
      return elCSS.gridTemplateColumns.split(' ').length <= 1 ? 'vertical' : 'horizontal';
    }
    if (child1 && firstChildCSS["float"] && firstChildCSS["float"] !== 'none') {
      var touchingSideChild2 = firstChildCSS["float"] === 'left' ? 'left' : 'right';
      return child2 && (secondChildCSS.clear === 'both' || secondChildCSS.clear === touchingSideChild2) ? 'vertical' : 'horizontal';
    }
    return child1 && (firstChildCSS.display === 'block' || firstChildCSS.display === 'flex' || firstChildCSS.display === 'table' || firstChildCSS.display === 'grid' || firstChildWidth >= elWidth && elCSS[CSSFloatProperty] === 'none' || child2 && elCSS[CSSFloatProperty] === 'none' && firstChildWidth + secondChildWidth > elWidth) ? 'vertical' : 'horizontal';
  },
  _dragElInRowColumn = function _dragElInRowColumn(dragRect, targetRect, vertical) {
    var dragElS1Opp = vertical ? dragRect.left : dragRect.top,
      dragElS2Opp = vertical ? dragRect.right : dragRect.bottom,
      dragElOppLength = vertical ? dragRect.width : dragRect.height,
      targetS1Opp = vertical ? targetRect.left : targetRect.top,
      targetS2Opp = vertical ? targetRect.right : targetRect.bottom,
      targetOppLength = vertical ? targetRect.width : targetRect.height;
    return dragElS1Opp === targetS1Opp || dragElS2Opp === targetS2Opp || dragElS1Opp + dragElOppLength / 2 === targetS1Opp + targetOppLength / 2;
  },
  /**
   * Detects first nearest empty sortable to X and Y position using emptyInsertThreshold.
   * @param  {Number} x      X position
   * @param  {Number} y      Y position
   * @return {HTMLElement}   Element of the first found nearest Sortable
   */
  _detectNearestEmptySortable = function _detectNearestEmptySortable(x, y) {
    var ret;
    sortables.some(function (sortable) {
      var threshold = sortable[expando].options.emptyInsertThreshold;
      if (!threshold || lastChild(sortable)) return;
      var rect = getRect(sortable),
        insideHorizontally = x >= rect.left - threshold && x <= rect.right + threshold,
        insideVertically = y >= rect.top - threshold && y <= rect.bottom + threshold;
      if (insideHorizontally && insideVertically) {
        return ret = sortable;
      }
    });
    return ret;
  },
  _prepareGroup = function _prepareGroup(options) {
    function toFn(value, pull) {
      return function (to, from, dragEl, evt) {
        var sameGroup = to.options.group.name && from.options.group.name && to.options.group.name === from.options.group.name;
        if (value == null && (pull || sameGroup)) {
          // Default pull value
          // Default pull and put value if same group
          return true;
        } else if (value == null || value === false) {
          return false;
        } else if (pull && value === 'clone') {
          return value;
        } else if (typeof value === 'function') {
          return toFn(value(to, from, dragEl, evt), pull)(to, from, dragEl, evt);
        } else {
          var otherGroup = (pull ? to : from).options.group.name;
          return value === true || typeof value === 'string' && value === otherGroup || value.join && value.indexOf(otherGroup) > -1;
        }
      };
    }
    var group = {};
    var originalGroup = options.group;
    if (!originalGroup || _typeof(originalGroup) != 'object') {
      originalGroup = {
        name: originalGroup
      };
    }
    group.name = originalGroup.name;
    group.checkPull = toFn(originalGroup.pull, true);
    group.checkPut = toFn(originalGroup.put);
    group.revertClone = originalGroup.revertClone;
    options.group = group;
  },
  _hideGhostForTarget = function _hideGhostForTarget() {
    if (!supportCssPointerEvents && ghostEl) {
      css(ghostEl, 'display', 'none');
    }
  },
  _unhideGhostForTarget = function _unhideGhostForTarget() {
    if (!supportCssPointerEvents && ghostEl) {
      css(ghostEl, 'display', '');
    }
  };

// #1184 fix - Prevent click event on fallback if dragged but item not changed position
if (documentExists && !ChromeForAndroid) {
  document.addEventListener('click', function (evt) {
    if (ignoreNextClick) {
      evt.preventDefault();
      evt.stopPropagation && evt.stopPropagation();
      evt.stopImmediatePropagation && evt.stopImmediatePropagation();
      ignoreNextClick = false;
      return false;
    }
  }, true);
}
var nearestEmptyInsertDetectEvent = function nearestEmptyInsertDetectEvent(evt) {
  if (dragEl) {
    evt = evt.touches ? evt.touches[0] : evt;
    var nearest = _detectNearestEmptySortable(evt.clientX, evt.clientY);
    if (nearest) {
      // Create imitation event
      var event = {};
      for (var i in evt) {
        if (evt.hasOwnProperty(i)) {
          event[i] = evt[i];
        }
      }
      event.target = event.rootEl = nearest;
      event.preventDefault = void 0;
      event.stopPropagation = void 0;
      nearest[expando]._onDragOver(event);
    }
  }
};
var _checkOutsideTargetEl = function _checkOutsideTargetEl(evt) {
  if (dragEl) {
    dragEl.parentNode[expando]._isOutsideThisEl(evt.target);
  }
};

/**
 * @class  Sortable
 * @param  {HTMLElement}  el
 * @param  {Object}       [options]
 */
function Sortable(el, options) {
  if (!(el && el.nodeType && el.nodeType === 1)) {
    throw "Sortable: `el` must be an HTMLElement, not ".concat({}.toString.call(el));
  }
  this.el = el; // root element
  this.options = options = _extends({}, options);

  // Export instance
  el[expando] = this;
  var defaults = {
    group: null,
    sort: true,
    disabled: false,
    store: null,
    handle: null,
    draggable: /^[uo]l$/i.test(el.nodeName) ? '>li' : '>*',
    swapThreshold: 1,
    // percentage; 0 <= x <= 1
    invertSwap: false,
    // invert always
    invertedSwapThreshold: null,
    // will be set to same as swapThreshold if default
    removeCloneOnHide: true,
    direction: function direction() {
      return _detectDirection(el, this.options);
    },
    ghostClass: 'sortable-ghost',
    chosenClass: 'sortable-chosen',
    dragClass: 'sortable-drag',
    ignore: 'a, img',
    filter: null,
    preventOnFilter: true,
    animation: 0,
    easing: null,
    setData: function setData(dataTransfer, dragEl) {
      dataTransfer.setData('Text', dragEl.textContent);
    },
    dropBubble: false,
    dragoverBubble: false,
    dataIdAttr: 'data-id',
    delay: 0,
    delayOnTouchOnly: false,
    touchStartThreshold: (Number.parseInt ? Number : window).parseInt(window.devicePixelRatio, 10) || 1,
    forceFallback: false,
    fallbackClass: 'sortable-fallback',
    fallbackOnBody: false,
    fallbackTolerance: 0,
    fallbackOffset: {
      x: 0,
      y: 0
    },
    // Disabled on Safari: #1571; Enabled on Safari IOS: #2244
    supportPointer: Sortable.supportPointer !== false && 'PointerEvent' in window && (!Safari || IOS),
    emptyInsertThreshold: 5
  };
  PluginManager.initializePlugins(this, el, defaults);

  // Set default options
  for (var name in defaults) {
    !(name in options) && (options[name] = defaults[name]);
  }
  _prepareGroup(options);

  // Bind all private methods
  for (var fn in this) {
    if (fn.charAt(0) === '_' && typeof this[fn] === 'function') {
      this[fn] = this[fn].bind(this);
    }
  }

  // Setup drag mode
  this.nativeDraggable = options.forceFallback ? false : supportDraggable;
  if (this.nativeDraggable) {
    // Touch start threshold cannot be greater than the native dragstart threshold
    this.options.touchStartThreshold = 1;
  }

  // Bind events
  if (options.supportPointer) {
    on(el, 'pointerdown', this._onTapStart);
  } else {
    on(el, 'mousedown', this._onTapStart);
    on(el, 'touchstart', this._onTapStart);
  }
  if (this.nativeDraggable) {
    on(el, 'dragover', this);
    on(el, 'dragenter', this);
  }
  sortables.push(this.el);

  // Restore sorting
  options.store && options.store.get && this.sort(options.store.get(this) || []);

  // Add animation state manager
  _extends(this, AnimationStateManager());
}
Sortable.prototype = /** @lends Sortable.prototype */{
  constructor: Sortable,
  _isOutsideThisEl: function _isOutsideThisEl(target) {
    if (!this.el.contains(target) && target !== this.el) {
      lastTarget = null;
    }
  },
  _getDirection: function _getDirection(evt, target) {
    return typeof this.options.direction === 'function' ? this.options.direction.call(this, evt, target, dragEl) : this.options.direction;
  },
  _onTapStart: function _onTapStart( /** Event|TouchEvent */evt) {
    if (!evt.cancelable) return;
    var _this = this,
      el = this.el,
      options = this.options,
      preventOnFilter = options.preventOnFilter,
      type = evt.type,
      touch = evt.touches && evt.touches[0] || evt.pointerType && evt.pointerType === 'touch' && evt,
      target = (touch || evt).target,
      originalTarget = evt.target.shadowRoot && (evt.path && evt.path[0] || evt.composedPath && evt.composedPath()[0]) || target,
      filter = options.filter;
    _saveInputCheckedState(el);

    // Don't trigger start event when an element is been dragged, otherwise the evt.oldindex always wrong when set option.group.
    if (dragEl) {
      return;
    }
    if (/mousedown|pointerdown/.test(type) && evt.button !== 0 || options.disabled) {
      return; // only left button and enabled
    }

    // cancel dnd if original target is content editable
    if (originalTarget.isContentEditable) {
      return;
    }

    // Safari ignores further event handling after mousedown
    if (!this.nativeDraggable && Safari && target && target.tagName.toUpperCase() === 'SELECT') {
      return;
    }
    target = closest(target, options.draggable, el, false);
    if (target && target.animated) {
      return;
    }
    if (lastDownEl === target) {
      // Ignoring duplicate `down`
      return;
    }

    // Get the index of the dragged element within its parent
    oldIndex = index(target);
    oldDraggableIndex = index(target, options.draggable);

    // Check filter
    if (typeof filter === 'function') {
      if (filter.call(this, evt, target, this)) {
        _dispatchEvent({
          sortable: _this,
          rootEl: originalTarget,
          name: 'filter',
          targetEl: target,
          toEl: el,
          fromEl: el
        });
        pluginEvent('filter', _this, {
          evt: evt
        });
        preventOnFilter && evt.preventDefault();
        return; // cancel dnd
      }
    } else if (filter) {
      filter = filter.split(',').some(function (criteria) {
        criteria = closest(originalTarget, criteria.trim(), el, false);
        if (criteria) {
          _dispatchEvent({
            sortable: _this,
            rootEl: criteria,
            name: 'filter',
            targetEl: target,
            fromEl: el,
            toEl: el
          });
          pluginEvent('filter', _this, {
            evt: evt
          });
          return true;
        }
      });
      if (filter) {
        preventOnFilter && evt.preventDefault();
        return; // cancel dnd
      }
    }
    if (options.handle && !closest(originalTarget, options.handle, el, false)) {
      return;
    }

    // Prepare `dragstart`
    this._prepareDragStart(evt, touch, target);
  },
  _prepareDragStart: function _prepareDragStart( /** Event */evt, /** Touch */touch, /** HTMLElement */target) {
    var _this = this,
      el = _this.el,
      options = _this.options,
      ownerDocument = el.ownerDocument,
      dragStartFn;
    if (target && !dragEl && target.parentNode === el) {
      var dragRect = getRect(target);
      rootEl = el;
      dragEl = target;
      parentEl = dragEl.parentNode;
      nextEl = dragEl.nextSibling;
      lastDownEl = target;
      activeGroup = options.group;
      Sortable.dragged = dragEl;
      tapEvt = {
        target: dragEl,
        clientX: (touch || evt).clientX,
        clientY: (touch || evt).clientY
      };
      tapDistanceLeft = tapEvt.clientX - dragRect.left;
      tapDistanceTop = tapEvt.clientY - dragRect.top;
      this._lastX = (touch || evt).clientX;
      this._lastY = (touch || evt).clientY;
      dragEl.style['will-change'] = 'all';
      dragStartFn = function dragStartFn() {
        pluginEvent('delayEnded', _this, {
          evt: evt
        });
        if (Sortable.eventCanceled) {
          _this._onDrop();
          return;
        }
        // Delayed drag has been triggered
        // we can re-enable the events: touchmove/mousemove
        _this._disableDelayedDragEvents();
        if (!FireFox && _this.nativeDraggable) {
          dragEl.draggable = true;
        }

        // Bind the events: dragstart/dragend
        _this._triggerDragStart(evt, touch);

        // Drag start event
        _dispatchEvent({
          sortable: _this,
          name: 'choose',
          originalEvent: evt
        });

        // Chosen item
        toggleClass(dragEl, options.chosenClass, true);
      };

      // Disable "draggable"
      options.ignore.split(',').forEach(function (criteria) {
        find(dragEl, criteria.trim(), _disableDraggable);
      });
      on(ownerDocument, 'dragover', nearestEmptyInsertDetectEvent);
      on(ownerDocument, 'mousemove', nearestEmptyInsertDetectEvent);
      on(ownerDocument, 'touchmove', nearestEmptyInsertDetectEvent);
      if (options.supportPointer) {
        on(ownerDocument, 'pointerup', _this._onDrop);
        // Native D&D triggers pointercancel
        !this.nativeDraggable && on(ownerDocument, 'pointercancel', _this._onDrop);
      } else {
        on(ownerDocument, 'mouseup', _this._onDrop);
        on(ownerDocument, 'touchend', _this._onDrop);
        on(ownerDocument, 'touchcancel', _this._onDrop);
      }

      // Make dragEl draggable (must be before delay for FireFox)
      if (FireFox && this.nativeDraggable) {
        this.options.touchStartThreshold = 4;
        dragEl.draggable = true;
      }
      pluginEvent('delayStart', this, {
        evt: evt
      });

      // Delay is impossible for native DnD in Edge or IE
      if (options.delay && (!options.delayOnTouchOnly || touch) && (!this.nativeDraggable || !(Edge || IE11OrLess))) {
        if (Sortable.eventCanceled) {
          this._onDrop();
          return;
        }
        // If the user moves the pointer or let go the click or touch
        // before the delay has been reached:
        // disable the delayed drag
        if (options.supportPointer) {
          on(ownerDocument, 'pointerup', _this._disableDelayedDrag);
          on(ownerDocument, 'pointercancel', _this._disableDelayedDrag);
        } else {
          on(ownerDocument, 'mouseup', _this._disableDelayedDrag);
          on(ownerDocument, 'touchend', _this._disableDelayedDrag);
          on(ownerDocument, 'touchcancel', _this._disableDelayedDrag);
        }
        on(ownerDocument, 'mousemove', _this._delayedDragTouchMoveHandler);
        on(ownerDocument, 'touchmove', _this._delayedDragTouchMoveHandler);
        options.supportPointer && on(ownerDocument, 'pointermove', _this._delayedDragTouchMoveHandler);
        _this._dragStartTimer = setTimeout(dragStartFn, options.delay);
      } else {
        dragStartFn();
      }
    }
  },
  _delayedDragTouchMoveHandler: function _delayedDragTouchMoveHandler( /** TouchEvent|PointerEvent **/e) {
    var touch = e.touches ? e.touches[0] : e;
    if (Math.max(Math.abs(touch.clientX - this._lastX), Math.abs(touch.clientY - this._lastY)) >= Math.floor(this.options.touchStartThreshold / (this.nativeDraggable && window.devicePixelRatio || 1))) {
      this._disableDelayedDrag();
    }
  },
  _disableDelayedDrag: function _disableDelayedDrag() {
    dragEl && _disableDraggable(dragEl);
    clearTimeout(this._dragStartTimer);
    this._disableDelayedDragEvents();
  },
  _disableDelayedDragEvents: function _disableDelayedDragEvents() {
    var ownerDocument = this.el.ownerDocument;
    off(ownerDocument, 'mouseup', this._disableDelayedDrag);
    off(ownerDocument, 'touchend', this._disableDelayedDrag);
    off(ownerDocument, 'touchcancel', this._disableDelayedDrag);
    off(ownerDocument, 'pointerup', this._disableDelayedDrag);
    off(ownerDocument, 'pointercancel', this._disableDelayedDrag);
    off(ownerDocument, 'mousemove', this._delayedDragTouchMoveHandler);
    off(ownerDocument, 'touchmove', this._delayedDragTouchMoveHandler);
    off(ownerDocument, 'pointermove', this._delayedDragTouchMoveHandler);
  },
  _triggerDragStart: function _triggerDragStart( /** Event */evt, /** Touch */touch) {
    touch = touch || evt.pointerType == 'touch' && evt;
    if (!this.nativeDraggable || touch) {
      if (this.options.supportPointer) {
        on(document, 'pointermove', this._onTouchMove);
      } else if (touch) {
        on(document, 'touchmove', this._onTouchMove);
      } else {
        on(document, 'mousemove', this._onTouchMove);
      }
    } else {
      on(dragEl, 'dragend', this);
      on(rootEl, 'dragstart', this._onDragStart);
    }
    try {
      if (document.selection) {
        _nextTick(function () {
          document.selection.empty();
        });
      } else {
        window.getSelection().removeAllRanges();
      }
    } catch (err) {}
  },
  _dragStarted: function _dragStarted(fallback, evt) {
    awaitingDragStarted = false;
    if (rootEl && dragEl) {
      pluginEvent('dragStarted', this, {
        evt: evt
      });
      if (this.nativeDraggable) {
        on(document, 'dragover', _checkOutsideTargetEl);
      }
      var options = this.options;

      // Apply effect
      !fallback && toggleClass(dragEl, options.dragClass, false);
      toggleClass(dragEl, options.ghostClass, true);
      Sortable.active = this;
      fallback && this._appendGhost();

      // Drag start event
      _dispatchEvent({
        sortable: this,
        name: 'start',
        originalEvent: evt
      });
    } else {
      this._nulling();
    }
  },
  _emulateDragOver: function _emulateDragOver() {
    if (touchEvt) {
      this._lastX = touchEvt.clientX;
      this._lastY = touchEvt.clientY;
      _hideGhostForTarget();
      var target = document.elementFromPoint(touchEvt.clientX, touchEvt.clientY);
      var parent = target;
      while (target && target.shadowRoot) {
        target = target.shadowRoot.elementFromPoint(touchEvt.clientX, touchEvt.clientY);
        if (target === parent) break;
        parent = target;
      }
      dragEl.parentNode[expando]._isOutsideThisEl(target);
      if (parent) {
        do {
          if (parent[expando]) {
            var inserted = void 0;
            inserted = parent[expando]._onDragOver({
              clientX: touchEvt.clientX,
              clientY: touchEvt.clientY,
              target: target,
              rootEl: parent
            });
            if (inserted && !this.options.dragoverBubble) {
              break;
            }
          }
          target = parent; // store last element
        }
        /* jshint boss:true */ while (parent = getParentOrHost(parent));
      }
      _unhideGhostForTarget();
    }
  },
  _onTouchMove: function _onTouchMove( /**TouchEvent*/evt) {
    if (tapEvt) {
      var options = this.options,
        fallbackTolerance = options.fallbackTolerance,
        fallbackOffset = options.fallbackOffset,
        touch = evt.touches ? evt.touches[0] : evt,
        ghostMatrix = ghostEl && matrix(ghostEl, true),
        scaleX = ghostEl && ghostMatrix && ghostMatrix.a,
        scaleY = ghostEl && ghostMatrix && ghostMatrix.d,
        relativeScrollOffset = PositionGhostAbsolutely && ghostRelativeParent && getRelativeScrollOffset(ghostRelativeParent),
        dx = (touch.clientX - tapEvt.clientX + fallbackOffset.x) / (scaleX || 1) + (relativeScrollOffset ? relativeScrollOffset[0] - ghostRelativeParentInitialScroll[0] : 0) / (scaleX || 1),
        dy = (touch.clientY - tapEvt.clientY + fallbackOffset.y) / (scaleY || 1) + (relativeScrollOffset ? relativeScrollOffset[1] - ghostRelativeParentInitialScroll[1] : 0) / (scaleY || 1);

      // only set the status to dragging, when we are actually dragging
      if (!Sortable.active && !awaitingDragStarted) {
        if (fallbackTolerance && Math.max(Math.abs(touch.clientX - this._lastX), Math.abs(touch.clientY - this._lastY)) < fallbackTolerance) {
          return;
        }
        this._onDragStart(evt, true);
      }
      if (ghostEl) {
        if (ghostMatrix) {
          ghostMatrix.e += dx - (lastDx || 0);
          ghostMatrix.f += dy - (lastDy || 0);
        } else {
          ghostMatrix = {
            a: 1,
            b: 0,
            c: 0,
            d: 1,
            e: dx,
            f: dy
          };
        }
        var cssMatrix = "matrix(".concat(ghostMatrix.a, ",").concat(ghostMatrix.b, ",").concat(ghostMatrix.c, ",").concat(ghostMatrix.d, ",").concat(ghostMatrix.e, ",").concat(ghostMatrix.f, ")");
        css(ghostEl, 'webkitTransform', cssMatrix);
        css(ghostEl, 'mozTransform', cssMatrix);
        css(ghostEl, 'msTransform', cssMatrix);
        css(ghostEl, 'transform', cssMatrix);
        lastDx = dx;
        lastDy = dy;
        touchEvt = touch;
      }
      evt.cancelable && evt.preventDefault();
    }
  },
  _appendGhost: function _appendGhost() {
    // Bug if using scale(): https://stackoverflow.com/questions/2637058
    // Not being adjusted for
    if (!ghostEl) {
      var container = this.options.fallbackOnBody ? document.body : rootEl,
        rect = getRect(dragEl, true, PositionGhostAbsolutely, true, container),
        options = this.options;

      // Position absolutely
      if (PositionGhostAbsolutely) {
        // Get relatively positioned parent
        ghostRelativeParent = container;
        while (css(ghostRelativeParent, 'position') === 'static' && css(ghostRelativeParent, 'transform') === 'none' && ghostRelativeParent !== document) {
          ghostRelativeParent = ghostRelativeParent.parentNode;
        }
        if (ghostRelativeParent !== document.body && ghostRelativeParent !== document.documentElement) {
          if (ghostRelativeParent === document) ghostRelativeParent = getWindowScrollingElement();
          rect.top += ghostRelativeParent.scrollTop;
          rect.left += ghostRelativeParent.scrollLeft;
        } else {
          ghostRelativeParent = getWindowScrollingElement();
        }
        ghostRelativeParentInitialScroll = getRelativeScrollOffset(ghostRelativeParent);
      }
      ghostEl = dragEl.cloneNode(true);
      toggleClass(ghostEl, options.ghostClass, false);
      toggleClass(ghostEl, options.fallbackClass, true);
      toggleClass(ghostEl, options.dragClass, true);
      css(ghostEl, 'transition', '');
      css(ghostEl, 'transform', '');
      css(ghostEl, 'box-sizing', 'border-box');
      css(ghostEl, 'margin', 0);
      css(ghostEl, 'top', rect.top);
      css(ghostEl, 'left', rect.left);
      css(ghostEl, 'width', rect.width);
      css(ghostEl, 'height', rect.height);
      css(ghostEl, 'opacity', '0.8');
      css(ghostEl, 'position', PositionGhostAbsolutely ? 'absolute' : 'fixed');
      css(ghostEl, 'zIndex', '100000');
      css(ghostEl, 'pointerEvents', 'none');
      Sortable.ghost = ghostEl;
      container.appendChild(ghostEl);

      // Set transform-origin
      css(ghostEl, 'transform-origin', tapDistanceLeft / parseInt(ghostEl.style.width) * 100 + '% ' + tapDistanceTop / parseInt(ghostEl.style.height) * 100 + '%');
    }
  },
  _onDragStart: function _onDragStart( /**Event*/evt, /**boolean*/fallback) {
    var _this = this;
    var dataTransfer = evt.dataTransfer;
    var options = _this.options;
    pluginEvent('dragStart', this, {
      evt: evt
    });
    if (Sortable.eventCanceled) {
      this._onDrop();
      return;
    }
    pluginEvent('setupClone', this);
    if (!Sortable.eventCanceled) {
      cloneEl = clone(dragEl);
      cloneEl.removeAttribute("id");
      cloneEl.draggable = false;
      cloneEl.style['will-change'] = '';
      this._hideClone();
      toggleClass(cloneEl, this.options.chosenClass, false);
      Sortable.clone = cloneEl;
    }

    // #1143: IFrame support workaround
    _this.cloneId = _nextTick(function () {
      pluginEvent('clone', _this);
      if (Sortable.eventCanceled) return;
      if (!_this.options.removeCloneOnHide) {
        rootEl.insertBefore(cloneEl, dragEl);
      }
      _this._hideClone();
      _dispatchEvent({
        sortable: _this,
        name: 'clone'
      });
    });
    !fallback && toggleClass(dragEl, options.dragClass, true);

    // Set proper drop events
    if (fallback) {
      ignoreNextClick = true;
      _this._loopId = setInterval(_this._emulateDragOver, 50);
    } else {
      // Undo what was set in _prepareDragStart before drag started
      off(document, 'mouseup', _this._onDrop);
      off(document, 'touchend', _this._onDrop);
      off(document, 'touchcancel', _this._onDrop);
      if (dataTransfer) {
        dataTransfer.effectAllowed = 'move';
        options.setData && options.setData.call(_this, dataTransfer, dragEl);
      }
      on(document, 'drop', _this);

      // #1276 fix:
      css(dragEl, 'transform', 'translateZ(0)');
    }
    awaitingDragStarted = true;
    _this._dragStartId = _nextTick(_this._dragStarted.bind(_this, fallback, evt));
    on(document, 'selectstart', _this);
    moved = true;
    window.getSelection().removeAllRanges();
    if (Safari) {
      css(document.body, 'user-select', 'none');
    }
  },
  // Returns true - if no further action is needed (either inserted or another condition)
  _onDragOver: function _onDragOver( /**Event*/evt) {
    var el = this.el,
      target = evt.target,
      dragRect,
      targetRect,
      revert,
      options = this.options,
      group = options.group,
      activeSortable = Sortable.active,
      isOwner = activeGroup === group,
      canSort = options.sort,
      fromSortable = putSortable || activeSortable,
      vertical,
      _this = this,
      completedFired = false;
    if (_silent) return;
    function dragOverEvent(name, extra) {
      pluginEvent(name, _this, _objectSpread2({
        evt: evt,
        isOwner: isOwner,
        axis: vertical ? 'vertical' : 'horizontal',
        revert: revert,
        dragRect: dragRect,
        targetRect: targetRect,
        canSort: canSort,
        fromSortable: fromSortable,
        target: target,
        completed: completed,
        onMove: function onMove(target, after) {
          return _onMove(rootEl, el, dragEl, dragRect, target, getRect(target), evt, after);
        },
        changed: changed
      }, extra));
    }

    // Capture animation state
    function capture() {
      dragOverEvent('dragOverAnimationCapture');
      _this.captureAnimationState();
      if (_this !== fromSortable) {
        fromSortable.captureAnimationState();
      }
    }

    // Return invocation when dragEl is inserted (or completed)
    function completed(insertion) {
      dragOverEvent('dragOverCompleted', {
        insertion: insertion
      });
      if (insertion) {
        // Clones must be hidden before folding animation to capture dragRectAbsolute properly
        if (isOwner) {
          activeSortable._hideClone();
        } else {
          activeSortable._showClone(_this);
        }
        if (_this !== fromSortable) {
          // Set ghost class to new sortable's ghost class
          toggleClass(dragEl, putSortable ? putSortable.options.ghostClass : activeSortable.options.ghostClass, false);
          toggleClass(dragEl, options.ghostClass, true);
        }
        if (putSortable !== _this && _this !== Sortable.active) {
          putSortable = _this;
        } else if (_this === Sortable.active && putSortable) {
          putSortable = null;
        }

        // Animation
        if (fromSortable === _this) {
          _this._ignoreWhileAnimating = target;
        }
        _this.animateAll(function () {
          dragOverEvent('dragOverAnimationComplete');
          _this._ignoreWhileAnimating = null;
        });
        if (_this !== fromSortable) {
          fromSortable.animateAll();
          fromSortable._ignoreWhileAnimating = null;
        }
      }

      // Null lastTarget if it is not inside a previously swapped element
      if (target === dragEl && !dragEl.animated || target === el && !target.animated) {
        lastTarget = null;
      }

      // no bubbling and not fallback
      if (!options.dragoverBubble && !evt.rootEl && target !== document) {
        dragEl.parentNode[expando]._isOutsideThisEl(evt.target);

        // Do not detect for empty insert if already inserted
        !insertion && nearestEmptyInsertDetectEvent(evt);
      }
      !options.dragoverBubble && evt.stopPropagation && evt.stopPropagation();
      return completedFired = true;
    }

    // Call when dragEl has been inserted
    function changed() {
      newIndex = index(dragEl);
      newDraggableIndex = index(dragEl, options.draggable);
      _dispatchEvent({
        sortable: _this,
        name: 'change',
        toEl: el,
        newIndex: newIndex,
        newDraggableIndex: newDraggableIndex,
        originalEvent: evt
      });
    }
    if (evt.preventDefault !== void 0) {
      evt.cancelable && evt.preventDefault();
    }
    target = closest(target, options.draggable, el, true);
    dragOverEvent('dragOver');
    if (Sortable.eventCanceled) return completedFired;
    if (dragEl.contains(evt.target) || target.animated && target.animatingX && target.animatingY || _this._ignoreWhileAnimating === target) {
      return completed(false);
    }
    ignoreNextClick = false;
    if (activeSortable && !options.disabled && (isOwner ? canSort || (revert = parentEl !== rootEl) // Reverting item into the original list
    : putSortable === this || (this.lastPutMode = activeGroup.checkPull(this, activeSortable, dragEl, evt)) && group.checkPut(this, activeSortable, dragEl, evt))) {
      vertical = this._getDirection(evt, target) === 'vertical';
      dragRect = getRect(dragEl);
      dragOverEvent('dragOverValid');
      if (Sortable.eventCanceled) return completedFired;
      if (revert) {
        parentEl = rootEl; // actualization
        capture();
        this._hideClone();
        dragOverEvent('revert');
        if (!Sortable.eventCanceled) {
          if (nextEl) {
            rootEl.insertBefore(dragEl, nextEl);
          } else {
            rootEl.appendChild(dragEl);
          }
        }
        return completed(true);
      }
      var elLastChild = lastChild(el, options.draggable);
      if (!elLastChild || _ghostIsLast(evt, vertical, this) && !elLastChild.animated) {
        // Insert to end of list

        // If already at end of list: Do not insert
        if (elLastChild === dragEl) {
          return completed(false);
        }

        // if there is a last element, it is the target
        if (elLastChild && el === evt.target) {
          target = elLastChild;
        }
        if (target) {
          targetRect = getRect(target);
        }
        if (_onMove(rootEl, el, dragEl, dragRect, target, targetRect, evt, !!target) !== false) {
          capture();
          if (elLastChild && elLastChild.nextSibling) {
            // the last draggable element is not the last node
            el.insertBefore(dragEl, elLastChild.nextSibling);
          } else {
            el.appendChild(dragEl);
          }
          parentEl = el; // actualization

          changed();
          return completed(true);
        }
      } else if (elLastChild && _ghostIsFirst(evt, vertical, this)) {
        // Insert to start of list
        var firstChild = getChild(el, 0, options, true);
        if (firstChild === dragEl) {
          return completed(false);
        }
        target = firstChild;
        targetRect = getRect(target);
        if (_onMove(rootEl, el, dragEl, dragRect, target, targetRect, evt, false) !== false) {
          capture();
          el.insertBefore(dragEl, firstChild);
          parentEl = el; // actualization

          changed();
          return completed(true);
        }
      } else if (target.parentNode === el) {
        targetRect = getRect(target);
        var direction = 0,
          targetBeforeFirstSwap,
          differentLevel = dragEl.parentNode !== el,
          differentRowCol = !_dragElInRowColumn(dragEl.animated && dragEl.toRect || dragRect, target.animated && target.toRect || targetRect, vertical),
          side1 = vertical ? 'top' : 'left',
          scrolledPastTop = isScrolledPast(target, 'top', 'top') || isScrolledPast(dragEl, 'top', 'top'),
          scrollBefore = scrolledPastTop ? scrolledPastTop.scrollTop : void 0;
        if (lastTarget !== target) {
          targetBeforeFirstSwap = targetRect[side1];
          pastFirstInvertThresh = false;
          isCircumstantialInvert = !differentRowCol && options.invertSwap || differentLevel;
        }
        direction = _getSwapDirection(evt, target, targetRect, vertical, differentRowCol ? 1 : options.swapThreshold, options.invertedSwapThreshold == null ? options.swapThreshold : options.invertedSwapThreshold, isCircumstantialInvert, lastTarget === target);
        var sibling;
        if (direction !== 0) {
          // Check if target is beside dragEl in respective direction (ignoring hidden elements)
          var dragIndex = index(dragEl);
          do {
            dragIndex -= direction;
            sibling = parentEl.children[dragIndex];
          } while (sibling && (css(sibling, 'display') === 'none' || sibling === ghostEl));
        }
        // If dragEl is already beside target: Do not insert
        if (direction === 0 || sibling === target) {
          return completed(false);
        }
        lastTarget = target;
        lastDirection = direction;
        var nextSibling = target.nextElementSibling,
          after = false;
        after = direction === 1;
        var moveVector = _onMove(rootEl, el, dragEl, dragRect, target, targetRect, evt, after);
        if (moveVector !== false) {
          if (moveVector === 1 || moveVector === -1) {
            after = moveVector === 1;
          }
          _silent = true;
          setTimeout(_unsilent, 30);
          capture();
          if (after && !nextSibling) {
            el.appendChild(dragEl);
          } else {
            target.parentNode.insertBefore(dragEl, after ? nextSibling : target);
          }

          // Undo chrome's scroll adjustment (has no effect on other browsers)
          if (scrolledPastTop) {
            scrollBy(scrolledPastTop, 0, scrollBefore - scrolledPastTop.scrollTop);
          }
          parentEl = dragEl.parentNode; // actualization

          // must be done before animation
          if (targetBeforeFirstSwap !== undefined && !isCircumstantialInvert) {
            targetMoveDistance = Math.abs(targetBeforeFirstSwap - getRect(target)[side1]);
          }
          changed();
          return completed(true);
        }
      }
      if (el.contains(dragEl)) {
        return completed(false);
      }
    }
    return false;
  },
  _ignoreWhileAnimating: null,
  _offMoveEvents: function _offMoveEvents() {
    off(document, 'mousemove', this._onTouchMove);
    off(document, 'touchmove', this._onTouchMove);
    off(document, 'pointermove', this._onTouchMove);
    off(document, 'dragover', nearestEmptyInsertDetectEvent);
    off(document, 'mousemove', nearestEmptyInsertDetectEvent);
    off(document, 'touchmove', nearestEmptyInsertDetectEvent);
  },
  _offUpEvents: function _offUpEvents() {
    var ownerDocument = this.el.ownerDocument;
    off(ownerDocument, 'mouseup', this._onDrop);
    off(ownerDocument, 'touchend', this._onDrop);
    off(ownerDocument, 'pointerup', this._onDrop);
    off(ownerDocument, 'pointercancel', this._onDrop);
    off(ownerDocument, 'touchcancel', this._onDrop);
    off(document, 'selectstart', this);
  },
  _onDrop: function _onDrop( /**Event*/evt) {
    var el = this.el,
      options = this.options;

    // Get the index of the dragged element within its parent
    newIndex = index(dragEl);
    newDraggableIndex = index(dragEl, options.draggable);
    pluginEvent('drop', this, {
      evt: evt
    });
    parentEl = dragEl && dragEl.parentNode;

    // Get again after plugin event
    newIndex = index(dragEl);
    newDraggableIndex = index(dragEl, options.draggable);
    if (Sortable.eventCanceled) {
      this._nulling();
      return;
    }
    awaitingDragStarted = false;
    isCircumstantialInvert = false;
    pastFirstInvertThresh = false;
    clearInterval(this._loopId);
    clearTimeout(this._dragStartTimer);
    _cancelNextTick(this.cloneId);
    _cancelNextTick(this._dragStartId);

    // Unbind events
    if (this.nativeDraggable) {
      off(document, 'drop', this);
      off(el, 'dragstart', this._onDragStart);
    }
    this._offMoveEvents();
    this._offUpEvents();
    if (Safari) {
      css(document.body, 'user-select', '');
    }
    css(dragEl, 'transform', '');
    if (evt) {
      if (moved) {
        evt.cancelable && evt.preventDefault();
        !options.dropBubble && evt.stopPropagation();
      }
      ghostEl && ghostEl.parentNode && ghostEl.parentNode.removeChild(ghostEl);
      if (rootEl === parentEl || putSortable && putSortable.lastPutMode !== 'clone') {
        // Remove clone(s)
        cloneEl && cloneEl.parentNode && cloneEl.parentNode.removeChild(cloneEl);
      }
      if (dragEl) {
        if (this.nativeDraggable) {
          off(dragEl, 'dragend', this);
        }
        _disableDraggable(dragEl);
        dragEl.style['will-change'] = '';

        // Remove classes
        // ghostClass is added in dragStarted
        if (moved && !awaitingDragStarted) {
          toggleClass(dragEl, putSortable ? putSortable.options.ghostClass : this.options.ghostClass, false);
        }
        toggleClass(dragEl, this.options.chosenClass, false);

        // Drag stop event
        _dispatchEvent({
          sortable: this,
          name: 'unchoose',
          toEl: parentEl,
          newIndex: null,
          newDraggableIndex: null,
          originalEvent: evt
        });
        if (rootEl !== parentEl) {
          if (newIndex >= 0) {
            // Add event
            _dispatchEvent({
              rootEl: parentEl,
              name: 'add',
              toEl: parentEl,
              fromEl: rootEl,
              originalEvent: evt
            });

            // Remove event
            _dispatchEvent({
              sortable: this,
              name: 'remove',
              toEl: parentEl,
              originalEvent: evt
            });

            // drag from one list and drop into another
            _dispatchEvent({
              rootEl: parentEl,
              name: 'sort',
              toEl: parentEl,
              fromEl: rootEl,
              originalEvent: evt
            });
            _dispatchEvent({
              sortable: this,
              name: 'sort',
              toEl: parentEl,
              originalEvent: evt
            });
          }
          putSortable && putSortable.save();
        } else {
          if (newIndex !== oldIndex) {
            if (newIndex >= 0) {
              // drag & drop within the same list
              _dispatchEvent({
                sortable: this,
                name: 'update',
                toEl: parentEl,
                originalEvent: evt
              });
              _dispatchEvent({
                sortable: this,
                name: 'sort',
                toEl: parentEl,
                originalEvent: evt
              });
            }
          }
        }
        if (Sortable.active) {
          /* jshint eqnull:true */
          if (newIndex == null || newIndex === -1) {
            newIndex = oldIndex;
            newDraggableIndex = oldDraggableIndex;
          }
          _dispatchEvent({
            sortable: this,
            name: 'end',
            toEl: parentEl,
            originalEvent: evt
          });

          // Save sorting
          this.save();
        }
      }
    }
    this._nulling();
  },
  _nulling: function _nulling() {
    pluginEvent('nulling', this);
    rootEl = dragEl = parentEl = ghostEl = nextEl = cloneEl = lastDownEl = cloneHidden = tapEvt = touchEvt = moved = newIndex = newDraggableIndex = oldIndex = oldDraggableIndex = lastTarget = lastDirection = putSortable = activeGroup = Sortable.dragged = Sortable.ghost = Sortable.clone = Sortable.active = null;
    savedInputChecked.forEach(function (el) {
      el.checked = true;
    });
    savedInputChecked.length = lastDx = lastDy = 0;
  },
  handleEvent: function handleEvent( /**Event*/evt) {
    switch (evt.type) {
      case 'drop':
      case 'dragend':
        this._onDrop(evt);
        break;
      case 'dragenter':
      case 'dragover':
        if (dragEl) {
          this._onDragOver(evt);
          _globalDragOver(evt);
        }
        break;
      case 'selectstart':
        evt.preventDefault();
        break;
    }
  },
  /**
   * Serializes the item into an array of string.
   * @returns {String[]}
   */
  toArray: function toArray() {
    var order = [],
      el,
      children = this.el.children,
      i = 0,
      n = children.length,
      options = this.options;
    for (; i < n; i++) {
      el = children[i];
      if (closest(el, options.draggable, this.el, false)) {
        order.push(el.getAttribute(options.dataIdAttr) || _generateId(el));
      }
    }
    return order;
  },
  /**
   * Sorts the elements according to the array.
   * @param  {String[]}  order  order of the items
   */
  sort: function sort(order, useAnimation) {
    var items = {},
      rootEl = this.el;
    this.toArray().forEach(function (id, i) {
      var el = rootEl.children[i];
      if (closest(el, this.options.draggable, rootEl, false)) {
        items[id] = el;
      }
    }, this);
    useAnimation && this.captureAnimationState();
    order.forEach(function (id) {
      if (items[id]) {
        rootEl.removeChild(items[id]);
        rootEl.appendChild(items[id]);
      }
    });
    useAnimation && this.animateAll();
  },
  /**
   * Save the current sorting
   */
  save: function save() {
    var store = this.options.store;
    store && store.set && store.set(this);
  },
  /**
   * For each element in the set, get the first element that matches the selector by testing the element itself and traversing up through its ancestors in the DOM tree.
   * @param   {HTMLElement}  el
   * @param   {String}       [selector]  default: `options.draggable`
   * @returns {HTMLElement|null}
   */
  closest: function closest$1(el, selector) {
    return closest(el, selector || this.options.draggable, this.el, false);
  },
  /**
   * Set/get option
   * @param   {string} name
   * @param   {*}      [value]
   * @returns {*}
   */
  option: function option(name, value) {
    var options = this.options;
    if (value === void 0) {
      return options[name];
    } else {
      var modifiedValue = PluginManager.modifyOption(this, name, value);
      if (typeof modifiedValue !== 'undefined') {
        options[name] = modifiedValue;
      } else {
        options[name] = value;
      }
      if (name === 'group') {
        _prepareGroup(options);
      }
    }
  },
  /**
   * Destroy
   */
  destroy: function destroy() {
    pluginEvent('destroy', this);
    var el = this.el;
    el[expando] = null;
    off(el, 'mousedown', this._onTapStart);
    off(el, 'touchstart', this._onTapStart);
    off(el, 'pointerdown', this._onTapStart);
    if (this.nativeDraggable) {
      off(el, 'dragover', this);
      off(el, 'dragenter', this);
    }
    // Remove draggable attributes
    Array.prototype.forEach.call(el.querySelectorAll('[draggable]'), function (el) {
      el.removeAttribute('draggable');
    });
    this._onDrop();
    this._disableDelayedDragEvents();
    sortables.splice(sortables.indexOf(this.el), 1);
    this.el = el = null;
  },
  _hideClone: function _hideClone() {
    if (!cloneHidden) {
      pluginEvent('hideClone', this);
      if (Sortable.eventCanceled) return;
      css(cloneEl, 'display', 'none');
      if (this.options.removeCloneOnHide && cloneEl.parentNode) {
        cloneEl.parentNode.removeChild(cloneEl);
      }
      cloneHidden = true;
    }
  },
  _showClone: function _showClone(putSortable) {
    if (putSortable.lastPutMode !== 'clone') {
      this._hideClone();
      return;
    }
    if (cloneHidden) {
      pluginEvent('showClone', this);
      if (Sortable.eventCanceled) return;

      // show clone at dragEl or original position
      if (dragEl.parentNode == rootEl && !this.options.group.revertClone) {
        rootEl.insertBefore(cloneEl, dragEl);
      } else if (nextEl) {
        rootEl.insertBefore(cloneEl, nextEl);
      } else {
        rootEl.appendChild(cloneEl);
      }
      if (this.options.group.revertClone) {
        this.animate(dragEl, cloneEl);
      }
      css(cloneEl, 'display', '');
      cloneHidden = false;
    }
  }
};
function _globalDragOver( /**Event*/evt) {
  if (evt.dataTransfer) {
    evt.dataTransfer.dropEffect = 'move';
  }
  evt.cancelable && evt.preventDefault();
}
function _onMove(fromEl, toEl, dragEl, dragRect, targetEl, targetRect, originalEvent, willInsertAfter) {
  var evt,
    sortable = fromEl[expando],
    onMoveFn = sortable.options.onMove,
    retVal;
  // Support for new CustomEvent feature
  if (window.CustomEvent && !IE11OrLess && !Edge) {
    evt = new CustomEvent('move', {
      bubbles: true,
      cancelable: true
    });
  } else {
    evt = document.createEvent('Event');
    evt.initEvent('move', true, true);
  }
  evt.to = toEl;
  evt.from = fromEl;
  evt.dragged = dragEl;
  evt.draggedRect = dragRect;
  evt.related = targetEl || toEl;
  evt.relatedRect = targetRect || getRect(toEl);
  evt.willInsertAfter = willInsertAfter;
  evt.originalEvent = originalEvent;
  fromEl.dispatchEvent(evt);
  if (onMoveFn) {
    retVal = onMoveFn.call(sortable, evt, originalEvent);
  }
  return retVal;
}
function _disableDraggable(el) {
  el.draggable = false;
}
function _unsilent() {
  _silent = false;
}
function _ghostIsFirst(evt, vertical, sortable) {
  var firstElRect = getRect(getChild(sortable.el, 0, sortable.options, true));
  var childContainingRect = getChildContainingRectFromElement(sortable.el, sortable.options, ghostEl);
  var spacer = 10;
  return vertical ? evt.clientX < childContainingRect.left - spacer || evt.clientY < firstElRect.top && evt.clientX < firstElRect.right : evt.clientY < childContainingRect.top - spacer || evt.clientY < firstElRect.bottom && evt.clientX < firstElRect.left;
}
function _ghostIsLast(evt, vertical, sortable) {
  var lastElRect = getRect(lastChild(sortable.el, sortable.options.draggable));
  var childContainingRect = getChildContainingRectFromElement(sortable.el, sortable.options, ghostEl);
  var spacer = 10;
  return vertical ? evt.clientX > childContainingRect.right + spacer || evt.clientY > lastElRect.bottom && evt.clientX > lastElRect.left : evt.clientY > childContainingRect.bottom + spacer || evt.clientX > lastElRect.right && evt.clientY > lastElRect.top;
}
function _getSwapDirection(evt, target, targetRect, vertical, swapThreshold, invertedSwapThreshold, invertSwap, isLastTarget) {
  var mouseOnAxis = vertical ? evt.clientY : evt.clientX,
    targetLength = vertical ? targetRect.height : targetRect.width,
    targetS1 = vertical ? targetRect.top : targetRect.left,
    targetS2 = vertical ? targetRect.bottom : targetRect.right,
    invert = false;
  if (!invertSwap) {
    // Never invert or create dragEl shadow when target movemenet causes mouse to move past the end of regular swapThreshold
    if (isLastTarget && targetMoveDistance < targetLength * swapThreshold) {
      // multiplied only by swapThreshold because mouse will already be inside target by (1 - threshold) * targetLength / 2
      // check if past first invert threshold on side opposite of lastDirection
      if (!pastFirstInvertThresh && (lastDirection === 1 ? mouseOnAxis > targetS1 + targetLength * invertedSwapThreshold / 2 : mouseOnAxis < targetS2 - targetLength * invertedSwapThreshold / 2)) {
        // past first invert threshold, do not restrict inverted threshold to dragEl shadow
        pastFirstInvertThresh = true;
      }
      if (!pastFirstInvertThresh) {
        // dragEl shadow (target move distance shadow)
        if (lastDirection === 1 ? mouseOnAxis < targetS1 + targetMoveDistance // over dragEl shadow
        : mouseOnAxis > targetS2 - targetMoveDistance) {
          return -lastDirection;
        }
      } else {
        invert = true;
      }
    } else {
      // Regular
      if (mouseOnAxis > targetS1 + targetLength * (1 - swapThreshold) / 2 && mouseOnAxis < targetS2 - targetLength * (1 - swapThreshold) / 2) {
        return _getInsertDirection(target);
      }
    }
  }
  invert = invert || invertSwap;
  if (invert) {
    // Invert of regular
    if (mouseOnAxis < targetS1 + targetLength * invertedSwapThreshold / 2 || mouseOnAxis > targetS2 - targetLength * invertedSwapThreshold / 2) {
      return mouseOnAxis > targetS1 + targetLength / 2 ? 1 : -1;
    }
  }
  return 0;
}

/**
 * Gets the direction dragEl must be swapped relative to target in order to make it
 * seem that dragEl has been "inserted" into that element's position
 * @param  {HTMLElement} target       The target whose position dragEl is being inserted at
 * @return {Number}                   Direction dragEl must be swapped
 */
function _getInsertDirection(target) {
  if (index(dragEl) < index(target)) {
    return 1;
  } else {
    return -1;
  }
}

/**
 * Generate id
 * @param   {HTMLElement} el
 * @returns {String}
 * @private
 */
function _generateId(el) {
  var str = el.tagName + el.className + el.src + el.href + el.textContent,
    i = str.length,
    sum = 0;
  while (i--) {
    sum += str.charCodeAt(i);
  }
  return sum.toString(36);
}
function _saveInputCheckedState(root) {
  savedInputChecked.length = 0;
  var inputs = root.getElementsByTagName('input');
  var idx = inputs.length;
  while (idx--) {
    var el = inputs[idx];
    el.checked && savedInputChecked.push(el);
  }
}
function _nextTick(fn) {
  return setTimeout(fn, 0);
}
function _cancelNextTick(id) {
  return clearTimeout(id);
}

// Fixed #973:
if (documentExists) {
  on(document, 'touchmove', function (evt) {
    if ((Sortable.active || awaitingDragStarted) && evt.cancelable) {
      evt.preventDefault();
    }
  });
}

// Export utils
Sortable.utils = {
  on: on,
  off: off,
  css: css,
  find: find,
  is: function is(el, selector) {
    return !!closest(el, selector, el, false);
  },
  extend: extend,
  throttle: throttle,
  closest: closest,
  toggleClass: toggleClass,
  clone: clone,
  index: index,
  nextTick: _nextTick,
  cancelNextTick: _cancelNextTick,
  detectDirection: _detectDirection,
  getChild: getChild,
  expando: expando
};

/**
 * Get the Sortable instance of an element
 * @param  {HTMLElement} element The element
 * @return {Sortable|undefined}         The instance of Sortable
 */
Sortable.get = function (element) {
  return element[expando];
};

/**
 * Mount a plugin to Sortable
 * @param  {...SortablePlugin|SortablePlugin[]} plugins       Plugins being mounted
 */
Sortable.mount = function () {
  for (var _len = arguments.length, plugins = new Array(_len), _key = 0; _key < _len; _key++) {
    plugins[_key] = arguments[_key];
  }
  if (plugins[0].constructor === Array) plugins = plugins[0];
  plugins.forEach(function (plugin) {
    if (!plugin.prototype || !plugin.prototype.constructor) {
      throw "Sortable: Mounted plugin must be a constructor function, not ".concat({}.toString.call(plugin));
    }
    if (plugin.utils) Sortable.utils = _objectSpread2(_objectSpread2({}, Sortable.utils), plugin.utils);
    PluginManager.mount(plugin);
  });
};

/**
 * Create sortable instance
 * @param {HTMLElement}  el
 * @param {Object}      [options]
 */
Sortable.create = function (el, options) {
  return new Sortable(el, options);
};

// Export
Sortable.version = version;

var autoScrolls = [],
  scrollEl,
  scrollRootEl,
  scrolling = false,
  lastAutoScrollX,
  lastAutoScrollY,
  touchEvt$1,
  pointerElemChangedInterval;
function AutoScrollPlugin() {
  function AutoScroll() {
    this.defaults = {
      scroll: true,
      forceAutoScrollFallback: false,
      scrollSensitivity: 30,
      scrollSpeed: 10,
      bubbleScroll: true
    };

    // Bind all private methods
    for (var fn in this) {
      if (fn.charAt(0) === '_' && typeof this[fn] === 'function') {
        this[fn] = this[fn].bind(this);
      }
    }
  }
  AutoScroll.prototype = {
    dragStarted: function dragStarted(_ref) {
      var originalEvent = _ref.originalEvent;
      if (this.sortable.nativeDraggable) {
        on(document, 'dragover', this._handleAutoScroll);
      } else {
        if (this.options.supportPointer) {
          on(document, 'pointermove', this._handleFallbackAutoScroll);
        } else if (originalEvent.touches) {
          on(document, 'touchmove', this._handleFallbackAutoScroll);
        } else {
          on(document, 'mousemove', this._handleFallbackAutoScroll);
        }
      }
    },
    dragOverCompleted: function dragOverCompleted(_ref2) {
      var originalEvent = _ref2.originalEvent;
      // For when bubbling is canceled and using fallback (fallback 'touchmove' always reached)
      if (!this.options.dragOverBubble && !originalEvent.rootEl) {
        this._handleAutoScroll(originalEvent);
      }
    },
    drop: function drop() {
      if (this.sortable.nativeDraggable) {
        off(document, 'dragover', this._handleAutoScroll);
      } else {
        off(document, 'pointermove', this._handleFallbackAutoScroll);
        off(document, 'touchmove', this._handleFallbackAutoScroll);
        off(document, 'mousemove', this._handleFallbackAutoScroll);
      }
      clearPointerElemChangedInterval();
      clearAutoScrolls();
      cancelThrottle();
    },
    nulling: function nulling() {
      touchEvt$1 = scrollRootEl = scrollEl = scrolling = pointerElemChangedInterval = lastAutoScrollX = lastAutoScrollY = null;
      autoScrolls.length = 0;
    },
    _handleFallbackAutoScroll: function _handleFallbackAutoScroll(evt) {
      this._handleAutoScroll(evt, true);
    },
    _handleAutoScroll: function _handleAutoScroll(evt, fallback) {
      var _this = this;
      var x = (evt.touches ? evt.touches[0] : evt).clientX,
        y = (evt.touches ? evt.touches[0] : evt).clientY,
        elem = document.elementFromPoint(x, y);
      touchEvt$1 = evt;

      // IE does not seem to have native autoscroll,
      // Edge's autoscroll seems too conditional,
      // MACOS Safari does not have autoscroll,
      // Firefox and Chrome are good
      if (fallback || this.options.forceAutoScrollFallback || Edge || IE11OrLess || Safari) {
        autoScroll(evt, this.options, elem, fallback);

        // Listener for pointer element change
        var ogElemScroller = getParentAutoScrollElement(elem, true);
        if (scrolling && (!pointerElemChangedInterval || x !== lastAutoScrollX || y !== lastAutoScrollY)) {
          pointerElemChangedInterval && clearPointerElemChangedInterval();
          // Detect for pointer elem change, emulating native DnD behaviour
          pointerElemChangedInterval = setInterval(function () {
            var newElem = getParentAutoScrollElement(document.elementFromPoint(x, y), true);
            if (newElem !== ogElemScroller) {
              ogElemScroller = newElem;
              clearAutoScrolls();
            }
            autoScroll(evt, _this.options, newElem, fallback);
          }, 10);
          lastAutoScrollX = x;
          lastAutoScrollY = y;
        }
      } else {
        // if DnD is enabled (and browser has good autoscrolling), first autoscroll will already scroll, so get parent autoscroll of first autoscroll
        if (!this.options.bubbleScroll || getParentAutoScrollElement(elem, true) === getWindowScrollingElement()) {
          clearAutoScrolls();
          return;
        }
        autoScroll(evt, this.options, getParentAutoScrollElement(elem, false), false);
      }
    }
  };
  return _extends(AutoScroll, {
    pluginName: 'scroll',
    initializeByDefault: true
  });
}
function clearAutoScrolls() {
  autoScrolls.forEach(function (autoScroll) {
    clearInterval(autoScroll.pid);
  });
  autoScrolls = [];
}
function clearPointerElemChangedInterval() {
  clearInterval(pointerElemChangedInterval);
}
var autoScroll = throttle(function (evt, options, rootEl, isFallback) {
  // Bug: https://bugzilla.mozilla.org/show_bug.cgi?id=505521
  if (!options.scroll) return;
  var x = (evt.touches ? evt.touches[0] : evt).clientX,
    y = (evt.touches ? evt.touches[0] : evt).clientY,
    sens = options.scrollSensitivity,
    speed = options.scrollSpeed,
    winScroller = getWindowScrollingElement();
  var scrollThisInstance = false,
    scrollCustomFn;

  // New scroll root, set scrollEl
  if (scrollRootEl !== rootEl) {
    scrollRootEl = rootEl;
    clearAutoScrolls();
    scrollEl = options.scroll;
    scrollCustomFn = options.scrollFn;
    if (scrollEl === true) {
      scrollEl = getParentAutoScrollElement(rootEl, true);
    }
  }
  var layersOut = 0;
  var currentParent = scrollEl;
  do {
    var el = currentParent,
      rect = getRect(el),
      top = rect.top,
      bottom = rect.bottom,
      left = rect.left,
      right = rect.right,
      width = rect.width,
      height = rect.height,
      canScrollX = void 0,
      canScrollY = void 0,
      scrollWidth = el.scrollWidth,
      scrollHeight = el.scrollHeight,
      elCSS = css(el),
      scrollPosX = el.scrollLeft,
      scrollPosY = el.scrollTop;
    if (el === winScroller) {
      canScrollX = width < scrollWidth && (elCSS.overflowX === 'auto' || elCSS.overflowX === 'scroll' || elCSS.overflowX === 'visible');
      canScrollY = height < scrollHeight && (elCSS.overflowY === 'auto' || elCSS.overflowY === 'scroll' || elCSS.overflowY === 'visible');
    } else {
      canScrollX = width < scrollWidth && (elCSS.overflowX === 'auto' || elCSS.overflowX === 'scroll');
      canScrollY = height < scrollHeight && (elCSS.overflowY === 'auto' || elCSS.overflowY === 'scroll');
    }
    var vx = canScrollX && (Math.abs(right - x) <= sens && scrollPosX + width < scrollWidth) - (Math.abs(left - x) <= sens && !!scrollPosX);
    var vy = canScrollY && (Math.abs(bottom - y) <= sens && scrollPosY + height < scrollHeight) - (Math.abs(top - y) <= sens && !!scrollPosY);
    if (!autoScrolls[layersOut]) {
      for (var i = 0; i <= layersOut; i++) {
        if (!autoScrolls[i]) {
          autoScrolls[i] = {};
        }
      }
    }
    if (autoScrolls[layersOut].vx != vx || autoScrolls[layersOut].vy != vy || autoScrolls[layersOut].el !== el) {
      autoScrolls[layersOut].el = el;
      autoScrolls[layersOut].vx = vx;
      autoScrolls[layersOut].vy = vy;
      clearInterval(autoScrolls[layersOut].pid);
      if (vx != 0 || vy != 0) {
        scrollThisInstance = true;
        /* jshint loopfunc:true */
        autoScrolls[layersOut].pid = setInterval(function () {
          // emulate drag over during autoscroll (fallback), emulating native DnD behaviour
          if (isFallback && this.layer === 0) {
            Sortable.active._onTouchMove(touchEvt$1); // To move ghost if it is positioned absolutely
          }
          var scrollOffsetY = autoScrolls[this.layer].vy ? autoScrolls[this.layer].vy * speed : 0;
          var scrollOffsetX = autoScrolls[this.layer].vx ? autoScrolls[this.layer].vx * speed : 0;
          if (typeof scrollCustomFn === 'function') {
            if (scrollCustomFn.call(Sortable.dragged.parentNode[expando], scrollOffsetX, scrollOffsetY, evt, touchEvt$1, autoScrolls[this.layer].el) !== 'continue') {
              return;
            }
          }
          scrollBy(autoScrolls[this.layer].el, scrollOffsetX, scrollOffsetY);
        }.bind({
          layer: layersOut
        }), 24);
      }
    }
    layersOut++;
  } while (options.bubbleScroll && currentParent !== winScroller && (currentParent = getParentAutoScrollElement(currentParent, false)));
  scrolling = scrollThisInstance; // in case another function catches scrolling as false in between when it is not
}, 30);

var drop = function drop(_ref) {
  var originalEvent = _ref.originalEvent,
    putSortable = _ref.putSortable,
    dragEl = _ref.dragEl,
    activeSortable = _ref.activeSortable,
    dispatchSortableEvent = _ref.dispatchSortableEvent,
    hideGhostForTarget = _ref.hideGhostForTarget,
    unhideGhostForTarget = _ref.unhideGhostForTarget;
  if (!originalEvent) return;
  var toSortable = putSortable || activeSortable;
  hideGhostForTarget();
  var touch = originalEvent.changedTouches && originalEvent.changedTouches.length ? originalEvent.changedTouches[0] : originalEvent;
  var target = document.elementFromPoint(touch.clientX, touch.clientY);
  unhideGhostForTarget();
  if (toSortable && !toSortable.el.contains(target)) {
    dispatchSortableEvent('spill');
    this.onSpill({
      dragEl: dragEl,
      putSortable: putSortable
    });
  }
};
function Revert() {}
Revert.prototype = {
  startIndex: null,
  dragStart: function dragStart(_ref2) {
    var oldDraggableIndex = _ref2.oldDraggableIndex;
    this.startIndex = oldDraggableIndex;
  },
  onSpill: function onSpill(_ref3) {
    var dragEl = _ref3.dragEl,
      putSortable = _ref3.putSortable;
    this.sortable.captureAnimationState();
    if (putSortable) {
      putSortable.captureAnimationState();
    }
    var nextSibling = getChild(this.sortable.el, this.startIndex, this.options);
    if (nextSibling) {
      this.sortable.el.insertBefore(dragEl, nextSibling);
    } else {
      this.sortable.el.appendChild(dragEl);
    }
    this.sortable.animateAll();
    if (putSortable) {
      putSortable.animateAll();
    }
  },
  drop: drop
};
_extends(Revert, {
  pluginName: 'revertOnSpill'
});
function Remove() {}
Remove.prototype = {
  onSpill: function onSpill(_ref4) {
    var dragEl = _ref4.dragEl,
      putSortable = _ref4.putSortable;
    var parentSortable = putSortable || this.sortable;
    parentSortable.captureAnimationState();
    dragEl.parentNode && dragEl.parentNode.removeChild(dragEl);
    parentSortable.animateAll();
  },
  drop: drop
};
_extends(Remove, {
  pluginName: 'removeOnSpill'
});

var lastSwapEl;
function SwapPlugin() {
  function Swap() {
    this.defaults = {
      swapClass: 'sortable-swap-highlight'
    };
  }
  Swap.prototype = {
    dragStart: function dragStart(_ref) {
      var dragEl = _ref.dragEl;
      lastSwapEl = dragEl;
    },
    dragOverValid: function dragOverValid(_ref2) {
      var completed = _ref2.completed,
        target = _ref2.target,
        onMove = _ref2.onMove,
        activeSortable = _ref2.activeSortable,
        changed = _ref2.changed,
        cancel = _ref2.cancel;
      if (!activeSortable.options.swap) return;
      var el = this.sortable.el,
        options = this.options;
      if (target && target !== el) {
        var prevSwapEl = lastSwapEl;
        if (onMove(target) !== false) {
          toggleClass(target, options.swapClass, true);
          lastSwapEl = target;
        } else {
          lastSwapEl = null;
        }
        if (prevSwapEl && prevSwapEl !== lastSwapEl) {
          toggleClass(prevSwapEl, options.swapClass, false);
        }
      }
      changed();
      completed(true);
      cancel();
    },
    drop: function drop(_ref3) {
      var activeSortable = _ref3.activeSortable,
        putSortable = _ref3.putSortable,
        dragEl = _ref3.dragEl;
      var toSortable = putSortable || this.sortable;
      var options = this.options;
      lastSwapEl && toggleClass(lastSwapEl, options.swapClass, false);
      if (lastSwapEl && (options.swap || putSortable && putSortable.options.swap)) {
        if (dragEl !== lastSwapEl) {
          toSortable.captureAnimationState();
          if (toSortable !== activeSortable) activeSortable.captureAnimationState();
          swapNodes(dragEl, lastSwapEl);
          toSortable.animateAll();
          if (toSortable !== activeSortable) activeSortable.animateAll();
        }
      }
    },
    nulling: function nulling() {
      lastSwapEl = null;
    }
  };
  return _extends(Swap, {
    pluginName: 'swap',
    eventProperties: function eventProperties() {
      return {
        swapItem: lastSwapEl
      };
    }
  });
}
function swapNodes(n1, n2) {
  var p1 = n1.parentNode,
    p2 = n2.parentNode,
    i1,
    i2;
  if (!p1 || !p2 || p1.isEqualNode(n2) || p2.isEqualNode(n1)) return;
  i1 = index(n1);
  i2 = index(n2);
  if (p1.isEqualNode(p2) && i1 < i2) {
    i2++;
  }
  p1.insertBefore(n2, p1.children[i1]);
  p2.insertBefore(n1, p2.children[i2]);
}

var multiDragElements = [],
  multiDragClones = [],
  lastMultiDragSelect,
  // for selection with modifier key down (SHIFT)
  multiDragSortable,
  initialFolding = false,
  // Initial multi-drag fold when drag started
  folding = false,
  // Folding any other time
  dragStarted = false,
  dragEl$1,
  clonesFromRect,
  clonesHidden;
function MultiDragPlugin() {
  function MultiDrag(sortable) {
    // Bind all private methods
    for (var fn in this) {
      if (fn.charAt(0) === '_' && typeof this[fn] === 'function') {
        this[fn] = this[fn].bind(this);
      }
    }
    if (!sortable.options.avoidImplicitDeselect) {
      if (sortable.options.supportPointer) {
        on(document, 'pointerup', this._deselectMultiDrag);
      } else {
        on(document, 'mouseup', this._deselectMultiDrag);
        on(document, 'touchend', this._deselectMultiDrag);
      }
    }
    on(document, 'keydown', this._checkKeyDown);
    on(document, 'keyup', this._checkKeyUp);
    this.defaults = {
      selectedClass: 'sortable-selected',
      multiDragKey: null,
      avoidImplicitDeselect: false,
      setData: function setData(dataTransfer, dragEl) {
        var data = '';
        if (multiDragElements.length && multiDragSortable === sortable) {
          multiDragElements.forEach(function (multiDragElement, i) {
            data += (!i ? '' : ', ') + multiDragElement.textContent;
          });
        } else {
          data = dragEl.textContent;
        }
        dataTransfer.setData('Text', data);
      }
    };
  }
  MultiDrag.prototype = {
    multiDragKeyDown: false,
    isMultiDrag: false,
    delayStartGlobal: function delayStartGlobal(_ref) {
      var dragged = _ref.dragEl;
      dragEl$1 = dragged;
    },
    delayEnded: function delayEnded() {
      this.isMultiDrag = ~multiDragElements.indexOf(dragEl$1);
    },
    setupClone: function setupClone(_ref2) {
      var sortable = _ref2.sortable,
        cancel = _ref2.cancel;
      if (!this.isMultiDrag) return;
      for (var i = 0; i < multiDragElements.length; i++) {
        multiDragClones.push(clone(multiDragElements[i]));
        multiDragClones[i].sortableIndex = multiDragElements[i].sortableIndex;
        multiDragClones[i].draggable = false;
        multiDragClones[i].style['will-change'] = '';
        toggleClass(multiDragClones[i], this.options.selectedClass, false);
        multiDragElements[i] === dragEl$1 && toggleClass(multiDragClones[i], this.options.chosenClass, false);
      }
      sortable._hideClone();
      cancel();
    },
    clone: function clone(_ref3) {
      var sortable = _ref3.sortable,
        rootEl = _ref3.rootEl,
        dispatchSortableEvent = _ref3.dispatchSortableEvent,
        cancel = _ref3.cancel;
      if (!this.isMultiDrag) return;
      if (!this.options.removeCloneOnHide) {
        if (multiDragElements.length && multiDragSortable === sortable) {
          insertMultiDragClones(true, rootEl);
          dispatchSortableEvent('clone');
          cancel();
        }
      }
    },
    showClone: function showClone(_ref4) {
      var cloneNowShown = _ref4.cloneNowShown,
        rootEl = _ref4.rootEl,
        cancel = _ref4.cancel;
      if (!this.isMultiDrag) return;
      insertMultiDragClones(false, rootEl);
      multiDragClones.forEach(function (clone) {
        css(clone, 'display', '');
      });
      cloneNowShown();
      clonesHidden = false;
      cancel();
    },
    hideClone: function hideClone(_ref5) {
      var _this = this;
      var sortable = _ref5.sortable,
        cloneNowHidden = _ref5.cloneNowHidden,
        cancel = _ref5.cancel;
      if (!this.isMultiDrag) return;
      multiDragClones.forEach(function (clone) {
        css(clone, 'display', 'none');
        if (_this.options.removeCloneOnHide && clone.parentNode) {
          clone.parentNode.removeChild(clone);
        }
      });
      cloneNowHidden();
      clonesHidden = true;
      cancel();
    },
    dragStartGlobal: function dragStartGlobal(_ref6) {
      var sortable = _ref6.sortable;
      if (!this.isMultiDrag && multiDragSortable) {
        multiDragSortable.multiDrag._deselectMultiDrag();
      }
      multiDragElements.forEach(function (multiDragElement) {
        multiDragElement.sortableIndex = index(multiDragElement);
      });

      // Sort multi-drag elements
      multiDragElements = multiDragElements.sort(function (a, b) {
        return a.sortableIndex - b.sortableIndex;
      });
      dragStarted = true;
    },
    dragStarted: function dragStarted(_ref7) {
      var _this2 = this;
      var sortable = _ref7.sortable;
      if (!this.isMultiDrag) return;
      if (this.options.sort) {
        // Capture rects,
        // hide multi drag elements (by positioning them absolute),
        // set multi drag elements rects to dragRect,
        // show multi drag elements,
        // animate to rects,
        // unset rects & remove from DOM

        sortable.captureAnimationState();
        if (this.options.animation) {
          multiDragElements.forEach(function (multiDragElement) {
            if (multiDragElement === dragEl$1) return;
            css(multiDragElement, 'position', 'absolute');
          });
          var dragRect = getRect(dragEl$1, false, true, true);
          multiDragElements.forEach(function (multiDragElement) {
            if (multiDragElement === dragEl$1) return;
            setRect(multiDragElement, dragRect);
          });
          folding = true;
          initialFolding = true;
        }
      }
      sortable.animateAll(function () {
        folding = false;
        initialFolding = false;
        if (_this2.options.animation) {
          multiDragElements.forEach(function (multiDragElement) {
            unsetRect(multiDragElement);
          });
        }

        // Remove all auxiliary multidrag items from el, if sorting enabled
        if (_this2.options.sort) {
          removeMultiDragElements();
        }
      });
    },
    dragOver: function dragOver(_ref8) {
      var target = _ref8.target,
        completed = _ref8.completed,
        cancel = _ref8.cancel;
      if (folding && ~multiDragElements.indexOf(target)) {
        completed(false);
        cancel();
      }
    },
    revert: function revert(_ref9) {
      var fromSortable = _ref9.fromSortable,
        rootEl = _ref9.rootEl,
        sortable = _ref9.sortable,
        dragRect = _ref9.dragRect;
      if (multiDragElements.length > 1) {
        // Setup unfold animation
        multiDragElements.forEach(function (multiDragElement) {
          sortable.addAnimationState({
            target: multiDragElement,
            rect: folding ? getRect(multiDragElement) : dragRect
          });
          unsetRect(multiDragElement);
          multiDragElement.fromRect = dragRect;
          fromSortable.removeAnimationState(multiDragElement);
        });
        folding = false;
        insertMultiDragElements(!this.options.removeCloneOnHide, rootEl);
      }
    },
    dragOverCompleted: function dragOverCompleted(_ref10) {
      var sortable = _ref10.sortable,
        isOwner = _ref10.isOwner,
        insertion = _ref10.insertion,
        activeSortable = _ref10.activeSortable,
        parentEl = _ref10.parentEl,
        putSortable = _ref10.putSortable;
      var options = this.options;
      if (insertion) {
        // Clones must be hidden before folding animation to capture dragRectAbsolute properly
        if (isOwner) {
          activeSortable._hideClone();
        }
        initialFolding = false;
        // If leaving sort:false root, or already folding - Fold to new location
        if (options.animation && multiDragElements.length > 1 && (folding || !isOwner && !activeSortable.options.sort && !putSortable)) {
          // Fold: Set all multi drag elements's rects to dragEl's rect when multi-drag elements are invisible
          var dragRectAbsolute = getRect(dragEl$1, false, true, true);
          multiDragElements.forEach(function (multiDragElement) {
            if (multiDragElement === dragEl$1) return;
            setRect(multiDragElement, dragRectAbsolute);

            // Move element(s) to end of parentEl so that it does not interfere with multi-drag clones insertion if they are inserted
            // while folding, and so that we can capture them again because old sortable will no longer be fromSortable
            parentEl.appendChild(multiDragElement);
          });
          folding = true;
        }

        // Clones must be shown (and check to remove multi drags) after folding when interfering multiDragElements are moved out
        if (!isOwner) {
          // Only remove if not folding (folding will remove them anyways)
          if (!folding) {
            removeMultiDragElements();
          }
          if (multiDragElements.length > 1) {
            var clonesHiddenBefore = clonesHidden;
            activeSortable._showClone(sortable);

            // Unfold animation for clones if showing from hidden
            if (activeSortable.options.animation && !clonesHidden && clonesHiddenBefore) {
              multiDragClones.forEach(function (clone) {
                activeSortable.addAnimationState({
                  target: clone,
                  rect: clonesFromRect
                });
                clone.fromRect = clonesFromRect;
                clone.thisAnimationDuration = null;
              });
            }
          } else {
            activeSortable._showClone(sortable);
          }
        }
      }
    },
    dragOverAnimationCapture: function dragOverAnimationCapture(_ref11) {
      var dragRect = _ref11.dragRect,
        isOwner = _ref11.isOwner,
        activeSortable = _ref11.activeSortable;
      multiDragElements.forEach(function (multiDragElement) {
        multiDragElement.thisAnimationDuration = null;
      });
      if (activeSortable.options.animation && !isOwner && activeSortable.multiDrag.isMultiDrag) {
        clonesFromRect = _extends({}, dragRect);
        var dragMatrix = matrix(dragEl$1, true);
        clonesFromRect.top -= dragMatrix.f;
        clonesFromRect.left -= dragMatrix.e;
      }
    },
    dragOverAnimationComplete: function dragOverAnimationComplete() {
      if (folding) {
        folding = false;
        removeMultiDragElements();
      }
    },
    drop: function drop(_ref12) {
      var evt = _ref12.originalEvent,
        rootEl = _ref12.rootEl,
        parentEl = _ref12.parentEl,
        sortable = _ref12.sortable,
        dispatchSortableEvent = _ref12.dispatchSortableEvent,
        oldIndex = _ref12.oldIndex,
        putSortable = _ref12.putSortable;
      var toSortable = putSortable || this.sortable;
      if (!evt) return;
      var options = this.options,
        children = parentEl.children;

      // Multi-drag selection
      if (!dragStarted) {
        if (options.multiDragKey && !this.multiDragKeyDown) {
          this._deselectMultiDrag();
        }
        toggleClass(dragEl$1, options.selectedClass, !~multiDragElements.indexOf(dragEl$1));
        if (!~multiDragElements.indexOf(dragEl$1)) {
          multiDragElements.push(dragEl$1);
          dispatchEvent({
            sortable: sortable,
            rootEl: rootEl,
            name: 'select',
            targetEl: dragEl$1,
            originalEvent: evt
          });

          // Modifier activated, select from last to dragEl
          if (evt.shiftKey && lastMultiDragSelect && sortable.el.contains(lastMultiDragSelect)) {
            var lastIndex = index(lastMultiDragSelect),
              currentIndex = index(dragEl$1);
            if (~lastIndex && ~currentIndex && lastIndex !== currentIndex) {
              (function () {
                // Must include lastMultiDragSelect (select it), in case modified selection from no selection
                // (but previous selection existed)
                var n, i;
                if (currentIndex > lastIndex) {
                  i = lastIndex;
                  n = currentIndex;
                } else {
                  i = currentIndex;
                  n = lastIndex + 1;
                }
                var filter = options.filter;
                for (; i < n; i++) {
                  if (~multiDragElements.indexOf(children[i])) continue;
                  // Check if element is draggable
                  if (!closest(children[i], options.draggable, parentEl, false)) continue;
                  // Check if element is filtered
                  var filtered = filter && (typeof filter === 'function' ? filter.call(sortable, evt, children[i], sortable) : filter.split(',').some(function (criteria) {
                    return closest(children[i], criteria.trim(), parentEl, false);
                  }));
                  if (filtered) continue;
                  toggleClass(children[i], options.selectedClass, true);
                  multiDragElements.push(children[i]);
                  dispatchEvent({
                    sortable: sortable,
                    rootEl: rootEl,
                    name: 'select',
                    targetEl: children[i],
                    originalEvent: evt
                  });
                }
              })();
            }
          } else {
            lastMultiDragSelect = dragEl$1;
          }
          multiDragSortable = toSortable;
        } else {
          multiDragElements.splice(multiDragElements.indexOf(dragEl$1), 1);
          lastMultiDragSelect = null;
          dispatchEvent({
            sortable: sortable,
            rootEl: rootEl,
            name: 'deselect',
            targetEl: dragEl$1,
            originalEvent: evt
          });
        }
      }

      // Multi-drag drop
      if (dragStarted && this.isMultiDrag) {
        folding = false;
        // Do not "unfold" after around dragEl if reverted
        if ((parentEl[expando].options.sort || parentEl !== rootEl) && multiDragElements.length > 1) {
          var dragRect = getRect(dragEl$1),
            multiDragIndex = index(dragEl$1, ':not(.' + this.options.selectedClass + ')');
          if (!initialFolding && options.animation) dragEl$1.thisAnimationDuration = null;
          toSortable.captureAnimationState();
          if (!initialFolding) {
            if (options.animation) {
              dragEl$1.fromRect = dragRect;
              multiDragElements.forEach(function (multiDragElement) {
                multiDragElement.thisAnimationDuration = null;
                if (multiDragElement !== dragEl$1) {
                  var rect = folding ? getRect(multiDragElement) : dragRect;
                  multiDragElement.fromRect = rect;

                  // Prepare unfold animation
                  toSortable.addAnimationState({
                    target: multiDragElement,
                    rect: rect
                  });
                }
              });
            }

            // Multi drag elements are not necessarily removed from the DOM on drop, so to reinsert
            // properly they must all be removed
            removeMultiDragElements();
            multiDragElements.forEach(function (multiDragElement) {
              if (children[multiDragIndex]) {
                parentEl.insertBefore(multiDragElement, children[multiDragIndex]);
              } else {
                parentEl.appendChild(multiDragElement);
              }
              multiDragIndex++;
            });

            // If initial folding is done, the elements may have changed position because they are now
            // unfolding around dragEl, even though dragEl may not have his index changed, so update event
            // must be fired here as Sortable will not.
            if (oldIndex === index(dragEl$1)) {
              var update = false;
              multiDragElements.forEach(function (multiDragElement) {
                if (multiDragElement.sortableIndex !== index(multiDragElement)) {
                  update = true;
                  return;
                }
              });
              if (update) {
                dispatchSortableEvent('update');
                dispatchSortableEvent('sort');
              }
            }
          }

          // Must be done after capturing individual rects (scroll bar)
          multiDragElements.forEach(function (multiDragElement) {
            unsetRect(multiDragElement);
          });
          toSortable.animateAll();
        }
        multiDragSortable = toSortable;
      }

      // Remove clones if necessary
      if (rootEl === parentEl || putSortable && putSortable.lastPutMode !== 'clone') {
        multiDragClones.forEach(function (clone) {
          clone.parentNode && clone.parentNode.removeChild(clone);
        });
      }
    },
    nullingGlobal: function nullingGlobal() {
      this.isMultiDrag = dragStarted = false;
      multiDragClones.length = 0;
    },
    destroyGlobal: function destroyGlobal() {
      this._deselectMultiDrag();
      off(document, 'pointerup', this._deselectMultiDrag);
      off(document, 'mouseup', this._deselectMultiDrag);
      off(document, 'touchend', this._deselectMultiDrag);
      off(document, 'keydown', this._checkKeyDown);
      off(document, 'keyup', this._checkKeyUp);
    },
    _deselectMultiDrag: function _deselectMultiDrag(evt) {
      if (typeof dragStarted !== "undefined" && dragStarted) return;

      // Only deselect if selection is in this sortable
      if (multiDragSortable !== this.sortable) return;

      // Only deselect if target is not item in this sortable
      if (evt && closest(evt.target, this.options.draggable, this.sortable.el, false)) return;

      // Only deselect if left click
      if (evt && evt.button !== 0) return;
      while (multiDragElements.length) {
        var el = multiDragElements[0];
        toggleClass(el, this.options.selectedClass, false);
        multiDragElements.shift();
        dispatchEvent({
          sortable: this.sortable,
          rootEl: this.sortable.el,
          name: 'deselect',
          targetEl: el,
          originalEvent: evt
        });
      }
    },
    _checkKeyDown: function _checkKeyDown(evt) {
      if (evt.key === this.options.multiDragKey) {
        this.multiDragKeyDown = true;
      }
    },
    _checkKeyUp: function _checkKeyUp(evt) {
      if (evt.key === this.options.multiDragKey) {
        this.multiDragKeyDown = false;
      }
    }
  };
  return _extends(MultiDrag, {
    // Static methods & properties
    pluginName: 'multiDrag',
    utils: {
      /**
       * Selects the provided multi-drag item
       * @param  {HTMLElement} el    The element to be selected
       */
      select: function select(el) {
        var sortable = el.parentNode[expando];
        if (!sortable || !sortable.options.multiDrag || ~multiDragElements.indexOf(el)) return;
        if (multiDragSortable && multiDragSortable !== sortable) {
          multiDragSortable.multiDrag._deselectMultiDrag();
          multiDragSortable = sortable;
        }
        toggleClass(el, sortable.options.selectedClass, true);
        multiDragElements.push(el);
      },
      /**
       * Deselects the provided multi-drag item
       * @param  {HTMLElement} el    The element to be deselected
       */
      deselect: function deselect(el) {
        var sortable = el.parentNode[expando],
          index = multiDragElements.indexOf(el);
        if (!sortable || !sortable.options.multiDrag || !~index) return;
        toggleClass(el, sortable.options.selectedClass, false);
        multiDragElements.splice(index, 1);
      }
    },
    eventProperties: function eventProperties() {
      var _this3 = this;
      var oldIndicies = [],
        newIndicies = [];
      multiDragElements.forEach(function (multiDragElement) {
        oldIndicies.push({
          multiDragElement: multiDragElement,
          index: multiDragElement.sortableIndex
        });

        // multiDragElements will already be sorted if folding
        var newIndex;
        if (folding && multiDragElement !== dragEl$1) {
          newIndex = -1;
        } else if (folding) {
          newIndex = index(multiDragElement, ':not(.' + _this3.options.selectedClass + ')');
        } else {
          newIndex = index(multiDragElement);
        }
        newIndicies.push({
          multiDragElement: multiDragElement,
          index: newIndex
        });
      });
      return {
        items: _toConsumableArray(multiDragElements),
        clones: [].concat(multiDragClones),
        oldIndicies: oldIndicies,
        newIndicies: newIndicies
      };
    },
    optionListeners: {
      multiDragKey: function multiDragKey(key) {
        key = key.toLowerCase();
        if (key === 'ctrl') {
          key = 'Control';
        } else if (key.length > 1) {
          key = key.charAt(0).toUpperCase() + key.substr(1);
        }
        return key;
      }
    }
  });
}
function insertMultiDragElements(clonesInserted, rootEl) {
  multiDragElements.forEach(function (multiDragElement, i) {
    var target = rootEl.children[multiDragElement.sortableIndex + (clonesInserted ? Number(i) : 0)];
    if (target) {
      rootEl.insertBefore(multiDragElement, target);
    } else {
      rootEl.appendChild(multiDragElement);
    }
  });
}

/**
 * Insert multi-drag clones
 * @param  {[Boolean]} elementsInserted  Whether the multi-drag elements are inserted
 * @param  {HTMLElement} rootEl
 */
function insertMultiDragClones(elementsInserted, rootEl) {
  multiDragClones.forEach(function (clone, i) {
    var target = rootEl.children[clone.sortableIndex + (elementsInserted ? Number(i) : 0)];
    if (target) {
      rootEl.insertBefore(clone, target);
    } else {
      rootEl.appendChild(clone);
    }
  });
}
function removeMultiDragElements() {
  multiDragElements.forEach(function (multiDragElement) {
    if (multiDragElement === dragEl$1) return;
    multiDragElement.parentNode && multiDragElement.parentNode.removeChild(multiDragElement);
  });
}

Sortable.mount(new AutoScrollPlugin());
Sortable.mount(Remove, Revert);

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (Sortable);



/***/ },

/***/ "./src/commands/helpers.ts"
/*!*********************************!*\
  !*** ./src/commands/helpers.ts ***!
  \*********************************/
(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   countExtractedMessages: () => (/* binding */ countExtractedMessages),
/* harmony export */   getMostRecentMessageId: () => (/* binding */ getMostRecentMessageId),
/* harmony export */   getStateForMessage: () => (/* binding */ getStateForMessage)
/* harmony export */ });
/* harmony import */ var _utils_messageState__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../utils/messageState */ "./src/utils/messageState.ts");
// ============================================
// Slash Command Helper Functions (Pure/Testable)
// ============================================

/**
 * Get the most recent message ID from the chat.
 */
function getMostRecentMessageId(context) {
    return context.chat.length - 1;
}
/**
 * Get stored state for a message by ID.
 */
function getStateForMessage(context, messageId) {
    const message = context.chat[messageId];
    if (!message)
        return null;
    const stateData = (0,_utils_messageState__WEBPACK_IMPORTED_MODULE_0__.getMessageState)(message);
    return stateData?.state ?? null;
}
/**
 * Count messages that have extracted state.
 */
function countExtractedMessages(context) {
    let extracted = 0;
    const total = context.chat.length;
    for (let i = 0; i < total; i++) {
        const message = context.chat[i];
        if ((0,_utils_messageState__WEBPACK_IMPORTED_MODULE_0__.getMessageState)(message)) {
            extracted++;
        }
    }
    return { extracted, total };
}


/***/ },

/***/ "./src/commands/slashCommands.ts"
/*!***************************************!*\
  !*** ./src/commands/slashCommands.ts ***!
  \***************************************/
(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   registerSlashCommands: () => (/* binding */ registerSlashCommands),
/* harmony export */   runExtractAll: () => (/* binding */ runExtractAll)
/* harmony export */ });
/* harmony import */ var _constants__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../constants */ "./src/constants.ts");
/* harmony import */ var _ui_stateDisplay__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../ui/stateDisplay */ "./src/ui/stateDisplay.tsx");
/* harmony import */ var _extractors_extractState__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../extractors/extractState */ "./src/extractors/extractState.ts");
/* harmony import */ var _utils_messageState__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../utils/messageState */ "./src/utils/messageState.ts");
/* harmony import */ var _injectors_injectState__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../injectors/injectState */ "./src/injectors/injectState.ts");
/* harmony import */ var _state_narrativeState__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../state/narrativeState */ "./src/state/narrativeState.ts");
/* harmony import */ var _extractors_extractChapter__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ../extractors/extractChapter */ "./src/extractors/extractChapter.ts");
/* harmony import */ var _helpers__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./helpers */ "./src/commands/helpers.ts");
// ============================================
// BlazeTracker Slash Commands (STScript)
// ============================================









// Slash command types are retrieved from SillyTavern context at registration time
function log(..._args) {
    // Logging disabled for production
}
// ============================================
// Helper Functions
// ============================================
/**
 * Get default time for chapter extraction.
 */
function getDefaultTime() {
    return {
        year: 2024,
        month: 1,
        day: 1,
        dayOfWeek: 'Monday',
        hour: 12,
        minute: 0,
        second: 0,
    };
}
// ============================================
// Command: /bt-extract
// ============================================
async function extractCommand(args, _value) {
    const context = SillyTavern.getContext();
    // Parse message ID from args or use most recent
    let messageId;
    if (args.id !== undefined && args.id !== '') {
        messageId = parseInt(args.id, 10);
        if (isNaN(messageId) || messageId < 0 || messageId >= context.chat.length) {
            return `Error: Invalid message ID "${args.id}". Valid range: 0-${context.chat.length - 1}`;
        }
    }
    else {
        messageId = (0,_helpers__WEBPACK_IMPORTED_MODULE_7__.getMostRecentMessageId)(context);
    }
    if (messageId <= 0) {
        return 'Error: No messages to extract (chat is empty or only has system message)';
    }
    log('Slash command: extracting state for message', messageId);
    // Note: Milestone clearing for re-extraction happens inside doExtractState
    // so it applies to all extraction triggers (swiping, editing, fire button, etc.)
    try {
        const result = await (0,_ui_stateDisplay__WEBPACK_IMPORTED_MODULE_1__.doExtractState)(messageId, { isManual: true });
        if (result) {
            (0,_injectors_injectState__WEBPACK_IMPORTED_MODULE_4__.updateInjectionFromChat)();
            return `Successfully extracted state for message ${messageId}`;
        }
        else {
            return `Extraction returned no result for message ${messageId} (may have been aborted or already in progress)`;
        }
    }
    catch (e) {
        log('Extraction error:', e);
        return `Error extracting state: ${e.message}`;
    }
}
// ============================================
// Command: /bt-chapter
// ============================================
async function chapterCommand(args, _value) {
    const context = SillyTavern.getContext();
    const lastMessageId = (0,_helpers__WEBPACK_IMPORTED_MODULE_7__.getMostRecentMessageId)(context);
    if (lastMessageId <= 0) {
        return 'Error: No messages in chat';
    }
    // Get the current state
    const message = context.chat[lastMessageId];
    let stateData = (0,_utils_messageState__WEBPACK_IMPORTED_MODULE_3__.getMessageState)(message);
    // If no state, run extraction first
    if (!stateData?.state) {
        if (_ui_stateDisplay__WEBPACK_IMPORTED_MODULE_1__.extractionInProgress.has(lastMessageId)) {
            return 'Error: Extraction already in progress for this message. Please wait.';
        }
        const extractResult = await (0,_ui_stateDisplay__WEBPACK_IMPORTED_MODULE_1__.doExtractState)(lastMessageId, { isManual: true });
        if (!extractResult?.state) {
            return 'Error: Failed to extract state for the most recent message.';
        }
        stateData = extractResult;
    }
    const state = stateData.state;
    const currentEvents = state.currentEvents ?? [];
    if (currentEvents.length === 0) {
        return 'Error: No events in current chapter to finalize. Need at least one event.';
    }
    const narrativeState = (0,_state_narrativeState__WEBPACK_IMPORTED_MODULE_5__.getOrInitializeNarrativeState)();
    const currentChapter = state.currentChapter ?? 0;
    // Get time range from events
    const startTime = currentEvents[0]?.timestamp ?? state.time ?? getDefaultTime();
    const endTime = state.time ?? getDefaultTime();
    const primaryLocation = state.location
        ? `${state.location.area} - ${state.location.place}`
        : 'Unknown';
    log('Slash command: forcing chapter break at chapter', currentChapter);
    try {
        // Extract chapter summary via LLM (force create since this is an explicit command)
        const chapterResult = await (0,_extractors_extractChapter__WEBPACK_IMPORTED_MODULE_6__.extractChapterBoundary)({
            events: currentEvents,
            narrativeState,
            chapterIndex: currentChapter,
            startTime,
            endTime,
            primaryLocation,
            forceCreate: true,
        });
        if (!chapterResult.chapter) {
            return 'Error: Failed to generate chapter summary';
        }
        // Allow title override
        if (args.title) {
            chapterResult.chapter.title = args.title;
        }
        // Add chapter to narrative state
        (0,_state_narrativeState__WEBPACK_IMPORTED_MODULE_5__.addChapter)(narrativeState, chapterResult.chapter);
        await (0,_state_narrativeState__WEBPACK_IMPORTED_MODULE_5__.saveNarrativeState)(narrativeState);
        // Update the message state - increment chapter, clear events, show chapter ended
        const updatedState = {
            ...state,
            currentChapter: currentChapter + 1,
            currentEvents: undefined,
            chapterEnded: {
                index: currentChapter,
                title: chapterResult.chapter.title,
                summary: chapterResult.chapter.summary,
                eventCount: currentEvents.length,
                reason: 'manual',
            },
        };
        const newStateData = {
            state: updatedState,
            extractedAt: new Date().toISOString(),
        };
        (0,_utils_messageState__WEBPACK_IMPORTED_MODULE_3__.setMessageState)(message, newStateData);
        await context.saveChat();
        // Re-render the state display with the new state data
        (0,_ui_stateDisplay__WEBPACK_IMPORTED_MODULE_1__.renderMessageState)(lastMessageId, newStateData);
        (0,_injectors_injectState__WEBPACK_IMPORTED_MODULE_4__.updateInjectionFromChat)();
        return `Chapter ${currentChapter + 1} created: "${chapterResult.chapter.title}" (${currentEvents.length} events archived)`;
    }
    catch (e) {
        log('Chapter creation error:', e);
        return `Error creating chapter: ${e.message}`;
    }
}
// ============================================
// Command: /bt-extract-all
// ============================================
async function extractAllCommand(_args, _value) {
    const context = SillyTavern.getContext();
    const totalMessages = context.chat.length;
    if (totalMessages <= 1) {
        return 'Error: No messages to extract (chat is empty or only has system message)';
    }
    // Get current state info for confirmation message
    const currentNarrativeState = (0,_state_narrativeState__WEBPACK_IMPORTED_MODULE_5__.getNarrativeState)();
    const chapterCount = currentNarrativeState?.chapters.length ?? 0;
    const relationshipCount = currentNarrativeState?.relationships.length ?? 0;
    // Show confirmation popup
    const confirmMessage = `This will DELETE all BlazeTracker data FOR THIS CHAT and re-extract from scratch:\n\n` +
        `â€¢ ${chapterCount} chapter(s)\n` +
        `â€¢ ${relationshipCount} relationship(s) (including all milestones)\n` +
        `â€¢ All per-message state data\n\n` +
        `Other chats are not affected. This cannot be undone. Continue?`;
    const confirmed = (await context.callGenericPopup?.(confirmMessage, 1 /* CONFIRM */)) ??
        window.confirm(confirmMessage);
    if (!confirmed) {
        return 'Extraction cancelled.';
    }
    log('Slash command: extracting all messages');
    // Unmount all roots first to prevent stale UI during extraction
    (0,_ui_stateDisplay__WEBPACK_IMPORTED_MODULE_1__.unmountAllRoots)();
    // Clear all existing state before starting
    log('Clearing all existing BlazeTracker state...');
    // 1. Reset narrative state (chapters, relationships)
    const freshNarrativeState = (0,_state_narrativeState__WEBPACK_IMPORTED_MODULE_5__.initializeNarrativeState)();
    (0,_state_narrativeState__WEBPACK_IMPORTED_MODULE_5__.setNarrativeState)(freshNarrativeState);
    // 2. Clear all per-message states
    for (let i = 1; i < totalMessages; i++) {
        const message = context.chat[i];
        if (message.extra && message.extra[_constants__WEBPACK_IMPORTED_MODULE_0__.EXTENSION_KEY]) {
            delete message.extra[_constants__WEBPACK_IMPORTED_MODULE_0__.EXTENSION_KEY];
        }
    }
    // Save the cleared state
    await context.saveChat();
    log('All state cleared, starting fresh extraction...');
    let extracted = 0;
    let failed = 0;
    // Set batch flag to prevent GENERATION_ENDED handler from interfering
    (0,_extractors_extractState__WEBPACK_IMPORTED_MODULE_2__.setBatchExtractionInProgress)(true);
    try {
        // Start from message 1 (skip system message at 0)
        for (let i = 1; i < totalMessages; i++) {
            try {
                // Show progress via toastr if available
                window.toastr?.info(`Extracting message ${i}/${totalMessages - 1}...`, _constants__WEBPACK_IMPORTED_MODULE_0__.EXTENSION_NAME, { timeOut: 1000 });
                const result = await (0,_ui_stateDisplay__WEBPACK_IMPORTED_MODULE_1__.doExtractState)(i);
                if (result) {
                    extracted++;
                }
                else {
                    failed++;
                }
            }
            catch (e) {
                log(`Failed to extract message ${i}:`, e);
                failed++;
            }
        }
    }
    finally {
        // Always clear the batch flag when done
        (0,_extractors_extractState__WEBPACK_IMPORTED_MODULE_2__.setBatchExtractionInProgress)(false);
    }
    // Final update
    (0,_ui_stateDisplay__WEBPACK_IMPORTED_MODULE_1__.renderAllStates)();
    (0,_injectors_injectState__WEBPACK_IMPORTED_MODULE_4__.updateInjectionFromChat)();
    const results = [];
    if (extracted > 0)
        results.push(`${extracted} extracted`);
    if (failed > 0)
        results.push(`${failed} failed`);
    return `Extraction complete (full reset): ${results.join(', ')}`;
}
/**
 * Run extraction on all messages (used by legacy data migration).
 * Assumes state has already been cleared/initialized.
 */
async function runExtractAll() {
    const context = SillyTavern.getContext();
    const totalMessages = context.chat.length;
    let extracted = 0;
    let failed = 0;
    // Set batch flag to prevent GENERATION_ENDED handler from interfering
    (0,_extractors_extractState__WEBPACK_IMPORTED_MODULE_2__.setBatchExtractionInProgress)(true);
    try {
        // Start from message 1 (skip system message at 0)
        for (let i = 1; i < totalMessages; i++) {
            try {
                window.toastr?.info(`Extracting message ${i}/${totalMessages - 1}...`, _constants__WEBPACK_IMPORTED_MODULE_0__.EXTENSION_NAME, { timeOut: 1000 });
                const result = await (0,_ui_stateDisplay__WEBPACK_IMPORTED_MODULE_1__.doExtractState)(i);
                if (result) {
                    extracted++;
                }
                else {
                    failed++;
                }
            }
            catch (e) {
                log(`Failed to extract message ${i}:`, e);
                failed++;
            }
        }
    }
    finally {
        (0,_extractors_extractState__WEBPACK_IMPORTED_MODULE_2__.setBatchExtractionInProgress)(false);
    }
    // Final update
    (0,_ui_stateDisplay__WEBPACK_IMPORTED_MODULE_1__.renderAllStates)();
    (0,_injectors_injectState__WEBPACK_IMPORTED_MODULE_4__.updateInjectionFromChat)();
    return { extracted, failed };
}
// ============================================
// Command: /bt-status
// ============================================
async function statusCommand(_args, _value) {
    const context = SillyTavern.getContext();
    const { extracted, total } = (0,_helpers__WEBPACK_IMPORTED_MODULE_7__.countExtractedMessages)(context);
    const narrativeState = (0,_state_narrativeState__WEBPACK_IMPORTED_MODULE_5__.getNarrativeState)();
    // Build status rows
    const rows = [
        { label: 'Messages Extracted', value: `${extracted} / ${total}` },
    ];
    if (narrativeState) {
        rows.push({ label: 'Chapters', value: String(narrativeState.chapters.length) });
        rows.push({ label: 'Relationships', value: String(narrativeState.relationships.length) });
    }
    else {
        rows.push({ label: 'Narrative State', value: 'Not initialized' });
    }
    // Get current events from most recent state
    const lastMessageId = (0,_helpers__WEBPACK_IMPORTED_MODULE_7__.getMostRecentMessageId)(context);
    if (lastMessageId > 0) {
        const state = (0,_helpers__WEBPACK_IMPORTED_MODULE_7__.getStateForMessage)(context, lastMessageId);
        if (state?.currentEvents) {
            rows.push({ label: 'Current Chapter Events', value: String(state.currentEvents.length) });
        }
    }
    // Create popup content
    const container = document.createElement('div');
    container.innerHTML = `
		<div style="padding: 15px; min-width: 300px;">
			<h3 style="margin: 0 0 15px 0; color: var(--SmartThemeEmColor, #8af);">
				<i class="fa-solid fa-fire" style="margin-right: 8px;"></i>BlazeTracker Status
			</h3>
			<table style="width: 100%; border-collapse: collapse;">
				${rows
        .map(row => `
					<tr style="border-bottom: 1px solid rgba(255,255,255,0.1);">
						<td style="padding: 8px 12px 8px 0; opacity: 0.8;">${row.label}</td>
						<td style="padding: 8px 0; font-weight: 600; text-align: right;">${row.value}</td>
					</tr>
				`)
        .join('')}
			</table>
		</div>
	`;
    // Show popup
    await context.callGenericPopup(container, context.POPUP_TYPE.TEXT, null, {
        okButton: 'Close',
    });
    return '';
}
// ============================================
// Registration
// ============================================
function registerSlashCommands() {
    try {
        // Get slash command classes from SillyTavern context
        const context = SillyTavern.getContext();
        const SlashCommandParser = context.SlashCommandParser;
        const SlashCommand = context.SlashCommand;
        const SlashCommandNamedArgument = context.SlashCommandNamedArgument;
        const ARGUMENT_TYPE = context.ARGUMENT_TYPE;
        if (!SlashCommandParser || !SlashCommand) {
            console.warn(`[${_constants__WEBPACK_IMPORTED_MODULE_0__.EXTENSION_NAME}] Slash command API not available, skipping registration`);
            return;
        }
        // /bt-extract - Extract state for a message
        SlashCommandParser.addCommandObject(SlashCommand.fromProps({
            name: 'bt-extract',
            callback: extractCommand,
            namedArgumentList: [
                SlashCommandNamedArgument.fromProps({
                    name: 'id',
                    description: 'Message ID to extract (defaults to most recent)',
                    typeList: [ARGUMENT_TYPE.NUMBER],
                    isRequired: false,
                }),
            ],
            helpString: `
				<div>
					Extract BlazeTracker state for a message.
					<br><br>
					<strong>Usage:</strong>
					<ul>
						<li><code>/bt-extract</code> - Extract most recent message</li>
						<li><code>/bt-extract id=5</code> - Extract message #5</li>
					</ul>
				</div>
			`,
            returns: ARGUMENT_TYPE.STRING,
        }));
        // /bt-chapter - Force chapter break
        SlashCommandParser.addCommandObject(SlashCommand.fromProps({
            name: 'bt-chapter',
            callback: chapterCommand,
            namedArgumentList: [
                SlashCommandNamedArgument.fromProps({
                    name: 'title',
                    description: 'Override the auto-generated chapter title',
                    typeList: [ARGUMENT_TYPE.STRING],
                    isRequired: false,
                }),
            ],
            helpString: `
				<div>
					Force a chapter break at the current point in the narrative.
					<br><br>
					<strong>Usage:</strong>
					<ul>
						<li><code>/bt-chapter</code> - Create chapter with auto-generated title</li>
						<li><code>/bt-chapter title="The Great Escape"</code> - Create chapter with custom title</li>
					</ul>
					<br>
					Requires extracted state with at least one event. Run /bt-extract first if needed.
				</div>
			`,
            returns: ARGUMENT_TYPE.STRING,
        }));
        // /bt-extract-all - Extract all messages (full reset)
        SlashCommandParser.addCommandObject(SlashCommand.fromProps({
            name: 'bt-extract-all',
            callback: extractAllCommand,
            helpString: `
				<div>
					Extract BlazeTracker state for all messages in the chat.
					<br><br>
					<strong>WARNING:</strong> This command clears ALL existing BlazeTracker data
					(relationships, chapters, events, per-message state) before starting fresh extraction.
					<br><br>
					<strong>Usage:</strong>
					<ul>
						<li><code>/bt-extract-all</code> - Clear all state and re-extract everything</li>
					</ul>
					<br>
					<em>Note: This can take a while for long chats as it makes multiple API calls.</em>
				</div>
			`,
            returns: ARGUMENT_TYPE.STRING,
        }));
        // /bt-status - Show BlazeTracker status
        SlashCommandParser.addCommandObject(SlashCommand.fromProps({
            name: 'bt-status',
            callback: statusCommand,
            helpString: `
				<div>
					Show BlazeTracker status for the current chat.
					<br><br>
					Displays:
					<ul>
						<li>Messages extracted vs total</li>
						<li>Number of chapters</li>
						<li>Number of relationships</li>
						<li>Events in current chapter</li>
					</ul>
				</div>
			`,
            returns: ARGUMENT_TYPE.STRING,
        }));
        log('Slash commands registered: /bt-extract, /bt-chapter, /bt-extract-all, /bt-status');
    }
    catch (e) {
        console.error(`[${_constants__WEBPACK_IMPORTED_MODULE_0__.EXTENSION_NAME}] Failed to register slash commands:`, e);
    }
}


/***/ },

/***/ "./src/constants.ts"
/*!**************************!*\
  !*** ./src/constants.ts ***!
  \**************************/
(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   EXTENSION_KEY: () => (/* binding */ EXTENSION_KEY),
/* harmony export */   EXTENSION_NAME: () => (/* binding */ EXTENSION_NAME)
/* harmony export */ });
const EXTENSION_NAME = 'BlazeTracker';
const EXTENSION_KEY = 'blazetracker';


/***/ },

/***/ "./src/extractors/extractChapter.ts"
/*!******************************************!*\
  !*** ./src/extractors/extractChapter.ts ***!
  \******************************************/
(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   CHAPTER_BOUNDARY_SCHEMA: () => (/* binding */ CHAPTER_BOUNDARY_SCHEMA),
/* harmony export */   extractChapterBoundary: () => (/* binding */ extractChapterBoundary)
/* harmony export */ });
/* harmony import */ var _settings__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../settings */ "./src/settings.ts");
/* harmony import */ var _prompts__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./prompts */ "./src/extractors/prompts.ts");
/* harmony import */ var _utils_generator__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../utils/generator */ "./src/utils/generator.ts");
/* harmony import */ var _utils_json__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../utils/json */ "./src/utils/json.ts");
/* harmony import */ var _state_chapters__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../state/chapters */ "./src/state/chapters.ts");
/* harmony import */ var _state_events__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../state/events */ "./src/state/events.ts");
/* harmony import */ var _state_relationships__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ../state/relationships */ "./src/state/relationships.ts");
// ============================================
// Chapter Extractor
// ============================================







// ============================================
// Schema & Example
// ============================================
const CHAPTER_BOUNDARY_SCHEMA = {
    type: 'object',
    description: 'Chapter boundary analysis result',
    additionalProperties: false,
    properties: {
        isChapterBoundary: {
            type: 'boolean',
            description: 'Whether this represents a true narrative chapter boundary',
        },
        title: {
            type: 'string',
            description: 'A short, evocative title for the chapter (3-6 words)',
        },
        summary: {
            type: 'string',
            description: '2-3 sentence summary of what happened in the chapter',
        },
        outcomes: {
            type: 'object',
            properties: {
                relationshipChanges: {
                    type: 'array',
                    items: { type: 'string' },
                    description: 'Brief descriptions of relationship shifts',
                },
                secretsRevealed: {
                    type: 'array',
                    items: { type: 'string' },
                    description: 'Secrets that came to light',
                },
                newComplications: {
                    type: 'array',
                    items: { type: 'string' },
                    description: 'New problems or tensions introduced',
                },
            },
        },
    },
    required: ['isChapterBoundary', 'title', 'summary'],
};
const CHAPTER_EXAMPLE = JSON.stringify({
    isChapterBoundary: true,
    title: 'The Midnight Confession',
    summary: 'Elena revealed her past to Marcus under the stars, leading to an unexpected moment of vulnerability. Their relationship deepened as secrets were shared and trust was established.',
    outcomes: {
        relationshipChanges: [
            'Elena and Marcus grew closer through shared vulnerability',
        ],
        secretsRevealed: ["Elena's criminal past"],
        newComplications: ["Marcus must now decide whether to keep Elena's secret"],
    },
}, null, 2);
// ============================================
// Constants
// ============================================
const SYSTEM_PROMPT = 'You are a narrative analysis agent for roleplay. Analyze chapter boundaries and summarize story progression. Return only valid JSON.';
/**
 * Extract chapter information when a potential boundary is detected.
 * Returns the chapter if it's a true boundary, null otherwise.
 */
async function extractChapterBoundary(params) {
    const settings = (0,_settings__WEBPACK_IMPORTED_MODULE_0__.getSettings)();
    const schemaStr = JSON.stringify(CHAPTER_BOUNDARY_SCHEMA, null, 2);
    const eventsStr = (0,_state_events__WEBPACK_IMPORTED_MODULE_5__.formatEventsForInjection)(params.events);
    const relationshipsStr = (0,_state_relationships__WEBPACK_IMPORTED_MODULE_6__.formatRelationshipsForPrompt)(params.narrativeState.relationships);
    const prompt = (0,_prompts__WEBPACK_IMPORTED_MODULE_1__.getPrompt)('chapter_boundary')
        .replace('{{currentEvents}}', eventsStr)
        .replace('{{currentRelationships}}', relationshipsStr)
        .replace('{{schema}}', schemaStr)
        .replace('{{schemaExample}}', CHAPTER_EXAMPLE);
    const llmMessages = (0,_utils_generator__WEBPACK_IMPORTED_MODULE_2__.buildExtractionMessages)(SYSTEM_PROMPT, prompt);
    try {
        const response = await (0,_utils_generator__WEBPACK_IMPORTED_MODULE_2__.makeGeneratorRequest)(llmMessages, {
            profileId: settings.profileId,
            maxTokens: settings.maxResponseTokens,
            temperature: (0,_settings__WEBPACK_IMPORTED_MODULE_0__.getTemperature)('chapter_boundary'),
            abortSignal: params.abortSignal,
        });
        const parsed = (0,_utils_json__WEBPACK_IMPORTED_MODULE_3__.parseJsonResponse)(response, {
            shape: 'object',
            moduleName: 'BlazeTracker/Chapter',
        });
        const result = validateChapterData(parsed);
        // If not forcing and LLM says it's not a boundary, return false
        if (!params.forceCreate && !result.isChapterBoundary) {
            return { isChapterBoundary: false };
        }
        // Create the chapter with extracted data (either forced or natural boundary)
        const chapter = (0,_state_chapters__WEBPACK_IMPORTED_MODULE_4__.createEmptyChapter)(params.chapterIndex);
        chapter.title = result.title;
        chapter.summary = result.summary;
        chapter.outcomes = result.outcomes;
        // Finalize with time range and events
        const finalizedChapter = (0,_state_chapters__WEBPACK_IMPORTED_MODULE_4__.finalizeChapter)(chapter, params.events, params.startTime, params.endTime, params.primaryLocation);
        return {
            isChapterBoundary: true,
            chapter: finalizedChapter,
        };
    }
    catch (error) {
        console.warn('[BlazeTracker] Chapter extraction failed:', error);
        // On error, assume it's not a chapter boundary
        return { isChapterBoundary: false };
    }
}
function validateChapterData(data) {
    if (!(0,_utils_json__WEBPACK_IMPORTED_MODULE_3__.isObject)(data)) {
        return {
            isChapterBoundary: false,
            title: '',
            summary: '',
            outcomes: (0,_state_chapters__WEBPACK_IMPORTED_MODULE_4__.createEmptyOutcomes)(),
        };
    }
    const isChapterBoundary = (0,_utils_json__WEBPACK_IMPORTED_MODULE_3__.asBoolean)(data.isChapterBoundary, false);
    const title = (0,_utils_json__WEBPACK_IMPORTED_MODULE_3__.asString)(data.title, 'Untitled Chapter');
    const summary = (0,_utils_json__WEBPACK_IMPORTED_MODULE_3__.asString)(data.summary, '');
    const outcomes = validateOutcomes(data.outcomes);
    return {
        isChapterBoundary,
        title,
        summary,
        outcomes,
    };
}
function validateOutcomes(data) {
    if (!(0,_utils_json__WEBPACK_IMPORTED_MODULE_3__.isObject)(data)) {
        return (0,_state_chapters__WEBPACK_IMPORTED_MODULE_4__.createEmptyOutcomes)();
    }
    return {
        relationshipChanges: (0,_utils_json__WEBPACK_IMPORTED_MODULE_3__.asStringArray)(data.relationshipChanges),
        secretsRevealed: (0,_utils_json__WEBPACK_IMPORTED_MODULE_3__.asStringArray)(data.secretsRevealed),
        newComplications: (0,_utils_json__WEBPACK_IMPORTED_MODULE_3__.asStringArray)(data.newComplications),
    };
}


/***/ },

/***/ "./src/extractors/extractCharacters.ts"
/*!*********************************************!*\
  !*** ./src/extractors/extractCharacters.ts ***!
  \*********************************************/
(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   CHARACTERS_SCHEMA: () => (/* binding */ CHARACTERS_SCHEMA),
/* harmony export */   extractCharacters: () => (/* binding */ extractCharacters)
/* harmony export */ });
/* harmony import */ var _settings__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../settings */ "./src/settings.ts");
/* harmony import */ var _prompts__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./prompts */ "./src/extractors/prompts.ts");
/* harmony import */ var _utils_generator__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../utils/generator */ "./src/utils/generator.ts");
/* harmony import */ var _utils_json__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../utils/json */ "./src/utils/json.ts");




// ============================================
// Schema & Example
// ============================================
const CHARACTERS_SCHEMA = {
    type: 'array',
    description: 'All characters present in the current scene',
    items: {
        type: 'object',
        additionalProperties: false,
        properties: {
            name: {
                type: 'string',
                description: "Character's name as used in the scene",
            },
            position: {
                type: 'string',
                description: "Physical position and where (e.g. 'sitting at the bar', 'leaning against the wall'). Be detailed about who they're facing/interacting with.",
            },
            activity: {
                type: 'string',
                description: "Current activity if any (e.g. 'nursing a whiskey', 'texting on phone')",
            },
            mood: {
                type: 'array',
                description: 'Current emotional states',
                minItems: 1,
                maxItems: 5,
                items: { type: 'string' },
            },
            physicalState: {
                type: 'array',
                description: 'Physical conditions affecting the character',
                maxItems: 5,
                items: { type: 'string' },
            },
            outfit: {
                type: 'object',
                description: 'Clothing items currently worn. Set to null if removed or if species would not wear clothes (pony, PokÃ©mon, etc.)',
                properties: {
                    head: {
                        type: ['string', 'null'],
                        description: 'Headwear (null if none)',
                    },
                    neck: {
                        type: ['string', 'null'],
                        description: 'Neckwear - necklaces, chokers, scarves, ties (null if none)',
                    },
                    jacket: {
                        type: ['string', 'null'],
                        description: 'Outer layer (null if none)',
                    },
                    back: {
                        type: ['string', 'null'],
                        description: 'Items worn on back - backpacks, quivers, cloaks, capes (null if none)',
                    },
                    torso: {
                        type: ['string', 'null'],
                        description: 'Shirt/top (null if none)',
                    },
                    legs: {
                        type: ['string', 'null'],
                        description: 'Pants/skirt (null if none)',
                    },
                    underwear: {
                        type: ['string', 'null'],
                        description: 'Underwear, be descriptive if partially removed',
                    },
                    socks: {
                        type: ['string', 'null'],
                        description: 'Socks/stockings, specify which foot if only one',
                    },
                    footwear: {
                        type: ['string', 'null'],
                        description: 'Shoes/boots, specify which foot if only one',
                    },
                },
                required: [
                    'head',
                    'neck',
                    'jacket',
                    'back',
                    'torso',
                    'legs',
                    'underwear',
                    'socks',
                    'footwear',
                ],
            },
            dispositions: {
                type: 'object',
                description: 'Feelings toward other characters in the scene',
                additionalProperties: {
                    type: 'array',
                    maxItems: 5,
                    items: { type: 'string' },
                },
            },
        },
        required: [
            'name',
            'position',
            'activity',
            'mood',
            'physicalState',
            'outfit',
            'dispositions',
        ],
    },
};
const CHARACTERS_EXAMPLE = JSON.stringify([
    {
        name: 'Elena',
        position: 'Sitting in the booth, facing the entrance',
        activity: 'Watching the door nervously, hands wrapped around a coffee mug',
        mood: ['anxious', 'hopeful'],
        physicalState: ['tired'],
        outfit: {
            head: null,
            neck: 'Silver pendant necklace',
            jacket: null,
            back: null,
            torso: 'Dark red blouse',
            legs: 'Black jeans',
            underwear: 'Black lace bra and matching panties',
            socks: 'Black tights',
            footwear: 'Black ankle boots',
        },
        dispositions: {
            Marcus: ['suspicious', 'curious'],
            Sarah: ['trusting', 'protective'],
        },
    },
], null, 2);
// ============================================
// Constants
// ============================================
const SYSTEM_PROMPT = 'You are a character state analysis agent for roleplay scenes. Return only valid JSON.';
// ============================================
// Public API
// ============================================
async function extractCharacters(isInitial, messages, location, userInfo, characterInfo, previousCharacters, abortSignal) {
    const settings = (0,_settings__WEBPACK_IMPORTED_MODULE_0__.getSettings)();
    const locationStr = `${location.area} - ${location.place} (${location.position})`;
    const schemaStr = JSON.stringify(CHARACTERS_SCHEMA, null, 2);
    const prompt = isInitial
        ? (0,_prompts__WEBPACK_IMPORTED_MODULE_1__.getPrompt)('characters_initial')
            .replace('{{userInfo}}', userInfo)
            .replace('{{characterInfo}}', characterInfo)
            .replace('{{location}}', locationStr)
            .replace('{{messages}}', messages)
            .replace('{{schema}}', schemaStr)
            .replace('{{schemaExample}}', CHARACTERS_EXAMPLE)
        : (0,_prompts__WEBPACK_IMPORTED_MODULE_1__.getPrompt)('characters_update')
            .replace('{{location}}', locationStr)
            .replace('{{previousState}}', JSON.stringify(previousCharacters, null, 2))
            .replace('{{messages}}', messages)
            .replace('{{schema}}', schemaStr)
            .replace('{{schemaExample}}', CHARACTERS_EXAMPLE);
    const llmMessages = (0,_utils_generator__WEBPACK_IMPORTED_MODULE_2__.buildExtractionMessages)(SYSTEM_PROMPT, prompt);
    const response = await (0,_utils_generator__WEBPACK_IMPORTED_MODULE_2__.makeGeneratorRequest)(llmMessages, {
        profileId: settings.profileId,
        maxTokens: settings.maxResponseTokens,
        temperature: (0,_settings__WEBPACK_IMPORTED_MODULE_0__.getTemperature)(isInitial ? 'characters_initial' : 'characters_update'),
        abortSignal,
    });
    const parsed = (0,_utils_json__WEBPACK_IMPORTED_MODULE_3__.parseJsonResponse)(response, {
        shape: 'array',
        moduleName: 'BlazeTracker/Characters',
    });
    return validateCharacters(parsed);
}
// ============================================
// Validation
// ============================================
function validateCharacters(data) {
    if (!Array.isArray(data)) {
        throw new Error('Invalid characters: expected array');
    }
    return data.map(validateCharacter);
}
function validateCharacter(data) {
    if (!(0,_utils_json__WEBPACK_IMPORTED_MODULE_3__.isObject)(data)) {
        throw new Error('Invalid character: expected object');
    }
    const name = data.name;
    if (!name || typeof name !== 'string') {
        throw new Error('Invalid character: missing name');
    }
    const position = data.position;
    if (!position || typeof position !== 'string') {
        throw new Error(`Invalid character ${name}: missing position`);
    }
    const outfit = validateOutfit(data.outfit);
    return {
        name,
        position,
        activity: typeof data.activity === 'string' ? data.activity : undefined,
        // Note: goals removed in v1.0.0, now tracked in CharacterArc
        mood: Array.isArray(data.mood) ? (0,_utils_json__WEBPACK_IMPORTED_MODULE_3__.asStringArray)(data.mood, 5) : ['neutral'],
        physicalState: Array.isArray(data.physicalState)
            ? (0,_utils_json__WEBPACK_IMPORTED_MODULE_3__.asStringArray)(data.physicalState, 5)
            : undefined,
        outfit,
        // Note: dispositions removed in v1.0.0, now tracked in Relationship
    };
}
function validateOutfit(data) {
    if (!(0,_utils_json__WEBPACK_IMPORTED_MODULE_3__.isObject)(data)) {
        return {
            head: null,
            neck: null,
            jacket: null,
            back: null,
            torso: null,
            legs: null,
            underwear: null,
            socks: null,
            footwear: null,
        };
    }
    return {
        head: (0,_utils_json__WEBPACK_IMPORTED_MODULE_3__.asStringOrNull)(data.head),
        neck: (0,_utils_json__WEBPACK_IMPORTED_MODULE_3__.asStringOrNull)(data.neck),
        jacket: (0,_utils_json__WEBPACK_IMPORTED_MODULE_3__.asStringOrNull)(data.jacket),
        back: (0,_utils_json__WEBPACK_IMPORTED_MODULE_3__.asStringOrNull)(data.back),
        torso: (0,_utils_json__WEBPACK_IMPORTED_MODULE_3__.asStringOrNull)(data.torso),
        legs: (0,_utils_json__WEBPACK_IMPORTED_MODULE_3__.asStringOrNull)(data.legs),
        underwear: (0,_utils_json__WEBPACK_IMPORTED_MODULE_3__.asStringOrNull)(data.underwear),
        socks: (0,_utils_json__WEBPACK_IMPORTED_MODULE_3__.asStringOrNull)(data.socks),
        footwear: (0,_utils_json__WEBPACK_IMPORTED_MODULE_3__.asStringOrNull)(data.footwear),
    };
}


/***/ },

/***/ "./src/extractors/extractClimate.ts"
/*!******************************************!*\
  !*** ./src/extractors/extractClimate.ts ***!
  \******************************************/
(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   CLIMATE_SCHEMA: () => (/* binding */ CLIMATE_SCHEMA),
/* harmony export */   extractClimate: () => (/* binding */ extractClimate),
/* harmony export */   extractClimateWithContext: () => (/* binding */ extractClimateWithContext),
/* harmony export */   isLegacyClimate: () => (/* reexport safe */ _weather__WEBPACK_IMPORTED_MODULE_4__.isLegacyClimate)
/* harmony export */ });
/* harmony import */ var _settings__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../settings */ "./src/settings.ts");
/* harmony import */ var _prompts__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./prompts */ "./src/extractors/prompts.ts");
/* harmony import */ var _utils_generator__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../utils/generator */ "./src/utils/generator.ts");
/* harmony import */ var _utils_json__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../utils/json */ "./src/utils/json.ts");
/* harmony import */ var _weather__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../weather */ "./src/weather/index.ts");





// ============================================
// Schema & Example (Legacy)
// ============================================
const CLIMATE_SCHEMA = {
    type: 'object',
    description: 'Current climate/weather conditions',
    additionalProperties: false,
    properties: {
        weather: {
            type: 'string',
            enum: ['sunny', 'cloudy', 'snowy', 'rainy', 'windy', 'thunderstorm'],
            description: 'The current weather in the locale (if characters are indoors, give the weather outdoors)',
        },
        temperature: {
            type: 'number',
            description: 'Current temperature in Fahrenheit (if characters are indoors, give the indoor temperature)',
        },
    },
    required: ['weather', 'temperature'],
};
const CLIMATE_EXAMPLE = JSON.stringify({
    weather: 'rainy',
    temperature: 52,
}, null, 2);
// ============================================
// Constants
// ============================================
const SYSTEM_PROMPT = 'You are a climate analysis agent for roleplay scenes. Return only valid JSON.';
const VALID_WEATHER = [
    'sunny',
    'cloudy',
    'snowy',
    'rainy',
    'windy',
    'thunderstorm',
];
/**
 * Main climate extraction function.
 * Uses procedural weather system if enabled, otherwise falls back to LLM extraction.
 */
async function extractClimateWithContext(options) {
    const settings = (0,_settings__WEBPACK_IMPORTED_MODULE_0__.getSettings)();
    if (settings.useProceduralWeather) {
        return extractProceduralClimateWrapper(options);
    }
    else {
        const climate = await extractLegacyClimate(options.isInitial, options.messages, options.narrativeTime, options.location, options.characterInfo, (0,_weather__WEBPACK_IMPORTED_MODULE_4__.isLegacyClimate)(options.previousClimate) ? options.previousClimate : null, options.abortSignal);
        return {
            climate,
            transition: null,
            // Return unchanged caches when using legacy mode
            forecastCache: options.forecastCache,
            locationMappings: options.locationMappings,
        };
    }
}
/**
 * Legacy extraction function for backward compatibility.
 * Uses LLM to extract climate data.
 */
async function extractClimate(isInitial, messages, narrativeTime, location, characterInfo, previousClimate, abortSignal) {
    return extractLegacyClimate(isInitial, messages, narrativeTime, location, characterInfo, previousClimate, abortSignal);
}
// ============================================
// Procedural Weather Wrapper
// ============================================
async function extractProceduralClimateWrapper(options) {
    const params = {
        isInitial: options.isInitial,
        currentTime: options.narrativeTime,
        currentLocation: options.location,
        previousClimate: options.previousClimate,
        narrativeContext: options.messages,
        forecastCache: options.forecastCache,
        locationMappings: options.locationMappings,
        abortSignal: options.abortSignal,
    };
    const result = await (0,_weather__WEBPACK_IMPORTED_MODULE_4__.extractProceduralClimate)(params);
    return {
        climate: result.climate,
        transition: result.transition,
        forecastCache: result.forecastCache,
        locationMappings: result.locationMappings,
    };
}
// ============================================
// Legacy LLM Extraction
// ============================================
async function extractLegacyClimate(isInitial, messages, narrativeTime, location, characterInfo, previousClimate, abortSignal) {
    const settings = (0,_settings__WEBPACK_IMPORTED_MODULE_0__.getSettings)();
    const timeStr = formatNarrativeTime(narrativeTime);
    const locationStr = `${location.area} - ${location.place} (${location.position})`;
    const schemaStr = JSON.stringify(CLIMATE_SCHEMA, null, 2);
    const prompt = isInitial
        ? (0,_prompts__WEBPACK_IMPORTED_MODULE_1__.getPrompt)('climate_initial')
            .replace('{{narrativeTime}}', timeStr)
            .replace('{{location}}', locationStr)
            .replace('{{characterInfo}}', characterInfo)
            .replace('{{messages}}', messages)
            .replace('{{schema}}', schemaStr)
            .replace('{{schemaExample}}', CLIMATE_EXAMPLE)
        : (0,_prompts__WEBPACK_IMPORTED_MODULE_1__.getPrompt)('climate_update')
            .replace('{{narrativeTime}}', timeStr)
            .replace('{{location}}', locationStr)
            .replace('{{previousState}}', JSON.stringify(previousClimate, null, 2))
            .replace('{{messages}}', messages)
            .replace('{{schema}}', schemaStr)
            .replace('{{schemaExample}}', CLIMATE_EXAMPLE);
    const llmMessages = (0,_utils_generator__WEBPACK_IMPORTED_MODULE_2__.buildExtractionMessages)(SYSTEM_PROMPT, prompt);
    const response = await (0,_utils_generator__WEBPACK_IMPORTED_MODULE_2__.makeGeneratorRequest)(llmMessages, {
        profileId: settings.profileId,
        maxTokens: settings.maxResponseTokens,
        temperature: (0,_settings__WEBPACK_IMPORTED_MODULE_0__.getTemperature)(isInitial ? 'climate_initial' : 'climate_update'),
        abortSignal,
    });
    const parsed = (0,_utils_json__WEBPACK_IMPORTED_MODULE_3__.parseJsonResponse)(response, {
        shape: 'object',
        moduleName: 'BlazeTracker/Climate',
    });
    return validateClimate(parsed);
}
// ============================================
// Internal: Helpers
// ============================================
function formatNarrativeTime(time) {
    const monthNames = [
        'January',
        'February',
        'March',
        'April',
        'May',
        'June',
        'July',
        'August',
        'September',
        'October',
        'November',
        'December',
    ];
    const hour12 = time.hour % 12 || 12;
    const ampm = time.hour < 12 ? 'AM' : 'PM';
    const minuteStr = String(time.minute).padStart(2, '0');
    return `${time.dayOfWeek}, ${monthNames[time.month - 1]} ${time.day}, ${time.year} at ${hour12}:${minuteStr} ${ampm}`;
}
// ============================================
// Validation
// ============================================
function validateClimate(data) {
    if (typeof data !== 'object' || data === null) {
        throw new Error('Invalid climate: expected object');
    }
    const obj = data;
    const weather = VALID_WEATHER.includes(obj.weather)
        ? obj.weather
        : 'sunny';
    const temperature = (0,_utils_json__WEBPACK_IMPORTED_MODULE_3__.asNumber)(obj.temperature, 70);
    return { weather, temperature };
}
// ============================================
// Type Guards
// ============================================



/***/ },

/***/ "./src/extractors/extractEvent.ts"
/*!****************************************!*\
  !*** ./src/extractors/extractEvent.ts ***!
  \****************************************/
(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   EVENT_SCHEMA: () => (/* binding */ EVENT_SCHEMA),
/* harmony export */   extractEvent: () => (/* binding */ extractEvent)
/* harmony export */ });
/* harmony import */ var _settings__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../settings */ "./src/settings.ts");
/* harmony import */ var _prompts__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./prompts */ "./src/extractors/prompts.ts");
/* harmony import */ var _utils_generator__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../utils/generator */ "./src/utils/generator.ts");
/* harmony import */ var _utils_json__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../utils/json */ "./src/utils/json.ts");
/* harmony import */ var _types_state__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../types/state */ "./src/types/state.ts");
/* harmony import */ var _state_relationships__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../state/relationships */ "./src/state/relationships.ts");
// ============================================
// Event Extractor
// ============================================






// ============================================
// Schema & Example
// ============================================
const EVENT_SCHEMA = {
    type: 'object',
    description: 'A significant event extracted from the messages',
    additionalProperties: false,
    properties: {
        summary: {
            type: 'string',
            description: 'Detailed 2-sentence summary capturing what happened, who was involved, and the emotional context',
        },
        eventTypes: {
            type: 'array',
            items: { type: 'string', enum: [..._types_state__WEBPACK_IMPORTED_MODULE_4__.EVENT_TYPES] },
            description: 'All applicable event type flags (can select multiple)',
        },
        eventPairs: {
            type: 'object',
            description: 'REQUIRED: Maps each event type to the pair(s) of characters involved. Value is either [char1, char2] for single pair, or [[char1, char2], [char3, char4]] for multiple pairs.',
            additionalProperties: {
                oneOf: [
                    {
                        type: 'array',
                        items: { type: 'string' },
                        minItems: 2,
                        maxItems: 2,
                        description: 'Single pair: [char1, char2]',
                    },
                    {
                        type: 'array',
                        items: {
                            type: 'array',
                            items: { type: 'string' },
                            minItems: 2,
                            maxItems: 2,
                        },
                        description: 'Multiple pairs: [[char1, char2], [char3, char4]]',
                    },
                ],
            },
        },
        eventDetails: {
            type: 'object',
            description: 'Brief clarifying details for event types that need context. Key is the event type, value is a short phrase explaining what specifically happened.',
            additionalProperties: { type: 'string' },
        },
        witnesses: {
            type: 'array',
            description: 'Characters who witnessed or participated in this event',
            items: { type: 'string' },
        },
        relationshipSignals: {
            type: 'array',
            description: 'Optional signals if events affect relationships. One entry per affected pair.',
            items: {
                type: 'object',
                properties: {
                    pair: {
                        type: 'array',
                        items: { type: 'string' },
                        minItems: 2,
                        maxItems: 2,
                        description: 'The two characters involved',
                    },
                    changes: {
                        type: 'array',
                        items: {
                            type: 'object',
                            properties: {
                                from: {
                                    type: 'string',
                                    description: 'Character whose attitude is changing',
                                },
                                toward: {
                                    type: 'string',
                                    description: 'Character they feel differently about',
                                },
                                feeling: {
                                    type: 'string',
                                    description: 'New or changed feeling',
                                },
                            },
                            required: ['from', 'toward', 'feeling'],
                        },
                    },
                },
            },
        },
    },
    required: ['summary', 'eventTypes', 'eventPairs', 'witnesses'],
};
// Multiple examples showing different scenarios
const EVENT_EXAMPLES = [
    // Example 1: Single pair, emotional moment
    {
        summary: "After hours of tense silence, Elena finally broke down and confessed her past as a thief to Marcus, her voice trembling as she revealed the crimes she'd committed before they met. Marcus listened without interrupting, his expression unreadable, before finally reaching across the table to take her hand.",
        eventTypes: ['secret_shared', 'emotional', 'confession'],
        eventPairs: {
            secret_shared: ['Elena', 'Marcus'],
            emotional: ['Elena', 'Marcus'],
            confession: ['Elena', 'Marcus'],
        },
        eventDetails: {
            secret_shared: "Elena's past as a thief and the crimes she committed",
            emotional: 'Elena broke down crying while revealing her past',
            confession: 'Elena admitted her criminal history to Marcus',
        },
        witnesses: ['Elena', 'Marcus'],
        relationshipSignals: [
            {
                pair: ['Elena', 'Marcus'],
                changes: [
                    { from: 'Elena', toward: 'Marcus', feeling: 'vulnerable' },
                    { from: 'Marcus', toward: 'Elena', feeling: 'protective' },
                ],
            },
        ],
    },
    // Example 2: Combat with multiple enemies (same event type, different pairs)
    {
        summary: "The ambush came from both sides - Jake barely dodged Viper's knife before spinning to block Razor's bat. He managed to disarm Viper with a swift kick, then turned his fury on Razor, slamming him against the alley wall.",
        eventTypes: ['combat', 'danger'],
        eventPairs: {
            combat: [
                ['Jake', 'Viper'],
                ['Jake', 'Razor'],
            ],
            danger: ['Jake', 'Viper'],
        },
        eventDetails: {
            combat: 'Jake fought off both Viper and Razor in the alley ambush',
            danger: 'Jake was ambushed by two armed attackers',
        },
        witnesses: ['Jake', 'Viper', 'Razor'],
        relationshipSignals: [
            {
                pair: ['Jake', 'Viper'],
                changes: [{ from: 'Viper', toward: 'Jake', feeling: 'vengeful' }],
            },
            {
                pair: ['Jake', 'Razor'],
                changes: [{ from: 'Razor', toward: 'Jake', feeling: 'fearful' }],
            },
        ],
    },
    // Example 3: Mixed - combat AND emotional support from different people
    {
        summary: 'After Sarah dispatched the last of the guards, she found Alex trembling in the corner. She knelt beside him, pulling him into a fierce embrace while promising they would make it out together.',
        eventTypes: ['combat', 'emotional', 'supportive', 'intimate_embrace'],
        eventPairs: {
            combat: ['Sarah', 'Guard'],
            emotional: ['Sarah', 'Alex'],
            supportive: ['Sarah', 'Alex'],
            intimate_embrace: ['Sarah', 'Alex'],
        },
        eventDetails: {
            combat: 'Sarah fought and defeated the guards',
            emotional: 'Alex was traumatized and trembling',
            supportive: 'Sarah comforted and reassured Alex',
            intimate_embrace: 'Sarah pulled Alex into a protective embrace',
        },
        witnesses: ['Sarah', 'Alex', 'Guard'],
        relationshipSignals: [
            {
                pair: ['Sarah', 'Alex'],
                changes: [
                    { from: 'Alex', toward: 'Sarah', feeling: 'grateful' },
                    { from: 'Sarah', toward: 'Alex', feeling: 'protective' },
                ],
            },
        ],
    },
];
const EVENT_EXAMPLE = JSON.stringify(EVENT_EXAMPLES[0], null, 2);
// ============================================
// Constants
// ============================================
const SYSTEM_PROMPT = 'You are an event analysis agent for roleplay. Extract significant events and relationship changes. Return only valid JSON.';
/**
 * Extract a significant event from the recent messages.
 * Returns null if no significant event occurred.
 */
async function extractEvent(params) {
    const settings = (0,_settings__WEBPACK_IMPORTED_MODULE_0__.getSettings)();
    if (!settings.trackEvents) {
        return null;
    }
    // Format relationships for context
    const relationshipsContext = formatRelationshipsForPrompt(params.relationships);
    const schemaStr = JSON.stringify(EVENT_SCHEMA, null, 2);
    const locationStr = `${params.currentLocation.area} - ${params.currentLocation.place}`;
    const prompt = (0,_prompts__WEBPACK_IMPORTED_MODULE_1__.getPrompt)('event_extract')
        .replace('{{messages}}', params.messages)
        .replace('{{currentRelationships}}', relationshipsContext)
        .replace('{{schema}}', schemaStr)
        .replace('{{schemaExample}}', EVENT_EXAMPLE);
    const llmMessages = (0,_utils_generator__WEBPACK_IMPORTED_MODULE_2__.buildExtractionMessages)(SYSTEM_PROMPT, prompt);
    try {
        const response = await (0,_utils_generator__WEBPACK_IMPORTED_MODULE_2__.makeGeneratorRequest)(llmMessages, {
            profileId: settings.profileId,
            maxTokens: settings.maxResponseTokens,
            temperature: (0,_settings__WEBPACK_IMPORTED_MODULE_0__.getTemperature)('event_extract'),
            abortSignal: params.abortSignal,
        });
        const parsed = (0,_utils_json__WEBPACK_IMPORTED_MODULE_3__.parseJsonResponse)(response, {
            shape: 'object',
            moduleName: 'BlazeTracker/Event',
        });
        const eventData = validateEventData(parsed, params.relationships);
        // If the summary indicates no significant event, return null
        if (!eventData || isNoEventResponse(eventData.summary)) {
            return null;
        }
        // Process relationship signals and add milestones
        // We use the first signal as the primary one for the event (for backward compat)
        let relationshipSignal;
        if (eventData.relationshipSignals && eventData.relationshipSignals.length > 0) {
            // Process each relationship signal - infer milestones based on eventPairs
            const processedSignals = await Promise.all(eventData.relationshipSignals.map(async (signal) => {
                // Find event types that apply to this pair
                const pairKey = (0,_state_relationships__WEBPACK_IMPORTED_MODULE_5__.sortPair)(signal.pair[0], signal.pair[1])
                    .join('|')
                    .toLowerCase();
                const eventTypesForPair = eventData.eventTypes.filter(et => {
                    const etPairValue = eventData.eventPairs[et];
                    if (!etPairValue)
                        return false;
                    // Normalize to array of pairs and check if any match
                    const etPairs = normalizePairs(etPairValue);
                    return etPairs.some(p => {
                        const etPairKey = (0,_state_relationships__WEBPACK_IMPORTED_MODULE_5__.sortPair)(p[0], p[1])
                            .join('|')
                            .toLowerCase();
                        return etPairKey === pairKey;
                    });
                });
                // Infer milestones from the event types for this pair
                const existingRelationship = findRelationshipForPair(params.relationships, signal.pair);
                const milestoneTypes = inferMilestoneTypesFromEventTypes(eventTypesForPair, existingRelationship);
                if (milestoneTypes.length > 0) {
                    const milestones = await createMilestonesWithDescriptions(milestoneTypes, signal.pair, params.messages, params.currentTime, params.currentLocation, params.characters ?? [], existingRelationship ?? undefined, eventData.eventDetails ?? {}, params.messageId, params.abortSignal);
                    return { ...signal, milestones };
                }
                return signal;
            }));
            // Use the first signal as the primary relationship signal for the event
            relationshipSignal = processedSignals[0];
        }
        // Create the timestamped event using scene's tension values
        return {
            timestamp: params.currentTime,
            summary: eventData.summary,
            eventTypes: eventData.eventTypes,
            tensionType: params.currentTensionType,
            tensionLevel: params.currentTensionLevel,
            witnesses: eventData.witnesses,
            location: locationStr,
            relationshipSignal,
        };
    }
    catch (error) {
        console.warn('[BlazeTracker] Event extraction failed:', error);
        return null;
    }
}
// ============================================
// Validation
// ============================================
function validateEventTypes(data) {
    if (!Array.isArray(data)) {
        return ['conversation']; // Default fallback
    }
    const valid = data.filter((t) => typeof t === 'string' && _types_state__WEBPACK_IMPORTED_MODULE_4__.EVENT_TYPES.includes(t));
    return valid.length > 0 ? valid : ['conversation'];
}
/**
 * Map event types to potential milestone types.
 */
const EVENT_TYPE_TO_MILESTONE = {
    // Bonding
    laugh: 'first_laugh',
    gift: 'first_gift',
    date: 'first_date',
    i_love_you: 'first_i_love_you',
    sleepover: 'first_sleepover',
    shared_meal: 'first_shared_meal',
    // Physical intimacy
    intimate_touch: 'first_touch',
    intimate_kiss: 'first_kiss',
    intimate_embrace: 'first_embrace',
    intimate_heated: 'first_heated',
    // Sexual milestones (atomic)
    intimate_foreplay: 'first_foreplay',
    intimate_oral: 'first_oral',
    intimate_manual: 'first_manual',
    intimate_penetrative: 'first_penetrative',
    intimate_climax: 'first_climax',
    // Emotional
    confession: 'confession',
    secret_shared: 'secret_shared',
    secret_revealed: 'secret_revealed',
    // Commitment
    promise: 'promise_made',
    betrayal: 'betrayal',
    // Life events
    exclusivity: 'promised_exclusivity',
    marriage: 'marriage',
    pregnancy: 'pregnancy',
    childbirth: 'had_child',
    // Conflicts
    argument: 'first_conflict',
    combat: 'first_conflict',
};
/**
 * Infer milestone types from event types, checking against existing relationship milestones.
 * Returns all applicable milestone types that don't already exist (multiple possible from one event).
 */
function inferMilestoneTypesFromEventTypes(eventTypes, existingRelationship) {
    const existingMilestoneTypes = new Set(existingRelationship?.milestones.map(m => m.type) ?? []);
    const milestoneTypes = [];
    const addedTypes = new Set();
    // Check for first_meeting if no existing relationship
    if (!existingRelationship && !existingMilestoneTypes.has('first_meeting')) {
        milestoneTypes.push('first_meeting');
        addedTypes.add('first_meeting');
    }
    // Check all event types for potential milestones
    for (const eventType of eventTypes) {
        const milestoneType = EVENT_TYPE_TO_MILESTONE[eventType];
        if (!milestoneType)
            continue;
        // Skip if already have this milestone in the relationship
        if (existingMilestoneTypes.has(milestoneType))
            continue;
        // Skip if we've already added this milestone type in this batch
        if (addedTypes.has(milestoneType))
            continue;
        milestoneTypes.push(milestoneType);
        addedTypes.add(milestoneType);
    }
    return milestoneTypes;
}
/**
 * Format character info for the milestone prompt.
 */
function formatCharacterForMilestone(char) {
    const parts = [`${char.name}:`];
    if (char.position) {
        parts.push(`Position: ${char.position}`);
    }
    if (char.mood?.length) {
        parts.push(`Mood: ${char.mood.join(', ')}`);
    }
    // Format outfit - only non-null slots
    const outfitParts = [];
    if (char.outfit) {
        for (const [slot, item] of Object.entries(char.outfit)) {
            if (item) {
                outfitParts.push(`${slot}: ${item}`);
            }
        }
    }
    if (outfitParts.length > 0) {
        parts.push(`Wearing: ${outfitParts.join(', ')}`);
    }
    return parts.join(' | ');
}
/**
 * Format relationship feelings for the milestone prompt.
 */
function formatRelationshipForMilestone(relationship, char1, char2) {
    const [a, b] = relationship.pair;
    const parts = [`${a} & ${b} (${relationship.status}):`];
    // Figure out which attitude is which
    const aIsChar1 = a.toLowerCase() === char1.toLowerCase();
    const aToB = relationship.aToB;
    const bToA = relationship.bToA;
    if (aIsChar1) {
        if (aToB.feelings?.length) {
            parts.push(`${char1} feels: ${aToB.feelings.join(', ')}`);
        }
        if (bToA.feelings?.length) {
            parts.push(`${char2} feels: ${bToA.feelings.join(', ')}`);
        }
    }
    else {
        if (bToA.feelings?.length) {
            parts.push(`${char1} feels: ${bToA.feelings.join(', ')}`);
        }
        if (aToB.feelings?.length) {
            parts.push(`${char2} feels: ${aToB.feelings.join(', ')}`);
        }
    }
    return parts.join(' | ');
}
/**
 * Map milestone types to the event types that provide relevant details.
 */
const MILESTONE_TO_EVENT_TYPE = {
    // Physical intimacy
    first_touch: ['intimate_touch'],
    first_kiss: ['intimate_kiss'],
    first_embrace: ['intimate_embrace'],
    first_heated: ['intimate_heated'],
    // Sexual milestones
    first_foreplay: ['intimate_foreplay'],
    first_oral: ['intimate_oral'],
    first_manual: ['intimate_manual'],
    first_penetrative: ['intimate_penetrative'],
    first_climax: ['intimate_climax'],
    // Emotional
    confession: ['confession'],
    emotional_intimacy: ['emotional'],
    // Secrets
    secret_shared: ['secret_shared'],
    secret_revealed: ['secret_revealed'],
    // Commitment
    promise_made: ['promise'],
    betrayal: ['betrayal'],
    // Life events
    promised_exclusivity: ['exclusivity'],
    marriage: ['marriage'],
    pregnancy: ['pregnancy'],
    had_child: ['childbirth'],
    // Conflicts
    first_conflict: ['argument', 'combat'],
};
/**
 * Get relevant event details for a milestone type.
 */
function getEventDetailsForMilestone(milestoneType, eventDetails) {
    const relevantEventTypes = MILESTONE_TO_EVENT_TYPE[milestoneType] ?? [];
    const details = [];
    for (const eventType of relevantEventTypes) {
        if (eventDetails[eventType]) {
            details.push(eventDetails[eventType]);
        }
    }
    return details.length > 0 ? details.join('; ') : '';
}
/**
 * Extract a grounded description for a milestone from the messages.
 */
async function extractMilestoneDescription(milestoneType, characterPair, messages, currentTime, location, characters, relationship, eventDetails, abortSignal) {
    const settings = (0,_settings__WEBPACK_IMPORTED_MODULE_0__.getSettings)();
    // Format time of day
    const hour = currentTime.hour;
    const timeOfDay = hour < 6
        ? 'late night'
        : hour < 9
            ? 'early morning'
            : hour < 12
                ? 'morning'
                : hour < 14
                    ? 'midday'
                    : hour < 17
                        ? 'afternoon'
                        : hour < 20
                            ? 'evening'
                            : 'night';
    // Format location
    const locationStr = [location.area, location.place, location.position]
        .filter(Boolean)
        .join(' - ');
    // Format props
    const propsStr = location.props?.length ? location.props.join(', ') : 'none specified';
    // Format character info for the pair
    const [char1Name, char2Name] = characterPair;
    const char1 = characters.find(c => c.name.toLowerCase() === char1Name.toLowerCase());
    const char2 = characters.find(c => c.name.toLowerCase() === char2Name.toLowerCase());
    const charactersStr = [
        char1 ? formatCharacterForMilestone(char1) : `${char1Name}: (no details)`,
        char2 ? formatCharacterForMilestone(char2) : `${char2Name}: (no details)`,
    ].join('\n');
    // Format relationship feelings
    const relationshipStr = relationship
        ? formatRelationshipForMilestone(relationship, char1Name, char2Name)
        : `${char1Name} & ${char2Name}: no established relationship`;
    // Get relevant event details for this milestone type
    const eventDetailStr = getEventDetailsForMilestone(milestoneType, eventDetails);
    const prompt = (0,_prompts__WEBPACK_IMPORTED_MODULE_1__.getPrompt)('milestone_description')
        .replace(/\{\{milestoneType\}\}/g, milestoneType.replace(/_/g, ' '))
        .replace(/\{\{characterPair\}\}/g, `${characterPair[0]} and ${characterPair[1]}`)
        .replace(/\{\{timeOfDay\}\}/g, timeOfDay)
        .replace(/\{\{location\}\}/g, locationStr)
        .replace(/\{\{props\}\}/g, propsStr)
        .replace(/\{\{characters\}\}/g, charactersStr)
        .replace(/\{\{relationship\}\}/g, relationshipStr)
        .replace(/\{\{eventDetail\}\}/g, eventDetailStr || 'none')
        .replace('{{messages}}', messages);
    // Use messages directly without wrapping in system prompt
    const llmMessages = (0,_utils_generator__WEBPACK_IMPORTED_MODULE_2__.buildExtractionMessages)('You are extracting factual descriptions of story moments. Be concise and accurate.', prompt);
    try {
        const response = await (0,_utils_generator__WEBPACK_IMPORTED_MODULE_2__.makeGeneratorRequest)(llmMessages, {
            profileId: settings.profileId,
            maxTokens: 200, // Shorter response expected
            temperature: (0,_settings__WEBPACK_IMPORTED_MODULE_0__.getTemperature)('milestone_description'),
            abortSignal,
        });
        // Clean up the response - remove any quotes or JSON formatting
        return response
            .trim()
            .replace(/^["']|["']$/g, '')
            .replace(/^description:\s*/i, '');
    }
    catch (error) {
        console.warn('[BlazeTracker] Milestone description extraction failed:', error);
        // Return a basic fallback description
        return `A significant ${milestoneType.replace(/_/g, ' ')} moment between ${characterPair[0]} and ${characterPair[1]}.`;
    }
}
/**
 * Create full milestone events with descriptions extracted from the messages.
 */
async function createMilestonesWithDescriptions(milestoneTypes, characterPair, messages, currentTime, location, characters, relationship, eventDetails, messageId, abortSignal) {
    // Extract descriptions in parallel for all milestones
    const descriptionPromises = milestoneTypes.map(type => extractMilestoneDescription(type, characterPair, messages, currentTime, location, characters, relationship, eventDetails, abortSignal));
    const descriptions = await Promise.all(descriptionPromises);
    // Format location string for storage
    const locationStr = [location.area, location.place].filter(Boolean).join(' - ');
    return milestoneTypes.map((type, index) => ({
        type,
        description: descriptions[index],
        timestamp: currentTime,
        location: locationStr,
        messageId,
    }));
}
/**
 * Find an existing relationship for a pair (case-insensitive).
 */
function findRelationshipForPair(relationships, pair) {
    return relationships.find(r => (r.pair[0].toLowerCase() === pair[0].toLowerCase() &&
        r.pair[1].toLowerCase() === pair[1].toLowerCase()) ||
        (r.pair[0].toLowerCase() === pair[1].toLowerCase() &&
            r.pair[1].toLowerCase() === pair[0].toLowerCase()));
}
function validateEventDetails(data) {
    if (!data || !(0,_utils_json__WEBPACK_IMPORTED_MODULE_3__.isObject)(data)) {
        return undefined;
    }
    const details = {};
    for (const [key, value] of Object.entries(data)) {
        if (typeof value === 'string' && value.trim()) {
            details[key] = value.trim();
        }
    }
    return Object.keys(details).length > 0 ? details : undefined;
}
/**
 * Parse a single pair from data.
 */
function parseSinglePair(pair) {
    if (!Array.isArray(pair) || pair.length < 2)
        return null;
    const char1 = typeof pair[0] === 'string' ? pair[0].trim() : '';
    const char2 = typeof pair[1] === 'string' ? pair[1].trim() : '';
    if (char1 && char2)
        return [char1, char2];
    return null;
}
/**
 * Validate eventPairs - supports both single pair and array of pairs per event type.
 */
function validateEventPairs(data, eventTypes) {
    const pairs = {};
    if (!data || !(0,_utils_json__WEBPACK_IMPORTED_MODULE_3__.isObject)(data)) {
        return pairs;
    }
    for (const eventType of eventTypes) {
        const value = data[eventType];
        if (!Array.isArray(value) || value.length < 2)
            continue;
        // Check if it's an array of pairs [[char1, char2], [char3, char4]]
        if (Array.isArray(value[0])) {
            const multiplePairs = [];
            for (const item of value) {
                const parsed = parseSinglePair(item);
                if (parsed)
                    multiplePairs.push(parsed);
            }
            if (multiplePairs.length > 0) {
                pairs[eventType] = multiplePairs;
            }
        }
        else {
            // Single pair [char1, char2]
            const parsed = parseSinglePair(value);
            if (parsed) {
                pairs[eventType] = parsed;
            }
        }
    }
    return pairs;
}
/**
 * Normalize eventPairs to always return an array of pairs for easier processing.
 */
function normalizePairs(value) {
    if (value.length === 0)
        return [];
    // Check if it's array of pairs or single pair
    if (Array.isArray(value[0])) {
        return value;
    }
    return [value];
}
function validateEventData(data, _relationships) {
    if (!(0,_utils_json__WEBPACK_IMPORTED_MODULE_3__.isObject)(data)) {
        return null;
    }
    const summary = (0,_utils_json__WEBPACK_IMPORTED_MODULE_3__.asString)(data.summary, '');
    if (!summary.trim()) {
        return null;
    }
    const eventTypes = validateEventTypes(data.eventTypes);
    const eventPairs = validateEventPairs(data.eventPairs, eventTypes);
    const eventDetails = validateEventDetails(data.eventDetails);
    const witnesses = (0,_utils_json__WEBPACK_IMPORTED_MODULE_3__.asStringArray)(data.witnesses);
    const relationshipSignals = validateRelationshipSignals(data.relationshipSignals);
    return {
        summary,
        eventTypes,
        eventPairs,
        eventDetails,
        witnesses,
        relationshipSignals,
    };
}
function validateRelationshipSignal(data) {
    if (!data || !(0,_utils_json__WEBPACK_IMPORTED_MODULE_3__.isObject)(data)) {
        return undefined;
    }
    // Validate pair
    const pair = data.pair;
    if (!Array.isArray(pair) || pair.length !== 2) {
        return undefined;
    }
    const char1 = typeof pair[0] === 'string' ? pair[0] : '';
    const char2 = typeof pair[1] === 'string' ? pair[1] : '';
    if (!char1 || !char2) {
        return undefined;
    }
    // Sort the pair alphabetically
    const sortedPair = (0,_state_relationships__WEBPACK_IMPORTED_MODULE_5__.sortPair)(char1, char2);
    // Validate changes
    let changes;
    if (Array.isArray(data.changes)) {
        changes = data.changes
            .filter(_utils_json__WEBPACK_IMPORTED_MODULE_3__.isObject)
            .map(c => ({
            from: (0,_utils_json__WEBPACK_IMPORTED_MODULE_3__.asString)(c.from, ''),
            toward: (0,_utils_json__WEBPACK_IMPORTED_MODULE_3__.asString)(c.toward, ''),
            feeling: (0,_utils_json__WEBPACK_IMPORTED_MODULE_3__.asString)(c.feeling, ''),
        }))
            .filter(c => c.from && c.toward && c.feeling);
        if (changes.length === 0) {
            changes = undefined;
        }
    }
    // Only return signal if we have changes
    if (!changes) {
        return undefined;
    }
    return {
        pair: sortedPair,
        changes,
    };
}
function validateRelationshipSignals(data) {
    if (!Array.isArray(data)) {
        return undefined;
    }
    const signals = data
        .map(item => validateRelationshipSignal(item))
        .filter((s) => s !== undefined);
    return signals.length > 0 ? signals : undefined;
}
function isNoEventResponse(summary) {
    const noEventPhrases = [
        'no significant event',
        'no notable event',
        'no major event',
        'nothing significant',
        'nothing notable',
        'routine conversation',
        'casual conversation',
        'n/a',
        'none',
    ];
    const lower = summary.toLowerCase().trim();
    return noEventPhrases.some(phrase => lower.includes(phrase) || lower === phrase);
}
// ============================================
// Helper Functions
// ============================================
function formatRelationshipsForPrompt(relationships) {
    if (relationships.length === 0) {
        return 'No established relationships yet.';
    }
    return relationships
        .map(r => {
        const [charA, charB] = r.pair;
        const aFeelings = r.aToB.feelings.join(', ') || 'neutral';
        const bFeelings = r.bToA.feelings.join(', ') || 'neutral';
        return `${charA} & ${charB} (${r.status}): ${charA} feels ${aFeelings}; ${charB} feels ${bFeelings}`;
    })
        .join('\n');
}


/***/ },

/***/ "./src/extractors/extractLocation.ts"
/*!*******************************************!*\
  !*** ./src/extractors/extractLocation.ts ***!
  \*******************************************/
(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   extractLocation: () => (/* binding */ extractLocation)
/* harmony export */ });
/* harmony import */ var _settings__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../settings */ "./src/settings.ts");
/* harmony import */ var _prompts__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./prompts */ "./src/extractors/prompts.ts");
/* harmony import */ var _utils_generator__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../utils/generator */ "./src/utils/generator.ts");
/* harmony import */ var _utils_json__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../utils/json */ "./src/utils/json.ts");




// ============================================
// Schema & Example
// ============================================
const LOCATION_SCHEMA = {
    type: 'object',
    properties: {
        area: {
            type: 'string',
            description: 'Broad area or region (city, town, region, etc.)',
        },
        place: {
            type: 'string',
            description: 'Specific location within the area (building, landmark, etc.)',
        },
        position: {
            type: 'string',
            description: 'Exact position within the place (room, corner, etc.)',
        },
        props: {
            type: 'array',
            description: 'Notable items or features in the immediate environment',
            items: {
                type: 'string',
                description: 'A nearby item which is part of the scene, detailed',
            },
            maxItems: 10,
        },
    },
    required: ['area', 'place', 'position', 'props'],
};
const LOCATION_EXAMPLE = JSON.stringify({
    area: 'Downtown Seattle',
    place: 'The Rusty Nail Bar',
    position: 'Corner booth',
    props: [
        'Jukebox playing soft rock',
        'Empty beer glasses on the table',
        'Bowl of peanuts',
        'Flickering neon sign above the bar',
    ],
}, null, 2);
// ============================================
// Constants
// ============================================
const SYSTEM_PROMPT = 'You are a location analysis agent for roleplay scenes. Return only valid JSON.';
// ============================================
// Public API
// ============================================
async function extractLocation(isInitial, messages, characterInfo, previousLocation, abortSignal) {
    const settings = (0,_settings__WEBPACK_IMPORTED_MODULE_0__.getSettings)();
    const schemaStr = JSON.stringify(LOCATION_SCHEMA, null, 2);
    const prompt = isInitial
        ? (0,_prompts__WEBPACK_IMPORTED_MODULE_1__.getPrompt)('location_initial')
            .replace('{{characterInfo}}', characterInfo)
            .replace('{{messages}}', messages)
            .replace('{{schema}}', schemaStr)
            .replace('{{schemaExample}}', LOCATION_EXAMPLE)
        : (0,_prompts__WEBPACK_IMPORTED_MODULE_1__.getPrompt)('location_update')
            .replace('{{previousState}}', JSON.stringify(previousLocation, null, 2))
            .replace('{{messages}}', messages)
            .replace('{{schema}}', schemaStr)
            .replace('{{schemaExample}}', LOCATION_EXAMPLE);
    const llmMessages = (0,_utils_generator__WEBPACK_IMPORTED_MODULE_2__.buildExtractionMessages)(SYSTEM_PROMPT, prompt);
    const response = await (0,_utils_generator__WEBPACK_IMPORTED_MODULE_2__.makeGeneratorRequest)(llmMessages, {
        profileId: settings.profileId,
        maxTokens: settings.maxResponseTokens,
        temperature: (0,_settings__WEBPACK_IMPORTED_MODULE_0__.getTemperature)(isInitial ? 'location_initial' : 'location_update'),
        abortSignal,
    });
    const parsed = (0,_utils_json__WEBPACK_IMPORTED_MODULE_3__.parseJsonResponse)(response, {
        shape: 'object',
        moduleName: 'BlazeTracker/Location',
    });
    return validateLocation(parsed);
}
// ============================================
// Validation
// ============================================
function validateLocation(data) {
    if (typeof data !== 'object' || data === null) {
        throw new Error('Invalid location: expected object');
    }
    const obj = data;
    if (!obj.place || typeof obj.place !== 'string') {
        throw new Error('Invalid location: missing or invalid place');
    }
    return {
        area: (0,_utils_json__WEBPACK_IMPORTED_MODULE_3__.asString)(obj.area, 'Unknown Area'),
        place: obj.place,
        position: (0,_utils_json__WEBPACK_IMPORTED_MODULE_3__.asString)(obj.position, 'Main area'),
        props: (0,_utils_json__WEBPACK_IMPORTED_MODULE_3__.asStringArray)(obj.props, 10),
    };
}


/***/ },

/***/ "./src/extractors/extractRelationships.ts"
/*!************************************************!*\
  !*** ./src/extractors/extractRelationships.ts ***!
  \************************************************/
(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   RELATIONSHIP_SCHEMA: () => (/* binding */ RELATIONSHIP_SCHEMA),
/* harmony export */   extractInitialRelationship: () => (/* binding */ extractInitialRelationship),
/* harmony export */   refreshRelationship: () => (/* binding */ refreshRelationship),
/* harmony export */   updateRelationshipFromSignal: () => (/* binding */ updateRelationshipFromSignal)
/* harmony export */ });
/* harmony import */ var _settings__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../settings */ "./src/settings.ts");
/* harmony import */ var _prompts__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./prompts */ "./src/extractors/prompts.ts");
/* harmony import */ var _utils_generator__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../utils/generator */ "./src/utils/generator.ts");
/* harmony import */ var _utils_json__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../utils/json */ "./src/utils/json.ts");
/* harmony import */ var _types_state__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../types/state */ "./src/types/state.ts");
/* harmony import */ var _state_relationships__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../state/relationships */ "./src/state/relationships.ts");
/* harmony import */ var _state_events__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ../state/events */ "./src/state/events.ts");
// ============================================
// Relationship Extractor
// ============================================







// ============================================
// Schema & Examples
// ============================================
const RELATIONSHIP_SCHEMA = {
    type: 'object',
    description: 'Relationship state between two characters',
    additionalProperties: false,
    properties: {
        status: {
            type: 'string',
            enum: [..._types_state__WEBPACK_IMPORTED_MODULE_4__.RELATIONSHIP_STATUSES],
            description: 'Current relationship status',
        },
        attitudes: {
            type: 'object',
            description: "Each character's attitude toward the other. Keys are character names.",
            additionalProperties: {
                type: 'object',
                properties: {
                    toward: {
                        type: 'string',
                        description: 'The other character this attitude is directed at',
                    },
                    feelings: {
                        type: 'array',
                        items: { type: 'string' },
                        description: 'Current feelings toward the other character',
                    },
                    secrets: {
                        type: 'array',
                        items: { type: 'string' },
                        description: 'Things they know that the other character does not',
                    },
                    wants: {
                        type: 'array',
                        items: { type: 'string' },
                        description: 'What they want from this relationship',
                    },
                },
            },
        },
        // Support legacy aToB/bToA format for backwards compatibility
        aToB: {
            type: 'object',
            description: 'How the first character (alphabetically) feels about the second',
            properties: {
                feelings: {
                    type: 'array',
                    items: { type: 'string' },
                },
                secrets: {
                    type: 'array',
                    items: { type: 'string' },
                },
                wants: {
                    type: 'array',
                    items: { type: 'string' },
                },
            },
        },
        bToA: {
            type: 'object',
            description: 'How the second character (alphabetically) feels about the first',
            properties: {
                feelings: {
                    type: 'array',
                    items: { type: 'string' },
                },
                secrets: {
                    type: 'array',
                    items: { type: 'string' },
                },
                wants: {
                    type: 'array',
                    items: { type: 'string' },
                },
            },
        },
    },
    required: ['status'],
};
function createRelationshipExample(char1, char2) {
    return JSON.stringify({
        status: 'friendly',
        attitudes: {
            [char1]: {
                toward: char2,
                feelings: ['trusting', 'curious'],
                secrets: ['knows about their hidden talent'],
                wants: ['friendship', 'adventure together'],
            },
            [char2]: {
                toward: char1,
                feelings: ['grateful', 'protective'],
                secrets: [],
                wants: ['loyalty', 'emotional support'],
            },
        },
    }, null, 2);
}
// ============================================
// Constants
// ============================================
const SYSTEM_PROMPT = 'You are a relationship analysis agent for roleplay. Extract and track character relationships with attention to asymmetry. Return only valid JSON.';
/**
 * Get a descriptive time of day phrase from hour.
 */
function getTimeOfDay(hour) {
    if (hour >= 5 && hour < 12)
        return 'in the morning';
    if (hour >= 12 && hour < 17)
        return 'in the afternoon';
    if (hour >= 17 && hour < 21)
        return 'in the evening';
    return 'at night';
}
/**
 * Extract the initial relationship state between two characters.
 */
async function extractInitialRelationship(params) {
    const settings = (0,_settings__WEBPACK_IMPORTED_MODULE_0__.getSettings)();
    const pair = (0,_state_relationships__WEBPACK_IMPORTED_MODULE_5__.sortPair)(params.char1, params.char2);
    const schemaStr = JSON.stringify(RELATIONSHIP_SCHEMA, null, 2);
    const exampleStr = createRelationshipExample(pair[0], pair[1]);
    const prompt = (0,_prompts__WEBPACK_IMPORTED_MODULE_1__.getPrompt)('relationship_initial')
        .replace('{{messages}}', params.messages)
        .replace('{{characterInfo}}', params.characterInfo)
        .replace('{{schema}}', schemaStr)
        .replace('{{schemaExample}}', exampleStr);
    const llmMessages = (0,_utils_generator__WEBPACK_IMPORTED_MODULE_2__.buildExtractionMessages)(SYSTEM_PROMPT, prompt);
    try {
        const response = await (0,_utils_generator__WEBPACK_IMPORTED_MODULE_2__.makeGeneratorRequest)(llmMessages, {
            profileId: settings.profileId,
            maxTokens: settings.maxResponseTokens,
            temperature: (0,_settings__WEBPACK_IMPORTED_MODULE_0__.getTemperature)('relationship_initial'),
            abortSignal: params.abortSignal,
        });
        const parsed = (0,_utils_json__WEBPACK_IMPORTED_MODULE_3__.parseJsonResponse)(response, {
            shape: 'object',
            moduleName: 'BlazeTracker/Relationship',
        });
        const relationship = buildRelationship(pair, parsed, undefined, params.messageId);
        // Automatically add first_meeting milestone for new relationships
        if (relationship && params.messageId !== undefined && params.currentTime && params.currentLocation) {
            const locationStr = [params.currentLocation.place, params.currentLocation.area]
                .filter(Boolean)
                .join(', ');
            const timeOfDay = getTimeOfDay(params.currentTime.hour);
            const description = `${pair[0]} and ${pair[1]} first appear together ${timeOfDay} at ${locationStr}.`;
            (0,_state_relationships__WEBPACK_IMPORTED_MODULE_5__.addMilestone)(relationship, {
                type: 'first_meeting',
                description,
                timestamp: params.currentTime,
                location: locationStr,
                messageId: params.messageId,
            });
        }
        return relationship;
    }
    catch (error) {
        console.warn('[BlazeTracker] Initial relationship extraction failed:', error);
        return null;
    }
}
/**
 * Update a relationship based on recent events.
 */
async function refreshRelationship(params) {
    const settings = (0,_settings__WEBPACK_IMPORTED_MODULE_0__.getSettings)();
    const pair = params.relationship.pair;
    const schemaStr = JSON.stringify(RELATIONSHIP_SCHEMA, null, 2);
    const exampleStr = createRelationshipExample(pair[0], pair[1]);
    const eventsStr = (0,_state_events__WEBPACK_IMPORTED_MODULE_6__.formatEventsForInjection)(params.events);
    const previousStr = formatPreviousRelationship(params.relationship);
    const prompt = (0,_prompts__WEBPACK_IMPORTED_MODULE_1__.getPrompt)('relationship_update')
        .replace('{{previousState}}', previousStr)
        .replace('{{currentEvents}}', eventsStr)
        .replace('{{messages}}', params.messages)
        .replace('{{schema}}', schemaStr)
        .replace('{{schemaExample}}', exampleStr);
    const llmMessages = (0,_utils_generator__WEBPACK_IMPORTED_MODULE_2__.buildExtractionMessages)(SYSTEM_PROMPT, prompt);
    try {
        const response = await (0,_utils_generator__WEBPACK_IMPORTED_MODULE_2__.makeGeneratorRequest)(llmMessages, {
            profileId: settings.profileId,
            maxTokens: settings.maxResponseTokens,
            temperature: (0,_settings__WEBPACK_IMPORTED_MODULE_0__.getTemperature)('relationship_update'),
            abortSignal: params.abortSignal,
        });
        const parsed = (0,_utils_json__WEBPACK_IMPORTED_MODULE_3__.parseJsonResponse)(response, {
            shape: 'object',
            moduleName: 'BlazeTracker/Relationship',
        });
        // Build updated relationship, preserving history
        const updated = buildRelationship(pair, parsed, params.relationship, params.messageId);
        // If this is a chapter boundary, add a history snapshot
        if (params.isChapterBoundary && updated) {
            // Note: Chapter index should be provided by caller if needed
            // For now we skip the snapshot creation here
        }
        return updated;
    }
    catch (error) {
        console.warn('[BlazeTracker] Relationship refresh failed:', error);
        return null;
    }
}
/**
 * Apply a relationship signal from event extraction to update the relationship.
 * This is a lighter-weight update that doesn't require an LLM call.
 */
function updateRelationshipFromSignal(relationship, signal) {
    // Create a copy to modify
    const updated = { ...relationship };
    updated.aToB = { ...updated.aToB };
    updated.bToA = { ...updated.bToA };
    updated.milestones = [...updated.milestones];
    const [charA, charB] = updated.pair;
    // Apply directional changes
    if (signal.changes) {
        for (const change of signal.changes) {
            const fromLower = change.from.toLowerCase();
            const towardLower = change.toward.toLowerCase();
            // Determine direction
            if (fromLower === charA.toLowerCase() &&
                towardLower === charB.toLowerCase()) {
                // A's feeling toward B changed
                if (!updated.aToB.feelings.includes(change.feeling)) {
                    updated.aToB.feelings = [
                        ...updated.aToB.feelings,
                        change.feeling,
                    ];
                }
            }
            else if (fromLower === charB.toLowerCase() &&
                towardLower === charA.toLowerCase()) {
                // B's feeling toward A changed
                if (!updated.bToA.feelings.includes(change.feeling)) {
                    updated.bToA.feelings = [
                        ...updated.bToA.feelings,
                        change.feeling,
                    ];
                }
            }
        }
    }
    // Add milestones if provided and not duplicates
    if (signal.milestones && signal.milestones.length > 0) {
        for (const milestone of signal.milestones) {
            const hasMilestone = updated.milestones.some(m => m.type === milestone.type);
            if (!hasMilestone) {
                updated.milestones = [...updated.milestones, milestone];
            }
        }
    }
    return updated;
}
// ============================================
// Helpers
// ============================================
function formatPreviousRelationship(relationship) {
    const [charA, charB] = relationship.pair;
    const lines = [
        `Characters: ${charA} & ${charB}`,
        `Status: ${relationship.status}`,
        '',
        `${charA}'s attitude toward ${charB}:`,
        `  Feelings: ${relationship.aToB.feelings.join(', ') || 'none'}`,
        `  Secrets: ${relationship.aToB.secrets.join('; ') || 'none'}`,
        `  Wants: ${relationship.aToB.wants.join(', ') || 'none'}`,
        '',
        `${charB}'s attitude toward ${charA}:`,
        `  Feelings: ${relationship.bToA.feelings.join(', ') || 'none'}`,
        `  Secrets: ${relationship.bToA.secrets.join('; ') || 'none'}`,
        `  Wants: ${relationship.bToA.wants.join(', ') || 'none'}`,
    ];
    if (relationship.milestones.length > 0) {
        lines.push('');
        lines.push('Milestones:');
        for (const m of relationship.milestones) {
            lines.push(`  - ${m.type}: ${m.description}`);
        }
    }
    return lines.join('\n');
}
/**
 * Find an attitude by character name (case-insensitive).
 */
function findAttitudeByName(attitudes, name) {
    const lowerName = name.toLowerCase();
    for (const [key, value] of Object.entries(attitudes)) {
        if (key.toLowerCase() === lowerName) {
            return value;
        }
    }
    return null;
}
/**
 * Infer minimum relationship status based on feelings.
 */
function inferMinimumStatus(feelings) {
    const lower = feelings.map(f => f.toLowerCase()).join(' ');
    if (/love|passionate|romantic|desire|intimate|adore/.test(lower))
        return 'intimate';
    if (/trust|care|protective|devoted|loyal|deep/.test(lower))
        return 'close';
    if (/like|enjoy|comfortable|fond|friendly|warm/.test(lower))
        return 'friendly';
    if (/hate|despise|enemy|loathe/.test(lower))
        return 'hostile';
    if (/suspicious|resentful|angry|bitter|distrust/.test(lower))
        return 'strained';
    return null;
}
/**
 * Milestones that indicate a romantic relationship has begun.
 * Without at least one of these, "intimate" status is not appropriate.
 */
const ROMANTIC_GATE_MILESTONES = new Set([
    'first_kiss',
    'first_date',
    'first_i_love_you',
    'promised_exclusivity',
    'marriage',
    // Sexual milestones
    'first_foreplay',
    'first_oral',
    'first_manual',
    'first_penetrative',
    'first_climax',
]);
/**
 * Infer maximum relationship status based on milestones.
 * This caps status to prevent models from over-estimating relationship depth.
 */
function inferMaximumStatus(milestones) {
    const milestoneTypes = new Set(milestones.map(m => m.type));
    // Check for any romantic gate milestone
    const hasRomanticMilestone = [...ROMANTIC_GATE_MILESTONES].some(m => milestoneTypes.has(m));
    // If no romantic milestones at all, cap at "close" (deep friendship, not romantic)
    if (!hasRomanticMilestone) {
        return 'close';
    }
    return null; // No cap
}
/**
 * Get numeric rank for status to compare relative closeness.
 */
function getStatusRank(status) {
    const statusRank = {
        hostile: -2,
        strained: -1,
        strangers: 0,
        acquaintances: 1,
        friendly: 2,
        close: 3,
        intimate: 4,
        complicated: 0,
    };
    return statusRank[status];
}
/**
 * Get status from rank.
 */
function getStatusFromRank(rank) {
    const rankToStatus = {
        [-2]: 'hostile',
        [-1]: 'strained',
        0: 'strangers',
        1: 'acquaintances',
        2: 'friendly',
        3: 'close',
        4: 'intimate',
    };
    return rankToStatus[rank] ?? 'acquaintances';
}
function buildRelationship(pair, data, existing, messageId) {
    if (!(0,_utils_json__WEBPACK_IMPORTED_MODULE_3__.isObject)(data)) {
        return null;
    }
    const [charA, charB] = pair;
    let aToB;
    let bToA;
    // Try new attitudes format first
    if ((0,_utils_json__WEBPACK_IMPORTED_MODULE_3__.isObject)(data.attitudes)) {
        const attitudes = data.attitudes;
        const charAAttitude = findAttitudeByName(attitudes, charA);
        const charBAttitude = findAttitudeByName(attitudes, charB);
        aToB = validateAttitude(charAAttitude);
        bToA = validateAttitude(charBAttitude);
    }
    else {
        // Fall back to legacy aToB/bToA format
        aToB = validateAttitude(data.aToB);
        bToA = validateAttitude(data.bToA);
    }
    // Validate status
    let status = validateStatus(data.status);
    // Infer minimum status from feelings if status seems too low
    const minFromA = inferMinimumStatus(aToB.feelings);
    const minFromB = inferMinimumStatus(bToA.feelings);
    let currentRank = getStatusRank(status);
    const minRank = Math.max(minFromA ? getStatusRank(minFromA) : -999, minFromB ? getStatusRank(minFromB) : -999);
    // Upgrade status if feelings suggest deeper connection
    if (minRank > currentRank && minRank !== -999) {
        currentRank = minRank;
        status = getStatusFromRank(currentRank);
    }
    // Apply maximum cap based on milestones (only for positive statuses)
    // We need the existing relationship's milestones to check this
    if (existing && currentRank > 0) {
        const maxStatus = inferMaximumStatus(existing.milestones);
        if (maxStatus) {
            const maxRank = getStatusRank(maxStatus);
            if (currentRank > maxRank) {
                status = maxStatus;
            }
        }
    }
    // Determine if status changed
    const statusChanged = !existing || existing.status !== status;
    // Start with existing or create new
    let relationship;
    if (existing) {
        relationship = {
            ...existing,
            status,
            aToB,
            bToA,
        };
        // Add a new version if status actually changed
        if (statusChanged && messageId !== undefined) {
            (0,_state_relationships__WEBPACK_IMPORTED_MODULE_5__.addRelationshipVersion)(relationship, messageId);
        }
    }
    else {
        relationship = (0,_state_relationships__WEBPACK_IMPORTED_MODULE_5__.createRelationship)(pair[0], pair[1], status, messageId);
        relationship.aToB = aToB;
        relationship.bToA = bToA;
    }
    return relationship;
}
function validateStatus(value) {
    if (typeof value === 'string' &&
        _types_state__WEBPACK_IMPORTED_MODULE_4__.RELATIONSHIP_STATUSES.includes(value)) {
        return value;
    }
    return 'acquaintances';
}
function validateAttitude(value) {
    if (!(0,_utils_json__WEBPACK_IMPORTED_MODULE_3__.isObject)(value)) {
        return (0,_state_relationships__WEBPACK_IMPORTED_MODULE_5__.createEmptyAttitude)();
    }
    return {
        feelings: (0,_utils_json__WEBPACK_IMPORTED_MODULE_3__.asStringArray)(value.feelings),
        secrets: (0,_utils_json__WEBPACK_IMPORTED_MODULE_3__.asStringArray)(value.secrets),
        wants: (0,_utils_json__WEBPACK_IMPORTED_MODULE_3__.asStringArray)(value.wants),
    };
}


/***/ },

/***/ "./src/extractors/extractScene.ts"
/*!****************************************!*\
  !*** ./src/extractors/extractScene.ts ***!
  \****************************************/
(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   SCENE_SCHEMA: () => (/* binding */ SCENE_SCHEMA),
/* harmony export */   extractScene: () => (/* binding */ extractScene),
/* harmony export */   shouldExtractScene: () => (/* binding */ shouldExtractScene)
/* harmony export */ });
/* harmony import */ var _settings__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../settings */ "./src/settings.ts");
/* harmony import */ var _prompts__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./prompts */ "./src/extractors/prompts.ts");
/* harmony import */ var _utils_generator__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../utils/generator */ "./src/utils/generator.ts");
/* harmony import */ var _utils_json__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../utils/json */ "./src/utils/json.ts");
/* harmony import */ var _utils_tension__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../utils/tension */ "./src/utils/tension.ts");





// ============================================
// Schema & Example
// ============================================
const SCENE_SCHEMA = {
    type: 'object',
    description: 'Summary of the current scene state',
    additionalProperties: false,
    properties: {
        topic: {
            type: 'string',
            description: '3-5 words describing the main topic(s) of the current interaction',
        },
        tone: {
            type: 'string',
            description: 'Dominant emotional tone of the scene (2-3 words)',
        },
        tension: {
            type: 'object',
            description: 'Current tension level in the scene',
            additionalProperties: false,
            properties: {
                level: {
                    type: 'string',
                    enum: [
                        'relaxed',
                        'aware',
                        'guarded',
                        'tense',
                        'charged',
                        'volatile',
                        'explosive',
                    ],
                },
                direction: {
                    type: 'string',
                    enum: ['escalating', 'stable', 'decreasing'],
                    description: 'Set based on comparison with previous level - will be recalculated',
                },
                type: {
                    type: 'string',
                    enum: [
                        'confrontation',
                        'intimate',
                        'vulnerable',
                        'celebratory',
                        'negotiation',
                        'suspense',
                        'conversation',
                    ],
                },
            },
            required: ['level', 'direction', 'type'],
        },
        // Note: recentEvents removed in v1.0.0, replaced by event extraction
    },
    required: ['topic', 'tone', 'tension'],
};
const SCENE_EXAMPLE = JSON.stringify({
    topic: "Discussing Marcus's heist plans",
    tone: 'Hushed, conspiratorial',
    tension: {
        level: 'tense',
        direction: 'escalating',
        type: 'negotiation',
    },
}, null, 2);
// ============================================
// Constants
// ============================================
const SYSTEM_PROMPT = 'You are a scene analysis agent for roleplay. Return only valid JSON.';
const VALID_TENSION_LEVELS = [
    'relaxed',
    'aware',
    'guarded',
    'tense',
    'charged',
    'volatile',
    'explosive',
];
const VALID_TENSION_DIRECTIONS = [
    'escalating',
    'stable',
    'decreasing',
];
const VALID_TENSION_TYPES = [
    'confrontation',
    'intimate',
    'vulnerable',
    'celebratory',
    'negotiation',
    'suspense',
    'conversation',
];
// ============================================
// Public API
// ============================================
async function extractScene(isInitial, messages, characters, userInfo, characterInfo, previousScene, abortSignal) {
    const settings = (0,_settings__WEBPACK_IMPORTED_MODULE_0__.getSettings)();
    // Create a brief summary of characters for context
    const charactersSummary = characters
        .map(c => `${c.name}: ${c.mood.join(', ')} - ${c.activity || c.position}`)
        .join('\n');
    const schemaStr = JSON.stringify(SCENE_SCHEMA, null, 2);
    const prompt = isInitial
        ? (0,_prompts__WEBPACK_IMPORTED_MODULE_1__.getPrompt)('scene_initial')
            .replace('{{userInfo}}', userInfo)
            .replace('{{characterInfo}}', characterInfo)
            .replace('{{charactersSummary}}', charactersSummary)
            .replace('{{messages}}', messages)
            .replace('{{schema}}', schemaStr)
            .replace('{{schemaExample}}', SCENE_EXAMPLE)
        : (0,_prompts__WEBPACK_IMPORTED_MODULE_1__.getPrompt)('scene_update')
            .replace('{{charactersSummary}}', charactersSummary)
            .replace('{{previousState}}', JSON.stringify(previousScene, null, 2))
            .replace('{{messages}}', messages)
            .replace('{{schema}}', schemaStr)
            .replace('{{schemaExample}}', SCENE_EXAMPLE);
    const llmMessages = (0,_utils_generator__WEBPACK_IMPORTED_MODULE_2__.buildExtractionMessages)(SYSTEM_PROMPT, prompt);
    const response = await (0,_utils_generator__WEBPACK_IMPORTED_MODULE_2__.makeGeneratorRequest)(llmMessages, {
        profileId: settings.profileId,
        maxTokens: settings.maxResponseTokens,
        temperature: (0,_settings__WEBPACK_IMPORTED_MODULE_0__.getTemperature)(isInitial ? 'scene_initial' : 'scene_update'),
        abortSignal,
    });
    const parsed = (0,_utils_json__WEBPACK_IMPORTED_MODULE_3__.parseJsonResponse)(response, {
        shape: 'object',
        moduleName: 'BlazeTracker/Scene',
    });
    const scene = validateScene(parsed);
    // Recalculate tension direction based on previous state
    scene.tension.direction = (0,_utils_tension__WEBPACK_IMPORTED_MODULE_4__.calculateTensionDirection)(scene.tension.level, previousScene?.tension?.level);
    return scene;
}
/**
 * Determine if scene extraction should run for this message.
 * Returns true if this is an assistant message (every 2nd message).
 */
function shouldExtractScene(_messageId, isAssistantMessage) {
    // Only extract scene after assistant responses
    return isAssistantMessage;
}
// ============================================
// Validation
// ============================================
function validateScene(data) {
    if (!(0,_utils_json__WEBPACK_IMPORTED_MODULE_3__.isObject)(data)) {
        throw new Error('Invalid scene: expected object');
    }
    if (!data.topic || typeof data.topic !== 'string') {
        throw new Error('Invalid scene: missing topic');
    }
    // Validate tension
    const tensionData = (0,_utils_json__WEBPACK_IMPORTED_MODULE_3__.isObject)(data.tension) ? data.tension : {};
    const level = VALID_TENSION_LEVELS.includes(tensionData.level)
        ? tensionData.level
        : 'relaxed';
    const direction = VALID_TENSION_DIRECTIONS.includes(tensionData.direction)
        ? tensionData.direction
        : 'stable';
    const type = VALID_TENSION_TYPES.includes(tensionData.type)
        ? tensionData.type
        : 'conversation';
    // Note: recentEvents removed in v1.0.0, replaced by currentEvents on TrackedState
    return {
        topic: data.topic,
        tone: (0,_utils_json__WEBPACK_IMPORTED_MODULE_3__.asString)(data.tone, 'neutral'),
        tension: { level, direction, type },
    };
}


/***/ },

/***/ "./src/extractors/extractState.ts"
/*!****************************************!*\
  !*** ./src/extractors/extractState.ts ***!
  \****************************************/
(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   abortCurrentExtraction: () => (/* binding */ abortCurrentExtraction),
/* harmony export */   extractState: () => (/* binding */ extractState),
/* harmony export */   isBatchExtractionInProgress: () => (/* binding */ isBatchExtractionInProgress),
/* harmony export */   setBatchExtractionInProgress: () => (/* binding */ setBatchExtractionInProgress),
/* harmony export */   setupExtractionAbortHandler: () => (/* binding */ setupExtractionAbortHandler),
/* harmony export */   updateSubsequentMessagesEvents: () => (/* binding */ updateSubsequentMessagesEvents),
/* harmony export */   wasGenerationAborted: () => (/* binding */ wasGenerationAborted)
/* harmony export */ });
/* harmony import */ var _settings__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../settings */ "./src/settings.ts");
/* harmony import */ var _utils_messageState__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../utils/messageState */ "./src/utils/messageState.ts");
/* harmony import */ var _extractTime__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./extractTime */ "./src/extractors/extractTime.ts");
/* harmony import */ var _extractLocation__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./extractLocation */ "./src/extractors/extractLocation.ts");
/* harmony import */ var _extractClimate__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./extractClimate */ "./src/extractors/extractClimate.ts");
/* harmony import */ var _extractCharacters__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./extractCharacters */ "./src/extractors/extractCharacters.ts");
/* harmony import */ var _extractScene__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./extractScene */ "./src/extractors/extractScene.ts");
/* harmony import */ var _extractEvent__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./extractEvent */ "./src/extractors/extractEvent.ts");
/* harmony import */ var _extractChapter__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ./extractChapter */ "./src/extractors/extractChapter.ts");
/* harmony import */ var _extractRelationships__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ./extractRelationships */ "./src/extractors/extractRelationships.ts");
/* harmony import */ var _utils_clothingMatch__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! ../utils/clothingMatch */ "./src/utils/clothingMatch.ts");
/* harmony import */ var _extractionProgress__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(/*! ./extractionProgress */ "./src/extractors/extractionProgress.ts");
/* harmony import */ var _state_narrativeState__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__(/*! ../state/narrativeState */ "./src/state/narrativeState.ts");
/* harmony import */ var _state_chapters__WEBPACK_IMPORTED_MODULE_13__ = __webpack_require__(/*! ../state/chapters */ "./src/state/chapters.ts");
/* harmony import */ var _state_relationships__WEBPACK_IMPORTED_MODULE_14__ = __webpack_require__(/*! ../state/relationships */ "./src/state/relationships.ts");


// Import extractors













// ============================================
// Module State
// ============================================
let currentAbortController = null;
let extractionCount = 0;
let generationWasStopped = false;
let batchExtractionInProgress = false;
/**
 * Check if a batch extraction is currently in progress.
 */
function isBatchExtractionInProgress() {
    return batchExtractionInProgress;
}
/**
 * Set the batch extraction flag. Used by bt-extract-all to prevent
 * GENERATION_ENDED handler from interfering.
 */
function setBatchExtractionInProgress(value) {
    batchExtractionInProgress = value;
}
// ============================================
// Send Button State Management
// ============================================
function setSendButtonState(isGenerating) {
    const context = SillyTavern.getContext();
    if (isGenerating) {
        context.deactivateSendButtons();
    }
    else {
        context.activateSendButtons();
    }
}
// ============================================
// Abort Handling
// ============================================
function setupExtractionAbortHandler() {
    const context = SillyTavern.getContext();
    context.eventSource.on(context.event_types.GENERATION_STOPPED, (() => {
        generationWasStopped = true;
        if (currentAbortController) {
            console.warn('[BlazeTracker] Generation stopped, aborting extraction');
            currentAbortController.abort();
            currentAbortController = null;
        }
    }));
}
/**
 * Check if the last generation was stopped/aborted by the user.
 * Returns the flag value and resets it to false.
 */
function wasGenerationAborted() {
    const wasStopped = generationWasStopped;
    generationWasStopped = false;
    return wasStopped;
}
function abortCurrentExtraction() {
    if (currentAbortController) {
        currentAbortController.abort();
        currentAbortController = null;
    }
}
// ============================================
// Default Values (for when extraction is disabled)
// ============================================
function getDefaultTime() {
    return {
        year: new Date().getFullYear(),
        month: 6,
        day: 15,
        hour: 12,
        minute: 0,
        second: 0,
        dayOfWeek: 'Monday',
    };
}
function getDefaultLocation() {
    return {
        area: 'Unknown Area',
        place: 'Unknown Place',
        position: 'Main area',
        props: [],
    };
}
function _getDefaultClimate() {
    return {
        weather: 'sunny',
        temperature: 70,
    };
}
function _getDefaultCharacters() {
    return [];
}
function getDefaultScene() {
    return {
        topic: 'Scene in progress',
        tone: 'neutral',
        tension: {
            level: 'relaxed',
            direction: 'stable',
            type: 'conversation',
        },
    };
}
// ============================================
// Main Extraction Orchestrator
// ============================================
async function extractState(context, messageId, previousState, abortSignal, options = {}) {
    const settings = (0,_settings__WEBPACK_IMPORTED_MODULE_0__.getSettings)();
    if (!settings.profileId) {
        throw new Error('No connection profile selected. Please configure BlazeTracker in extension settings.');
    }
    // Create and register abort controller
    const abortController = new AbortController();
    currentAbortController = abortController;
    // Link external abort signal if provided
    if (abortSignal) {
        abortSignal.addEventListener('abort', () => abortController.abort());
    }
    // Track active extractions for button state
    extractionCount++;
    if (extractionCount === 1) {
        setSendButtonState(true);
    }
    const rawResponses = {};
    try {
        const { lastXMessages } = settings;
        const isInitial = previousState === null;
        // Determine if this is an assistant message (for scene extraction)
        const currentMessage = context.chat[messageId];
        const isAssistantMessage = currentMessage?.is_user === false;
        const shouldRunScene = settings.trackScene !== false &&
            (options.forceSceneExtraction ||
                (0,_extractScene__WEBPACK_IMPORTED_MODULE_6__.shouldExtractScene)(messageId, isAssistantMessage));
        // Determine if event extraction should run
        const shouldRunEvent = settings.trackEvents !== false && isAssistantMessage;
        // Configure enabled steps for progress display
        (0,_extractionProgress__WEBPACK_IMPORTED_MODULE_11__.setEnabledSteps)({
            time: settings.trackTime !== false,
            location: settings.trackLocation !== false,
            climate: settings.trackClimate !== false,
            characters: settings.trackCharacters !== false,
            scene: shouldRunScene,
            event: shouldRunEvent,
        });
        // ========================================
        // STEP 0: Initialize time tracker from previous state
        // ========================================
        if (previousState?.time) {
            (0,_extractTime__WEBPACK_IMPORTED_MODULE_2__.setTimeTrackerState)(previousState.time);
        }
        // ========================================
        // Get narrative state (needed for climate cache and relationships)
        // ========================================
        const narrativeState = (0,_state_narrativeState__WEBPACK_IMPORTED_MODULE_12__.getOrInitializeNarrativeState)();
        // ========================================
        // Get message window for extraction
        // ========================================
        const { formattedMessages, characterInfo, userInfo } = prepareExtractionContext(context, messageId, lastXMessages, previousState);
        // ========================================
        // STEP 1: Extract Time (if enabled)
        // ========================================
        let narrativeTime;
        if (settings.trackTime !== false) {
            (0,_extractionProgress__WEBPACK_IMPORTED_MODULE_11__.setExtractionStep)('time');
            narrativeTime = await (0,_extractTime__WEBPACK_IMPORTED_MODULE_2__.extractTime)(!isInitial, formattedMessages, abortController.signal);
        }
        else {
            // Use previous or default (undefined means not tracked)
            narrativeTime = previousState?.time;
        }
        // ========================================
        // STEP 2: Extract Location (if enabled)
        // ========================================
        let location;
        if (settings.trackLocation !== false) {
            (0,_extractionProgress__WEBPACK_IMPORTED_MODULE_11__.setExtractionStep)('location');
            location = await (0,_extractLocation__WEBPACK_IMPORTED_MODULE_3__.extractLocation)(isInitial, formattedMessages, isInitial ? characterInfo : '', previousState?.location ?? null, abortController.signal);
        }
        else {
            // Use previous or undefined
            location = previousState?.location;
        }
        // ========================================
        // STEP 3: Extract Climate (if enabled)
        // ========================================
        let climate;
        let weatherTransition = null;
        if (settings.trackClimate !== false) {
            (0,_extractionProgress__WEBPACK_IMPORTED_MODULE_11__.setExtractionStep)('climate');
            // Climate extraction needs time and location - use defaults if not available
            const timeForClimate = narrativeTime ?? getDefaultTime();
            const locationForClimate = location ?? getDefaultLocation();
            const climateResult = await (0,_extractClimate__WEBPACK_IMPORTED_MODULE_4__.extractClimateWithContext)({
                isInitial,
                messages: formattedMessages,
                narrativeTime: timeForClimate,
                location: locationForClimate,
                characterInfo: isInitial ? characterInfo : '',
                previousClimate: previousState?.climate ?? null,
                forecastCache: narrativeState.forecastCache,
                locationMappings: narrativeState.locationMappings,
                abortSignal: abortController.signal,
            });
            climate = climateResult.climate;
            weatherTransition = climateResult.transition;
            // Update narrative state caches if they changed
            if (climateResult.forecastCache) {
                narrativeState.forecastCache = climateResult.forecastCache;
            }
            if (climateResult.locationMappings) {
                narrativeState.locationMappings = climateResult.locationMappings;
            }
        }
        else {
            // Use previous or undefined
            climate = previousState?.climate;
        }
        // ========================================
        // STEP 4: Extract Characters (if enabled)
        // ========================================
        let characters;
        if (settings.trackCharacters !== false) {
            (0,_extractionProgress__WEBPACK_IMPORTED_MODULE_11__.setExtractionStep)('characters');
            // Characters extraction uses location - use default if not available
            const locationForCharacters = location ?? getDefaultLocation();
            characters = await (0,_extractCharacters__WEBPACK_IMPORTED_MODULE_5__.extractCharacters)(isInitial, formattedMessages, locationForCharacters, isInitial ? userInfo : '', isInitial ? characterInfo : '', previousState?.characters ?? null, abortController.signal);
            // ========================================
            // STEP 4.5: Post-process outfits (only if we have location)
            // ========================================
            if (location) {
                const cleanup = cleanupOutfitsAndMoveProps(characters, location);
                characters = cleanup.characters;
                location = cleanup.location;
            }
        }
        else {
            // Use previous or undefined
            characters = previousState?.characters;
        }
        // ========================================
        // STEP 5: Extract Scene (conditional)
        // ========================================
        let scene;
        if (shouldRunScene) {
            (0,_extractionProgress__WEBPACK_IMPORTED_MODULE_11__.setExtractionStep)('scene');
            // Scene needs at least 2 messages for tension analysis
            const sceneMessages = formatMessagesForScene(context, messageId, lastXMessages, previousState);
            const isInitialScene = !previousState?.scene;
            // Use characters for context if available, otherwise empty
            const charactersForScene = characters ?? [];
            scene = await (0,_extractScene__WEBPACK_IMPORTED_MODULE_6__.extractScene)(isInitialScene, sceneMessages, charactersForScene, isInitialScene ? userInfo : '', isInitialScene ? characterInfo : '', previousState?.scene ?? null, abortController.signal);
        }
        else if (settings.trackScene !== false) {
            // Carry forward previous scene
            scene = previousState?.scene;
        }
        // ========================================
        // STEP 6: Extract Event (conditional)
        // ========================================
        // Filter out any events from this messageId (handles re-extraction)
        let currentEvents = (previousState?.currentEvents ?? []).filter(e => e.messageId !== messageId);
        if (shouldRunEvent) {
            (0,_extractionProgress__WEBPACK_IMPORTED_MODULE_11__.setExtractionStep)('event');
            // Use effective values for event extraction
            const timeForEvent = narrativeTime ?? getDefaultTime();
            const locationForEvent = location ?? getDefaultLocation();
            const sceneForEvent = scene ?? getDefaultScene();
            const extractedEvent = await (0,_extractEvent__WEBPACK_IMPORTED_MODULE_7__.extractEvent)({
                messages: formattedMessages,
                messageId,
                currentTime: timeForEvent,
                currentLocation: locationForEvent,
                currentTensionType: sceneForEvent.tension.type,
                currentTensionLevel: sceneForEvent.tension.level,
                relationships: narrativeState.relationships,
                characters: characters ?? [],
                abortSignal: abortController.signal,
            });
            if (extractedEvent) {
                // Append the new event with messageId for re-extraction tracking
                const eventWithId = {
                    ...extractedEvent,
                    messageId,
                };
                currentEvents = [...currentEvents, eventWithId];
                // Apply relationship signal if present
                if (extractedEvent.relationshipSignal &&
                    settings.trackRelationships !== false) {
                    const signal = extractedEvent.relationshipSignal;
                    const [char1, char2] = signal.pair;
                    let relationship = (0,_state_narrativeState__WEBPACK_IMPORTED_MODULE_12__.getRelationship)(narrativeState, char1, char2);
                    if (relationship) {
                        // Pop version if re-extracting this message (swipe/re-extract)
                        (0,_state_relationships__WEBPACK_IMPORTED_MODULE_14__.popVersionForMessage)(relationship, messageId);
                        // Check if signal has milestones - if so, do a full LLM refresh
                        const hasMilestones = signal.milestones &&
                            signal.milestones.length > 0;
                        if (hasMilestones) {
                            const relationshipMessages = formatMessagesForRelationship(context, messageId, lastXMessages, relationship);
                            const refreshed = await (0,_extractRelationships__WEBPACK_IMPORTED_MODULE_9__.refreshRelationship)({
                                relationship,
                                events: currentEvents,
                                messages: relationshipMessages,
                                messageId,
                                abortSignal: abortController.signal,
                            });
                            if (refreshed) {
                                // Apply milestones from signal (LLM might not include them)
                                relationship =
                                    (0,_extractRelationships__WEBPACK_IMPORTED_MODULE_9__.updateRelationshipFromSignal)(refreshed, signal);
                            }
                            else {
                                // Fallback to simple update if refresh fails
                                relationship =
                                    (0,_extractRelationships__WEBPACK_IMPORTED_MODULE_9__.updateRelationshipFromSignal)(relationship, signal);
                            }
                        }
                        else {
                            // Simple update for non-milestone signals
                            relationship = (0,_extractRelationships__WEBPACK_IMPORTED_MODULE_9__.updateRelationshipFromSignal)(relationship, signal);
                        }
                        (0,_state_narrativeState__WEBPACK_IMPORTED_MODULE_12__.updateRelationship)(narrativeState, relationship);
                    }
                    else {
                        // Need to initialize this relationship first
                        const relationshipMessages = formatMessagesForRelationship(context, messageId, lastXMessages, undefined);
                        const newRelationship = await (0,_extractRelationships__WEBPACK_IMPORTED_MODULE_9__.extractInitialRelationship)({
                            char1,
                            char2,
                            messages: relationshipMessages,
                            characterInfo: isInitial
                                ? characterInfo
                                : '',
                            messageId,
                            currentTime: narrativeTime,
                            currentLocation: location,
                            abortSignal: abortController.signal,
                        });
                        if (newRelationship) {
                            // Apply the signal to the new relationship
                            const withSignal = (0,_extractRelationships__WEBPACK_IMPORTED_MODULE_9__.updateRelationshipFromSignal)(newRelationship, signal);
                            (0,_state_narrativeState__WEBPACK_IMPORTED_MODULE_12__.updateRelationship)(narrativeState, withSignal);
                        }
                    }
                }
            }
        }
        // ========================================
        // STEP 6.3: Initialize Missing Relationships
        // ========================================
        // Check if there are character pairs that don't have relationships yet
        if (settings.trackRelationships !== false && characters && characters.length >= 2) {
            const characterNames = characters.map(c => c.name);
            const unestablishedPairs = (0,_state_relationships__WEBPACK_IMPORTED_MODULE_14__.findUnestablishedPairs)(characterNames, narrativeState.relationships);
            // Limit to initializing one relationship per extraction to avoid slowdown
            if (unestablishedPairs.length > 0) {
                const [char1, char2] = unestablishedPairs[0];
                const relationshipMessages = formatMessagesForRelationship(context, messageId, lastXMessages, undefined);
                const newRelationship = await (0,_extractRelationships__WEBPACK_IMPORTED_MODULE_9__.extractInitialRelationship)({
                    char1,
                    char2,
                    messages: relationshipMessages,
                    characterInfo: isInitial ? characterInfo : '',
                    messageId,
                    currentTime: narrativeTime,
                    currentLocation: location,
                    abortSignal: abortController.signal,
                });
                if (newRelationship) {
                    (0,_state_narrativeState__WEBPACK_IMPORTED_MODULE_12__.updateRelationship)(narrativeState, newRelationship);
                }
            }
        }
        // ========================================
        // STEP 6.5: Check Chapter Boundary
        // ========================================
        let currentChapter = previousState?.currentChapter ?? 0;
        let chapterEnded = undefined;
        // Only check for chapter boundary if we have a previous state (not initial extraction)
        if (previousState && currentEvents.length > 0) {
            const boundaryCheck = (0,_state_chapters__WEBPACK_IMPORTED_MODULE_13__.checkChapterBoundary)(previousState.location, location, previousState.time, narrativeTime);
            if (boundaryCheck.triggered) {
                // Get the time range from events
                const startTime = currentEvents[0]?.timestamp ??
                    previousState.time ??
                    getDefaultTime();
                const endTime = narrativeTime ?? getDefaultTime();
                const primaryLocation = previousState.location
                    ? `${previousState.location.area} - ${previousState.location.place}`
                    : 'Unknown';
                // Extract chapter summary via LLM
                const chapterResult = await (0,_extractChapter__WEBPACK_IMPORTED_MODULE_8__.extractChapterBoundary)({
                    events: currentEvents,
                    narrativeState,
                    chapterIndex: currentChapter,
                    startTime,
                    endTime,
                    primaryLocation,
                    abortSignal: abortController.signal,
                });
                if (chapterResult.isChapterBoundary && chapterResult.chapter) {
                    // Store chapter ended summary for display
                    chapterEnded = {
                        index: currentChapter,
                        title: chapterResult.chapter.title,
                        summary: chapterResult.chapter.summary,
                        eventCount: currentEvents.length,
                        reason: boundaryCheck.reason,
                    };
                    // Add chapter to narrative state
                    (0,_state_narrativeState__WEBPACK_IMPORTED_MODULE_12__.addChapter)(narrativeState, chapterResult.chapter);
                    await (0,_state_narrativeState__WEBPACK_IMPORTED_MODULE_12__.saveNarrativeState)(narrativeState);
                    // Increment chapter counter and clear current events
                    currentChapter++;
                    currentEvents = [];
                }
            }
        }
        // ========================================
        // STEP 7: Assemble Final State
        // ========================================
        (0,_extractionProgress__WEBPACK_IMPORTED_MODULE_11__.setExtractionStep)('complete');
        const state = {
            time: narrativeTime,
            location,
            climate,
            scene,
            characters,
            currentChapter,
            currentEvents: currentEvents.length > 0 ? currentEvents : undefined,
            chapterEnded,
        };
        return {
            state,
            raw: rawResponses,
            weatherTransition: weatherTransition ?? undefined,
        };
    }
    finally {
        extractionCount--;
        if (extractionCount === 0) {
            setSendButtonState(false);
            (0,_extractionProgress__WEBPACK_IMPORTED_MODULE_11__.setExtractionStep)('idle');
        }
        if (currentAbortController === abortController) {
            currentAbortController = null;
        }
    }
}
// ============================================
// Re-extraction Event Cleanup
// ============================================
/**
 * Update subsequent messages after re-extracting a message.
 * Removes old events from the re-extracted messageId and optionally adds the new event.
 */
function updateSubsequentMessagesEvents(context, reExtractedMessageId, newEvent) {
    // Iterate through all messages after the re-extracted one
    for (let i = reExtractedMessageId + 1; i < context.chat.length; i++) {
        const message = context.chat[i];
        const stateData = (0,_utils_messageState__WEBPACK_IMPORTED_MODULE_1__.getMessageState)(message);
        if (!stateData?.state?.currentEvents) {
            continue;
        }
        // Filter out events from the re-extracted messageId
        const filteredEvents = stateData.state.currentEvents.filter((e) => e.messageId !== reExtractedMessageId);
        // If we have a new event and it should be included (before any chapter boundary that cleared events)
        // Add it to the filtered list if this message's events include events after the new one
        let updatedEvents = filteredEvents;
        if (newEvent) {
            // Insert the new event at the right position (by messageId order)
            const insertIndex = filteredEvents.findIndex((e) => (e.messageId ?? 0) > reExtractedMessageId);
            if (insertIndex === -1) {
                // No events after this one, append
                updatedEvents = [...filteredEvents, newEvent];
            }
            else {
                // Insert before events from later messages
                updatedEvents = [
                    ...filteredEvents.slice(0, insertIndex),
                    newEvent,
                    ...filteredEvents.slice(insertIndex),
                ];
            }
        }
        // Update the message state
        const newStateData = {
            ...stateData,
            state: {
                ...stateData.state,
                currentEvents: updatedEvents.length > 0 ? updatedEvents : undefined,
            },
        };
        (0,_utils_messageState__WEBPACK_IMPORTED_MODULE_1__.setMessageState)(message, newStateData);
    }
}
/**
 * Format messages for scene extraction with a minimum of 2 messages.
 * This ensures we have both sides of the conversation for tension analysis.
 */
function formatMessagesForScene(context, messageId, lastXMessages, previousState) {
    const MIN_SCENE_MESSAGES = 2;
    // Find where previous state was stored
    let stateIdx = -1;
    if (previousState) {
        for (let i = messageId - 1; i >= 0; i--) {
            const msg = context.chat[i];
            const stored = (0,_utils_messageState__WEBPACK_IMPORTED_MODULE_1__.getMessageState)(msg);
            if (stored?.state) {
                stateIdx = i;
                break;
            }
        }
    }
    // Calculate start: we want at least MIN_SCENE_MESSAGES, but also respect lastXMessages
    // and include all messages since last state
    const minStart = Math.max(0, messageId - MIN_SCENE_MESSAGES + 1);
    const stateStart = stateIdx >= 0 ? stateIdx + 1 : 0;
    const limitStart = messageId - lastXMessages;
    // Take the earliest of: minimum messages needed, or messages since state
    // But don't go earlier than lastXMessages limit
    const effectiveStart = Math.max(limitStart, Math.min(minStart, stateStart));
    const chatMessages = context.chat.slice(effectiveStart, messageId + 1);
    return chatMessages.map(msg => `${msg.name}: ${msg.mes}`).join('\n\n');
}
function prepareExtractionContext(context, messageId, lastXMessages, previousState) {
    // Find where to start reading messages
    let startIdx = 0;
    if (previousState) {
        for (let i = messageId - 1; i >= 0; i--) {
            const msg = context.chat[i];
            const stored = (0,_utils_messageState__WEBPACK_IMPORTED_MODULE_1__.getMessageState)(msg);
            if (stored?.state) {
                startIdx = i + 1; // Start from message AFTER the one with state
                break;
            }
        }
    }
    // Get only new messages (but respect lastXMessages limit)
    const effectiveStart = Math.max(startIdx, messageId - lastXMessages);
    const chatMessages = context.chat.slice(effectiveStart, messageId + 1);
    // Format messages for prompts
    const formattedMessages = chatMessages.map(msg => `${msg.name}: ${msg.mes}`).join('\n\n');
    // Get user persona info
    const userPersona = context.powerUserSettings?.persona_description || '';
    const userInfo = userPersona
        ? `Name: ${context.name1}\nDescription: ${userPersona
            .replace(/\{\{user\}\}/gi, context.name1)
            .replace(/\{\{char\}\}/gi, context.name2)}`
        : `Name: ${context.name1}`;
    // Get character info
    const character = context.characters?.[context.characterId];
    const charDescription = (character?.description || 'No description')
        .replace(/\{\{char\}\}/gi, context.name2)
        .replace(/\{\{user\}\}/gi, context.name1);
    const characterInfo = `Name: ${context.name2}\nDescription: ${charDescription}`;
    return { formattedMessages, characterInfo, userInfo };
}
/**
 * Format messages for relationship extraction.
 * Uses messages since the last status change (or lastXMessages, whichever is smaller).
 * Ensures a minimum of MIN_RELATIONSHIP_MESSAGES for context.
 */
function formatMessagesForRelationship(context, messageId, lastXMessages, relationship) {
    const MIN_RELATIONSHIP_MESSAGES = 3;
    // Calculate the start based on last version's messageId
    let statusChangeStart = 0;
    const lastVersionMessageId = relationship
        ? (0,_state_relationships__WEBPACK_IMPORTED_MODULE_14__.getLatestVersionMessageId)(relationship)
        : undefined;
    if (lastVersionMessageId !== undefined) {
        // Start from the message after the last status change
        statusChangeStart = lastVersionMessageId + 1;
    }
    // Calculate start: take minimum of (messages since status change, lastXMessages)
    // But ensure we have at least MIN_RELATIONSHIP_MESSAGES
    const minStart = Math.max(0, messageId - MIN_RELATIONSHIP_MESSAGES + 1);
    const limitStart = Math.max(0, messageId - lastXMessages);
    // Take the later of: limit start or status change start
    // This ensures we don't exceed lastXMessages
    const constrainedStart = Math.max(limitStart, statusChangeStart);
    // But ensure we have at least MIN_RELATIONSHIP_MESSAGES
    const effectiveStart = Math.min(constrainedStart, minStart);
    const chatMessages = context.chat.slice(effectiveStart, messageId + 1);
    return chatMessages.map(msg => `${msg.name}: ${msg.mes}`).join('\n\n');
}
// ============================================
// Outfit Cleanup Post-Processing
// ============================================
/**
 * Regex patterns that indicate an item has been removed.
 * Captures the item name in group 1.
 */
const REMOVED_PATTERNS = [
    /^(.+?)\s*\((?:removed|off|taken off|discarded|dropped|on (?:the )?floor|on (?:the )?ground|cast aside|tossed aside)\)$/i,
    /^(.+?)\s*-\s*(?:removed|off|taken off)$/i,
    /^(?:removed|off|none|nothing|bare|naked)$/i,
];
/**
 * Values that should be treated as null (no item).
 */
const NULL_VALUES = new Set(['none', 'nothing', 'bare', 'naked', 'n/a', 'na', '-', '']);
/**
 * Post-process characters to fix outfit items that the LLM marked as removed
 * but didn't set to null. Moves removed items to location props if not already there.
 */
function cleanupOutfitsAndMoveProps(characters, location) {
    const movedItems = [];
    const existingProps = new Set((location.props || []).map(p => p.toLowerCase()));
    const processedCharacters = characters.map(char => {
        if (!char.outfit)
            return char;
        const newOutfit = { ...char.outfit };
        const outfitSlots = [
            'head',
            'neck',
            'jacket',
            'back',
            'torso',
            'legs',
            'underwear',
            'socks',
            'footwear',
        ];
        for (const slot of outfitSlots) {
            const value = newOutfit[slot];
            if (value === null || value === undefined)
                continue;
            const trimmed = value.trim();
            // Check for explicit null values
            if (NULL_VALUES.has(trimmed.toLowerCase())) {
                newOutfit[slot] = null;
                continue;
            }
            // Check for removal patterns
            for (const pattern of REMOVED_PATTERNS) {
                const match = trimmed.match(pattern);
                if (match) {
                    // Extract the item name (group 1, or the whole thing if no group)
                    const itemName = match[1]?.trim() || trimmed;
                    // Set to null
                    newOutfit[slot] = null;
                    // Add to props if we have a real item name and it's not already there
                    if (itemName && !NULL_VALUES.has(itemName.toLowerCase())) {
                        if (!(0,_utils_clothingMatch__WEBPACK_IMPORTED_MODULE_10__.propAlreadyExists)(itemName, char.name, existingProps)) {
                            const propEntry = `${char.name}'s ${itemName}`;
                            movedItems.push(propEntry);
                            existingProps.add(propEntry.toLowerCase());
                        }
                    }
                    break;
                }
            }
        }
        return { ...char, outfit: newOutfit };
    });
    // Build new props array if we added items
    const newProps = movedItems.length > 0 ? [...(location.props || []), ...movedItems] : location.props;
    return {
        characters: processedCharacters,
        location: { ...location, props: newProps },
        movedItems,
    };
}


/***/ },

/***/ "./src/extractors/extractTime.ts"
/*!***************************************!*\
  !*** ./src/extractors/extractTime.ts ***!
  \***************************************/
(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   extractDateTime: () => (/* binding */ extractDateTime),
/* harmony export */   extractTime: () => (/* binding */ extractTime),
/* harmony export */   getCurrentDateTime: () => (/* binding */ getCurrentDateTime),
/* harmony export */   isTimeTrackerInitialized: () => (/* binding */ isTimeTrackerInitialized),
/* harmony export */   resetTimeTracker: () => (/* binding */ resetTimeTracker),
/* harmony export */   setTimeTrackerState: () => (/* binding */ setTimeTrackerState)
/* harmony export */ });
/* harmony import */ var _settings__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../settings */ "./src/settings.ts");
/* harmony import */ var _prompts__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./prompts */ "./src/extractors/prompts.ts");
/* harmony import */ var _utils_generator__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../utils/generator */ "./src/utils/generator.ts");
/* harmony import */ var _utils_json__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../utils/json */ "./src/utils/json.ts");




// ============================================
// Schemas & Examples
// ============================================
const DATETIME_SCHEMA = {
    type: 'object',
    properties: {
        year: {
            type: 'number',
            description: 'Four digit year, e.g. 2024. Infer from context or use a reasonable default.',
        },
        month: {
            type: 'number',
            description: 'Month 1-12. Infer from seasonal context, weather, or use a reasonable default.',
        },
        day: {
            type: 'number',
            description: 'Day of month 1-31. Infer if possible or use a reasonable default.',
        },
        hour: { type: 'number', description: 'Hour 0-23 in 24-hour format.' },
        minute: { type: 'number', description: 'Minute 0-59.' },
        second: {
            type: 'number',
            description: 'Second 0-59. Usually 0 unless specifically mentioned.',
        },
    },
    required: ['year', 'month', 'day', 'hour', 'minute', 'second'],
};
const DATETIME_EXAMPLE = JSON.stringify({
    year: 2024,
    month: 6,
    day: 15,
    hour: 14,
    minute: 30,
    second: 0,
}, null, 2);
const DELTA_SCHEMA = {
    type: 'object',
    properties: {
        hours: { type: 'number', description: 'Hours passed. 0 if less than an hour.' },
        minutes: { type: 'number', description: 'Minutes passed (0-59). Added to hours.' },
        seconds: {
            type: 'number',
            description: 'Seconds passed (0-59). Usually 0 unless specifically mentioned.',
        },
    },
    required: ['hours', 'minutes', 'seconds'],
};
const DELTA_EXAMPLE = JSON.stringify({
    hours: 0,
    minutes: 2,
    seconds: 30,
}, null, 2);
// ============================================
// Constants
// ============================================
const SYSTEM_PROMPT = 'You are a time analysis agent. Return only valid JSON.';
const DAYS_OF_WEEK = ['Sunday', 'Monday', 'Tuesday', 'Wednesday', 'Thursday', 'Friday', 'Saturday'];
// ============================================
// Time Tracker State (module-level singleton)
// ============================================
const timeTracker = {
    currentDate: new Date(),
    lastDeltaSeconds: 0,
    initialized: false,
};
// ============================================
// Public API
// ============================================
/**
 * Extract time for a message. Handles both initial datetime extraction
 * and delta extraction based on whether there's previous state.
 */
async function extractTime(hasPreviousState, messages, abortSignal) {
    const settings = (0,_settings__WEBPACK_IMPORTED_MODULE_0__.getSettings)();
    if (!hasPreviousState) {
        const extracted = await extractDateTime(messages, settings.profileId, abortSignal);
        initializeTracker(extracted);
    }
    else {
        const delta = await extractTimeDelta(messages, settings.profileId, abortSignal);
        applyDelta(delta, settings.leapThresholdMinutes ?? 20);
    }
    return getCurrentDateTime();
}
/**
 * Get the current narrative datetime without extraction.
 */
function getCurrentDateTime() {
    return dateToNarrative(timeTracker.currentDate);
}
/**
 * Check if the time tracker has been initialized.
 */
function isTimeTrackerInitialized() {
    return timeTracker.initialized;
}
/**
 * Reset the time tracker (e.g., when switching chats).
 */
function resetTimeTracker() {
    timeTracker.currentDate = new Date();
    timeTracker.lastDeltaSeconds = 0;
    timeTracker.initialized = false;
}
/**
 * Manually set the tracker state (e.g., when loading from saved state).
 */
function setTimeTrackerState(datetime) {
    timeTracker.currentDate = narrativeToDate(datetime);
    timeTracker.lastDeltaSeconds = 0;
    timeTracker.initialized = true;
}
// ============================================
// Internal: Extraction Functions
// ============================================
async function extractDateTime(message, profileId, abortSignal) {
    const settings = (0,_settings__WEBPACK_IMPORTED_MODULE_0__.getSettings)();
    const prompt = (0,_prompts__WEBPACK_IMPORTED_MODULE_1__.getPrompt)('time_datetime')
        .replace('{{messages}}', message)
        .replace('{{schema}}', JSON.stringify(DATETIME_SCHEMA, null, 2))
        .replace('{{schemaExample}}', DATETIME_EXAMPLE);
    const llmMessages = (0,_utils_generator__WEBPACK_IMPORTED_MODULE_2__.buildExtractionMessages)(SYSTEM_PROMPT, prompt);
    const response = await (0,_utils_generator__WEBPACK_IMPORTED_MODULE_2__.makeGeneratorRequest)(llmMessages, {
        profileId,
        maxTokens: settings.maxResponseTokens,
        temperature: (0,_settings__WEBPACK_IMPORTED_MODULE_0__.getTemperature)('time_datetime'),
        abortSignal,
    });
    const parsed = (0,_utils_json__WEBPACK_IMPORTED_MODULE_3__.parseJsonResponse)(response, {
        shape: 'object',
        moduleName: 'BlazeTracker/Time',
    });
    return validateDateTime(parsed);
}
async function extractTimeDelta(message, profileId, abortSignal) {
    const currentTimeStr = formatTimeForPrompt(timeTracker.currentDate);
    const settings = (0,_settings__WEBPACK_IMPORTED_MODULE_0__.getSettings)();
    const prompt = (0,_prompts__WEBPACK_IMPORTED_MODULE_1__.getPrompt)('time_delta')
        .replace('{{messages}}', message)
        .replace('{{currentTime}}', currentTimeStr)
        .replace('{{schema}}', JSON.stringify(DELTA_SCHEMA, null, 2))
        .replace('{{schemaExample}}', DELTA_EXAMPLE);
    const llmMessages = (0,_utils_generator__WEBPACK_IMPORTED_MODULE_2__.buildExtractionMessages)(SYSTEM_PROMPT, prompt);
    const response = await (0,_utils_generator__WEBPACK_IMPORTED_MODULE_2__.makeGeneratorRequest)(llmMessages, {
        profileId,
        maxTokens: settings.maxResponseTokens,
        temperature: (0,_settings__WEBPACK_IMPORTED_MODULE_0__.getTemperature)('time_delta'),
        abortSignal,
    });
    const parsed = (0,_utils_json__WEBPACK_IMPORTED_MODULE_3__.parseJsonResponse)(response, {
        shape: 'object',
        moduleName: 'BlazeTracker/Time',
    });
    return validateDelta(parsed);
}
// ============================================
// Internal: Time Tracker Operations
// ============================================
function initializeTracker(datetime) {
    timeTracker.currentDate = narrativeToDate(datetime);
    timeTracker.lastDeltaSeconds = 0;
    timeTracker.initialized = true;
}
function applyDelta(delta, leapThresholdMinutes) {
    const deltaSeconds = delta.hours * 3600 + delta.minutes * 60 + delta.seconds;
    const thresholdSeconds = leapThresholdMinutes * 60;
    // Consecutive leap detection
    const isLeap = deltaSeconds > thresholdSeconds;
    const wasLeap = timeTracker.lastDeltaSeconds > thresholdSeconds;
    const cappedSeconds = isLeap && wasLeap ? thresholdSeconds : deltaSeconds;
    // Apply to Date object - handles all edge cases (month overflow, leap years, etc.)
    timeTracker.currentDate = new Date(timeTracker.currentDate.getTime() + cappedSeconds * 1000);
    // Store the raw delta (not capped) for next comparison
    timeTracker.lastDeltaSeconds = deltaSeconds;
}
// ============================================
// Internal: Conversion Utilities
// ============================================
function dateToNarrative(date) {
    return {
        year: date.getFullYear(),
        month: date.getMonth() + 1, // JS months are 0-indexed
        day: date.getDate(),
        hour: date.getHours(),
        minute: date.getMinutes(),
        second: date.getSeconds(),
        dayOfWeek: DAYS_OF_WEEK[date.getDay()],
    };
}
function narrativeToDate(narrative) {
    return new Date(narrative.year, narrative.month - 1, // JS months are 0-indexed
    narrative.day, narrative.hour, narrative.minute, narrative.second);
}
function formatTimeForPrompt(date) {
    const narrative = dateToNarrative(date);
    const monthNames = [
        'January',
        'February',
        'March',
        'April',
        'May',
        'June',
        'July',
        'August',
        'September',
        'October',
        'November',
        'December',
    ];
    const hour12 = narrative.hour % 12 || 12;
    const ampm = narrative.hour < 12 ? 'AM' : 'PM';
    const minuteStr = String(narrative.minute).padStart(2, '0');
    return `${narrative.dayOfWeek}, ${monthNames[narrative.month - 1]} ${narrative.day}, ${narrative.year} at ${hour12}:${minuteStr} ${ampm}`;
}
// ============================================
// Validation
// ============================================
function validateDateTime(data) {
    if (typeof data !== 'object' || data === null) {
        throw new Error('Invalid datetime: expected object');
    }
    const obj = data;
    // Parse and clamp year/month first
    const year = (0,_utils_json__WEBPACK_IMPORTED_MODULE_3__.asNumber)(obj.year, new Date().getFullYear());
    const month = clamp((0,_utils_json__WEBPACK_IMPORTED_MODULE_3__.asNumber)(obj.month, 6), 1, 12);
    // Clamp day to valid range for this month (handles Feb 30 -> Feb 28/29, etc.)
    const maxDay = getDaysInMonth(year, month);
    const day = clamp((0,_utils_json__WEBPACK_IMPORTED_MODULE_3__.asNumber)(obj.day, 15), 1, maxDay);
    const result = {
        year: clamp(year, 1, 9999),
        month,
        day,
        hour: clamp((0,_utils_json__WEBPACK_IMPORTED_MODULE_3__.asNumber)(obj.hour, 12), 0, 23),
        minute: clamp((0,_utils_json__WEBPACK_IMPORTED_MODULE_3__.asNumber)(obj.minute, 0), 0, 59),
        second: clamp((0,_utils_json__WEBPACK_IMPORTED_MODULE_3__.asNumber)(obj.second, 0), 0, 59),
        dayOfWeek: '', // Will be calculated
    };
    // Get correct day of week from Date object
    const dateObj = narrativeToDate(result);
    result.dayOfWeek = DAYS_OF_WEEK[dateObj.getDay()];
    return result;
}
function getDaysInMonth(year, month) {
    // Day 0 of next month = last day of this month
    return new Date(year, month, 0).getDate();
}
function validateDelta(data) {
    if (typeof data !== 'object' || data === null) {
        return { hours: 0, minutes: 0, seconds: 0 };
    }
    const obj = data;
    return {
        hours: Math.max(0, Math.floor((0,_utils_json__WEBPACK_IMPORTED_MODULE_3__.asNumber)(obj.hours, 0))),
        minutes: clamp(Math.floor((0,_utils_json__WEBPACK_IMPORTED_MODULE_3__.asNumber)(obj.minutes, 0)), 0, 59),
        seconds: clamp(Math.floor((0,_utils_json__WEBPACK_IMPORTED_MODULE_3__.asNumber)(obj.seconds, 0)), 0, 59),
    };
}
function clamp(value, min, max) {
    return Math.max(min, Math.min(max, value));
}


/***/ },

/***/ "./src/extractors/extractionProgress.ts"
/*!**********************************************!*\
  !*** ./src/extractors/extractionProgress.ts ***!
  \**********************************************/
(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   getEnabledSteps: () => (/* binding */ getEnabledSteps),
/* harmony export */   getExtractionStep: () => (/* binding */ getExtractionStep),
/* harmony export */   getStepLabel: () => (/* binding */ getStepLabel),
/* harmony export */   onExtractionProgress: () => (/* binding */ onExtractionProgress),
/* harmony export */   setEnabledSteps: () => (/* binding */ setEnabledSteps),
/* harmony export */   setExtractionStep: () => (/* binding */ setExtractionStep)
/* harmony export */ });
// ============================================
// Extraction Progress Tracking
// ============================================
// ============================================
// Module State
// ============================================
let currentStep = 'idle';
let progressCallback = null;
// Default: all steps enabled
let enabledSteps = {
    time: true,
    location: true,
    climate: true,
    characters: true,
    scene: true,
    event: true,
};
// All possible extraction steps (in order)
const ALL_EXTRACTION_STEPS = [
    'time',
    'location',
    'climate',
    'characters',
    'scene',
    'event',
];
// ============================================
// Public API
// ============================================
/**
 * Register a callback to receive progress updates.
 */
function onExtractionProgress(callback) {
    progressCallback = callback;
}
/**
 * Configure which extraction steps are enabled for the current extraction.
 * Call this before starting extraction to ensure progress shows correct totals.
 */
function setEnabledSteps(steps) {
    enabledSteps = { ...steps };
}
/**
 * Get the list of currently enabled extraction steps.
 */
function getEnabledSteps() {
    return ALL_EXTRACTION_STEPS.filter(step => enabledSteps[step]);
}
/**
 * Set the current extraction step and notify listeners.
 */
function setExtractionStep(step) {
    currentStep = step;
    if (progressCallback) {
        const activeSteps = getEnabledSteps();
        const stepIndex = step === 'idle'
            ? 0
            : step === 'complete'
                ? activeSteps.length
                : activeSteps.indexOf(step);
        progressCallback({
            step,
            stepIndex: Math.max(0, stepIndex),
            totalSteps: activeSteps.length,
        });
    }
}
/**
 * Get the current extraction step.
 */
function getExtractionStep() {
    return currentStep;
}
/**
 * Get a human-readable label for a step.
 */
function getStepLabel(step) {
    switch (step) {
        case 'idle':
            return 'Ready';
        case 'time':
            return 'Extracting time...';
        case 'location':
            return 'Extracting location...';
        case 'climate':
            return 'Extracting climate...';
        case 'characters':
            return 'Extracting characters...';
        case 'scene':
            return 'Extracting scene...';
        case 'event':
            return 'Extracting events...';
        case 'complete':
            return 'Complete';
    }
}


/***/ },

/***/ "./src/extractors/prompts.ts"
/*!***********************************!*\
  !*** ./src/extractors/prompts.ts ***!
  \***********************************/
(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   DEFAULT_PROMPTS: () => (/* binding */ DEFAULT_PROMPTS),
/* harmony export */   getAllPromptDefinitions: () => (/* binding */ getAllPromptDefinitions),
/* harmony export */   getPlaceholderDocs: () => (/* binding */ getPlaceholderDocs),
/* harmony export */   getPrompt: () => (/* binding */ getPrompt),
/* harmony export */   getPromptDefinition: () => (/* binding */ getPromptDefinition),
/* harmony export */   isPromptCustomized: () => (/* binding */ isPromptCustomized)
/* harmony export */ });
/* harmony import */ var _settings__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../settings */ "./src/settings.ts");
// ============================================
// Prompt Configuration System
// ============================================
// Adjust this import path based on your project structure:

// ============================================
// Placeholder Documentation
// ============================================
const COMMON_PLACEHOLDERS = {
    messages: {
        name: '{{messages}}',
        description: 'Recent roleplay messages formatted as "Name: message content"',
        example: 'Elena: *She walked into the bar*\n\nMarcus: "You made it."',
    },
    characterInfo: {
        name: '{{characterInfo}}',
        description: 'Character name and description (only on initial extraction)',
        example: 'Name: Elena\nDescription: A cunning thief with a heart of gold...',
    },
    userInfo: {
        name: '{{userInfo}}',
        description: 'User persona name and description (only on initial extraction)',
        example: 'Name: Marcus\nDescription: A grizzled detective...',
    },
    previousState: {
        name: '{{previousState}}',
        description: 'JSON of the previous state for this extractor',
        example: '{ "area": "Downtown", "place": "Bar", ... }',
    },
    schema: {
        name: '{{schema}}',
        description: 'JSON schema defining the expected output format',
        example: '{ "type": "object", "properties": { ... } }',
    },
    schemaExample: {
        name: '{{schemaExample}}',
        description: 'Example output matching the schema',
        example: '{ "area": "Downtown Seattle", ... }',
    },
    narrativeTime: {
        name: '{{narrativeTime}}',
        description: 'Current narrative time as formatted string',
        example: 'Monday, June 15, 2024 at 2:30 PM',
    },
    location: {
        name: '{{location}}',
        description: 'Current location summary',
        example: 'Downtown Seattle - The Rusty Nail bar (Corner booth)',
    },
    currentTime: {
        name: '{{currentTime}}',
        description: 'Current narrative time for context',
        example: 'Monday, June 15, 2024 at 2:30 PM',
    },
    charactersSummary: {
        name: '{{charactersSummary}}',
        description: 'Brief summary of characters present with moods/activities',
        example: 'Elena: anxious, hopeful - Watching the door\nMarcus: scheming - Drinking wine',
    },
    currentRelationships: {
        name: '{{currentRelationships}}',
        description: 'Current relationship states between characters',
        example: 'Elena & Marcus (complicated): Elena feels trusting, hopeful; Marcus feels suspicious, curious',
    },
    currentEvents: {
        name: '{{currentEvents}}',
        description: 'Recent events in the current chapter',
        example: '- Marcus revealed his true identity\n- Elena agreed to help with the heist',
    },
    chapterSummaries: {
        name: '{{chapterSummaries}}',
        description: 'Summaries of previous chapters',
        example: 'Chapter 1: Elena and Marcus meet at the bar...',
    },
    milestoneType: {
        name: '{{milestoneType}}',
        description: 'The type of milestone to describe (e.g., first_kiss, first_embrace)',
        example: 'first_kiss',
    },
    characterPair: {
        name: '{{characterPair}}',
        description: 'The two characters involved in the milestone',
        example: 'Elena and Marcus',
    },
    timeOfDay: {
        name: '{{timeOfDay}}',
        description: 'The time of day when the milestone occurred',
        example: 'evening',
    },
    props: {
        name: '{{props}}',
        description: 'Nearby objects/props in the scene',
        example: 'worn leather couch, coffee table, dim lamp',
    },
    characters: {
        name: '{{characters}}',
        description: 'Character positions, moods, and attire',
        example: 'Elena: Position: sitting on couch | Mood: nervous, hopeful | Wearing: torso: blue dress',
    },
    relationship: {
        name: '{{relationship}}',
        description: 'Current relationship status and feelings between characters',
        example: 'Elena & Marcus (close): Elena feels: trusting, attracted | Marcus feels: protective, conflicted',
    },
    eventDetail: {
        name: '{{eventDetail}}',
        description: 'Specific detail about what happened (e.g., what secret was shared)',
        example: "Elena's past as a thief",
    },
};
// ============================================
// Default Prompts
// ============================================
const DEFAULT_PROMPTS = {
    time_datetime: {
        key: 'time_datetime',
        name: 'Time - Initial DateTime',
        description: 'Extracts the narrative date and time from the scene opening',
        defaultTemperature: 0.3,
        placeholders: [
            COMMON_PLACEHOLDERS.messages,
            COMMON_PLACEHOLDERS.schema,
            COMMON_PLACEHOLDERS.schemaExample,
        ],
        default: `Analyze this roleplay scene opening and determine the narrative date and time. You must only return valid JSON with no commentary.

<instructions>
- Determine the date and time when this scene takes place.
- Look for explicit mentions: "Monday morning", "3pm", "June 15th", "winter evening", etc.
- Look for contextual clues: weather, lighting, activities, meals, seasons.
- If the year is not specified, infer from context or use a reasonable modern year.
- If the month is not specified, infer from seasonal/weather clues or use a reasonable default.
- If the day is not specified, use a reasonable default (e.g., 15 for mid-month).
- Always provide complete values for all fields - never omit anything.
- Use 24-hour format for the hour field.
</instructions>

<examples>
<example>
<input>
*The first snow of the season was falling outside the coffee shop window, fat flakes drifting lazily under the streetlights. Elena wrapped her hands around her pumpkin spice latte, watching the evening crowd hurry past with their collars turned up against the cold. It was barely past five, but the sun had already setâ€”one of those November days that made her wish she'd moved somewhere warmer.*

*Her phone buzzed: a text from Marcus saying he was running late, stuck in traffic from the corporate holiday party he'd been dreading all week. She smiled and texted back that she'd order him something warm. The barista had just put up the Christmas decorationsâ€”a little early, but Elena didn't mind. The twinkling lights reflected off the dark window, making the shop feel cozy despite the chill creeping in around the door frame.*
</input>
<output>
{
  "year": 2024,
  "month": 11,
  "day": 15,
  "hour": 17,
  "minute": 15,
  "period": "evening",
  "season": "late autumn"
}
</output>
<explanation>
EXPLICIT clues:
- "first snow of the season" + "November days" â†’ month is 11 (November)
- "barely past five, but the sun had already set" â†’ hour is 17 (5 PM), early sunset confirms late autumn
- "evening crowd" â†’ period is "evening"

INFERRED values:
- year: Not specified, use current/reasonable modern year (2024)
- day: Not specified, default to mid-month (15)
- minute: "barely past five" suggests just after the hour (15)
- season: "late autumn" - November with first snow, not quite winter yet

Context clues that CONFIRM the inference:
- Pumpkin spice latte (seasonal fall drink)
- Corporate holiday party (November-December timing)
- Christmas decorations going up early (pre-December)
- Cold weather, collars turned up
</explanation>
</example>

<example>
<input>
*The summer sun blazed overhead as Marcus hauled the last cooler out of the truck bed. It was barely noon, but the Fourth of July heat was already oppressiveâ€”had to be pushing ninety-five in the shade, if there'd been any shade to speak of. The beach parking lot shimmered with heat mirages, and he could feel the asphalt burning through his sandals.*

*Down by the water, Elena and the kids had already claimed their spot, the red-white-and-blue umbrella visible even from here. She waved, and he could see Sophie jumping up and down with excitement, probably begging to go in the water before lunch. He checked his phoneâ€”12:17â€”and started the long trudge across the sand.*
</input>
<output>
{
  "year": 2024,
  "month": 7,
  "day": 4,
  "hour": 12,
  "minute": 17,
  "period": "midday",
  "season": "summer"
}
</output>
<explanation>
EXPLICIT clues:
- "Fourth of July" â†’ month: 7, day: 4
- "barely noon" and "12:17" on phone â†’ hour: 12, minute: 17
- "summer sun" â†’ season: "summer"

INFERRED values:
- year: Not specified, use reasonable modern year (2024)
- period: "midday" - noon timeframe

Context clues that CONFIRM:
- Extreme heat (95Â°F) typical of July
- Beach trip with family (common July 4th activity)
- Patriotic umbrella colors (holiday-appropriate)
</explanation>
</example>

<example>
<input>
*The cherry blossoms were in full bloom along the Potomac, their delicate pink petals drifting down like snow onto the jogging path. Elena stretched her calves against a park bench, watching the early morning runners pass by in the golden dawn light. It was the perfect time of year for thisâ€”not too hot yet, the air fresh and cool, the city just starting to wake up.*

*Her fitness tracker showed 6:47 AM and a respectable heart rate after her warm-up. In the distance, she could see the Washington Monument catching the first rays of sunlight, and beyond it, the dome of the Capitol building. A few dog walkers ambled past, coffee cups in hand, taking advantage of the quiet before the tourist crowds arrived.*
</input>
<output>
{
  "year": 2024,
  "month": 4,
  "day": 8,
  "hour": 6,
  "minute": 47,
  "period": "early morning",
  "season": "spring"
}
</output>
<explanation>
EXPLICIT clues:
- "cherry blossoms in full bloom" â†’ late March to mid-April (peak bloom in DC)
- "6:47 AM" on fitness tracker â†’ hour: 6, minute: 47
- "early morning runners" + "golden dawn light" â†’ period: "early morning"

INFERRED values:
- year: Modern year (2024) - Washington Monument, fitness tracker suggest contemporary
- month: 4 (April) - cherry blossom peak season
- day: 8 - mid-peak bloom period, reasonable default
- season: "spring" - cherry blossoms, "not too hot yet," fresh cool air

Location clues (Washington DC) help date the cherry blossoms specifically - they bloom late March through mid-April there.
</explanation>
</example>
</examples>

<scene_opening>
{{messages}}
</scene_opening>

<schema>
{{schema}}
</schema>

<output_example>
{{schemaExample}}
</output_example>

Extract the narrative date and time as valid JSON:`,
    },
    time_delta: {
        key: 'time_delta',
        name: 'Time - Delta',
        description: 'Determines how much narrative time has passed in the messages',
        defaultTemperature: 0.3,
        placeholders: [
            COMMON_PLACEHOLDERS.currentTime,
            COMMON_PLACEHOLDERS.messages,
            COMMON_PLACEHOLDERS.schema,
            COMMON_PLACEHOLDERS.schemaExample,
        ],
        default: `Analyze these roleplay messages and determine how much narrative time has passed. You must only return valid JSON with no commentary.

<instructions>
- Determine how much time passes WITHIN these messages based on their actual content.
- The example output below is just showing the JSON format - do NOT copy its values.
- Look for explicit time jumps: "an hour later", "after a few minutes", "the next morning".
- Look for implicit time passage: travel, sleeping, waiting, activities with known durations.
- If the messages are just dialogue or immediate action with no time skip, return small values (0-2 minutes).
- Estimate based on what actually happens in the messages:
  * Pure dialogue exchange: 1-2 minutes
  * Walking somewhere nearby: 5-15 minutes
  * Driving across town: 15-45 minutes
  * Napping: 1-3 hours (consider currentTime)
  * Sleeping overnight: 6-10 hours (consider currentTime)
  * "A few minutes": 3-5 minutes
  * "A while": 15-30 minutes
  * "Some time": 30-60 minutes
- Be conservative - if unsure, prefer smaller time jumps.
- Return 0 for all fields if no time has passed.
</instructions>

<examples>
<example>
<current_time>Tuesday, March 12, 2024 at 10:30 PM</current_time>
<input>
*Elena yawned and stretched, her eyes heavy after the long day. The movie credits were rolling on the TV, but neither of them had really been watching for the last half hour.*

Elena: "I should probably head to bed. Early meeting tomorrow."

Marcus: "Yeah, me too." *He clicked off the TV and stood, offering her a hand.* "I'll lock up."

*They made their way upstairs, taking turns in the bathroom. By the time Elena had finished her skincare routine and climbed into bed, Marcus was already half-asleep, the lamp on his side still on.*

Elena: *turning off the lamp* "Night."

Marcus: *mumbling* "Night..."

*The morning sun streaming through a gap in the curtains woke Elena before her alarm. She blinked at the clockâ€”6:47 AMâ€”and groaned. Still thirteen minutes before she actually needed to be up. Beside her, Marcus was snoring softly, completely dead to the world.*
</input>
<output>
{
  "days": 0,
  "hours": 8,
  "minutes": 17
}
</output>
<explanation>
This is an OVERNIGHT time skip:
- currentTime: 10:30 PM Tuesday
- They went to bed shortly after (maybe 15-20 min for bathroom routine)
- Elena wakes at 6:47 AM
- Total elapsed: approximately 8 hours 17 minutes

The scene explicitly moves from "heading to bed" at night to "morning sun" waking her at 6:47 AM. We calculate from 10:30 PM to 6:47 AM = 8h 17m.

Key indicators of overnight skip:
- Going to bed at night
- "Morning sun streaming through curtains"
- Specific wake-up time given (6:47 AM)
- "Before her alarm" implies morning routine starting
</explanation>
</example>

<example>
<current_time>Saturday, June 8, 2024 at 2:15 PM</current_time>
<input>
*The argument had been building for twenty minutes now, voices rising with each exchange. Elena stood by the window, arms crossed, while Marcus paced the length of the living room.*

Marcus: "I just don't understand why you didn't tell me about the job offer!"

Elena: "Because I knew you'd react exactly like this!"

Marcus: "Like what? Like someone who thought we made decisions together?"

*Elena flinched. That one landed. She turned away from him, staring out at the street below without really seeing it.*

Elena: "I haven't even decided if I'm taking it yet."

Marcus: "But you're considering it. You're considering moving across the country and you didn't think that was worth mentioning?"

*The silence stretched between them, heavy and painful. Finally, Elena spoke, her voice smaller than before.*

Elena: "I was scared. I didn't know how to bring it up."

Marcus: *sighing heavily, running a hand through his hair* "I just... I need a minute." *He grabbed his jacket from the couch.* "I'm going for a walk."

*The door closed behind him with a quiet click that somehow felt louder than all the shouting.*
</input>
<output>
{
  "days": 0,
  "hours": 0,
  "minutes": 25
}
</output>
<explanation>
This is REAL-TIME dialogue with stated duration:
- "The argument had been building for twenty minutes now" establishes base time
- The rest of the exchange takes another ~5 minutes of heated dialogue
- Total: approximately 25 minutes

NO time skip occurs - this is a continuous scene. The time represents:
- 20 minutes of prior argument (mentioned)
- ~5 minutes of the dialogue we see
- Marcus leaving at the end

Key principle: Emotional conversations feel longer but don't actually take much clock time. An intense 5-minute argument can feel like an hour.
</explanation>
</example>

<example>
<current_time>Monday, September 16, 2024 at 9:00 AM</current_time>
<input>
*Elena grabbed her laptop bag and headed for the door, already running late for the presentation.*

Elena: "I'll see you tonight!"

Marcus: *from the kitchen* "Good luck! You've got this!"

*The commute was brutalâ€”an accident on the highway had traffic backed up for miles. Elena spent forty-five minutes crawling along, mentally rehearsing her talking points and trying not to check the clock every thirty seconds. By the time she finally pulled into the parking garage, she had exactly three minutes to get upstairs.*

*She power-walked through the lobby, badge already in hand, and caught the elevator just as the doors were closing. The conference room was on the twelfth floor. She watched the numbers climb with growing anxietyâ€”8, 9, 10, 11, 12â€”and practically sprinted down the hallway when the doors opened.*

*She slid into the conference room at 9:58 AM, two minutes before her slot. Her boss raised an eyebrow but said nothing. Elena set up her laptop with slightly shaking hands and took a deep breath. She'd made it.*
</input>
<output>
{
  "days": 0,
  "hours": 0,
  "minutes": 58
}
</output>
<explanation>
Time skip with EXPLICIT endpoint:
- Starts: 9:00 AM (currentTime, she's "already running late")
- Ends: 9:58 AM (explicitly stated - "slid into the conference room at 9:58 AM")
- Total: 58 minutes

Breakdown of time passage:
- Brief goodbye at home: 1-2 min
- 45 minutes of commute (explicitly stated)
- Parking, walking, elevator: ~10 min
- Total checks out: 2 + 45 + 10 â‰ˆ 57-58 minutes

When EXACT times are given, use them for precision rather than estimating.
</explanation>
</example>

<bad_example>
<current_time>Tuesday, March 12, 2024 at 10:30 PM</current_time>
<input>
*Elena yawned...* [overnight sleep scene] *...woke at 6:47 AM*
</input>
<output>
{
  "days": 1,
  "hours": 0,
  "minutes": 0
}
</output>
<why_bad>
- Used "days: 1" but only 8 hours passed (10:30 PM to 6:47 AM)
- Should be: days: 0, hours: 8, minutes: 17
- "Next day" doesn't mean 24 hours - calculate actual elapsed time
- Always compute from current_time to the scene's end time
</why_bad>
</bad_example>
</examples>

<current_time>
{{currentTime}}
</current_time>

<messages>
{{messages}}
</messages>

<schema>
{{schema}}
</schema>

<output_format_example>
{{schemaExample}}
</output_format_example>

Based on the actual content of the messages above, extract the time delta as valid JSON:`,
    },
    location_initial: {
        key: 'location_initial',
        name: 'Location - Initial',
        description: 'Extracts location from the scene opening',
        defaultTemperature: 0.5,
        placeholders: [
            COMMON_PLACEHOLDERS.characterInfo,
            COMMON_PLACEHOLDERS.messages,
            COMMON_PLACEHOLDERS.schema,
            COMMON_PLACEHOLDERS.schemaExample,
        ],
        default: `Analyze this roleplay scene and extract the current location. You must only return valid JSON with no commentary.

<instructions>
- Determine where this scene takes place.
- The 'area' should be neighborhood + city + country/region (e.g. 'Downtown, Huntsville, AL', 'Farringdon, London, UK', 'Mordor, Middle Earth', 'Ponyville, Equestria'). Always include the country or region identifier.
- The 'place' should be a SPECIFIC named location:
  - For buildings: Use FULL proper names (e.g. 'Pixar Animation Studios' NOT just 'Studio', 'The Rusty Nail Bar' NOT just 'Bar')
  - For outdoor/street locations: Use street name + nearby landmark (e.g. 'Ferris Street (near Zenith nightclub)', 'Central Park West (by the fountain)', 'Baker Street (outside 221B)')
  - NEVER use generic descriptions like 'Nightclub in a busy district' or 'Street in the city' - always invent a specific name
- The 'position' should be a SPATIAL location within the place (e.g. 'Main lobby', 'Corner booth', 'Sidewalk near entrance'). Do NOT include character poses or actions in position.
- Props rules (IMPORTANT):
  - Props are PHYSICAL OBJECTS that characters could pick up or interact with
  - Each prop should be ONE SINGLE ITEM (e.g. "Neon sign" not "Neon signs reflecting in puddles")
  - NO sounds, smells, or atmosphere (e.g. NOT "Bass thumping" or "Smell of smoke")
  - NO people or their activities (e.g. NOT "Smokers huddled by door" or "Idling taxis")
  - NO clothing that characters are currently WEARING - that goes in character outfits
  - Only include clothing as props if REMOVED and placed somewhere (e.g. "Discarded jacket on chair")
- If location is not explicit, infer from context clues and INVENT specific names that fit the setting.
</instructions>

<examples>
<example>
<input>
Elena: *She pushed through the revolving door into the Meridian Grand Hotel, shaking raindrops from her umbrella. The lobby stretched before her in all its art deco gloryâ€”geometric patterns in the marble floor, brass fixtures polished to a mirror shine, and a massive crystal chandelier casting prismatic light across the space. A string quartet played something classical near the fountain, their music competing with the murmur of well-dressed guests and the occasional ding of elevator arrivals.*

*She spotted the concierge desk to her left, staffed by a woman in an immaculate uniform, and beyond it the entrance to what looked like a high-end restaurant. The check-in counter dominated the far wall, where a short queue of travelers waited with their luggage. Elena's heels clicked against the marble as she made her way toward the seating area near the windows, where oversized leather armchairs surrounded low coffee tables scattered with magazines.*

"Impressive," *she murmured, taking in the fifteen-foot ceilings and the gallery of black-and-white photographs lining the walls.*
</input>
<output>
{
  "area": "Downtown, Chicago, IL",
  "place": "Meridian Grand Hotel",
  "position": "Main lobby near window seating area",
  "props": ["Crystal chandelier", "Art deco marble floor", "Brass fixtures", "Fountain with string quartet nearby", "Oversized leather armchairs", "Low coffee tables with magazines", "Black-and-white photograph gallery"]
}
</output>
<explanation>
- area: Inferred as major city with grand hotels; "Downtown, Chicago, IL" includes neighborhood + city + state
- place: Full proper name "Meridian Grand Hotel" extracted exactly as mentioned, not abbreviated to "Hotel" or "The Meridian"
- position: "Main lobby near window seating area" - describes WHERE she is spatially, not WHAT she's doing (no "walking" or "taking in the view")
- props: Selected the most scene-relevant items that characters might interact with. Excluded transient elements (the queue of travelers, the concierge herself) and focused on environmental features. Note specificity: "Art deco marble floor" not just "floor"
</explanation>
</example>

<example>
<input>
*The submarine's control room was cramped and humid, every surface covered in switches, dials, and screens displaying sonar readouts. Captain Reyes stood at the periscope station, one eye pressed to the viewfinder while her XO monitored the depth gauge nearby. Red emergency lighting bathed everything in an ominous glowâ€”they'd been running silent for six hours now, and the tension was palpable.*

*Banks of monitors showed the surrounding ocean in ghostly green sonar imagery. The helm station dominated the front of the room, where two junior officers sat rigid at their controls. Overhead, pipes and cables snaked across the ceiling, occasionally dripping condensation onto the metal deck plates below. A navigation chart was spread across the plotting table, weighted down with coffee mugs and a brass compass.*

*The air recycler hummed its constant drone, barely masking the distant ping of active sonar from somewhere above them.*

Reyes: "Maintain current depth. Nobody makes a sound."
</input>
<output>
{
  "area": "Pacific Ocean, 200 meters depth",
  "place": "USS Triton (Attack Submarine)",
  "position": "Control room",
  "props": ["Periscope station", "Sonar display monitors", "Helm control stations", "Navigation plotting table with charts", "Brass compass", "Depth gauge", "Red emergency lighting", "Overhead pipe network", "Air recycler"]
}
</output>
<explanation>
- area: For mobile locations like vehicles/vessels, area describes the broader environment ("Pacific Ocean, 200 meters depth")
- place: Vessel name inferred as military submarine; given a reasonable designation. Full name includes vessel type for clarity
- position: "Control room" - the specific compartment, not "standing at periscope" or "running silent"
- props: Focused on interactive/notable equipment. Excluded people (XO, junior officers) and temporary states (coffee mugs as weights). Included atmospheric elements (red lighting, air recycler) that affect scene mood
</explanation>
</example>

<example>
<input>
*Marcus found himself in what had clearly once been a grand ballroom, though decades of neglect had transformed it into something out of a gothic nightmare. Faded murals peeled from the walls in long strips, revealing water-stained plaster beneath. The parquet floor, once polished to a gleam, was now warped and broken in places, with weeds pushing through the gaps where it met the crumbling baseboards.*

*Dust motes danced in the shafts of pale light filtering through broken windows high above. A massive fireplace dominated one wall, its marble mantle cracked and blackened with old soot. Someone had dragged a mattress into the cornerâ€”recent, by the look of it, with rumpled blankets and empty food cans scattered nearby. Graffiti covered the lower portions of the walls, tags and crude drawings layered over each other.*

*The remnants of a crystal chandelier lay shattered in the center of the room, its brass frame twisted and tarnished. Marcus could hear pigeons cooing somewhere in the rafters above, and the distant sound of traffic from the street outside.*
</input>
<output>
{
  "area": "Old Town, Baltimore, MD",
  "place": "Abandoned Harrington Estate",
  "position": "Former grand ballroom",
  "props": ["Peeling murals and water-stained walls", "Warped parquet floor with weeds", "Cracked marble fireplace (blackened)", "Recent mattress with blankets in corner", "Empty food cans", "Layered graffiti", "Shattered crystal chandelier (brass frame on floor)", "Broken high windows"]
}
</output>
<explanation>
- area: "Old Town, Baltimore, MD" - specific district + city + state inferred from context of historic estate
- place: Named estate rather than just "abandoned building" - gives the location identity and history
- position: "Former grand ballroom" - spatial designation with context about what the room was/is
- props: Mixed permanent features (fireplace, floor) with signs of decay (peeling murals, shattered chandelier) AND evidence of recent habitation (mattress, food cans). Props tell the story of the location. Note state descriptors: "cracked," "blackened," "shattered"
</explanation>
</example>

<example>
<input>
*The bass from the club behind them was still audible, a muffled thump-thump-thump that vibrated through the pavement. Elena stepped out into the cool night air, grateful to escape the crush of bodies inside. The street was quiet at this hourâ€”just a few smokers huddled near the entrance and a taxi idling at the curb.*

*Across the street, a kebab shop's neon sign flickered on and off, casting red and blue shadows on the wet pavement. The rain had stopped, but puddles still dotted the sidewalk, reflecting the glow of the streetlamps. A bouncer in a black jacket stood by the velvet rope, checking his phone while a couple argued nearby about whose turn it was to call an Uber.*

*Elena pulled her jacket tighter against the chill and walked a few steps away from the crowd, past a shuttered newsagent and a graffiti-covered electrical box. The smell of cigarette smoke and frying meat mixed in the air.*
</input>
<output>
{
  "area": "Shoreditch, London, UK",
  "place": "Kingsland Road (outside Vinyl Dreams nightclub)",
  "position": "Sidewalk near shuttered newsagent",
  "props": ["Kebab shop neon sign", "Streetlamp", "Velvet rope", "Electrical box", "Newsagent shutters"]
}
</output>
<explanation>
- area: "Shoreditch, London, UK" - specific neighborhood + city + country, inferred from nightclub culture context
- place: "Kingsland Road (outside Vinyl Dreams nightclub)" - specific street name + nearby landmark, NOT generic "Street near nightclub" or "Outside a club"
- position: "Sidewalk near shuttered newsagent" - spatial location on the street
- props: ONLY physical objects characters could interact with. Each is ONE item. Excludes: people (bouncer, smokers), sounds (bass), atmosphere (puddles, reflections), worn clothing
</explanation>
</example>

<bad_example>
<output>
{
  "area": "City",
  "place": "Hotel",
  "position": "Walking through the lobby, looking around nervously while shaking off her umbrella"
}
</output>
<why_bad>
- area too vague: Should include neighborhood + city + state/country ("Downtown, Chicago, IL" not "City")
- place too generic: Should use the full proper name ("Meridian Grand Hotel" not "Hotel")
- position contains actions: "Walking through," "looking around nervously," and "shaking off umbrella" are character actions, not spatial locations. Should be "Main lobby" or "Lobby entrance"
</why_bad>
</bad_example>

<bad_example>
<output>
{
  "area": "London",
  "place": "Nightclub in a busy district",
  "position": "Outside near the entrance, under a flickering streetlamp"
}
</output>
<why_bad>
- area missing neighborhood and country: Should be "Shoreditch, London, UK" or "Soho, London, UK" - not just the city name
- place is a generic description, not a specific name: "Nightclub in a busy district" should be a specific place like "Kingsland Road (outside Vinyl Dreams)" or "Greek Street (near The Blue Note)"
- Always invent specific place names when not provided - never use generic descriptions
</why_bad>
</bad_example>

<bad_example>
<output>
{
  "area": "Downtown, Seattle, WA",
  "place": "The Blue Moon Lounge",
  "position": "Main bar area",
  "props": ["Leather bar stools", "Neon signs", "Elena's red cocktail dress", "Marcus's gray suit jacket", "Martini glasses"]
}
</output>
<why_bad>
- props include clothing characters are WEARING: "Elena's red cocktail dress" and "Marcus's gray suit jacket" should NOT be in props - they belong in each character's outfit slots
- Only include clothing in props if it has been REMOVED and placed somewhere (e.g., "Marcus's suit jacket on barstool", "Discarded scarf near entrance")
- Clothing that characters are currently wearing goes in character outfit tracking, not location props
</why_bad>
</bad_example>

<bad_example>
<output>
{
  "area": "Shoreditch, London, UK",
  "place": "Kingsland Road (outside Vinyl Dreams)",
  "position": "Sidewalk near entrance",
  "props": ["Flickering neon signs reflecting in puddles", "Bass thumping from nightclub entrance", "Smokers huddled by the door", "Idling taxis", "Clara's limited edition hat", "Matt's designer hoodie"]
}
</output>
<why_bad>
- "Flickering neon signs reflecting in puddles" combines multiple things - should be separate: "Neon sign" (puddles are not props)
- "Bass thumping from nightclub entrance" is a SOUND, not a physical object - do not include sounds/atmosphere
- "Smokers huddled by the door" and "Idling taxis" are PEOPLE and their activities - do not include people as props
- "Clara's limited edition hat" and "Matt's designer hoodie" are clothing characters are WEARING - belongs in character outfits, not props
- Correct props would be: "Neon sign", "Velvet rope", "Club entrance door", "Electrical box"
</why_bad>
</bad_example>
</examples>

<character_info>
{{characterInfo}}
</character_info>

<scene_messages>
{{messages}}
</scene_messages>

<schema>
{{schema}}
</schema>

<output_example>
{{schemaExample}}
</output_example>

Extract the location as valid JSON:`,
    },
    location_update: {
        key: 'location_update',
        name: 'Location - Update',
        description: 'Updates location based on recent messages',
        defaultTemperature: 0.5,
        placeholders: [
            COMMON_PLACEHOLDERS.previousState,
            COMMON_PLACEHOLDERS.messages,
            COMMON_PLACEHOLDERS.schema,
            COMMON_PLACEHOLDERS.schemaExample,
        ],
        default: `Analyze these roleplay messages and extract any location changes. You must only return valid JSON with no commentary.

<instructions>
- Determine if the location has changed from the previous state.
- Track any movement: characters entering new rooms, traveling, position changes within a space.
- The 'area' should be neighborhood + city + country/region (e.g. 'Downtown, Huntsville, AL', 'Farringdon, London, UK'). Always include country/region.
- The 'place' should be a SPECIFIC named location:
  - For buildings: Use FULL proper names (e.g. 'Meridian Grand Hotel' not 'Hotel')
  - For outdoor/street locations: Use street name + nearby landmark (e.g. 'Kingsland Road (outside Vinyl Dreams nightclub)')
  - NEVER use generic descriptions - always use or invent specific names
- The 'position' should be a SPATIAL location only (e.g. 'Corner booth', 'Kitchen', 'Sidewalk near entrance'). Do NOT include character poses or actions.
- Props rules (IMPORTANT):
  - Props are PHYSICAL OBJECTS that characters could pick up or interact with
  - Each prop should be ONE SINGLE ITEM (e.g. "Neon sign" not "Neon signs reflecting in puddles")
  - NO sounds, smells, or atmosphere (e.g. NOT "Bass thumping" or "Smell of smoke")
  - NO people or their activities (e.g. NOT "Smokers huddled by door")
  - NO clothing that characters are currently WEARING - that goes in character outfits
  - Only include clothing as props if REMOVED and placed somewhere (e.g. "Discarded jacket on chair")
- Update props: new items introduced, items picked up/removed, items changing state.
- If no location change occurred, return the previous location but consider prop changes.
- Be careful to track items that have been picked up (remove from props) or put down (add to props).
</instructions>

<examples>
<example>
<input>
*Elena finally let herself relax, kicking off her heels with a relieved sigh. They tumbled across the hardwood floor, coming to rest near the closet door. She shrugged out of her blazer and tossed it carelessly onto the armchair by the window, then padded over to the bed and flopped down face-first into the pillows.*

*After a moment, she rolled onto her back and stared at the ceiling, her stockinged feet hanging off the edge of the mattress. The room was quiet except for the soft hum of the air conditioning and the muffled sounds of city traffic from far below. She reached over to the nightstand and grabbed her phone, scrolling through messages she'd been ignoring all day.*

*The afternoon light filtered through the sheer curtains, casting long shadows across the Persian rug. Her laptop sat open on the desk across the room, screen dark but charging light blinking steadily. She should probably check her work email, but the thought made her groan and bury her face in the nearest pillow instead.*
</input>
<previous_location>
{
  "area": "Upper East Side, Manhattan, NY",
  "place": "Elena's Apartment (Unit 12B)",
  "position": "Entryway",
  "props": ["Coat rack", "Mirror", "Small table with keys bowl", "Umbrella stand"]
}
</previous_location>
<output>
{
  "area": "Upper East Side, Manhattan, NY",
  "place": "Elena's Apartment (Unit 12B)",
  "position": "Master bedroom",
  "props": ["Queen bed with pillows", "Nightstand with phone charger", "Armchair by window with discarded blazer", "Black heels near closet door", "Persian rug", "Desk with laptop (charging)", "Sheer curtains", "Air conditioning unit"]
}
</output>
<explanation>
- position: Changed from "Entryway" to "Master bedroom" - she moved rooms. Note we don't say "lying on bed" (that's her pose, not her location)
- props completely replaced: When moving to a new room, previous room's props (coat rack, mirror, etc.) are no longer relevant - we only track props in the CURRENT location
- Removed clothing added to props: "Black heels near closet door" and "Armchair by window with discarded blazer" - both include WHERE the items ended up
- New room props identified: Items she interacts with (bed, nightstand, phone) plus environmental details (rug, curtains, laptop) that could become relevant
- State noted where relevant: "laptop (charging)" because the blinking light was mentioned and could matter
</explanation>
</example>

<example>
<input>
*The storm had gotten worse since they'd arrived. Marcus stood at the cabin window, watching lightning illuminate the forest in staccato bursts. Rain hammered against the glass so hard he could feel the vibration through the frame. Behind him, Elena had gotten the old wood stove goingâ€”it crackled and popped, slowly pushing back against the chill that had seeped into the abandoned structure.*

*She'd found some moth-eaten blankets in the closet and spread them on the dusty floor near the stove, creating a makeshift camp. Their wet jackets hung from nails in the wall, dripping steadily onto the warped floorboards. Marcus had dragged in some firewood from the covered porch, stacking it near the door where it could dry out.*

*The cabin was sparseâ€”just the one room with a rusted kitchenette in the corner and what might have once been a bed frame, now just bare springs and rotten wood. But it had a roof that mostly didn't leak, and right now that was enough.*

Elena: "Come sit by the fire. You're not going to make the storm stop by glaring at it."
</input>
<previous_location>
{
  "area": "Cascade Mountains, Washington",
  "place": "Forest Trail",
  "position": "Rocky outcropping (seeking shelter)",
  "props": ["Dense pine trees", "Trail marker", "Loose rocks", "Marcus's backpack"]
}
</previous_location>
<output>
{
  "area": "Cascade Mountains, Washington",
  "place": "Abandoned Ranger Cabin",
  "position": "Main room",
  "props": ["Wood stove (lit, crackling)", "Moth-eaten blankets on floor near stove", "Wet jackets hanging on wall nails", "Firewood stack by door", "Rain-streaked window", "Rusted kitchenette", "Broken bed frame", "Covered porch (exterior)"]
}
</output>
<explanation>
- area: Stays the same - they're still in the same mountain region
- place: Changed from "Forest Trail" to "Abandoned Ranger Cabin" - they found shelter and moved indoors
- position: "Main room" - simple spatial designation. NOT "standing at window" or "by the fire"
- props transformation: Trail props completely replaced with cabin interior. Note we track:
  * Items they brought/affected: "Wet jackets hanging on wall nails", "Firewood stack by door"
  * Environmental features: "Wood stove (lit, crackling)", "Rain-streaked window"
  * Potential interaction points: "Rusted kitchenette", "Broken bed frame", "Moth-eaten blankets"
  * Connected spaces: "Covered porch (exterior)" mentioned for context since firewood came from there
- State descriptors matter: "lit, crackling" for the stove, "wet" for jackets, "rusted" and "broken" for damaged items
</explanation>
</example>

<example>
<input>
*Sarah carefully set down her coffee cup, leaving a ring on the manuscript pages scattered across the table. The interview had been going for nearly an hour now, and the small conference room felt increasingly claustrophobic. Detective Morrison sat across from her, his recorder blinking red between them, while his partner leaned against the wall by the doorâ€”blocking the exit, Sarah noted.*

*The fluorescent lights buzzed overhead, one of them flickering intermittently in a way that was slowly driving her crazy. Someone had tried to make the room less institutional with a potted plant in the corner, but it was clearly fake and covered in dust. The blinds were drawn, cutting off any view of the bullpen outside, though she could hear phones ringing and people talking through the thin walls.*

*Morrison slid another photograph across the tableâ€”the third one in the last ten minutes. Sarah forced herself not to react, keeping her hands flat on the cool surface of the table. The chair was deliberately uncomfortable, she realized. Everything about this room was designed to make people want to leave, to say whatever would get them out fastest.*
</input>
<previous_location>
{
  "area": "Downtown Precinct",
  "place": "Central Police Station",
  "position": "Main lobby waiting area",
  "props": ["Plastic chairs", "Vending machines", "Bulletin board with wanted posters", "Front desk with duty officer"]
}
</previous_location>
<output>
{
  "area": "Downtown Precinct",
  "place": "Central Police Station",
  "position": "Interview Room B",
  "props": ["Metal table with scattered manuscript pages", "Coffee cup (with ring stain)", "Audio recorder (recording)", "Photographs (evidence)", "Uncomfortable metal chairs", "Flickering fluorescent lights", "Dusty fake plant in corner", "Drawn window blinds", "Single door (blocked by detective)"]
}
</output>
<explanation>
- area/place: Unchanged - still in same building, just different room
- position: Changed from "Main lobby waiting area" to "Interview Room B" - specific room designation inferred from context (police station interview rooms are typically lettered/numbered)
- props completely refreshed for new room:
  * Interview-specific items: "Audio recorder (recording)", "Photographs (evidence)", "Metal table with scattered manuscript pages"
  * Items characters placed: "Coffee cup (with ring stain)" - detail matters for scene continuity
  * Environmental/atmospheric: "Flickering fluorescent lights", "Uncomfortable metal chairs", "Dusty fake plant"
  * Tactical note: "Single door (blocked by detective)" - relevant to scene tension even though it involves a character's position
- Previous room props (vending machines, bulletin board, etc.) completely removed - not in current location
</explanation>
</example>

<bad_example>
<output>
{
  "area": "Downtown Precinct",
  "place": "Central Police Station",
  "position": "Sitting nervously across from the detective, trying to stay calm",
  "props": ["Plastic chairs", "Vending machines", "Bulletin board", "Audio recorder", "Photographs"]
}
</output>
<why_bad>
- position contains character state: "Sitting nervously" and "trying to stay calm" are character poses and emotions, not spatial locations. Should be "Interview Room B" or "Conference room"
- props mixed from two rooms: "Plastic chairs" and "Vending machines" were in the lobby, not the interview room. When location changes, props should COMPLETELY update to the new room
- props lack state/context: "Audio recorder" should note "(recording)", "Photographs" should note "(evidence)" for scene relevance
</why_bad>
</bad_example>
</examples>

<previous_location>
{{previousState}}
</previous_location>

<recent_messages>
{{messages}}
</recent_messages>

<schema>
{{schema}}
</schema>

<output_example>
{{schemaExample}}
</output_example>

Extract the current location as valid JSON:`,
    },
    climate_initial: {
        key: 'climate_initial',
        name: 'Climate - Initial',
        description: 'Extracts weather and temperature from scene opening',
        defaultTemperature: 0.3,
        placeholders: [
            COMMON_PLACEHOLDERS.narrativeTime,
            COMMON_PLACEHOLDERS.location,
            COMMON_PLACEHOLDERS.characterInfo,
            COMMON_PLACEHOLDERS.messages,
            COMMON_PLACEHOLDERS.schema,
            COMMON_PLACEHOLDERS.schemaExample,
        ],
        default: `Analyze this roleplay scene and determine the current climate/weather. You must only return valid JSON with no commentary.

<instructions>
- Determine the weather and temperature for this scene.
- Consider the narrative time and location to infer season and typical weather.
- Look for explicit weather mentions: rain, snow, sunshine, etc.
- Look for contextual clues: characters wearing coats, sweating, mentioning cold/heat.
- If characters are indoors, weather should be what it is outside, but temperature should be indoor temperature.
- Consider the hemisphere: December is winter in the northern hemisphere, summer in the southern.
- Temperature should be in Fahrenheit.
</instructions>

<examples>
<example>
<narrative_time>Wednesday, January 15, 2024 at 7:30 PM</narrative_time>
<location>Minneapolis, Minnesota - Elena's Apartment (Living room)</location>
<input>
*Elena pressed her forehead against the cold window, watching the snow pile up on the fire escape outside. The forecast had warned about thisâ€”the worst blizzard in a decade, they said. Already the cars parked on the street below were nothing but white lumps, and the wind was howling loud enough to hear through the double-paned glass.*

*She pulled her cardigan tighter and retreated to the couch, where Marcus had made a nest of blankets. The radiator was clanking away in the corner, working overtime, but it could only do so much against a Minnesota winter.*

Marcus: "Power company says to expect outages tonight." *He held up his phone.* "I filled the bathtub just in case."

Elena: "Smart." *She curled up against him, stealing his warmth.* "I'm glad I'm not trying to drive in this."

*Another gust of wind rattled the windows, and somewhere in the building, a door slammed.*
</input>
<output>
{
  "weather": "Heavy snowfall with blizzard conditions, strong winds",
  "temperature": 68
}
</output>
<explanation>
WEATHER: Explicitly described - "worst blizzard in a decade," heavy snow visible on cars/fire escape, howling wind, windows rattling.

TEMPERATURE: 68Â°F - This is INDOOR temperature:
- They're inside the apartment (living room)
- Radiator is "working overtime" but "can only do so much"
- Elena is cold enough to pull cardigan tighter and seek Marcus's warmth
- 68Â°F represents a slightly cool but still heated indoor space during a blizzard
- Outside would be well below freezing (single digits or negative), but we report indoor temp since they're indoors

Key principle: When characters are indoors, report indoor temperature but outdoor weather. The weather affects the scene (visible through windows, wind rattling them) but temperature should reflect their immediate environment.
</explanation>
</example>

<example>
<narrative_time>Saturday, August 3, 2024 at 2:15 PM</narrative_time>
<location>Phoenix, Arizona - Desert Botanical Garden (Main pathway)</location>
<input>
*The heat was absolutely brutal. Marcus could feel sweat soaking through his shirt within minutes of leaving the air-conditioned visitor center. The sun beat down from a cloudless sky, reflecting off the pale gravel paths until he had to squint even with sunglasses.*

*Elena had insisted on seeing the saguaro collection, and he'd agreed before checking the weather. 115 degrees, the sign at the entrance had warned. Even the cacti looked like they were struggling. They passed a family heading back toward the buildings, the kids red-faced and whining, one of them being carried.*

Elena: *fanning herself with the park map* "Maybe we should have done this in the morning."

Marcus: "You think?" *He pointed to a shaded ramada up ahead.* "Let's at least get out of direct sun."

*They hurried to the shade, but it barely helped. The air itself felt like an oven, shimmering over the desert landscape in visible waves.*
</input>
<output>
{
  "weather": "Clear, cloudless, extreme sun exposure",
  "temperature": 115
}
</output>
<explanation>
WEATHER: "Clear, cloudless, extreme sun exposure"
- "cloudless sky" explicitly stated
- Emphasis on brutal direct sunlight
- No moisture, no clouds, no relief

TEMPERATURE: 115Â°F - OUTDOOR temperature:
- Explicitly stated on the entrance sign
- They're outdoors on the garden pathway
- Multiple heat indicators: soaking sweat, squinting, kids overheating, shimmering air
- This is actual ambient temperature, not just "feels like"

Phoenix in August commonly hits 115Â°F+. The scene confirms extreme heat through physical reactions (sweating through shirt, seeking shade desperately) and environmental details (shimmering air, heat waves).
</explanation>
</example>

<example>
<narrative_time>Friday, October 18, 2024 at 6:45 PM</narrative_time>
<location>Portland, Oregon - Waterfront Park (Riverside path)</location>
<input>
*The rain had been falling steadily all afternoon, the kind of gray Pacific Northwest drizzle that wasn't heavy enough for an umbrella but somehow still got you soaked. Elena pulled up the hood of her rain jacket and fell into step beside Marcus, their boots splashing through shallow puddles on the riverside path.*

*The Willamette River was high and fast-moving, swollen with runoff. Across the water, the lights of downtown Portland glowed soft and hazy through the mist. A few other hardy souls were out walkingâ€”joggers, mostly, seemingly immune to the weather.*

Marcus: "I love this, you know." *He spread his arms, letting the rain hit his face.* "Everyone else hides from it, but this is real Portland."

Elena: "You're insane." *But she was smiling.* "My socks are going to be wet for days."

*A gust of wind blew spray off the river, adding to the general dampness. The temperature had dropped since sunset, and Elena could see her breath now, thin wisps of vapor disappearing into the gray.*
</input>
<output>
{
  "weather": "Steady light rain, misty, overcast",
  "temperature": 48
}
</output>
<explanation>
WEATHER: "Steady light rain, misty, overcast"
- "Gray Pacific Northwest drizzle" - classic description of light but persistent rain
- "Mist" explicitly mentioned (downtown visible but hazy)
- Rain steady enough to soak through clothes over time
- Overcast implied by gray sky, no sun mentioned

TEMPERATURE: 48Â°F - OUTDOOR temperature:
- They're outside on the riverside path
- Cool enough to see breath ("thin wisps of vapor")
- Temperature "dropped since sunset" - evening in October
- 48Â°F is typical for Portland in October evening with rain
- Not cold enough for winter gear, but uncomfortable when wet

Note the difference from indoor scenes: here we track actual outdoor temperature since they're outside in the weather.
</explanation>
</example>
</examples>

<narrative_time>
{{narrativeTime}}
</narrative_time>

<location>
{{location}}
</location>

<character_info>
{{characterInfo}}
</character_info>

<scene_messages>
{{messages}}
</scene_messages>

<schema>
{{schema}}
</schema>

<output_example>
{{schemaExample}}
</output_example>

Extract the climate as valid JSON:`,
    },
    climate_update: {
        key: 'climate_update',
        name: 'Climate - Update',
        description: 'Updates weather/temperature based on recent messages',
        defaultTemperature: 0.3,
        placeholders: [
            COMMON_PLACEHOLDERS.narrativeTime,
            COMMON_PLACEHOLDERS.location,
            COMMON_PLACEHOLDERS.previousState,
            COMMON_PLACEHOLDERS.messages,
            COMMON_PLACEHOLDERS.schema,
            COMMON_PLACEHOLDERS.schemaExample,
        ],
        default: `Analyze these roleplay messages and determine if the climate has changed. You must only return valid JSON with no commentary.

<instructions>
- Check if weather or temperature has changed since the previous state.
- Weather can change: storm rolling in, rain stopping, etc.
- Temperature can change: moving indoors/outdoors, time passing, heating/AC mentioned.
- Consider the current narrative time when inferring temperature changes.
- If characters moved indoors/outdoors, adjust temperature accordingly.
- Temperature should be in Fahrenheit.
</instructions>

<examples>
<example>
<narrative_time>Saturday, August 3, 2024 at 2:45 PM</narrative_time>
<location>Phoenix, Arizona - Desert Botanical Garden (Visitor Center cafe)</location>
<previous_climate>
{
  "weather": "Clear, cloudless, extreme sun exposure",
  "temperature": 115
}
</previous_climate>
<input>
*The air conditioning hit them like a wall of blessed relief as they pushed through the visitor center doors. Marcus stood just inside the entrance for a moment, arms spread, letting the cool air wash over his sweat-soaked shirt.*

Marcus: "I'm never leaving this building."

Elena: *laughing* "Dramatic." *She made a beeline for the water fountain, drinking deeply.* "But also same."

*The cafe was sparsely populatedâ€”most sensible people had either come in the early morning or stayed home entirely. They found a table by the window, where they could watch the heat shimmer outside without being in it. A ceiling fan rotated lazily overhead, adding to the refrigerated chill.*

Elena: "I think my skin is still radiating heat."

Marcus: "Well, the sign says it's 72 in here, so you should cool down eventually." *He nodded toward a digital temperature display on the wall.*
</input>
<output>
{
  "weather": "Clear, cloudless, extreme sun exposure",
  "temperature": 72
}
</output>
<explanation>
WEATHER: UNCHANGED - "Clear, cloudless, extreme sun exposure"
- They moved indoors, but weather outside hasn't changed
- Still visible through the window (heat shimmer)
- Weather tracks outdoor conditions even when characters are inside

TEMPERATURE: 115Â°F â†’ 72Â°F - CHANGED due to moving indoors
- Explicitly stated on digital display: 72Â°F
- Strong AC indicated by "blessed relief" and "refrigerated chill"
- Dramatic contrast between outdoor heat and indoor comfort
- Temperature tracks characters' immediate environment

This is the key indoor/outdoor distinction: when characters move inside, temperature changes to reflect their environment, but weather remains the outdoor condition.
</explanation>
</example>

<example>
<narrative_time>Wednesday, January 15, 2024 at 11:30 PM</narrative_time>
<location>Minneapolis, Minnesota - Elena's Apartment (Living room)</location>
<previous_climate>
{
  "weather": "Heavy snowfall with blizzard conditions, strong winds",
  "temperature": 68
}
</previous_climate>
<input>
*The power had gone out two hours ago. Elena and Marcus huddled together on the couch under every blanket they owned, their breath visible in the flashlight beam. The radiator had gone cold and silent, and the temperature was dropping fast.*

*Outside, the storm had intensifiedâ€”if that was even possible. The wind was screaming now, a constant howl that made the old building creak and groan. Through the frosted window, Elena couldn't even see the building across the street anymore, just a wall of swirling white.*

Marcus: *checking his phone* "Still no update on when power's coming back."

Elena: *shivering* "How cold do you think it is in here now?"

Marcus: "I'd guess low fifties? The pipes are going to freeze if this keeps up."

*She pulled the blankets tighter, pressing herself against him. At least body heat was free.*
</input>
<output>
{
  "weather": "Severe blizzard, whiteout conditions, dangerously high winds",
  "temperature": 52
}
</output>
<explanation>
WEATHER: Updated from "Heavy snowfall with blizzard conditions" â†’ "Severe blizzard, whiteout conditions, dangerously high winds"
- Storm has intensified ("if that was even possible")
- Visibility now zero (can't see building across street)
- Wind upgraded from "strong" to "screaming" and "constant howl"
- Weather can change during scenes; track these updates

TEMPERATURE: 68Â°F â†’ 52Â°F - DROPPED due to power outage
- Power out for 2 hours, radiator cold
- Breath now visible indoors (wasn't before)
- Marcus estimates "low fifties"
- Temperature dropping because heating failed
- Still indoor temp, but indoor conditions have changed dramatically

Both fields changed this time: weather intensified AND indoor temperature dropped. Track each independently based on what the scene describes.
</explanation>
</example>

<example>
<narrative_time>Friday, October 18, 2024 at 9:30 PM</narrative_time>
<location>Portland, Oregon - Marcus's House (Enclosed back porch)</location>
<previous_climate>
{
  "weather": "Steady light rain, misty, overcast",
  "temperature": 48
}
</previous_climate>
<input>
*The rain had finally stopped, though water still dripped from the gutters and the trees in Marcus's backyard. Elena stood on the enclosed back porch, a mug of tea warming her hands, watching the clouds break apart to reveal patches of stars.*

Marcus: *joining her* "Hey, look at thatâ€”you can actually see the moon."

*It was true. The clouds were moving fast, pushed by upper-level winds, and a three-quarter moon was emerging from behind them. The air felt cleaner now, washed fresh by the rain, though it had gotten noticeably colder since the sky cleared.*

Elena: "It's beautiful. But cold." *She pulled her sweater sleeves down over her hands.* "Probably thirty degrees colder than when we were at the waterfront."

Marcus: "Clear skies do that. All the heat radiates away." *He put an arm around her.* "Want to go back inside?"

Elena: "In a minute. I want to see if we can spot any constellations."
</input>
<output>
{
  "weather": "Clear and clearing, post-rain, partial moon visible",
  "temperature": 45
}
</output>
<explanation>
WEATHER: "Steady light rain, misty, overcast" â†’ "Clear and clearing, post-rain, partial moon visible"
- Rain stopped (major change)
- Clouds breaking up, moon and stars visible
- "Post-rain" captures the recent weather context (water dripping, fresh air)

TEMPERATURE: 48Â°F â†’ 45Â°F - SLIGHT drop
- They're on an ENCLOSED porch (semi-outdoor)
- Clear skies = radiative cooling (Marcus explains this)
- Elena notes it's "noticeably colder" since clouds cleared
- ~3Â°F drop is realistic for clearing skies in evening
- Not as cold as fully outdoors would be, but cooler than inside

The enclosed porch is a middle ground - affected by outdoor temperature but somewhat sheltered. Temperature reflects this semi-outdoor environment.
</explanation>
</example>
</examples>

<narrative_time>
{{narrativeTime}}
</narrative_time>

<current_location>
{{location}}
</current_location>

<previous_climate>
{{previousState}}
</previous_climate>

<recent_messages>
{{messages}}
</recent_messages>

<schema>
{{schema}}
</schema>

<output_example>
{{schemaExample}}
</output_example>

Extract the current climate as valid JSON:`,
    },
    characters_initial: {
        key: 'characters_initial',
        name: 'Characters - Initial',
        description: 'Extracts all character states from scene opening',
        defaultTemperature: 0.7,
        placeholders: [
            COMMON_PLACEHOLDERS.userInfo,
            COMMON_PLACEHOLDERS.characterInfo,
            COMMON_PLACEHOLDERS.location,
            COMMON_PLACEHOLDERS.messages,
            COMMON_PLACEHOLDERS.schema,
            COMMON_PLACEHOLDERS.schemaExample,
        ],
        default: `Analyze this roleplay scene and extract all character states. You must only return valid JSON with no commentary.

<instructions>
<general>
- Extract all characters present in the scene.
- For each character, determine their position, activity, mood, physical state, and outfit.
- Make reasonable inferences where information is not explicit.
</general>
<outfit_rules>
- Consider whether the character would usually wear clothes (ponies, PokÃ©mon, animals typically don't).
- For non-clothed species, return null for all outfit slots unless explicitly dressed.
- Be specific: 't-shirt' not 'default top' or 'unspecified top'.
- Include underwear/socks with reasonable assumptions for clothed characters.
- Fur, scales, and other anatomy do NOT count as outfit items.
- If clothing is described as removed or off, set that slot to null.
- neck slot: necklaces, chokers, scarves, ties, collars.
- back slot: backpacks, quivers, cloaks, capes, messenger bags, holsters.
</outfit_rules>
</instructions>

<examples>
<example>
<input>
*The coffee shop was quiet for a Monday morning. Elena sat in her usual corner booth, laptop open but ignored as she stared out the rain-streaked window. She'd thrown on her favorite oversized cardigan over a simple white tank top before leaving the apartment, paired with the worn jeans she always reached for on days when she needed comfort. Her hair was still damp from the shower, pulled back in a messy ponytail that dripped occasionally onto her shoulders.*

*She wrapped both hands around her latte, letting the warmth seep into her fingers. The shop's AC was cranked too high, as usual, and she wished she'd worn something warmer. Her phone buzzed on the tableâ€”probably Marcus againâ€”but she couldn't bring herself to look at it yet. Instead, she watched a businessman outside struggle with his umbrella in the wind, his expensive suit getting splattered despite his efforts.*

*Her laptop pinged with a new email notification. Work. Always work. Elena sighed and finally pulled the computer closer, resigned to dealing with whatever crisis had erupted overnight. Her reading glasses were somewhere in her bag, but she didn't feel like digging for them.*
</input>
<output>
[{
  "name": "Elena",
  "position": "Corner booth by window",
  "activity": "Reluctantly checking work emails, holding latte",
  "mood": ["melancholy", "reluctant", "tired"],
  "physicalState": ["cold", "damp hair"],
  "outfit": {
    "head": null,
    "neck": null,
    "jacket": "Oversized cardigan",
    "back": null,
    "torso": "White tank top",
    "legs": "Worn comfortable jeans",
    "underwear": "Cotton bra and panties",
    "socks": "Ankle socks",
    "footwear": "Canvas sneakers"
  }
}]
</output>
<explanation>
- position: "Corner booth by window" - spatial location extracted from "usual corner booth" and "stared out the window"
- activity: Combines her current action (checking emails) with physical detail (holding latte) to paint the scene
- mood: Multiple moods captured - "melancholy" from window staring, "reluctant" from avoiding phone/emails, "tired" from overall tone
- physicalState: "cold" (AC too high, wished for warmer clothes) and "damp hair" (still wet from shower)
- outfit inference reasoning:
  * jacket: "Oversized cardigan" explicitly mentioned
  * torso: "White tank top" explicitly mentioned
  * legs: "Worn jeans" explicitly mentioned, added "comfortable" based on context about comfort-seeking
  * underwear: NOT mentioned, but inferred as "Cotton bra and panties" - simple, practical choice matching the casual comfort-focused outfit. A tank top requires a bra; the casual vibe suggests cotton over lace
  * socks: NOT mentioned, but inferred as "Ankle socks" - jeans typically worn with socks; casual outfit suggests simple ankle socks
  * footwear: NOT mentioned, but inferred as "Canvas sneakers" - casual comfort outfit + rainy day + jeans strongly suggests sneakers over heels or sandals
  * neck: null - no neckwear mentioned or contextually implied
  * back: null - she's sitting in a cafe, no bag/backpack mentioned
- Key principle: NEVER use "unspecified" or "unknown" - always make a reasonable inference based on the outfit style, occasion, and character context
</explanation>
</example>

<example>
<input>
*Detective Morrison entered the precinct looking like he hadn't slept in daysâ€”which, to be fair, he hadn't. His tie was loosened, top button undone, and his usually crisp white dress shirt had developed a concerning coffee stain near the pocket. The shoulder holster was visible under his rumpled gray suit jacket, service weapon a familiar weight against his ribs.*

*He tossed his badge on the desk and dropped into his chair with a groan, the old springs protesting loudly. Three days on this case and they were no closer to finding the girl. The case files were still spread across his desk from last night, photos and reports mixed together in organized chaos that only made sense to him.*

*His partner Chen looked up from her own desk, raising an eyebrow at his disheveled state. She was, as always, immaculately put togetherâ€”pressed navy blazer, hair in a perfect bun, not a wrinkle in sight. How she managed it on the same hours he was working remained one of life's great mysteries.*

Morrison: "Don't say it."
Chen: "Wasn't going to say anything." *She slid a fresh coffee across the desk toward him.* "You look like hell, by the way."
</input>
<output>
[{
  "name": "Morrison",
  "position": "At his desk",
  "activity": "Just arrived, accepting coffee from partner",
  "mood": ["exhausted", "frustrated", "grimly determined"],
  "physicalState": ["sleep-deprived", "disheveled"],
  "outfit": {
    "head": null,
    "neck": "Loosened striped tie",
    "jacket": "Rumpled gray suit jacket",
    "back": null,
    "torso": "White dress shirt (coffee-stained, top button undone)",
    "legs": "Gray suit trousers",
    "underwear": "White undershirt, boxers",
    "socks": "Black dress socks",
    "footwear": "Black leather oxfords"
  }
},
{
  "name": "Chen",
  "position": "At her desk across from Morrison",
  "activity": "Offering coffee to partner, light teasing",
  "mood": ["alert", "professional", "slightly amused"],
  "physicalState": [],
  "outfit": {
    "head": null,
    "neck": "Simple gold chain necklace",
    "jacket": "Pressed navy blazer",
    "back": null,
    "torso": "White silk blouse",
    "legs": "Navy dress trousers",
    "underwear": "Seamless nude bra and panties",
    "socks": "Sheer nude knee-highs",
    "footwear": "Navy low heels"
  }
}]
</output>
<explanation>
TWO characters extracted - both detectives present in the scene.

Morrison:
- physicalState: "sleep-deprived" and "disheveled" - multiple states can coexist
- outfit details: State descriptors in parentheses - "(coffee-stained, top button undone)" for the shirt
- legs: "Gray suit trousers" inferred to match the "gray suit jacket" - suits come as sets
- underwear: "White undershirt, boxers" - male detective in a suit would typically wear an undershirt; boxers are standard professional default for men
- socks: "Black dress socks" - standard with suit and dark shoes
- footwear: "Black leather oxfords" - classic detective/professional male footwear, matches suit

Chen:
- mood includes "slightly amused" from her teasing
- outfit is described as immaculate/pressed - reflects personality
- torso: "White silk blouse" inferred - blazers typically worn over blouses in professional settings; silk matches her put-together appearance
- underwear: "Seamless nude bra and panties" - professional women often wear seamless undergarments under fitted clothing to avoid visible lines
- socks: "Sheer nude knee-highs" - professional women in trousers often wear knee-highs rather than full pantyhose for comfort
- footwear: "Navy low heels" - matches the navy blazer, professional but practical for detective work

Key inference principles:
1. Match underwear formality to outfit formality (silk blouse â†’ nicer undergarments)
2. Consider practicality (detective work â†’ low heels, not stilettos)
3. Color coordinate where logical (navy suit pieces together)
4. Account for gender norms in professional settings
</explanation>
</example>

<example>
<input>
*The Pikachu bounced excitedly around the Pokemon Center lobby, cheeks sparking with barely contained electricity. Its trainer, a young woman with bright pink hair, was trying desperately to calm it down before it short-circuited the healing machines again.*

Nurse Joy: "Perhaps some fresh air would help? The courtyard is lovely this time of day."

*The trainerâ€”her name tag read 'Zoe'â€”sighed and scooped up the energetic electric mouse, tucking it under her arm like a fuzzy yellow football. She was dressed for travel: sturdy hiking boots, cargo shorts with about a million pockets, and a fitted black athletic top that had seen better days. A large backpack sat on the bench behind her, covered in patches from different gym badges and travel destinations.*

Zoe: "Sorry, he gets like this after battles. Too much energy and nowhere to put it."

*The Pikachu's ears twitched, and it let out a cheerful 'Pika!' before settling down slightly, though its tail still wagged against Zoe's hip.*
</input>
<output>
[{
  "name": "Pikachu",
  "position": "Being held under Zoe's arm",
  "activity": "Calming down after excitement, tail wagging",
  "mood": ["excited", "energetic", "happy"],
  "physicalState": ["excess electrical charge"],
  "outfit": {
    "head": null,
    "neck": null,
    "jacket": null,
    "back": null,
    "torso": null,
    "legs": null,
    "underwear": null,
    "socks": null,
    "footwear": null
  }
},
{
  "name": "Zoe",
  "position": "Near Pokemon Center lobby bench",
  "activity": "Holding Pikachu, apologizing to Nurse Joy",
  "mood": ["exasperated", "apologetic", "fond"],
  "physicalState": [],
  "outfit": {
    "head": null,
    "neck": null,
    "jacket": null,
    "back": "Large travel backpack (on bench)",
    "torso": "Black fitted athletic top (worn)",
    "legs": "Cargo shorts with multiple pockets",
    "underwear": "Sports bra and athletic briefs",
    "socks": "Thick hiking socks",
    "footwear": "Sturdy hiking boots"
  }
},
{
  "name": "Nurse Joy",
  "position": "Behind Pokemon Center counter",
  "activity": "Suggesting the courtyard, being helpful",
  "mood": ["patient", "helpful", "professional"],
  "physicalState": [],
  "outfit": {
    "head": "Nurse cap",
    "neck": null,
    "jacket": null,
    "back": null,
    "torso": "Pink nurse uniform dress",
    "legs": "Pink nurse uniform dress",
    "underwear": "White practical bra and panties",
    "socks": "White knee-high stockings",
    "footwear": "White nursing shoes"
  }
}]
</output>
<explanation>
THREE characters extracted, including the Pokemon:

Pikachu (non-human):
- ALL outfit slots are null - Pokemon don't wear clothes by default
- physicalState: "excess electrical charge" - this IS tracked for non-humans as it's a relevant physical condition
- mood still tracked normally - Pokemon have emotions

Zoe (Pokemon trainer):
- outfit matches "dressed for travel" description with practical/athletic theme
- underwear: "Sports bra and athletic briefs" - inferred from athletic top and active lifestyle. Someone in hiking gear and athletic wear would wear athletic undergarments, not lace
- socks: "Thick hiking socks" - hiking boots require substantial socks; this is a practical inference
- State descriptor "(worn)" added to athletic top since text mentioned "had seen better days"

Nurse Joy (uniform character):
- Iconic uniform character - nurse cap, pink dress, white accessories
- torso AND legs both list "Pink nurse uniform dress" - it's a single garment covering both
- underwear: "White practical bra and panties" - professional medical setting suggests practical, likely white to not show under uniform
- socks: "White knee-high stockings" - traditional nurse uniform includes white stockings
- footwear: "White nursing shoes" - comfortable, professional medical footwear

Key species principle: Pokemon, animals, and non-humanoid creatures get null for ALL outfit slots unless they're explicitly wearing something (like a Pokemon costume or accessory). But they still have mood and physicalState.
</explanation>
</example>

<bad_example>
<output>
[{
  "name": "Elena",
  "outfit": {
    "head": null,
    "neck": null,
    "jacket": "Cardigan",
    "back": null,
    "torso": "Tank top",
    "legs": "Jeans",
    "underwear": "Unspecified undergarments",
    "socks": "Unknown",
    "footwear": "Shoes"
  }
}]
</output>
<why_bad>
- "Unspecified undergarments" and "Unknown" are NEVER acceptable - always infer based on outfit style and context
- Outfit items lack detail: "Cardigan" should be "Oversized cardigan", "Tank top" should be "White tank top", "Jeans" should be "Worn comfortable jeans"
- "Shoes" is too vague - specify the type based on outfit context (sneakers, heels, boots, etc.)
- Missing state descriptors where relevant
- Should infer: casual outfit = cotton underwear, ankle socks, canvas sneakers
</why_bad>
</bad_example>
</examples>

<character_info>
{{userInfo}}

{{characterInfo}}
</character_info>

<current_location>
{{location}}
</current_location>

<scene_messages>
{{messages}}
</scene_messages>

<schema>
{{schema}}
</schema>

<output_example>
{{schemaExample}}
</output_example>

Extract all characters as valid JSON array:`,
    },
    characters_update: {
        key: 'characters_update',
        name: 'Characters - Update',
        description: 'Updates character states based on recent messages',
        defaultTemperature: 0.7,
        placeholders: [
            COMMON_PLACEHOLDERS.location,
            COMMON_PLACEHOLDERS.previousState,
            COMMON_PLACEHOLDERS.messages,
            COMMON_PLACEHOLDERS.schema,
            COMMON_PLACEHOLDERS.schemaExample,
        ],
        default: `Analyze these roleplay messages and update character states. You must only return valid JSON with no commentary.

<instructions>
<general>
- Start from the previous state and apply changes from the messages.
- Watch for: characters entering/exiting, position changes, mood shifts, outfit changes.
</general>
<presence_tracking>
CRITICAL: Track which characters are PRESENT in the scene.

REMOVE characters who have LEFT:
- Walked out of the building/location entirely
- Went to another room AND closed the door behind them
- Drove/ran/walked away out of sight
- Any situation where POV character can no longer see or interact with them

ADD characters who have ENTERED:
- Arrived at the location (came home, walked in, etc.)
- Came into the room from elsewhere in the building
- Appeared/showed up in the scene

If a character leaves, they should NOT be in the output array.
If a character enters, ADD them with inferred state from context.
</presence_tracking>
<outfit_tracking>
- If clothing is removed, set that slot to null.
- Add removed clothing to location props (handled separately, just set slot to null here).
- Do NOT suffix with '(off)', '(removed)' - just set to null.
- Be specific about partially removed items: 'white panties (pulled aside)'.
- Track which foot if only one shoe/sock remains.
- neck slot: necklaces, chokers, scarves, ties, collars.
- back slot: backpacks, quivers, cloaks, capes, messenger bags.
</outfit_tracking>
<position_and_mood>
- Update positions as characters move.
- Update moods based on dialogue, reactions, internal thoughts.
</position_and_mood>
<pruning>
- Clear physical states that have resolved.
</pruning>
</instructions>

<examples>
<example>
<input>
*Elena stretched her arms over her head with a yawn, then reached down to unzip her boots. The left one came off easily, thudding to the floor beside the couch, but the right one's zipper stuck halfway. She muttered a curse and tugged harder until it finally gave way, sending her sock-clad foot free.*

*She wiggled her toes gratefully and pulled her legs up onto the cushions, tucking them beneath her. The blazer she'd been wearing all day felt suddenly suffocating, so she shrugged out of it and tossed it over the back of the couch. Much better. She loosened the top two buttons of her blouse, feeling like she could finally breathe.*

Marcus: *glancing up from his laptop* "Long day?"

Elena: "You have no idea." *She pulled the elastic from her hair, shaking her ponytail loose and running her fingers through it.* "Peterson had me in meetings from nine to six. I think I've permanently lost feeling in my feet."

*She rubbed her neck, tilting her head from side to side to work out the knots. The headache that had been building all afternoon was finally starting to fade now that she was home.*
</input>
<previous_state>
[{
  "name": "Elena",
  "position": "Standing in the entryway",
  "activity": "Just arriving home",
  "mood": ["tired", "stressed"],
  "physicalState": ["tension headache"],
  "outfit": {
    "head": "Hair in ponytail",
    "neck": "Pearl earrings and simple silver necklace",
    "jacket": "Charcoal gray blazer",
    "back": null,
    "torso": "White silk blouse",
    "legs": "Black pencil skirt",
    "underwear": "Nude seamless bra and panties",
    "socks": "Sheer black knee-highs",
    "footwear": "Black leather ankle boots"
  }
},
{
  "name": "Marcus",
  "position": "On the living room couch",
  "activity": "Working on laptop",
  "mood": ["focused", "relaxed"],
  "physicalState": [],
  "outfit": {
    "head": null,
    "neck": null,
    "jacket": null,
    "back": null,
    "torso": "Navy henley shirt",
    "legs": "Gray sweatpants",
    "underwear": "Boxer briefs",
    "socks": "White athletic socks",
    "footwear": null
  }
}]
</previous_state>
<output>
[{
  "name": "Elena",
  "position": "Curled up on the couch",
  "activity": "Decompressing, talking with Marcus",
  "mood": ["exhausted", "relieved", "comfortable"],
  "physicalState": ["sore feet", "neck tension", "headache fading"],
  "outfit": {
    "head": null,
    "neck": "Pearl earrings and simple silver necklace",
    "jacket": null,
    "back": null,
    "torso": "White silk blouse (top buttons undone)",
    "legs": "Black pencil skirt",
    "underwear": "Nude seamless bra and panties",
    "socks": "Sheer black knee-highs",
    "footwear": null
  }
},
{
  "name": "Marcus",
  "position": "On the living room couch",
  "activity": "Working on laptop, chatting with Elena",
  "mood": ["focused", "relaxed", "attentive"],
  "physicalState": [],
  "outfit": {
    "head": null,
    "neck": null,
    "jacket": null,
    "back": null,
    "torso": "Navy henley shirt",
    "legs": "Gray sweatpants",
    "underwear": "Boxer briefs",
    "socks": "White athletic socks",
    "footwear": null
  }
}]
</output>
<explanation>
Multiple changes tracked for Elena:

POSITION changed: "Standing in the entryway" â†’ "Curled up on the couch" - she moved and changed posture

MOOD evolved: "tired, stressed" â†’ "exhausted, relieved, comfortable" - same base tiredness but context shifted to being home

PHYSICAL STATE updated:
- "tension headache" â†’ "headache fading" - still present but improving, as noted in text
- Added "sore feet" and "neck tension" - explicitly mentioned complaints

OUTFIT changes (4 items affected):
1. head: "Hair in ponytail" â†’ null - she removed the elastic and let her hair down
2. jacket: "Charcoal gray blazer" â†’ null - tossed over back of couch (FULLY removed = null)
3. torso: "White silk blouse" â†’ "White silk blouse (top buttons undone)" - PARTIALLY changed, so we keep the item but add state descriptor
4. footwear: "Black leather ankle boots" â†’ null - both boots removed (note: we don't need to track each boot separately since both were removed)

Items that did NOT change remain exactly as they were: legs, underwear, socks

Marcus: Minimal changes - just added "attentive" to mood since he asked about her day. Everything else unchanged.

Key principles demonstrated:
- Fully removed items â†’ null (blazer, boots, hair elastic)
- Partially modified items â†’ keep item with state descriptor (blouse with buttons undone)
- Hair accessories count as "head" slot
- Physical states can be updated/evolved, not just added/removed
</explanation>
</example>

<example>
<input>
*The rain had soaked through everything. Marcus peeled off his ruined leather jacketâ€”beyond saving at this pointâ€”and dropped it in a wet heap by the door. His t-shirt underneath was plastered to his skin, and he grabbed the hem and pulled it over his head without ceremony, revealing the fresh bandage wrapped around his ribs.*

Elena: *eyes widening* "Jesus, what happened to you?"

Marcus: "Just a scratch." *He kicked off his waterlogged boots, grimacing as he put weight on his left ankle.* "The other guy looks worse."

*He limped toward the bathroom, leaving a trail of wet footprints on the hardwood. His jeans hung heavy with water, but he couldn't deal with those until he got somewhere with a towel. His socks squelched with every stepâ€”definitely ruined.*

Elena: "Marcus, that bandage is bleeding through. Sit down, let me look at it."

*He paused at the bathroom door, one hand braced against the frame. In the better lighting, Elena could see the bruise forming along his jaw and the split in his lip that was still seeping.*

Marcus: "I'm fine. Just need to dry off."
</input>
<previous_state>
[{
  "name": "Marcus",
  "position": "Outside, approaching the building",
  "activity": "Making his way home in the rain",
  "mood": ["determined", "pained"],
  "physicalState": ["injured ribs (bandaged)"],
  "outfit": {
    "head": null,
    "neck": null,
    "jacket": "Black leather jacket",
    "back": null,
    "torso": "Gray cotton t-shirt",
    "legs": "Dark blue jeans",
    "underwear": "Black boxer briefs",
    "socks": "Black crew socks",
    "footwear": "Brown leather boots"
  }
},
{
  "name": "Elena",
  "position": "In the apartment living room",
  "activity": "Waiting anxiously",
  "mood": ["worried", "anxious"],
  "physicalState": [],
  "outfit": {
    "head": null,
    "neck": null,
    "jacket": null,
    "back": null,
    "torso": "Oversized band t-shirt",
    "legs": "Cotton sleep shorts",
    "underwear": "Cotton panties, no bra",
    "socks": null,
    "footwear": null
  }
}]
</previous_state>
<output>
[{
  "name": "Marcus",
  "position": "At bathroom doorway",
  "activity": "Refusing medical attention, bracing against door frame",
  "mood": ["stubborn", "pained", "dismissive"],
  "physicalState": ["injured ribs (bandaged, bleeding through)", "sprained left ankle", "bruised jaw", "split lip (bleeding)", "soaking wet"],
  "outfit": {
    "head": null,
    "neck": null,
    "jacket": null,
    "back": null,
    "torso": null,
    "legs": "Dark blue jeans (waterlogged)",
    "underwear": "Black boxer briefs",
    "socks": "Black crew socks (soaked, ruined)",
    "footwear": null
  }
},
{
  "name": "Elena",
  "position": "In the apartment living room",
  "activity": "Trying to get Marcus to accept help",
  "mood": ["alarmed", "worried", "frustrated"],
  "physicalState": [],
  "outfit": {
    "head": null,
    "neck": null,
    "jacket": null,
    "back": null,
    "torso": "Oversized band t-shirt",
    "legs": "Cotton sleep shorts",
    "underwear": "Cotton panties, no bra",
    "socks": null,
    "footwear": null
  }
}]
</output>
<explanation>
Significant changes to Marcus after a rough encounter:

POSITION: "Outside, approaching the building" â†’ "At bathroom doorway" - tracked his movement through the scene

ACTIVITY: Updated to current action with posture detail

MOOD: "determined, pained" â†’ "stubborn, pained, dismissive" - evolved based on his dialogue and refusal of help

PHYSICAL STATE (major updates):
- "injured ribs (bandaged)" â†’ "injured ribs (bandaged, bleeding through)" - state worsened/more visible
- Added "sprained left ankle" - grimacing when putting weight on it
- Added "bruised jaw" - Elena sees it in better lighting
- Added "split lip (bleeding)" - seeping mentioned
- Added "soaking wet" - general state from rain

OUTFIT changes with STATE DESCRIPTORS:
- jacket: "Black leather jacket" â†’ null - removed and dropped (described as ruined, but that's the location prop system's concern)
- torso: "Gray cotton t-shirt" â†’ null - pulled off, revealing bandage
- legs: "Dark blue jeans" â†’ "Dark blue jeans (waterlogged)" - NOT removed but state changed significantly
- socks: "Black crew socks" â†’ "Black crew socks (soaked, ruined)" - still wearing them but state matters
- footwear: "Brown leather boots" â†’ null - kicked off

Elena's changes are minor:
- mood: "worried, anxious" â†’ "alarmed, worried, frustrated" - escalated upon seeing his condition
- activity: Updated to reflect her current action
- Everything else unchanged

Key principles:
- Use state descriptors for items affected but not removed: "(waterlogged)", "(soaked, ruined)"
- Physical states can stack - list all relevant conditions
- Update physical state descriptors when conditions change: "(bandaged)" â†’ "(bandaged, bleeding through)"
- Track position changes through the scene
</explanation>
</example>

<example>
<input>
*The dance studio mirrors reflected their movements as Elena helped Sarah through the routine one more time. Sarah had finally gotten the hang of the footwork, her sneakers squeaking against the polished floor as she spun. But the August heat was brutal even with the AC running, and both women were feeling it.*

Elena: "Take five, you've earned it." *She grabbed her water bottle from the bench and took a long drink, then poured some over the back of her neck.* "God, it's like a sauna in here."

*Sarah flopped down onto the floor, sprawling on her back with her arms spread wide. She pulled her tank top away from her skin, fanning herself with the fabric.*

Sarah: "I don't know how you do this for a living. I'm dying."

*Elena laughed and sat down beside her, stretching her legs out. She reached down and pulled off her dance sneakers, peeling away the damp socks underneath and tossing them toward her bag. Her feet were red and sore from two hours of practice.*

Sarah: *sitting up and doing the same* "Yeah, okay, that's a good idea." *She kicked off her own sneakers but left her socks on, too tired to bother.*

*They sat in companionable silence for a moment, catching their breath. Elena pulled her damp sports bra strap away from her shoulder, unsticking it from her skin with a grimace.*
</input>
<previous_state>
[{
  "name": "Elena",
  "position": "Center of dance floor",
  "activity": "Teaching dance routine",
  "mood": ["patient", "encouraging", "focused"],
  "physicalState": ["sweating"],
  "outfit": {
    "head": "Hair in high bun",
    "neck": null,
    "jacket": null,
    "back": null,
    "torso": "Black sports bra",
    "legs": "Gray yoga leggings",
    "underwear": "Athletic thong",
    "socks": "White no-show dance socks",
    "footwear": "Black dance sneakers"
  }
},
{
  "name": "Sarah",
  "position": "Center of dance floor",
  "activity": "Learning dance routine, practicing spins",
  "mood": ["determined", "slightly frustrated", "improving"],
  "physicalState": ["sweating", "tired"],
  "outfit": {
    "head": "Ponytail",
    "neck": null,
    "jacket": null,
    "back": null,
    "torso": "Light blue tank top",
    "legs": "Black athletic shorts",
    "underwear": "Sports bra and boyshorts",
    "socks": "White ankle socks",
    "footwear": "White running sneakers"
  }
}]
</previous_state>
<output>
[{
  "name": "Elena",
  "position": "Sitting on dance floor near bench",
  "activity": "Taking a break, cooling off",
  "mood": ["relaxed", "amused", "overheated"],
  "physicalState": ["sweating heavily", "sore feet", "overheated"],
  "outfit": {
    "head": "Hair in high bun",
    "neck": null,
    "jacket": null,
    "back": null,
    "torso": "Black sports bra (damp)",
    "legs": "Gray yoga leggings",
    "underwear": "Athletic thong",
    "socks": null,
    "footwear": null
  }
},
{
  "name": "Sarah",
  "position": "Sitting on dance floor",
  "activity": "Taking a break, recovering",
  "mood": ["exhausted", "relieved", "companionable"],
  "physicalState": ["sweating heavily", "exhausted", "overheated"],
  "outfit": {
    "head": "Ponytail",
    "neck": null,
    "jacket": null,
    "back": null,
    "torso": "Light blue tank top (pulled away from skin)",
    "legs": "Black athletic shorts",
    "underwear": "Sports bra and boyshorts",
    "socks": "White ankle socks",
    "footwear": null
  }
}]
</output>
<explanation>
Both characters taking a break with different clothing changes:

ELENA:
- position: Moved from "Center of dance floor" to "Sitting on dance floor near bench"
- physicalState: Expanded from just "sweating" to "sweating heavily", "sore feet", "overheated" - conditions worsened/more detailed
- outfit changes:
  * torso: Added state "(damp)" - the sports bra is wet from sweat (pulling strap away from skin)
  * socks: "White no-show dance socks" â†’ null - explicitly removed and tossed toward bag
  * footwear: "Black dance sneakers" â†’ null - pulled off
  * head stays "Hair in high bun" - not mentioned as changed

SARAH:
- position: Changed to floor from standing/dancing
- physicalState: "sweating, tired" â†’ "sweating heavily, exhausted, overheated" - more intense after practice
- outfit changes:
  * torso: Added state "(pulled away from skin)" - she's fanning herself with it
  * footwear: "White running sneakers" â†’ null - kicked off
  * socks: UNCHANGED at "White ankle socks" - explicitly mentioned she left them on ("too tired to bother")

Key principles demonstrated:
- When text explicitly says someone DIDN'T remove something, keep it
- State descriptors for how clothing is currently being worn: "(pulled away from skin)"
- Physical states can intensify: "sweating" â†’ "sweating heavily"
- Both characters can have outfit changes in the same message - track each separately
</explanation>
</example>

<example type="character_leaving">
<input>
*The argument had gone on long enough. Marcus slammed his palm against the table.*

Marcus: "I can't do this right now." *He pushed back from the table, chair scraping loudly against the floor.* "I need some air."

*Without waiting for a response, he grabbed his jacket from the back of the chair and strode toward the front door. Elena started to follow, but he held up a hand without turning around.*

Marcus: "Don't."

*The door opened, closed firmly behind him. Through the window, Elena watched him disappear down the street, his shoulders hunched against the cold night air.*

*Lily reached over and put a hand on Elena's arm.*

Lily: "Give him time. He'll come around."

Elena: *sinking back into her chair, voice hollow* "Will he though?"
</input>
<previous_state>
[{
  "name": "Marcus",
  "position": "At kitchen table",
  "activity": "Arguing with Elena",
  "mood": ["angry", "frustrated", "hurt"],
  "physicalState": [],
  "outfit": {
    "head": null,
    "neck": null,
    "jacket": null,
    "back": null,
    "torso": "Gray sweater",
    "legs": "Dark jeans",
    "underwear": "Boxer briefs",
    "socks": "Black socks",
    "footwear": "Boots"
  }
},
{
  "name": "Elena",
  "position": "At kitchen table",
  "activity": "Arguing with Marcus",
  "mood": ["defensive", "upset", "pleading"],
  "physicalState": [],
  "outfit": {
    "head": null,
    "neck": null,
    "jacket": null,
    "back": null,
    "torso": "Cream sweater",
    "legs": "Leggings",
    "underwear": "Bra and panties",
    "socks": "Fuzzy socks",
    "footwear": null
  }
},
{
  "name": "Lily",
  "position": "At kitchen table",
  "activity": "Witnessing the argument",
  "mood": ["uncomfortable", "worried"],
  "physicalState": [],
  "outfit": {
    "head": null,
    "neck": null,
    "jacket": null,
    "back": null,
    "torso": "Green cardigan over white tee",
    "legs": "Jeans",
    "underwear": "Bra and panties",
    "socks": "Ankle socks",
    "footwear": "Canvas sneakers"
  }
}]
</previous_state>
<output>
[{
  "name": "Elena",
  "position": "At kitchen table",
  "activity": "Processing Marcus leaving",
  "mood": ["defeated", "hurt", "hollow"],
  "physicalState": [],
  "outfit": {
    "head": null,
    "neck": null,
    "jacket": null,
    "back": null,
    "torso": "Cream sweater",
    "legs": "Leggings",
    "underwear": "Bra and panties",
    "socks": "Fuzzy socks",
    "footwear": null
  }
},
{
  "name": "Lily",
  "position": "At kitchen table",
  "activity": "Comforting Elena",
  "mood": ["sympathetic", "concerned"],
  "physicalState": [],
  "outfit": {
    "head": null,
    "neck": null,
    "jacket": null,
    "back": null,
    "torso": "Green cardigan over white tee",
    "legs": "Jeans",
    "underwear": "Bra and panties",
    "socks": "Ankle socks",
    "footwear": "Canvas sneakers"
  }
}]
</output>
<explanation>
CHARACTER LEAVING SCENE (3 â†’ 2 characters):
- Marcus LEFT THE SCENE entirely (went out the front door, watched disappearing down street)
- He is REMOVED from the output array - do not include characters who have left
- His jacket was picked up but he left with it - this is NOT a prop left behind

Elena and Lily remain:
- Elena's mood shifted from "defensive, upset, pleading" â†’ "defeated, hurt, hollow"
- Lily's activity updated to "Comforting Elena", mood shifted to "sympathetic, concerned"
- Both outfits unchanged

Key principle: When a character LEAVES (exits building, goes outside, walks away out of sight), REMOVE them from the array entirely.
</explanation>
</example>

<example type="character_leaving_room">
<input>
*The tension in the bedroom was suffocating. Sarah finally threw up her hands.*

Sarah: "I can't talk about this anymore tonight."

*She grabbed her phone from the nightstand and walked out of the bedroom, bare feet padding down the hallway. Jake heard the bathroom door close, then the lock click into place. A moment later, the shower started running.*

*Jake sat on the edge of the bed, staring at the empty doorway. His brother Mike, who had been awkwardly pretending to read in the corner armchair, finally looked up.*

Mike: "Dude... what did you do?"

Jake: "I don't want to talk about it."
</input>
<previous_state>
[{
  "name": "Jake",
  "position": "Sitting on edge of bed",
  "activity": "Having difficult conversation with Sarah",
  "mood": ["guilty", "defensive"],
  "physicalState": [],
  "outfit": {
    "head": null,
    "neck": null,
    "jacket": null,
    "back": null,
    "torso": "White undershirt",
    "legs": "Pajama pants",
    "underwear": "Boxers",
    "socks": null,
    "footwear": null
  }
},
{
  "name": "Sarah",
  "position": "Standing by the window",
  "activity": "Confronting Jake",
  "mood": ["hurt", "angry", "exhausted"],
  "physicalState": [],
  "outfit": {
    "head": null,
    "neck": null,
    "jacket": null,
    "back": null,
    "torso": "Silk nightgown",
    "legs": null,
    "underwear": "Panties only",
    "socks": null,
    "footwear": null
  }
},
{
  "name": "Mike",
  "position": "In corner armchair",
  "activity": "Pretending to read, avoiding eye contact",
  "mood": ["uncomfortable", "awkward"],
  "physicalState": [],
  "outfit": {
    "head": null,
    "neck": null,
    "jacket": null,
    "back": null,
    "torso": "Old band t-shirt",
    "legs": "Basketball shorts",
    "underwear": "Boxers",
    "socks": null,
    "footwear": null
  }
}]
</previous_state>
<output>
[{
  "name": "Jake",
  "position": "Sitting on edge of bed",
  "activity": "Staring at empty doorway",
  "mood": ["guilty", "regretful", "closed off"],
  "physicalState": [],
  "outfit": {
    "head": null,
    "neck": null,
    "jacket": null,
    "back": null,
    "torso": "White undershirt",
    "legs": "Pajama pants",
    "underwear": "Boxers",
    "socks": null,
    "footwear": null
  }
},
{
  "name": "Mike",
  "position": "In corner armchair",
  "activity": "Questioning Jake about what happened",
  "mood": ["concerned", "curious", "awkward"],
  "physicalState": [],
  "outfit": {
    "head": null,
    "neck": null,
    "jacket": null,
    "back": null,
    "torso": "Old band t-shirt",
    "legs": "Basketball shorts",
    "underwear": "Boxers",
    "socks": null,
    "footwear": null
  }
}]
</output>
<explanation>
CHARACTER LEAVING TO ANOTHER ROOM (3 â†’ 2 characters):
- Sarah left the bedroom, went down the hall, bathroom door closed and LOCKED
- She is in a different room with a closed door = NO LONGER PRESENT
- Remove her from the array - she's not in the scene anymore

Jake and Mike remain:
- Jake's activity and mood updated to reflect aftermath
- Mike's activity updated to questioning, mood shifted
- Both outfits unchanged

Key principle: When someone goes to another room AND closes the door (especially locks it), they've left the scene. The POV character cannot see or directly interact with them.
</explanation>
</example>

<example type="pov_moves_leaving_character_behind">
<input>
*The tension in the living room was unbearable. Rachel's roommate Dave had been hovering the entire time, making comments, and I'd finally had enough.*

*I stood up and held out my hand to Rachel.*

"Can we talk? Alone?"

*Rachel glanced at Dave, then back at me. She took my hand and let me pull her up from the couch.*

Rachel: "Yeah. Let's go to my room."

*We walked down the hallway together. I could feel Dave's eyes on our backs. Rachel opened her bedroom door and we stepped inside. She closed it firmly behind us, and I heard her flip the lock.*

*The bedroom was small but cozy - fairy lights strung above the bed, a pile of pillows, her guitar leaning against the wall.*

Rachel: *leaning back against the door, finally relaxing* "God, I'm sorry about him. He means well, he's just..."

"Overprotective?"

Rachel: *laughing softly* "That's one word for it."
</input>
<previous_state>
[{
  "name": "User",
  "position": "On the couch",
  "activity": "Trying to have a conversation with Rachel",
  "mood": ["frustrated", "tense", "hopeful"],
  "physicalState": [],
  "outfit": {
    "head": null,
    "neck": null,
    "jacket": null,
    "back": null,
    "torso": "Black button-up shirt",
    "legs": "Dark jeans",
    "underwear": "Boxer briefs",
    "socks": "Black socks",
    "footwear": null
  }
},
{
  "name": "Rachel",
  "position": "On the couch next to User",
  "activity": "Talking with User",
  "mood": ["nervous", "apologetic", "interested"],
  "physicalState": [],
  "outfit": {
    "head": null,
    "neck": null,
    "jacket": null,
    "back": null,
    "torso": "Cropped sweater",
    "legs": "High-waisted jeans",
    "underwear": "Bra and panties",
    "socks": "Ankle socks",
    "footwear": null
  }
},
{
  "name": "Dave",
  "position": "Armchair across from couch",
  "activity": "Watching User and Rachel, making comments",
  "mood": ["suspicious", "protective", "intrusive"],
  "physicalState": [],
  "outfit": {
    "head": null,
    "neck": null,
    "jacket": null,
    "back": null,
    "torso": "Gaming t-shirt",
    "legs": "Sweatpants",
    "underwear": "Boxers",
    "socks": null,
    "footwear": "Slippers"
  }
}]
</previous_state>
<output>
[{
  "name": "User",
  "position": "Standing in Rachel's bedroom",
  "activity": "Talking privately with Rachel",
  "mood": ["relieved", "curious", "warm"],
  "physicalState": [],
  "outfit": {
    "head": null,
    "neck": null,
    "jacket": null,
    "back": null,
    "torso": "Black button-up shirt",
    "legs": "Dark jeans",
    "underwear": "Boxer briefs",
    "socks": "Black socks",
    "footwear": null
  }
},
{
  "name": "Rachel",
  "position": "Leaning against bedroom door",
  "activity": "Apologizing for Dave, relaxing now that they're alone",
  "mood": ["relieved", "amused", "comfortable"],
  "physicalState": [],
  "outfit": {
    "head": null,
    "neck": null,
    "jacket": null,
    "back": null,
    "torso": "Cropped sweater",
    "legs": "High-waisted jeans",
    "underwear": "Bra and panties",
    "socks": "Ankle socks",
    "footwear": null
  }
}]
</output>
<explanation>
POV CHARACTER MOVES WITH ANOTHER, LEAVING SOMEONE BEHIND (3 â†’ 2 characters):
- User and Rachel BOTH moved from living room to Rachel's bedroom
- Door was closed AND locked behind them
- Dave was left in the living room - he's no longer present in the current scene
- REMOVE Dave from the array - the scene is now in the bedroom, not the living room

User and Rachel remain (they moved together):
- Both have updated positions reflecting the new room
- Both have updated moods - relief at being alone
- Outfits unchanged

Key principle: The scene follows the POV character. When POV moves to a new room with someone and shuts the door, anyone left behind is removed from the array.
</explanation>
</example>

<example type="character_entering">
<input>
*Elena was curled up on the couch reading when she heard keys in the front door. She set her book down, marking her place with a finger.*

*Marcus stepped inside, stomping snow off his boots on the mat. His cheeks were red from the cold, and he was juggling grocery bags in both arms.*

Marcus: "Little help?" *He nodded toward the kitchen, struggling not to drop anything.*

Elena: *jumping up* "I didn't know you were going shopping!"

*She hurried over to grab two of the bags, peeking inside.*

Elena: "Did you get theâ€”"

Marcus: "Yes, I got your weird fancy cheese. And before you ask, yes, they had the good bread."
</input>
<previous_state>
[{
  "name": "Elena",
  "position": "Curled up on the couch",
  "activity": "Reading",
  "mood": ["relaxed", "content"],
  "physicalState": [],
  "outfit": {
    "head": null,
    "neck": null,
    "jacket": null,
    "back": null,
    "torso": "Oversized hoodie",
    "legs": "Yoga pants",
    "underwear": "Sports bra and cotton panties",
    "socks": "Thick wool socks",
    "footwear": null
  }
}]
</previous_state>
<output>
[{
  "name": "Elena",
  "position": "Near the front door",
  "activity": "Helping Marcus with groceries",
  "mood": ["pleasantly surprised", "helpful", "cheerful"],
  "physicalState": [],
  "outfit": {
    "head": null,
    "neck": null,
    "jacket": null,
    "back": null,
    "torso": "Oversized hoodie",
    "legs": "Yoga pants",
    "underwear": "Sports bra and cotton panties",
    "socks": "Thick wool socks",
    "footwear": null
  }
},
{
  "name": "Marcus",
  "position": "Just inside front door",
  "activity": "Arriving home with groceries",
  "mood": ["cold but pleased", "playful"],
  "physicalState": ["cheeks red from cold"],
  "outfit": {
    "head": null,
    "neck": "Scarf",
    "jacket": "Winter coat",
    "back": null,
    "torso": null,
    "legs": "Jeans",
    "underwear": null,
    "socks": null,
    "footwear": "Snow boots"
  }
}]
</output>
<explanation>
CHARACTER ENTERING SCENE:
- Marcus was NOT in previous state - he just arrived home
- ADD him to the array with full state information
- Infer reasonable outfit for context (winter, just came from outside)
- Note visible physical states (red cheeks from cold)

Elena updated:
- Position moved from couch to near front door
- Activity and mood updated
- Outfit unchanged

Key principle: When a character enters (arrives, comes through door, appears), ADD them to the array. Infer what you can about their state from context.
</explanation>
</example>

<example type="character_entering_room">
<input>
*Jake had been working at his desk for hours when the study door creaked open. He glanced up to see Sarah peeking in, two mugs in her hands.*

Sarah: "Peace offering?" *She held up the mugs.* "I made hot chocolate. The good kind, with the little marshmallows."

*Jake leaned back in his chair, rubbing his tired eyes.*

Jake: "I thought you were asleep."

Sarah: *padding over in her slippers* "Couldn't sleep. And I felt bad about earlier." *She set one mug on his desk, wrapping both hands around her own.* "Can we talk? Actually talk this time?"

*She perched on the arm of the leather chair in the corner, tucking her feet up under her robe.*
</input>
<previous_state>
[{
  "name": "Jake",
  "position": "At desk in study",
  "activity": "Working on laptop",
  "mood": ["focused", "tired", "distracted"],
  "physicalState": ["eye strain"],
  "outfit": {
    "head": null,
    "neck": null,
    "jacket": null,
    "back": null,
    "torso": "White undershirt",
    "legs": "Pajama pants",
    "underwear": "Boxers",
    "socks": null,
    "footwear": null
  }
}]
</previous_state>
<output>
[{
  "name": "Jake",
  "position": "Leaning back in desk chair",
  "activity": "Talking with Sarah",
  "mood": ["tired", "cautious", "receptive"],
  "physicalState": ["eye strain", "tired eyes"],
  "outfit": {
    "head": null,
    "neck": null,
    "jacket": null,
    "back": null,
    "torso": "White undershirt",
    "legs": "Pajama pants",
    "underwear": "Boxers",
    "socks": null,
    "footwear": null
  }
},
{
  "name": "Sarah",
  "position": "Perched on arm of leather chair",
  "activity": "Offering peace, wanting to talk",
  "mood": ["apologetic", "hopeful", "nervous"],
  "physicalState": [],
  "outfit": {
    "head": null,
    "neck": null,
    "jacket": "Fluffy robe",
    "back": null,
    "torso": null,
    "legs": null,
    "underwear": null,
    "socks": null,
    "footwear": "Slippers"
  }
}]
</output>
<explanation>
CHARACTER ENTERING FROM ANOTHER ROOM:
- Sarah was NOT present before (she was in bed/elsewhere in house)
- She opened the door and came into the study = now present
- ADD her to the array
- Outfit inferred from context (robe, slippers = nightwear, came from bedroom)

Jake updated:
- Position detail added (leaning back)
- Mood shifted to reflect the interruption and conversation
- Added "tired eyes" to physical state (rubbing eyes)

Key principle: When someone enters from another room (opens door, comes in), add them. They are now present and interactable.
</explanation>
</example>

<bad_example type="missing_entering_character">
<input>
*The front door burst open and both Marcus and his sister Emma tumbled in, laughing and shaking snow off their coats.*

Marcus: "Elena! You're not going to believe what happened at the store!"

Emma: *still giggling* "Tell her about the shopping cart!"

*Elena looked up from her book, eyebrows raised at the commotion.*
</input>
<previous_state>
[{
  "name": "Elena",
  "position": "On the couch",
  "activity": "Reading",
  "mood": ["relaxed"],
  "physicalState": [],
  "outfit": { "torso": "Sweater", "legs": "Leggings" }
}]
</previous_state>
<wrong_output>
[{
  "name": "Elena",
  "position": "On the couch",
  "activity": "Looking up at Marcus",
  "mood": ["curious", "amused"],
  "physicalState": [],
  "outfit": { "torso": "Sweater", "legs": "Leggings" }
},
{
  "name": "Marcus",
  "position": "Just inside front door",
  "activity": "Telling a story",
  "mood": ["excited", "amused"],
  "physicalState": ["snow in hair"],
  "outfit": { "jacket": "Winter coat", "legs": "Jeans", "footwear": "Boots" }
}]
</wrong_output>
<why_bad>
MISSING CHARACTER - Emma entered too but is not in the output!
- Both Marcus AND Emma came through the door together
- Emma is speaking, laughing, interacting - she is clearly present
- The output only includes Marcus, forgetting Emma entirely
- CORRECT output should include all 3 characters: Elena, Marcus, AND Emma
</why_bad>
</bad_example>

<bad_example type="character_not_removed">
<input>
*The argument reached its peak. Sarah grabbed her keys from the counter.*

Sarah: "I can't be here right now. I'm going for a drive."

*She didn't wait for Jake's response, just walked out the front door. Through the window, Jake watched her car back out of the driveway and disappear down the street.*

*Mike, who had been frozen in the kitchen doorway the whole time, finally exhaled.*

Mike: "Dude... that was intense."
</input>
<previous_state>
[{
  "name": "Jake",
  "position": "In the living room",
  "activity": "Arguing with Sarah",
  "mood": ["angry", "defensive"],
  "physicalState": [],
  "outfit": { "torso": "T-shirt", "legs": "Jeans" }
},
{
  "name": "Sarah",
  "position": "In the living room",
  "activity": "Arguing with Jake",
  "mood": ["furious", "hurt"],
  "physicalState": [],
  "outfit": { "torso": "Blouse", "legs": "Skirt" }
},
{
  "name": "Mike",
  "position": "Kitchen doorway",
  "activity": "Awkwardly witnessing",
  "mood": ["uncomfortable"],
  "physicalState": [],
  "outfit": { "torso": "Hoodie", "legs": "Shorts" }
}]
</previous_state>
<wrong_output>
[{
  "name": "Jake",
  "position": "In the living room",
  "activity": "Watching Sarah leave",
  "mood": ["stunned", "regretful"],
  "physicalState": [],
  "outfit": { "torso": "T-shirt", "legs": "Jeans" }
},
{
  "name": "Sarah",
  "position": "Left the house",
  "activity": "Driving away",
  "mood": ["upset"],
  "physicalState": [],
  "outfit": { "torso": "Blouse", "legs": "Skirt" }
},
{
  "name": "Mike",
  "position": "Kitchen doorway",
  "activity": "Commenting on the situation",
  "mood": ["relieved", "concerned"],
  "physicalState": [],
  "outfit": { "torso": "Hoodie", "legs": "Shorts" }
}]
</wrong_output>
<why_bad>
CHARACTER NOT REMOVED - Sarah left but is still in the output!
- Sarah walked out the front door, got in her car, and drove away
- She is GONE from the scene - not in the house anymore
- The output incorrectly keeps her with "position: Left the house"
- NEVER use position to indicate someone left - REMOVE them from the array entirely
- CORRECT output should only include Jake and Mike (2 characters, not 3)
</why_bad>
</bad_example>

<bad_example type="outfit_descriptors">
<output>
[{
  "name": "Elena",
  "outfit": {
    "head": null,
    "neck": null,
    "jacket": null,
    "back": null,
    "torso": "Sports bra (removed from shoulder)",
    "legs": null,
    "underwear": null,
    "socks": "Dance socks (removed)",
    "footwear": "Sneakers (off)"
  }
}]
</output>
<why_bad>
- "(removed)" and "(off)" should NOT be used - set to null instead for fully removed items
- "Sports bra (removed from shoulder)" is wrong - she just pulled the strap, the bra is still on. Should be "Black sports bra (damp)" since it's still being worn
- Socks and footwear should be null, not have removal descriptors
- Use state descriptors only for items still being worn: "(unbuttoned)", "(damp)", "(pulled aside)" - never "(removed)" or "(off)"
</why_bad>
</bad_example>
</examples>

<current_location>
{{location}}
</current_location>

<previous_characters>
{{previousState}}
</previous_characters>

<recent_messages>
{{messages}}
</recent_messages>

<schema>
{{schema}}
</schema>

<output_example>
{{schemaExample}}
</output_example>

Extract updated characters as valid JSON array:`,
    },
    scene_initial: {
        key: 'scene_initial',
        name: 'Scene - Initial',
        description: 'Extracts scene topic, tone, tension, and events from opening',
        defaultTemperature: 0.6,
        placeholders: [
            COMMON_PLACEHOLDERS.characterInfo,
            COMMON_PLACEHOLDERS.charactersSummary,
            COMMON_PLACEHOLDERS.messages,
            COMMON_PLACEHOLDERS.schema,
            COMMON_PLACEHOLDERS.schemaExample,
        ],
        default: `Analyze this roleplay scene and extract the scene state. You must only return valid JSON with no commentary.

<instructions>
<general>
- Determine the topic, tone, tension, and significant events of the scene.
- Topic should be 3-5 words summarizing the main focus.
- Tone should be 2-3 descriptive words capturing the emotional atmosphere (e.g. "Tense, suspicious" or "Warm, playful").
</general>
<tension>
- Direction will be calculated automatically, but set your best guess.
<levels>
Tension levels form a spectrum of emotional/dramatic intensity (applies to ALL tension types):
- relaxed: Low stakes, comfortable. Casual chat, downtime, nothing pressing.
- aware: Mild interest or attention. Something noted but no real stakes yet.
- guarded: Careful, measured. Testing waters - whether for trust, attraction, or safety.
- tense: Stakes feel real. Could be conflict brewing, unspoken attraction, or difficult truth approaching.
- charged: Intense emotions dominate. Anger before a fight, desire before a kiss, fear before confession.
- volatile: On the edge. One word changes everything - into violence, intimacy, or revelation.
- explosive: The moment itself. Fight breaks out, characters kiss or engage in sex, secret revealed, breakdown happens.
</levels>
<types>
Tension type describes the nature of what's driving the tension:
- conversation: Neutral dialogue, information exchange, casual interaction.
- negotiation: Competing interests seeking agreement. Deals, persuasion, bargaining.
- confrontation: Direct opposition or conflict. Arguments, accusations, standoffs.
- intimate: Emotional/physical closeness. Romance, deep sharing, intimacy, sexual tension.
- vulnerable: Exposure of weakness or secrets. Confessions, emotional risk, asking for help.
- suspense: Uncertainty about outcome. Waiting, anticipation, something about to happen.
- celebratory: Positive excitement. Joy, triumph, celebration, shared happiness.
</types>
</tension>
<recent_events>
- Include significant events that affect the ongoing narrative.
- Events should be consequential: discoveries, relationship changes, injuries, commitments.
- Maximum 5 events, prioritize the most important ones.
</recent_events>
</instructions>

<examples>
<example>
<input>
*The restaurant had finally emptied out, the last of the dinner crowd filtering into the rainy night outside. Elena sat across from Marcus in the corner booth, her wine glass mostly untouched, watching him struggle to find the right words. He'd asked her to dinner with that particular tone in his voiceâ€”the one that meant something important was comingâ€”and she'd spent the entire meal waiting for the other shoe to drop.*

*The candles on the table had burned down to stubs, casting flickering shadows across his face. Outside, thunder rumbled in the distance, and the rain intensified against the windows. A waiter hovered near the kitchen door, clearly wanting to close up but too polite to interrupt.*

Elena: "Marcus, whatever it is, just say it. You've been dancing around something all night."

Marcus: *finally meeting her eyes* "I'm leaving. The job in Tokyoâ€”I took it." *He reached across the table, his fingers brushing against hers.* "But I don't want to go without you."

*The words hung in the air between them. Elena felt her heart skip, her mind racing through a thousand implicationsâ€”her career, her family, everything she'd built here. But looking at him now, vulnerable and hopeful and terrified all at once, she realized the answer wasn't as complicated as she'd thought.*
</input>
<output>
{
  "topic": "Life-changing proposal",
  "tone": "Vulnerable, electric, bittersweet",
  "tension": {"level": "charged", "type": "intimate", "direction": "escalating"}
}
</output>
<explanation>
TOPIC: "Life-changing proposal" - captures the weight of what's being asked (not just "dinner conversation" or "relationship talk"). The proposal isn't marriage, but it IS asking her to change her entire life.

TONE: Three words to capture a complex emotional atmosphere:
- "Vulnerable" - Marcus is exposing himself to rejection, Elena is confronting a huge decision
- "Electric" - the air is charged with anticipation and significance
- "Bittersweet" - whatever the answer, something will be lost (either the opportunity or her current life)

TENSION analysis:
- Level "charged": Intense emotions dominate. This is a pivotal momentâ€”not yet at "volatile" (one word changes everything) but definitely beyond "tense" (stakes feel real)
- Type "intimate": This is about emotional/relational closeness, not conflict. Despite the stakes, they're on the same side
- Direction "escalating": Building toward a decision/revelation. The question has been asked; the answer will raise or resolve tension further

Why NOT other levels:
- Not "explosive" - the moment hasn't broken yet, she hasn't answered
- Not "volatile" - there's no sense it could go violent or completely wrong
- Not "tense" - too understated for this pivotal moment
</explanation>
</example>

<example>
<input>
*The precinct bullpen was chaosâ€”phones ringing, detectives shouting across desks, a suspect being dragged toward booking while screaming about his rights. But Captain Rodriguez's office was an island of deadly calm. Sarah sat in the hard plastic chair across from his desk, hands folded in her lap, expression carefully neutral.*

*Rodriguez hadn't said a word since calling her in. He just sat there, reading through the file in front of him, occasionally making small noises of disapproval. The silence stretched unbearably. On the wall behind him, the clock ticked loud enough to hearâ€”2:47 PM. She'd been sitting here for almost five minutes.*

Rodriguez: *finally looking up* "Detective Chen. Thirteen years on the force. Exemplary record." *He closed the file with a soft thump.* "So explain to me why I have Internal Affairs breathing down my neck about a missing evidence log."

Sarah: "Captain, I filed that log myself three days ago. Whatever discrepancy they foundâ€”"

Rodriguez: *holding up a hand* "I've known you a long time, Chen. Which is why I'm giving you exactly one chance to tell me what really happened before this goes any further. Because right now?" *He leaned forward, his voice dropping.* "Right now, it looks like you made something disappear. And I need to know why."

*The accusation landed like a punch. Sarah felt the blood drain from her face, her carefully maintained composure cracking at the edges.*
</input>
<output>
{
  "topic": "Internal affairs accusation",
  "tone": "Ominous, suffocating, accusatory",
  "tension": {"level": "tense", "type": "confrontation", "direction": "escalating"}
}
</output>
<explanation>
TOPIC: "Internal affairs accusation" - specific and consequential. Not just "meeting with captain" or "work trouble." The IA involvement and evidence tampering allegation are the core issue.

TONE: Captures the oppressive atmosphere:
- "Ominous" - the extended silence, the careful reading, the ticking clock all create dread
- "Suffocating" - she's trapped, the room feels small despite the chaos outside, nowhere to go
- "Accusatory" - Rodriguez isn't asking if something happened; he's telling her he knows and demanding explanation

TENSION analysis:
- Level "tense": Stakes feel realâ€”career, reputation, possibly freedom are on the line. The confrontation is direct but still in the "explain yourself" phase
- Type "confrontation": Direct opposition between authority figure and accused. Rodriguez has power; Sarah is defending herself
- Direction "escalating": Building toward a breaking point. Rodriguez is offering "one chance" which implies escalation is coming if she doesn't satisfy him

Why "tense" and not higher:
- Not "charged": That would suggest emotional intensity dominatingâ€”this is more controlled, procedural despite the stakes
- Not "volatile": Nobody's about to snap; this is deliberate pressure, not explosive emotion
- Could become "volatile" or "charged" if she confesses or accuses back, but currently it's a calculated confrontation
</explanation>
</example>

<example>
<input>
*The morning sun streamed through the kitchen windows as Elena padded in wearing Marcus's oversized t-shirt, her hair a mess from sleep. Marcus was already at the stove, the smell of bacon and coffee filling the apartment. He looked over his shoulder and grinned at her sleep-rumpled appearance.*

Marcus: "There she is. I was about to send a search party."

Elena: *yawning hugely* "What time is it?"

Marcus: "Almost eleven. You were out cold." *He slid a mug of coffee across the counter toward her.* "I figured you earned it after last night."

*She wrapped her hands around the warm mug, smiling into the steam. Through the window, she could see the city skyline glittering in the sunshine, the storm from last night nothing but a memory. Her phone buzzed on the counterâ€”probably her sister checking inâ€”but she ignored it. The real world could wait.*

Elena: "Is that bacon I smell?"

Marcus: "And pancakes. The good ones, with the chocolate chips." *He turned back to the stove, but not before she caught the soft expression on his face.* "Sit down, I'll bring you a plate."

*She hopped onto one of the bar stools, tucking her bare feet under her, and watched him cook with a contentment she hadn't felt in years.*
</input>
<output>
{
  "topic": "Lazy morning after",
  "tone": "Warm, domestic, contented",
  "tension": {"level": "relaxed", "type": "intimate", "direction": "stable"}
}
</output>
<explanation>
TOPIC: "Lazy morning after" - captures the context (implied intimacy the night before) and current activity (casual, unhurried morning). Specific enough to be useful, not overly clinical.

TONE: All positive, soft emotions:
- "Warm" - physical (sun, coffee, cooking) and emotional (their dynamic)
- "Domestic" - the comfortable ordinariness of the scene, making breakfast together
- "Contented" - no urgency, no worry, just enjoying the moment

TENSION analysis:
- Level "relaxed": Low stakes, comfortable. Nothing pressing, nobody worried, just enjoying each other
- Type "intimate": Despite the low tension, the TYPE is intimateâ€”they're emotionally/physically close (she's wearing his shirt, he's making her favorite breakfast)
- Direction "stable": No building or releasing of tension. The scene could continue like this indefinitely

Key insight: Low tension doesn't mean the scene isn't meaningful or intimate. "Relaxed" + "intimate" captures a loving, comfortable relationship moment. Not every scene needs conflict.

Why NOT other types:
- Not "conversation" - that implies neutral exchange, but there's clear romantic intimacy here
- Not "celebratory" - they're not celebrating anything specific, just enjoying normalcy
</explanation>
</example>

<bad_example>
<output>
{
  "topic": "Dinner",
  "tone": "Romantic",
  "tension": {"level": "moderate", "type": "emotional", "direction": "building"}
}
</output>
<why_bad>
- topic too vague: "Dinner" could be anything. Should capture what makes THIS dinner significant: "Life-changing proposal"
- tone too simple: "Romantic" is one word and doesn't capture the complexity. Use 2-3 descriptive words: "Vulnerable, electric, bittersweet"
- tension level invalid: "moderate" is not a valid level. Must use: relaxed, aware, guarded, tense, charged, volatile, explosive
- tension type invalid: "emotional" is not a valid type. Must use: conversation, negotiation, confrontation, intimate, vulnerable, suspense, celebratory
- direction invalid: "building" is not valid. Must use: escalating, stable, decreasing
</why_bad>
</bad_example>
</examples>

<character_info>
{{userInfo}}

{{characterInfo}}
</character_info>

<characters_present>
{{charactersSummary}}
</characters_present>

<scene_messages>
{{messages}}
</scene_messages>

<schema>
{{schema}}
</schema>

<output_example>
{{schemaExample}}
</output_example>

Extract the scene state as valid JSON:`,
    },
    scene_update: {
        key: 'scene_update',
        name: 'Scene - Update',
        description: 'Updates scene state based on recent messages',
        defaultTemperature: 0.6,
        placeholders: [
            COMMON_PLACEHOLDERS.charactersSummary,
            COMMON_PLACEHOLDERS.previousState,
            COMMON_PLACEHOLDERS.messages,
            COMMON_PLACEHOLDERS.schema,
            COMMON_PLACEHOLDERS.schemaExample,
        ],
        default: `Analyze these roleplay messages and update the scene state. You must only return valid JSON with no commentary.

<instructions>
<general>
- Update topic if the focus has shifted.
- Update tone if the emotional atmosphere has changed. Use 2-3 descriptive words (e.g. "Tense, suspicious" or "Warm, playful").
- Consider whether tension has increased, decreased, or remained stable.
</general>
<tension>
- Direction will be recalculated based on level change.
- If previous direction was 'stable', strongly consider whether type or level has changed.
<levels>
Tension levels form a spectrum of emotional/dramatic intensity (applies to ALL tension types):
- relaxed: Low stakes, comfortable. Casual chat, downtime, nothing pressing.
- aware: Mild interest or attention. Something noted but no real stakes yet.
- guarded: Careful, measured. Testing waters - whether for trust, attraction, or safety.
- tense: Stakes feel real. Could be conflict brewing, unspoken attraction, or difficult truth approaching.
- charged: Intense emotions dominate. Anger before a fight, desire before a kiss, fear before confession.
- volatile: On the edge. One word changes everything - into violence, intimacy, or revelation.
- explosive: The moment itself. Fight breaks out, characters kiss or engage in sex, secret revealed, breakdown happens.
</levels>
<types>
Tension type describes the nature of what's driving the tension:
- conversation: Neutral dialogue, information exchange, casual interaction.
- negotiation: Competing interests seeking agreement. Deals, persuasion, bargaining.
- confrontation: Direct opposition or conflict. Arguments, accusations, standoffs.
- intimate: Emotional/physical closeness. Romance, deep sharing, intimacy, sexual tension.
- vulnerable: Exposure of weakness or secrets. Confessions, emotional risk, asking for help.
- suspense: Uncertainty about outcome. Waiting, anticipation, something about to happen.
- celebratory: Positive excitement. Joy, triumph, celebration, shared happiness.
</types>
</tension>
<recent_events>
- Keep events that are still relevant to the ongoing scene.
- Remove events that have been resolved or superseded.
- Add new significant events from the recent messages.
- Maximum 5 events - prune aggressively, keep most salient.
- Even if previous_scene has more than 5 events, return at most 5.
</recent_events>
</instructions>

<examples>
<example>
<input>
*Elena set down her wine glass with deliberate care, her laughter from a moment ago fading as something shifted in her expression. Across the table, Marcus was still chuckling about the ridiculous mishap she'd just describedâ€”the time she'd accidentally called her boss "mom" in a board meetingâ€”but Elena wasn't smiling anymore.*

Elena: "Marcus, there's something I need to tell you." *She clasped her hands together on the table, knuckles whitening.* "About that night. The night you found me at the hotel."

*The temperature in the room seemed to drop. Marcus's smile faltered, then disappeared entirely. He'd asked about that night a dozen times over the past six months, and she'd always deflected, always found a way to change the subject. The fact that she was bringing it up now...*

Marcus: "Elena, you don't have toâ€”"

Elena: "Yes, I do." *She finally looked up at him, and he could see the fear there, the vulnerability she usually kept so carefully hidden.* "I wasn't there for a work conference. I was meeting someone. Someone I'd been talking to for months." *Her voice cracked.* "Someone I almost left you for."

*The words hung between them like broken glass.*
</input>
<previous_scene>
{
  "topic": "Sharing embarrassing memories",
  "tone": "Lighthearted, nostalgic, warm",
  "tension": {"level": "relaxed", "type": "conversation", "direction": "stable"}
}
</previous_scene>
<output>
{
  "topic": "Confession of almost-affair",
  "tone": "Heavy, fearful, exposed",
  "tension": {"level": "volatile", "type": "vulnerable", "direction": "escalating"}
}
</output>
<explanation>
DRAMATIC SHIFT in scene state:

TOPIC: "Sharing embarrassing memories" â†’ "Confession of almost-affair"
- The subject matter has completely transformed from light anecdotes to a relationship-threatening revelation
- Topic should reflect what the scene is NOW about, not what it started as

TONE: "Lighthearted, nostalgic, warm" â†’ "Heavy, fearful, exposed"
- Complete tonal reversal - none of the original warmth remains
- "Heavy" - the weight of the confession, the "broken glass" metaphor
- "Fearful" - Elena's visible fear, her vulnerability
- "Exposed" - she's revealing her deepest secret, making herself vulnerable

TENSION changes:
- Level: "relaxed" â†’ "volatile" (jumped multiple levels)
  * This isn't just "tense" - she's confessing to almost ending the relationship
  * "Volatile" = one word changes everything, and her next words could destroy or save them
- Type: "conversation" â†’ "vulnerable"
  * This is about exposure of secrets, emotional risk, not casual exchange
  * She's asking for forgiveness by confessing, putting herself at his mercy
- Direction: "stable" â†’ "escalating"
  * The revelation demands a response; tension is building toward Marcus's reaction

Why "volatile" not "explosive":
- "Explosive" is the moment itself - the fight breaking out, the breakdown happening
- We're AT the edge of explosive, but Marcus hasn't reacted yet
- His response could push it to "explosive" or start de-escalating
</explanation>
</example>

<example>
<input>
*The shouting had finally stopped. Marcus stood by the window, his back to the room, shoulders tight with tension. Elena sat on the edge of the bed where she'd collapsed after their worst fight yet, mascara-streaked tears still drying on her cheeks. Neither of them had spoken in almost five minutes.*

*Finally, Marcus turned around. His expression was unreadable, but when he spoke, his voice was quieter than she'd ever heard it.*

Marcus: "I need to know one thing." *He crossed the room slowly, stopping a few feet from the bed.* "Did you love him?"

Elena: *voice barely a whisper* "No." *She looked up at him, and for the first time tonight, she let him see everythingâ€”the regret, the shame, the desperate hope.* "I was lonely, and I was stupid, and I was looking for something I already had. But I never loved him." *She reached out tentatively.* "I love you. I've only ever loved you."

*Marcus stared at her outstretched hand for a long moment. Then, slowly, he took it.*

Marcus: "Then we figure this out." *He sat down beside her, still holding her hand.* "I don't know how yet, but... we figure it out."
</input>
<previous_scene>
{
  "topic": "Confession of almost-affair",
  "tone": "Heavy, fearful, exposed",
  "tension": {"level": "volatile", "type": "vulnerable", "direction": "escalating"}
}
</previous_scene>
<output>
{
  "topic": "Choosing forgiveness",
  "tone": "Raw, fragile, hopeful",
  "tension": {"level": "charged", "type": "vulnerable", "direction": "decreasing"}
}
</output>
<explanation>
RESOLUTION beginning - tension decreasing but still intense:

TOPIC: "Confession of almost-affair" â†’ "Choosing forgiveness"
- The confession has been made; now the scene is about his response
- "Choosing forgiveness" captures that this is an active decision, not passive acceptance

TONE: "Heavy, fearful, exposed" â†’ "Raw, fragile, hopeful"
- Still emotionally intense, but the quality has shifted
- "Raw" - nerves exposed, both vulnerable, the aftermath of emotional upheaval
- "Fragile" - this reconciliation could still shatter; they're being careful
- "Hopeful" - he took her hand, they're going to try

TENSION changes:
- Level: "volatile" â†’ "charged"
  * Still intense emotions, but the immediate danger has passed
  * "Volatile" (one word changes everything) â†’ "charged" (emotions dominate, but there's direction)
  * He's chosen to stay; that decision lowered the stakes
- Type: Still "vulnerable"
  * This remains about emotional exposure and risk
  * She's still exposed; he's now exposed too by choosing forgiveness
- Direction: "escalating" â†’ "decreasing"
  * The worst moment has passed
  * They're moving toward resolution, not away from it
  * Tension is releasing, though slowly

Why not lower than "charged":
- This isn't "tense" (still too raw for that measured feeling)
- Definitely not "guarded" or "relaxed" - they just had their worst fight ever
- The emotions are still overwhelming; they're just now moving in a positive direction
</explanation>
</example>

<example>
<input>
*The apartment was chaosâ€”balloons everywhere, streamers hanging from every surface, the kitchen counter covered in half-assembled party supplies. Elena stood in the middle of it all, hair in a messy bun, wearing an apron covered in frosting stains, looking utterly frazzled.*

Elena: "The cake is lopsided, Marcus. LOPSIDED." *She gestured at the three-tier monstrosity on the counter.* "Sophie's going to be here in two hours and I haven't even started the frosting and the living room still needsâ€”"

Marcus: *catching her by the shoulders* "Hey. Breathe."

Elena: *taking a shaky breath* "I just want it to be perfect. She only turns five once, and after the year she's had with the hospital and everythingâ€”"

Marcus: "And she's going to love it." *He pulled her into a hug, despite the flour on her apron.* "She's going to love the lopsided cake and the slightly crooked streamers and the balloons that I definitely did not accidentally pop three of while inflating."

Elena: *laughing despite herself* "Three?!"

Marcus: "They were VERY aggressive balloons." *He kissed her forehead.* "Now put me to work. What needs frosting?"

*Elena finally let some of the tension drain from her shoulders. It wasn't going to be perfect. But watching Marcus gamely attempt to wield a piping bag, she realized it was going to be exactly right.*
</input>
<previous_scene>
{
  "topic": "Birthday party crisis",
  "tone": "Frantic, stressed, anxious",
  "tension": {"level": "tense", "type": "suspense", "direction": "escalating"}
}
</previous_scene>
<output>
{
  "topic": "Party preparation teamwork",
  "tone": "Reassured, warm, playful",
  "tension": {"level": "aware", "type": "conversation", "direction": "decreasing"}
}
</output>
<explanation>
STRESS â†’ REASSURANCE transition:

TOPIC: "Birthday party crisis" â†’ "Party preparation teamwork"
- The "crisis" has been reframed as manageable
- Focus shifted from "everything is going wrong" to "we're doing this together"
- Still party prep, but the framing is completely different

TONE: "Frantic, stressed, anxious" â†’ "Reassured, warm, playful"
- Complete reversal through Marcus's intervention
- "Reassured" - he calmed her down, validated her stress, offered help
- "Warm" - the hug, the kiss, the physical comfort
- "Playful" - the balloon joke, her laughing despite herself

TENSION changes:
- Level: "tense" â†’ "aware"
  * "Tense" = stakes feel real (party pressure, Sophie's health history)
  * "Aware" = mild interest/attention, something noted but manageable
  * Marcus successfully lowered the emotional temperature
- Type: "suspense" â†’ "conversation"
  * "Suspense" was about uncertainty (will the party be okay?)
  * Now it's just two people talking, working together
  * The outcome is no longer in question - it'll be fine
- Direction: "escalating" â†’ "decreasing"
  * She was spiraling; now she's grounded
  * The stress is actively dissipating

This shows how quickly tension can shift through emotional support - one conversation completely changed the scene's energy.
</explanation>
</example>

<bad_example>
<output>
{
  "topic": "Sharing embarrassing memories",
  "tone": "Lighthearted, nostalgic, warm",
  "tension": {"level": "relaxed", "type": "conversation", "direction": "stable"}
}
</output>
<why_bad>
This is just copying the previous_scene without analyzing the new messages!
- The messages show a DRAMATIC confession about an almost-affair
- Topic should change: "Sharing embarrassing memories" â†’ "Confession of almost-affair"
- Tone should change completely: "Lighthearted" â†’ "Heavy, fearful, exposed"
- Tension should jump dramatically: "relaxed" â†’ "volatile", "conversation" â†’ "vulnerable"
- Direction should change: "stable" â†’ "escalating"

Always analyze what ACTUALLY happened in the recent_messages and update accordingly. Never just return the previous state unchanged when significant events occurred.
</why_bad>
</bad_example>
</examples>

<characters_present>
{{charactersSummary}}
</characters_present>

<previous_scene>
{{previousState}}
</previous_scene>

<recent_messages>
{{messages}}
</recent_messages>

<schema>
{{schema}}
</schema>

<output_example>
{{schemaExample}}
</output_example>

Extract the updated scene state as valid JSON:`,
    },
    event_extract: {
        key: 'event_extract',
        name: 'Event - Extract',
        description: 'Extracts significant events from recent messages with relationship signals',
        defaultTemperature: 0.4,
        placeholders: [
            COMMON_PLACEHOLDERS.messages,
            COMMON_PLACEHOLDERS.currentRelationships,
            COMMON_PLACEHOLDERS.schema,
            COMMON_PLACEHOLDERS.schemaExample,
        ],
        default: `Analyze these roleplay messages and extract any significant events that occurred. You must only return valid JSON with no commentary.

<instructions>
<general>
- Identify significant events that affect the narrative, relationships, or character development.
- A "significant event" is something consequential: a revelation, promise, conflict, intimate moment, discovery, or decision.
- If nothing significant happened (just casual dialogue or routine actions), return a summary indicating no notable event.
- Focus on what actually happened, not background information or internal thoughts alone.
</general>

<summary_guidelines>
Write a DETAILED 2-sentence summary that captures:
- Specifically what happened (actions, words, reactions)
- Who was involved and their emotional state
- The context and significance of the moment

BAD (too vague): "They kissed."
GOOD: "After weeks of tension, Elena finally pulled Marcus close and kissed him softly, her hands trembling against his chest. He responded by wrapping his arms around her waist and deepening the kiss, neither of them caring that they were standing in the middle of the crowded marketplace."

BAD: "They had an argument."
GOOD: "Marcus's accusation about the missing money sent Elena into a defensive rage, her voice rising as she threw the ledger across the table at him. The confrontation ended with her storming out into the rain, leaving Marcus alone with the shattered remnants of their partnership."
</summary_guidelines>

<event_types>
Select ALL applicable event types (multiple can apply to one event):

CONVERSATION & SOCIAL:
- conversation: General dialogue, discussion, chatting
- confession: Admitting feelings, confessing something, revealing truth
- argument: Verbal conflict, heated disagreement
- negotiation: Making deals, bargaining, compromising

DISCOVERY & SECRETS:
- discovery: Learning new information, revelation
- secret_shared: Voluntarily sharing a secret with someone
- secret_revealed: A secret being exposed (possibly unwillingly)

EMOTIONAL:
- emotional: Emotional vulnerability, showing feelings
- supportive: Providing comfort, emotional support
- rejection: Rejecting someone's advances or request
- comfort: Comforting someone who is distressed
- apology: Apologizing for something done wrong
- forgiveness: Forgiving someone for a transgression

BONDING & CONNECTION:
- laugh: Sharing a genuine laugh, humor, joy together
- gift: Giving or receiving a gift (offered to buy drinks/food, gave a present, brought flowers)
- compliment: Giving sincere praise or compliment (complimented appearance, praised skills, admired qualities)
- tease: Playful teasing, banter, jokes at someone's expense (not mean-spirited)
- flirt: Flirtatious behavior, romantic advances (suggestive comments, winks, innuendo)
- date: Going on a date or romantic outing
- i_love_you: Saying "I love you" or equivalent declaration of love
- sleepover: Sleeping over together (non-sexual, just sharing a bed/space)
- shared_meal: Eating together (breakfast, lunch, dinner, coffee, drinks, snacks together)
- shared_activity: Doing an activity together (games, hobbies, adventures, watching movies)

ROMANTIC INTIMACY:
- intimate_touch: Hand-holding, caressing, non-sexual physical affection
- intimate_kiss: Kissing (any type)
- intimate_embrace: Hugging, cuddling, holding each other
- intimate_heated: Making out, heavy petting, grinding

SEXUAL ACTIVITY (select all that apply):
- intimate_foreplay: Teasing, undressing, building up to sex
- intimate_oral: Oral sexual activity
- intimate_manual: Manual stimulation (hands, fingers)
- intimate_penetrative: Penetrative sex
- intimate_climax: Orgasm, completion

ACTION & DANGER:
- action: Physical activity, doing something concrete
- combat: Fighting, violence, physical conflict
- danger: Threat, peril, risky situation

COMMITMENTS:
- decision: Making a significant choice
- promise: Making a commitment or vow
- betrayal: Breaking trust, backstabbing
- lied: Telling a lie or deceiving someone (NOT for sharing true secrets)

LIFE EVENTS:
- exclusivity: Committing to an exclusive relationship
- marriage: Getting married, wedding ceremony
- pregnancy: Discovering or announcing pregnancy
- childbirth: Having a baby, giving birth

SOCIAL:
- social: Meeting new people, group dynamics
- achievement: Accomplishing a goal, success

EXAMPLES of multi-select:
- A kiss during a love confession = ["confession", "intimate_kiss", "emotional"]
- Revealing a secret while being held = ["secret_shared", "intimate_embrace", "emotional"]
- An argument that turns into a fight = ["argument", "combat"]
- Sex scene = ["intimate_heated", "intimate_foreplay", "intimate_penetrative", "intimate_climax"] (select all that apply)

IMPORTANT: Intimacy types are for ACTUAL physical contact, not discussing intimacy.
- Talking about wanting to kiss someone = ["conversation"] or ["emotional"]
- Actually kissing someone = ["intimate_kiss"]
</event_types>

<event_details>
MANDATORY: You MUST provide an eventDetails entry for EVERY event type you select.
Each entry should be a brief phrase (5-15 words) describing what specifically happened.

Examples by type:
- conversation: "discussed plans for the heist tomorrow night"
- confession: "Elena admitted her romantic feelings for Marcus"
- argument: "fought about whether to trust the informant"
- discovery: "found the hidden compartment in the desk"
- secret_shared: "Elena revealed her TRUE past as a thief"
- secret_revealed: "Marcus's true identity as an agent was exposed"
- emotional: "Elena broke down crying about her father"
- supportive: "Marcus comforted Elena after her breakdown"
- comfort: "held her while she cried about her past"
- apology: "apologized for lying about his identity"
- forgiveness: "forgave Marcus for the betrayal"
- laugh: "shared a genuine laugh at his terrible joke"
- gift: "gave her a hand-carved wooden pendant"
- gift: "offered to buy her dinner at the cafÃ©"
- gift: "brought her favorite coffee as a surprise"
- compliment: "told her she had the most beautiful smile"
- compliment: "praised his bravery in facing the danger"
- tease: "playfully mocked his cooking disaster"
- tease: "joked about his terrible sense of direction"
- flirt: "winked and suggested they find somewhere private"
- flirt: "leaned in close while complimenting her eyes"
- date: "went to the art museum together"
- i_love_you: "told her he loved her for the first time"
- sleepover: "fell asleep together on the couch"
- shared_meal: "had dinner together at the candlelit restaurant"
- shared_meal: "ate breakfast together at the cafÃ©"
- shared_meal: "grabbed coffee and chatted for hours"
- shared_activity: "played cards together into the night"
- shared_activity: "watched the sunset together from the rooftop"
- intimate_kiss: "first kiss in the corner booth"
- intimate_embrace: "held each other on the couch"
- promise: "vowed to protect Elena no matter what"
- betrayal: "sold the information to their enemies"
- lied: "told Marcus she was a teacher when she's actually a spy"

CRITICAL - SECRET_SHARED vs LIED:
- secret_shared: Character shares a TRUE secret about themselves (real past, real identity, real feelings)
- lied: Character tells something FALSE, deceives, or gives a cover story
- If someone shares a fake backstory, that is "lied" NOT "secret_shared"
- "secret_shared" is ONLY for truthful revelations

SECRET_SHARED vs SECRET_REVEALED:
- secret_shared: Character VOLUNTARILY tells someone their TRUE secret
- secret_revealed: TRUE secret is EXPOSED (found out, overheard, discovered by accident, or told by a third party)
</event_details>

<event_pairs>
MANDATORY: You MUST specify which two characters are involved in EACH event type.
Different event types can involve different character pairs!

FORMAT:
- Single pair: "combat": ["User", "Thug"]
- Multiple pairs (same event type): "combat": [["User", "Thug1"], ["User", "Thug2"]]

EXAMPLE 1 - Single pair (confession between two people):
eventTypes: ["confession", "emotional", "secret_shared"]
eventPairs: {
  "confession": ["Elena", "Marcus"],
  "emotional": ["Elena", "Marcus"],
  "secret_shared": ["Elena", "Marcus"]
}

EXAMPLE 2 - Combat with multiple enemies:
eventTypes: ["combat", "danger"]
eventPairs: {
  "combat": [["Jake", "Thug1"], ["Jake", "Thug2"]],
  "danger": ["Jake", "Thug1"]
}

EXAMPLE 3 - Mixed event (fight enemies, comfort ally):
eventTypes: ["combat", "emotional", "supportive", "intimate_embrace"]
eventPairs: {
  "combat": ["Sarah", "Guard"],
  "emotional": ["Sarah", "Alex"],
  "supportive": ["Sarah", "Alex"],
  "intimate_embrace": ["Sarah", "Alex"]
}

This is CRITICAL for tracking relationships correctly. Each event type MUST have its own pair entry.
</event_pairs>

<relationship_signals>
If events affect relationships, include relationshipSignals (array - one per affected pair).
Only include signals for MEANINGFUL relationship shifts, not routine interactions.

FORMAT: Array of signal objects, each with a pair and changes array.

EXAMPLE 1 - No relationship signal (routine combat with nameless enemies):
relationshipSignals: []

EXAMPLE 2 - Single signal (emotional moment between two characters):
relationshipSignals: [
  {
    pair: ["Elena", "Marcus"],
    changes: [
      { from: "Elena", toward: "Marcus", feeling: "vulnerable" },
      { from: "Marcus", toward: "Elena", feeling: "protective" }
    ]
  }
]

EXAMPLE 3 - Multiple signals (fight with named enemies who will remember):
relationshipSignals: [
  { pair: ["Jake", "Viper"], changes: [{ from: "Viper", toward: "Jake", feeling: "vengeful" }] },
  { pair: ["Jake", "Razor"], changes: [{ from: "Razor", toward: "Jake", feeling: "fearful" }] }
]

EXAMPLE 4 - Mixed (combat with enemy, emotional support from ally):
relationshipSignals: [
  { pair: ["Sarah", "Alex"], changes: [
    { from: "Alex", toward: "Sarah", feeling: "grateful" },
    { from: "Sarah", toward: "Alex", feeling: "protective" }
  ]}
]
(Note: No signal for Guard unless they're a recurring character)

IMPORTANT: Only create relationship signals for characters who will appear again.
Generic enemies, random NPCs, or one-off characters don't need signals.
</relationship_signals>

<witnesses>
- Include all characters who witnessed or participated in the event.
- This is important for dramatic irony (tracking who knows what).
</witnesses>
</instructions>

<current_relationships>
{{currentRelationships}}
</current_relationships>

<recent_messages>
{{messages}}
</recent_messages>

<schema>
{{schema}}
</schema>

<output_example>
{{schemaExample}}
</output_example>

Extract the significant event (or indicate no significant event) as valid JSON:`,
    },
    chapter_boundary: {
        key: 'chapter_boundary',
        name: 'Chapter - Boundary Detection',
        description: 'Determines if a chapter boundary has occurred and generates chapter summary',
        defaultTemperature: 0.5,
        placeholders: [
            COMMON_PLACEHOLDERS.currentEvents,
            COMMON_PLACEHOLDERS.currentRelationships,
            COMMON_PLACEHOLDERS.schema,
            COMMON_PLACEHOLDERS.schemaExample,
        ],
        default: `A potential chapter boundary has been detected (location change or time jump). Analyze whether this represents a true narrative chapter break and generate a chapter summary. You must only return valid JSON with no commentary.

<instructions>
<boundary_detection>
- A true chapter boundary marks a significant narrative transition.
- Time jumps of several hours or location changes to new areas often indicate chapters.
- Minor movements within the same scene (e.g., moving to another room in the same building) are NOT chapter boundaries.
- Consider if the narrative tone or focus has shifted significantly.
</boundary_detection>
<summary>
- Write a 2-3 sentence summary of what happened in the chapter.
- Focus on the most important events and character developments.
- Include any relationship changes.
</summary>
<outcomes>
- relationshipChanges: Note any significant shifts in how characters relate to each other.
- secretsRevealed: Any secrets that came to light.
- newComplications: New problems or tensions introduced.
</outcomes>
</instructions>

<chapter_events>
{{currentEvents}}
</chapter_events>

<current_relationships>
{{currentRelationships}}
</current_relationships>

<schema>
{{schema}}
</schema>

<output_example>
{{schemaExample}}
</output_example>

Analyze the chapter boundary and generate summary as valid JSON:`,
    },
    relationship_initial: {
        key: 'relationship_initial',
        name: 'Relationship - Initial',
        description: 'Extracts initial relationship state between two characters',
        defaultTemperature: 0.6,
        placeholders: [
            COMMON_PLACEHOLDERS.messages,
            COMMON_PLACEHOLDERS.characterInfo,
            COMMON_PLACEHOLDERS.schema,
            COMMON_PLACEHOLDERS.schemaExample,
        ],
        default: `Analyze this roleplay scene and extract the relationship between two characters. You must only return valid JSON with no commentary.

<instructions>
<general>
- Determine the current status of the relationship (strangers, acquaintances, friendly, close, intimate, strained, hostile, complicated).
- Extract how each character feels about the other (asymmetric feelings are common and important).
- Note any secrets one character knows that the other doesn't.
- Identify what each character wants from the relationship.
</general>

<status_guidelines>
Status definitions and requirements:

- strangers: Never met or just met, no rapport
- acquaintances: Know each other casually, no strong bond
- friendly: Positive rapport, enjoy each other's company
- close: Deep friendship, trust, confide in each other. Maximum for platonic relationships.
- intimate: ONLY for romantic/sexual relationships with explicit romantic actions (kiss, date, love confession, sex)
- strained: Tension, unresolved conflict, damaged trust
- hostile: Active antagonism, enemies
- complicated: Mixed feelings, unclear relationship

CRITICAL STATUS LIMITS:
- "intimate" REQUIRES romantic actions to have occurred (first kiss, first date, love confession, sexual activity)
- Sharing secrets or emotional vulnerability alone = "close" at most, NOT "intimate"
- Caring about someone or wanting to help them = "friendly" or "close", NOT "intimate"
- "intimate" means ROMANTIC relationship, not just emotional closeness

Examples:
- Characters shared deep secrets, support each other emotionally â†’ "close" (not intimate - no romance)
- Characters had their first kiss â†’ can be "intimate"
- Characters confessed romantic love â†’ can be "intimate"
- Characters care deeply about each other but no romantic actions â†’ "close"
- Characters are suspicious but talking â†’ "strained" or "acquaintances"
</status_guidelines>

<asymmetry>
- Each character's feelings may be very different from the other's.
- One character might be trusting while the other is suspicious.
- One might want romance while the other wants friendship.
- Capture these differences accurately.
</asymmetry>

<output_format>
Return attitudes using actual character names as keys:
{
  "status": "friendly",
  "attitudes": {
    "CharacterName1": {
      "toward": "CharacterName2",
      "feelings": ["trusting", "curious"],
      "secrets": ["knows about their past"],
      "wants": ["friendship"]
    },
    "CharacterName2": {
      "toward": "CharacterName1",
      "feelings": ["grateful", "protective"],
      "secrets": [],
      "wants": ["loyalty"]
    }
  }
}

IMPORTANT: Use the actual character names as keys, NOT "aToB" or "bToA".
The "toward" field clarifies who the feelings are directed at.
</output_format>

<secrets>
- Secrets are things one character knows about the other (or about a situation) that the other doesn't know.
- This is crucial for dramatic irony in the narrative.
- Only include actual secrets, not just information one character hasn't shared yet.
</secrets>
</instructions>

<character_info>
{{characterInfo}}
</character_info>

<scene_messages>
{{messages}}
</scene_messages>

<schema>
{{schema}}
</schema>

<output_example>
{{schemaExample}}
</output_example>

Extract the relationship state as valid JSON:`,
    },
    relationship_update: {
        key: 'relationship_update',
        name: 'Relationship - Update',
        description: 'Updates relationship state based on recent events',
        defaultTemperature: 0.6,
        placeholders: [
            COMMON_PLACEHOLDERS.previousState,
            COMMON_PLACEHOLDERS.currentEvents,
            COMMON_PLACEHOLDERS.messages,
            COMMON_PLACEHOLDERS.schema,
            COMMON_PLACEHOLDERS.schemaExample,
        ],
        default: `Analyze recent events and update the relationship between two characters. You must only return valid JSON with no commentary.

<instructions>
<general>
- Analyze the previous relationship state and recent events to determine the CURRENT state.
- Update status if the relationship has progressed or deteriorated.
- REPLACE feelings with what the character CURRENTLY feels - do NOT accumulate old feelings.
  - If someone was "angry" but has forgiven, remove "angry" and add appropriate new feelings.
  - Feelings should reflect the PRESENT emotional state, not a history of all feelings ever felt.
- Add new secrets if one character learned something the other doesn't know.
- Remove secrets that have been revealed or are no longer relevant.
- Update wants based on how the relationship has evolved.
</general>

<feelings_guidance>
CRITICAL: Feelings arrays should contain CURRENT feelings only, not accumulated history.

WRONG approach (accumulating):
- Previous: ["curious", "cautious"]
- After bonding: ["curious", "cautious", "trusting", "warm"]  â† BAD: old feelings remain

CORRECT approach (replacing):
- Previous: ["curious", "cautious"]
- After bonding: ["trusting", "warm", "comfortable"]  â† GOOD: reflects current state

Think: "What does this character feel RIGHT NOW about the other person?"
</feelings_guidance>

<status_guidelines>
Status definitions and requirements:

- strangers: Never met or just met, no rapport
- acquaintances: Know each other casually, no strong bond
- friendly: Positive rapport, enjoy each other's company
- close: Deep friendship, trust, confide in each other. Maximum for platonic relationships.
- intimate: ONLY for romantic/sexual relationships with explicit romantic actions (kiss, date, love confession, sex)
- strained: Tension, unresolved conflict, damaged trust
- hostile: Active antagonism, enemies
- complicated: Mixed feelings, unclear relationship

CRITICAL STATUS LIMITS:
- "intimate" REQUIRES romantic actions to have occurred (first kiss, first date, love confession, sexual activity)
- Sharing secrets or emotional vulnerability alone = "close" at most, NOT "intimate"
- Caring about someone or wanting to help them = "friendly" or "close", NOT "intimate"
- "intimate" means ROMANTIC relationship, not just emotional closeness

Examples:
- Characters shared deep secrets, support each other emotionally â†’ "close" (not intimate - no romance)
- Characters had their first kiss â†’ can be "intimate"
- Characters confessed romantic love â†’ can be "intimate"
- Characters care deeply about each other but no romantic actions â†’ "close"
- Characters are suspicious but talking â†’ "strained" or "acquaintances"
</status_guidelines>

<output_format>
Return attitudes using actual character names as keys:
{
  "status": "close",
  "attitudes": {
    "CharacterName1": {
      "toward": "CharacterName2",
      "feelings": ["trusting", "protective", "grateful"],
      "secrets": [],
      "wants": ["continued friendship", "support"]
    },
    "CharacterName2": {
      "toward": "CharacterName1",
      "feelings": ["caring", "understanding", "hopeful"],
      "secrets": [],
      "wants": ["to help", "trust"]
    }
  }
}

IMPORTANT: Use the actual character names as keys, NOT "aToB" or "bToA".
The "toward" field clarifies who the feelings are directed at.
</output_format>

<history>
- If this is a chapter boundary update, include a history snapshot summarizing the relationship state at this point.
</history>
</instructions>

<previous_relationship>
{{previousState}}
</previous_relationship>

<recent_events>
{{currentEvents}}
</recent_events>

<recent_messages>
{{messages}}
</recent_messages>

<schema>
{{schema}}
</schema>

<output_example>
{{schemaExample}}
</output_example>

Extract the updated relationship state as valid JSON:`,
    },
    milestone_description: {
        key: 'milestone_description',
        name: 'Milestone - Description',
        description: 'Extracts a concise, grounded description of a relationship milestone moment',
        defaultTemperature: 0.5,
        placeholders: [
            COMMON_PLACEHOLDERS.messages,
            COMMON_PLACEHOLDERS.milestoneType,
            COMMON_PLACEHOLDERS.characterPair,
            COMMON_PLACEHOLDERS.timeOfDay,
            COMMON_PLACEHOLDERS.location,
            COMMON_PLACEHOLDERS.props,
            COMMON_PLACEHOLDERS.characters,
            COMMON_PLACEHOLDERS.relationship,
            COMMON_PLACEHOLDERS.eventDetail,
        ],
        default: `Extract a brief description of this {{milestoneType}} moment. Return ONLY the description text, no JSON, no quotes, no commentary.

<context>
<milestone_type>{{milestoneType}}</milestone_type>
<character_pair>{{characterPair}}</character_pair>
<time_of_day>{{timeOfDay}}</time_of_day>
<location>{{location}}</location>
<nearby_props>{{props}}</nearby_props>
<event_detail>{{eventDetail}}</event_detail>
<character_details>
{{characters}}
</character_details>
<relationship_state>
{{relationship}}
</relationship_state>
</context>

<instructions>
Write 1-2 sentences describing ONLY the specific {{milestoneType}} moment between {{characterPair}}.

FOCUS: Describe the exact moment of the milestone - not the entire conversation or scene.
- For first_kiss: describe the kiss itself, not everything that led to it
- For secret_shared: describe what secret was shared (use the event_detail)
- For first_embrace: describe the embrace itself

REQUIREMENTS:
- Use the event_detail field - it tells you exactly what happened
- Reference location and time of day
- Be factual and concise, not flowery
- Write in past tense, third person
- Do NOT summarize the whole scene - ONLY the milestone moment
</instructions>

<examples>
<example milestone="first_kiss">
<time_of_day>evening</time_of_day>
<location>Downtown - The Blue Moon Bar - Corner booth</location>
<props>half-empty glasses, dim overhead light</props>
<character_details>
Elena: Position: leaning across booth | Mood: nervous, anticipating | Wearing: torso: red blouse
Marcus: Position: sitting across from her | Mood: intent, warm | Wearing: torso: dark suit jacket
</character_details>
<relationship_state>Elena & Marcus (close): Elena feels: attracted, hopeful | Marcus feels: protective, drawn</relationship_state>
<messages>
Elena: *She leaned closer across the booth* "I've been thinking about this all night."
Marcus: *He reached over and cupped her cheek* "Me too." *He kissed her*
</messages>
<description>
Elena and Marcus shared their first kiss in the corner booth of the Blue Moon Bar that evening, leaning across the table between their half-empty drinks.
</description>
</example>

<example milestone="first_embrace">
<time_of_day>afternoon</time_of_day>
<location>Westside - Elena's Apartment - Living room</location>
<props>couch, scattered tissues, muted TV</props>
<character_details>
Elena: Position: sitting on couch | Mood: devastated, vulnerable | Wearing: torso: oversized sweater
Marcus: Position: sitting beside her | Mood: concerned, gentle | Wearing: torso: t-shirt, jacket: leather jacket
</character_details>
<relationship_state>Elena & Marcus (friendly): Elena feels: grateful, needing support | Marcus feels: protective, caring</relationship_state>
<messages>
Marcus: *He found her on the couch, crying* "Hey. I came as soon as I heard."
Elena: *She looked up* "I didn't think you'd come."
Marcus: *He sat beside her and pulled her into a hug* "Of course I came."
</messages>
<description>
Marcus held Elena for the first time on her couch that afternoon, pulling her in while she cried about her father's diagnosis.
</description>
</example>

<example milestone="first_conflict">
<time_of_day>night</time_of_day>
<location>Marcus's Office - Private study</location>
<props>desk, papers, whiskey glass</props>
<character_details>
Elena: Position: standing at desk | Mood: furious, betrayed | Wearing: torso: work blouse
Marcus: Position: behind desk | Mood: defensive, guilty | Wearing: torso: dress shirt, sleeves rolled
</character_details>
<relationship_state>Elena & Marcus (intimate): Elena feels: betrayed, hurt | Marcus feels: guilty, desperate</relationship_state>
<messages>
Elena: *She threw the documents on his desk* "You've been lying to me this whole time."
Marcus: "I was trying to protect youâ€”"
Elena: "Don't. Just don't." *She walked out*
</messages>
<description>
Their first real fight happened in Marcus's study when Elena confronted him with the documents proving his deception. She walked out before he could explain.
</description>
</example>

<example milestone="confession">
<time_of_day>morning</time_of_day>
<location>Riverside Park - Bench near the fountain</location>
<props>coffee cups, park bench</props>
<character_details>
Elena: Position: sitting on bench | Mood: nervous, determined | Wearing: jacket: light cardigan
Marcus: Position: sitting beside her | Mood: attentive, curious | Wearing: torso: casual shirt
</character_details>
<relationship_state>Elena & Marcus (close): Elena feels: in love, scared | Marcus feels: comfortable, uncertain</relationship_state>
<messages>
Elena: *She stared at her coffee* "I need to tell you something."
Marcus: *He waited*
Elena: "I'm in love with you. I have been for a while."
</messages>
<description>
Elena confessed her feelings on a park bench that morning, gripping her coffee cup as she finally admitted she'd been in love with Marcus for a while.
</description>
</example>

<example milestone="first_laugh">
<time_of_day>evening</time_of_day>
<location>Downtown - Ramen Shop - Counter seats</location>
<props>steaming ramen bowls, chopsticks, napkins</props>
<character_details>
Elena: Position: sitting at counter | Mood: amused, relaxed | Wearing: jacket: denim jacket
Marcus: Position: sitting beside her | Mood: playful, grinning | Wearing: torso: hoodie
</character_details>
<relationship_state>Elena & Marcus (acquaintances): Elena feels: warming up, curious | Marcus feels: interested, comfortable</relationship_state>
<messages>
Marcus: *He slurped his noodles loudly, getting broth on his chin* "That's how you're supposed to eat ramen. Trust me."
Elena: *She burst out laughing* "You look ridiculous."
Marcus: *He grinned, not wiping his face* "But am I wrong?"
</messages>
<description>
Their first genuine laugh together came at the ramen shop that evening when Marcus deliberately slurped his noodles and got broth all over his chin, making Elena burst out laughing despite herself.
</description>
</example>

<example milestone="first_gift">
<time_of_day>afternoon</time_of_day>
<location>Elena's Apartment - Doorway</location>
<props>doorframe, mailbox, potted plant</props>
<character_details>
Elena: Position: standing in doorway | Mood: surprised, touched | Wearing: torso: casual sweater
Marcus: Position: standing at door | Mood: nervous, hopeful | Wearing: jacket: coat, torso: button-up
</character_details>
<relationship_state>Elena & Marcus (friendly): Elena feels: appreciating, curious | Marcus feels: eager, nervous</relationship_state>
<messages>
Marcus: *He held out a small wrapped box* "I saw this and thought of you."
Elena: *She unwrapped it to find a vintage compass* "Marcus... this is beautiful."
Marcus: "So you'll always find your way home."
</messages>
<description>
Marcus gave Elena her first gift at her apartment door that afternoonâ€”a vintage compass he'd found, saying it was so she'd always find her way home.
</description>
</example>
</examples>

<recent_messages>
{{messages}}
</recent_messages>

Write the milestone description:`,
    },
};
// ============================================
// Public API
// ============================================
/**
 * Get a prompt by key, using custom prompt from settings if available.
 */
function getPrompt(key) {
    const settings = (0,_settings__WEBPACK_IMPORTED_MODULE_0__.getSettings)();
    const customPrompts = settings.customPrompts;
    if (customPrompts?.[key]) {
        return customPrompts[key];
    }
    return DEFAULT_PROMPTS[key].default;
}
/**
 * Get all prompt definitions for UI display.
 */
function getAllPromptDefinitions() {
    return Object.values(DEFAULT_PROMPTS);
}
/**
 * Get a specific prompt definition.
 */
function getPromptDefinition(key) {
    return DEFAULT_PROMPTS[key];
}
/**
 * Check if a prompt has been customized.
 */
function isPromptCustomized(key) {
    const settings = (0,_settings__WEBPACK_IMPORTED_MODULE_0__.getSettings)();
    const customPrompts = settings.customPrompts;
    return !!customPrompts?.[key];
}
/**
 * Get placeholder documentation for a prompt.
 */
function getPlaceholderDocs(key) {
    return DEFAULT_PROMPTS[key].placeholders;
}


/***/ },

/***/ "./src/injectors/injectState.ts"
/*!**************************************!*\
  !*** ./src/injectors/injectState.ts ***!
  \**************************************/
(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   formatStateForInjection: () => (/* binding */ formatStateForInjection),
/* harmony export */   injectState: () => (/* binding */ injectState),
/* harmony export */   updateInjectionFromChat: () => (/* binding */ updateInjectionFromChat)
/* harmony export */ });
/* harmony import */ var _utils_messageState__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../utils/messageState */ "./src/utils/messageState.ts");
/* harmony import */ var _settings__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../settings */ "./src/settings.ts");
/* harmony import */ var _utils_temperatures__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../utils/temperatures */ "./src/utils/temperatures.ts");
/* harmony import */ var _state_narrativeState__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../state/narrativeState */ "./src/state/narrativeState.ts");
/* harmony import */ var _state_chapters__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../state/chapters */ "./src/state/chapters.ts");
/* harmony import */ var _state_events__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../state/events */ "./src/state/events.ts");
/* harmony import */ var _state_relationships__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ../state/relationships */ "./src/state/relationships.ts");
/* harmony import */ var _weather__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ../weather */ "./src/weather/index.ts");








// ============================================
// Helper Functions for Knowledge Gaps
// ============================================
/**
 * Build knowledge gaps - events that present characters missed.
 * Returns formatted strings describing what each present character doesn't know.
 */
function buildKnowledgeGaps(events, presentCharacters) {
    const gaps = new Map();
    // For each present character, find events they weren't witnesses to
    for (const character of presentCharacters) {
        const charLower = character.toLowerCase();
        for (const event of events) {
            const witnessLower = event.witnesses.map(w => w.toLowerCase());
            if (!witnessLower.includes(charLower)) {
                if (!gaps.has(character)) {
                    gaps.set(character, []);
                }
                gaps.get(character).push(event.summary);
            }
        }
    }
    // Format as strings
    const result = [];
    for (const [character, missedEvents] of gaps) {
        if (missedEvents.length > 0) {
            result.push(`${character} was not present for: ${missedEvents.join('; ')}`);
        }
    }
    return result;
}
const EXTENSION_KEY = 'blazetracker';
const MONTH_NAMES = [
    'January',
    'February',
    'March',
    'April',
    'May',
    'June',
    'July',
    'August',
    'September',
    'October',
    'November',
    'December',
];
function formatOutfit(outfit) {
    const outfitParts = [
        outfit.torso || 'topless',
        outfit.legs || 'bottomless',
        outfit.underwear || 'no underwear',
        outfit.head || null,
        outfit.jacket || null,
        outfit.socks || null,
        outfit.footwear || null,
    ];
    return outfitParts.filter((v) => v !== null).join(', ');
}
function formatClimate(climate) {
    const settings = (0,_settings__WEBPACK_IMPORTED_MODULE_1__.getSettings)();
    if ((0,_weather__WEBPACK_IMPORTED_MODULE_7__.isLegacyClimate)(climate)) {
        // Legacy format: simple weather + temperature
        return `${(0,_utils_temperatures__WEBPACK_IMPORTED_MODULE_2__.formatTemperature)(climate.temperature, settings.temperatureUnit)}, ${climate.weather}`;
    }
    // Procedural format: more detailed
    const parts = [];
    // Temperature with feels like if significantly different
    const tempStr = (0,_utils_temperatures__WEBPACK_IMPORTED_MODULE_2__.formatTemperature)(climate.temperature, settings.temperatureUnit);
    if (Math.abs(climate.feelsLike - climate.temperature) > 5) {
        const feelsLikeStr = (0,_utils_temperatures__WEBPACK_IMPORTED_MODULE_2__.formatTemperature)(climate.feelsLike, settings.temperatureUnit);
        parts.push(`${tempStr} (feels like ${feelsLikeStr})`);
    }
    else {
        parts.push(tempStr);
    }
    // Conditions
    parts.push(climate.conditions);
    // Wind if notable
    if (climate.windSpeed >= 15) {
        parts.push(`${Math.round(climate.windSpeed)} mph winds from ${climate.windDirection}`);
    }
    // Indoor note
    if (climate.isIndoors && climate.indoorTemperature !== undefined) {
        const outdoorStr = (0,_utils_temperatures__WEBPACK_IMPORTED_MODULE_2__.formatTemperature)(climate.outdoorTemperature, settings.temperatureUnit);
        parts.push(`(${outdoorStr} outside)`);
    }
    return parts.join(', ');
}
function formatScene(scene) {
    const tensionParts = [
        scene.tension.type,
        scene.tension.level,
        scene.tension.direction !== 'stable' ? scene.tension.direction : null,
    ].filter(Boolean);
    return `Topic: ${scene.topic}
Tone: ${scene.tone}
Tension: ${tensionParts.join(', ')}`;
}
function formatNarrativeDateTime(time) {
    const hour12 = time.hour % 12 || 12;
    const ampm = time.hour < 12 ? 'AM' : 'PM';
    const minuteStr = String(time.minute).padStart(2, '0');
    // "Monday, June 15th, 2024 at 2:30 PM"
    const dayOrdinal = getDayOrdinal(time.day);
    return `${time.dayOfWeek}, ${MONTH_NAMES[time.month - 1]} ${time.day}${dayOrdinal}, ${time.year} at ${hour12}:${minuteStr} ${ampm}`;
}
function getDayOrdinal(day) {
    if (day >= 11 && day <= 13)
        return 'th';
    switch (day % 10) {
        case 1:
            return 'st';
        case 2:
            return 'nd';
        case 3:
            return 'rd';
        default:
            return 'th';
    }
}
function formatStateForInjection(state, narrativeState, options) {
    const settings = (0,_settings__WEBPACK_IMPORTED_MODULE_1__.getSettings)();
    // Check what's enabled AND what data exists
    const hasTime = settings.trackTime !== false && state.time;
    const hasLocation = settings.trackLocation !== false && state.location;
    const hasClimate = settings.trackClimate !== false && state.climate;
    const hasScene = settings.trackScene !== false && state.scene;
    const hasCharacters = settings.trackCharacters !== false &&
        state.characters &&
        state.characters.length > 0;
    const hasEvents = settings.trackEvents !== false &&
        state.currentEvents &&
        state.currentEvents.length > 0;
    const hasRelationships = settings.trackRelationships !== false &&
        narrativeState &&
        narrativeState.relationships.length > 0;
    const hasChapters = narrativeState && narrativeState.chapters.length > 0;
    // If nothing is tracked/available, return empty
    if (!hasTime &&
        !hasLocation &&
        !hasClimate &&
        !hasScene &&
        !hasCharacters &&
        !hasEvents &&
        !hasRelationships &&
        !hasChapters) {
        return '';
    }
    const sections = [];
    // ========================================
    // Previous Chapters (Story So Far)
    // ========================================
    if (hasChapters && narrativeState) {
        const chapterLimit = settings.injectedChapters ?? 3;
        const chaptersStr = (0,_state_chapters__WEBPACK_IMPORTED_MODULE_4__.formatChaptersForInjection)(narrativeState.chapters, chapterLimit);
        if (chaptersStr !== 'No previous chapters.') {
            sections.push(`[Story So Far]\n${chaptersStr}\n[/Story So Far]`);
        }
    }
    // ========================================
    // Current Scene State
    // ========================================
    let sceneOutput = `[Scene State]`;
    // Scene info first - it's the narrative context
    if (hasScene && state.scene) {
        sceneOutput += `\n${formatScene(state.scene)}`;
    }
    // Time (if enabled and available)
    if (hasTime && state.time) {
        const timeStr = formatNarrativeDateTime(state.time);
        sceneOutput += `\nTime: ${timeStr}`;
    }
    // Location (if enabled and available)
    if (hasLocation && state.location) {
        const location = [
            state.location.area,
            state.location.place,
            state.location.position,
        ]
            .filter(Boolean)
            .join(' - ');
        sceneOutput += `\nLocation: ${location}`;
        // Props are part of location
        if (state.location.props && state.location.props.length > 0) {
            const props = state.location.props.join(', ');
            sceneOutput += `\nNearby objects: ${props}`;
        }
    }
    // Climate (if enabled and available)
    if (hasClimate && state.climate) {
        const climate = formatClimate(state.climate);
        sceneOutput += `\nClimate: ${climate}`;
    }
    // Characters (if enabled and available)
    if (hasCharacters && state.characters) {
        const characters = state.characters
            .map(char => {
            const parts = [`${char.name}: ${char.position}`];
            if (char.activity)
                parts.push(`doing: ${char.activity}`);
            if (char.mood?.length)
                parts.push(`mood: ${char.mood.join(', ')}`);
            if (char.physicalState?.length)
                parts.push(`physical: ${char.physicalState.join(', ')}`);
            if (char.outfit)
                parts.push(`wearing: ${formatOutfit(char.outfit)}`);
            return parts.join('; ');
        })
            .join('\n');
        sceneOutput += `\nCharacters present:\n${characters}`;
    }
    sceneOutput += `\n[/Scene State]`;
    sections.push(sceneOutput);
    // ========================================
    // Weather Transition (if procedural weather with change)
    // ========================================
    if (options?.weatherTransition &&
        settings.useProceduralWeather &&
        settings.injectWeatherTransitions) {
        sections.push(`[Weather Change]\n${options.weatherTransition}\n[/Weather Change]`);
    }
    // ========================================
    // Recent Events in Current Chapter
    // ========================================
    if (hasEvents && state.currentEvents) {
        const eventsStr = (0,_state_events__WEBPACK_IMPORTED_MODULE_5__.formatEventsForInjection)(state.currentEvents);
        sections.push(`[Recent Events]\n${eventsStr}\n[/Recent Events]`);
        // Add witness absence notes for dramatic irony (if characters are tracked)
        if (hasCharacters && state.characters) {
            const presentCharacters = state.characters.map(c => c.name);
            const knowledgeGaps = buildKnowledgeGaps(state.currentEvents, presentCharacters);
            if (knowledgeGaps.length > 0) {
                sections.push(`[Knowledge Gaps]\n${knowledgeGaps.join('\n')}\n[/Knowledge Gaps]`);
            }
        }
    }
    // ========================================
    // Relationships (filtered for present characters)
    // ========================================
    if (hasRelationships && narrativeState) {
        const presentCharacters = hasCharacters && state.characters
            ? state.characters.map(c => c.name)
            : undefined;
        const relationshipsStr = (0,_state_relationships__WEBPACK_IMPORTED_MODULE_6__.formatRelationshipsForPrompt)(narrativeState.relationships, presentCharacters, settings.includeRelationshipSecrets ?? true);
        if (relationshipsStr !== 'No established relationships yet.') {
            sections.push(`[Relationships]\n${relationshipsStr}\n[/Relationships]`);
        }
    }
    return sections.join('\n\n');
}
function injectState(state, narrativeState, options) {
    const context = SillyTavern.getContext();
    if (!state) {
        context.setExtensionPrompt(EXTENSION_KEY, '', 0, 0);
        return;
    }
    const formatted = formatStateForInjection(state, narrativeState, options);
    // If nothing to inject, clear the prompt
    if (!formatted) {
        context.setExtensionPrompt(EXTENSION_KEY, '', 0, 0);
        return;
    }
    // Inject at depth 0 (with most recent messages), position IN_CHAT
    // Position 1 = after main prompt, before chat
    // Depth 0 = at the end (near most recent messages)
    context.setExtensionPrompt(EXTENSION_KEY, formatted, 1, // extension_prompt_types.IN_CHAT or similar
    0);
}
function updateInjectionFromChat() {
    const context = SillyTavern.getContext();
    // Get narrative state
    const narrativeState = (0,_state_narrativeState__WEBPACK_IMPORTED_MODULE_3__.getNarrativeState)();
    // Find most recent tracked state
    for (let i = context.chat.length - 1; i >= 0; i--) {
        const message = context.chat[i];
        const stateData = (0,_utils_messageState__WEBPACK_IMPORTED_MODULE_0__.getMessageState)(message);
        if (stateData?.state) {
            injectState(stateData.state, narrativeState);
            return;
        }
    }
    // No state found, clear injection
    injectState(null);
}


/***/ },

/***/ "./src/migrations/migrateOldTime.ts"
/*!******************************************!*\
  !*** ./src/migrations/migrateOldTime.ts ***!
  \******************************************/
(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   migrateOldTimeFormats: () => (/* binding */ migrateOldTimeFormats)
/* harmony export */ });
/* harmony import */ var _utils_messageState__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../utils/messageState */ "./src/utils/messageState.ts");
/* harmony import */ var _extractors_extractTime__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../extractors/extractTime */ "./src/extractors/extractTime.ts");
/* harmony import */ var sillytavern_utils_lib_config__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! sillytavern-utils-lib/config */ "./node_modules/sillytavern-utils-lib/dist/config.js");
// migration.ts



const DAYS_OF_WEEK = ['Sunday', 'Monday', 'Tuesday', 'Wednesday', 'Thursday', 'Friday', 'Saturday'];
function isOldTimeFormat(time) {
    return time && typeof time.day === 'string' && !time.dayOfWeek;
}
function getDayIndex(dayName) {
    return DAYS_OF_WEEK.indexOf(dayName);
}
function daysBetween(fromDay, toDay) {
    const fromIdx = getDayIndex(fromDay);
    const toIdx = getDayIndex(toDay);
    if (fromIdx === -1 || toIdx === -1)
        return 0;
    // Calculate forward distance (handles wrap-around)
    let diff = toIdx - fromIdx;
    if (diff <= 0)
        diff += 7; // Went to next week
    if (diff === 7)
        diff = 0; // Same day
    return diff;
}
function addDays(date, days) {
    const result = new Date(date);
    result.setDate(result.getDate() + days);
    return result;
}
function dateToNarrativeTime(date, hour, minute) {
    return {
        year: date.getFullYear(),
        month: date.getMonth() + 1,
        day: date.getDate(),
        hour,
        minute,
        second: 0,
        dayOfWeek: DAYS_OF_WEEK[date.getDay()],
    };
}
function narrativeToDate(time) {
    return new Date(time.year, time.month - 1, time.day, time.hour, time.minute, time.second);
}
/**
 * Migrate old time formats to NarrativeDateTime.
 * Call on CHAT_CHANGED after loading states.
 */
async function migrateOldTimeFormats(context, profileId) {
    let needsMigration = false;
    let firstOldStateIdx = -1;
    // First pass: check if any states need migration
    for (let i = 0; i < context.chat.length; i++) {
        const stored = (0,_utils_messageState__WEBPACK_IMPORTED_MODULE_0__.getMessageState)(context.chat[i]);
        if (stored?.state && isOldTimeFormat(stored.state.time)) {
            needsMigration = true;
            if (firstOldStateIdx === -1) {
                firstOldStateIdx = i;
            }
            break;
        }
    }
    if (!needsMigration) {
        return false;
    }
    (0,sillytavern_utils_lib_config__WEBPACK_IMPORTED_MODULE_2__.st_echo)?.('warning', 'ðŸ”¥ Updating date/time to v0.3.0 format.');
    // Get messages up to and including the first state for context
    const contextMessages = context.chat
        .slice(0, Math.min(firstOldStateIdx + 1, 5))
        .map(m => `${m.name}: ${m.mes}`)
        .join('\n\n');
    // Use LLM to infer baseline date
    let baselineTime;
    try {
        baselineTime = await (0,_extractors_extractTime__WEBPACK_IMPORTED_MODULE_1__.extractDateTime)(contextMessages, profileId);
    }
    catch (e) {
        console.error('[BlazeTracker] Failed to infer baseline date, using defaults:', e);
        baselineTime = {
            year: new Date().getFullYear(),
            month: 6,
            day: 15,
            hour: 12,
            minute: 0,
            second: 0,
            dayOfWeek: 'Monday',
        };
    }
    // Adjust baseline to match the first state's day of week
    const firstStored = (0,_utils_messageState__WEBPACK_IMPORTED_MODULE_0__.getMessageState)(context.chat[firstOldStateIdx]);
    let currentDate = narrativeToDate(baselineTime);
    const firstTime = firstStored?.state?.time;
    if (firstTime && isOldTimeFormat(firstTime)) {
        const targetDayIdx = getDayIndex(firstTime.day);
        const currentDayIdx = currentDate.getDay();
        if (targetDayIdx !== -1 && targetDayIdx !== currentDayIdx) {
            let diff = targetDayIdx - currentDayIdx;
            if (diff > 0)
                diff -= 7;
            currentDate = addDays(currentDate, diff);
        }
    }
    let lastDayOfWeek = null;
    // Second pass: migrate each state
    for (let i = 0; i < context.chat.length; i++) {
        const msg = context.chat[i];
        const stored = (0,_utils_messageState__WEBPACK_IMPORTED_MODULE_0__.getMessageState)(msg);
        if (!stored?.state || !isOldTimeFormat(stored.state.time)) {
            continue;
        }
        const oldTime = stored.state.time;
        // If day changed, advance the date
        if (lastDayOfWeek !== null && oldTime.day !== lastDayOfWeek) {
            const daysToAdd = daysBetween(lastDayOfWeek, oldTime.day);
            currentDate = addDays(currentDate, daysToAdd);
        }
        // Create new time format, preserving the original hour/minute
        const newTime = dateToNarrativeTime(currentDate, oldTime.hour, oldTime.minute);
        // Update state
        const newState = {
            ...stored.state,
            time: newTime,
        };
        (0,_utils_messageState__WEBPACK_IMPORTED_MODULE_0__.setMessageState)(msg, { ...stored, state: newState });
        lastDayOfWeek = oldTime.day;
    }
    // Save the chat to persist migrations
    const saveContext = SillyTavern.getContext();
    await saveContext.saveChat();
    return true;
}


/***/ },

/***/ "./src/settings.ts"
/*!*************************!*\
  !*** ./src/settings.ts ***!
  \*************************/
(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   defaultSettings: () => (/* binding */ defaultSettings),
/* harmony export */   defaultTemperatures: () => (/* binding */ defaultTemperatures),
/* harmony export */   getSettings: () => (/* binding */ getSettings),
/* harmony export */   getTemperature: () => (/* binding */ getTemperature),
/* harmony export */   settingsManager: () => (/* binding */ settingsManager),
/* harmony export */   updateSetting: () => (/* binding */ updateSetting)
/* harmony export */ });
/* harmony import */ var sillytavern_utils_lib__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! sillytavern-utils-lib */ "./node_modules/sillytavern-utils-lib/dist/index.js");
/* harmony import */ var _constants__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./constants */ "./src/constants.ts");


const defaultSettings = {
    profileId: '',
    autoMode: 'both',
    lastXMessages: 10,
    maxResponseTokens: 4000,
    displayPosition: 'below',
    // All extractions enabled by default
    trackTime: true,
    trackLocation: true,
    trackClimate: true,
    trackCharacters: true,
    trackScene: true,
    trackEvents: true,
    trackRelationships: true,
    // Weather settings
    useProceduralWeather: true,
    injectWeatherTransitions: true,
    // Chapter settings
    chapterTimeThreshold: 60,
    injectedChapters: 3,
    // Relationship settings
    relationshipRefreshInterval: 10,
    includeRelationshipSecrets: true,
    // Other defaults
    leapThresholdMinutes: 20,
    temperatureUnit: 'fahrenheit',
    timeFormat: '24h',
    customPrompts: {},
    customTemperatures: {},
};
// Default temperatures for each extractor prompt
const defaultTemperatures = {
    time_datetime: 0.3,
    time_delta: 0.3,
    location_initial: 0.5,
    location_update: 0.5,
    climate_initial: 0.3,
    climate_update: 0.3,
    climate_location_map: 0.4,
    characters_initial: 0.7,
    characters_update: 0.7,
    scene_initial: 0.6,
    scene_update: 0.6,
    event_extract: 0.4,
    chapter_boundary: 0.5,
    relationship_initial: 0.6,
    relationship_update: 0.6,
    milestone_description: 0.7,
};
/**
 * Get the temperature for a specific prompt key.
 * Returns custom temperature if set, otherwise the default.
 */
function getTemperature(key) {
    const settings = getSettings();
    if (key in settings.customTemperatures) {
        return settings.customTemperatures[key];
    }
    return defaultTemperatures[key] ?? 0.5;
}
const settingsManager = new sillytavern_utils_lib__WEBPACK_IMPORTED_MODULE_0__.ExtensionSettingsManager(_constants__WEBPACK_IMPORTED_MODULE_1__.EXTENSION_KEY, defaultSettings);
function getSettings() {
    return settingsManager.getSettings();
}
function updateSetting(key, value) {
    const settings = settingsManager.getSettings();
    settings[key] = value;
    settingsManager.saveSettings();
}


/***/ },

/***/ "./src/state/chapters.ts"
/*!*******************************!*\
  !*** ./src/state/chapters.ts ***!
  \*******************************/
(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   checkChapterBoundary: () => (/* binding */ checkChapterBoundary),
/* harmony export */   createEmptyChapter: () => (/* binding */ createEmptyChapter),
/* harmony export */   createEmptyOutcomes: () => (/* binding */ createEmptyOutcomes),
/* harmony export */   finalizeChapter: () => (/* binding */ finalizeChapter),
/* harmony export */   formatChapterForPrompt: () => (/* binding */ formatChapterForPrompt),
/* harmony export */   formatChaptersForInjection: () => (/* binding */ formatChaptersForInjection),
/* harmony export */   formatDateTime: () => (/* binding */ formatDateTime),
/* harmony export */   formatTimeElapsed: () => (/* binding */ formatTimeElapsed),
/* harmony export */   getTimeDeltaMinutes: () => (/* binding */ getTimeDeltaMinutes)
/* harmony export */ });
/* harmony import */ var _settings__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../settings */ "./src/settings.ts");
// ============================================
// Chapter Utility Functions
// ============================================

// ============================================
// Time Delta Calculations
// ============================================
/**
 * Convert a NarrativeDateTime to total minutes since epoch (for comparison).
 */
function toMinutes(dt) {
    // Simple conversion: assumes 30 days per month, 365 days per year
    // This is approximate but sufficient for detecting large time jumps
    const yearMinutes = dt.year * 365 * 24 * 60;
    const monthMinutes = (dt.month - 1) * 30 * 24 * 60;
    const dayMinutes = (dt.day - 1) * 24 * 60;
    const hourMinutes = dt.hour * 60;
    return yearMinutes + monthMinutes + dayMinutes + hourMinutes + dt.minute;
}
/**
 * Calculate the time delta in minutes between two NarrativeDateTimes.
 * Returns positive if 'to' is after 'from', negative otherwise.
 */
function getTimeDeltaMinutes(from, to) {
    return toMinutes(to) - toMinutes(from);
}
/**
 * Format a time delta in minutes to a human-readable string.
 */
function formatTimeElapsed(minutes) {
    const absMinutes = Math.abs(minutes);
    if (absMinutes < 60) {
        return `${absMinutes} minute${absMinutes !== 1 ? 's' : ''}`;
    }
    const hours = Math.floor(absMinutes / 60);
    const remainingMinutes = absMinutes % 60;
    if (hours < 24) {
        if (remainingMinutes === 0) {
            return `${hours} hour${hours !== 1 ? 's' : ''}`;
        }
        return `${hours} hour${hours !== 1 ? 's' : ''}, ${remainingMinutes} minute${remainingMinutes !== 1 ? 's' : ''}`;
    }
    const days = Math.floor(hours / 24);
    const remainingHours = hours % 24;
    if (days < 7) {
        if (remainingHours === 0) {
            return `${days} day${days !== 1 ? 's' : ''}`;
        }
        return `${days} day${days !== 1 ? 's' : ''}, ${remainingHours} hour${remainingHours !== 1 ? 's' : ''}`;
    }
    const weeks = Math.floor(days / 7);
    const remainingDays = days % 7;
    if (remainingDays === 0) {
        return `${weeks} week${weeks !== 1 ? 's' : ''}`;
    }
    return `${weeks} week${weeks !== 1 ? 's' : ''}, ${remainingDays} day${remainingDays !== 1 ? 's' : ''}`;
}
/**
 * Check if a chapter boundary should be triggered based on location or time changes.
 * @param previousLocation Previous location state
 * @param currentLocation Current location state
 * @param previousTime Previous narrative time
 * @param currentTime Current narrative time
 * @returns BoundaryCheckResult indicating if and why a boundary was triggered
 */
function checkChapterBoundary(previousLocation, currentLocation, previousTime, currentTime) {
    const settings = (0,_settings__WEBPACK_IMPORTED_MODULE_0__.getSettings)();
    const threshold = settings.chapterTimeThreshold ?? 60; // Default 60 minutes
    let locationChanged = false;
    let timeJumped = false;
    let locationChange;
    let timeJump;
    // Check for significant location change (different area or place)
    if (previousLocation && currentLocation) {
        const areaChanged = previousLocation.area.toLowerCase() !== currentLocation.area.toLowerCase();
        const placeChanged = previousLocation.place.toLowerCase() !==
            currentLocation.place.toLowerCase();
        if (areaChanged || placeChanged) {
            locationChanged = true;
            locationChange = {
                from: `${previousLocation.area} - ${previousLocation.place}`,
                to: `${currentLocation.area} - ${currentLocation.place}`,
            };
        }
    }
    // Check for time jump
    if (previousTime && currentTime) {
        const delta = getTimeDeltaMinutes(previousTime, currentTime);
        if (delta >= threshold) {
            timeJumped = true;
            timeJump = {
                minutes: delta,
                formatted: formatTimeElapsed(delta),
            };
        }
    }
    // Determine result
    if (locationChanged && timeJumped) {
        return {
            triggered: true,
            reason: 'both',
            locationChange,
            timeJump,
        };
    }
    else if (locationChanged) {
        return {
            triggered: true,
            reason: 'location_change',
            locationChange,
        };
    }
    else if (timeJumped) {
        return {
            triggered: true,
            reason: 'time_jump',
            timeJump,
        };
    }
    return { triggered: false };
}
// ============================================
// Chapter Creation
// ============================================
/**
 * Create a new chapter with default empty values.
 */
function createEmptyChapter(index) {
    const now = {
        year: new Date().getFullYear(),
        month: 6,
        day: 15,
        hour: 12,
        minute: 0,
        second: 0,
        dayOfWeek: 'Monday',
    };
    return {
        index,
        title: `Chapter ${index + 1}`,
        summary: '',
        timeRange: {
            start: now,
            end: now,
        },
        primaryLocation: 'Unknown',
        events: [],
        outcomes: createEmptyOutcomes(),
    };
}
/**
 * Create empty chapter outcomes.
 */
function createEmptyOutcomes() {
    return {
        relationshipChanges: [],
        secretsRevealed: [],
        newComplications: [],
    };
}
/**
 * Finalize a chapter with events and time range.
 */
function finalizeChapter(chapter, events, startTime, endTime, primaryLocation) {
    return {
        ...chapter,
        events,
        timeRange: {
            start: startTime,
            end: endTime,
        },
        primaryLocation,
    };
}
// ============================================
// Formatting
// ============================================
/**
 * Format a chapter for display in prompts.
 */
function formatChapterForPrompt(chapter) {
    const lines = [];
    lines.push(`## Chapter ${chapter.index + 1}: ${chapter.title}`);
    lines.push(`Location: ${chapter.primaryLocation}`);
    lines.push(`Time: ${formatDateTime(chapter.timeRange.start)} - ${formatDateTime(chapter.timeRange.end)}`);
    lines.push('');
    lines.push(chapter.summary);
    if (chapter.outcomes.relationshipChanges.length > 0) {
        lines.push('');
        lines.push(`Relationship changes: ${chapter.outcomes.relationshipChanges.join('; ')}`);
    }
    if (chapter.outcomes.secretsRevealed.length > 0) {
        lines.push(`Secrets revealed: ${chapter.outcomes.secretsRevealed.join('; ')}`);
    }
    return lines.join('\n');
}
/**
 * Format multiple chapters for injection.
 */
function formatChaptersForInjection(chapters, limit) {
    if (chapters.length === 0) {
        return 'No previous chapters.';
    }
    const toFormat = limit ? chapters.slice(-limit) : chapters;
    return toFormat.map(formatChapterForPrompt).join('\n\n---\n\n');
}
/**
 * Format a NarrativeDateTime for display.
 */
function formatDateTime(dt) {
    const hour12 = dt.hour % 12 || 12;
    const ampm = dt.hour < 12 ? 'AM' : 'PM';
    const minute = dt.minute.toString().padStart(2, '0');
    const months = [
        'January',
        'February',
        'March',
        'April',
        'May',
        'June',
        'July',
        'August',
        'September',
        'October',
        'November',
        'December',
    ];
    return `${dt.dayOfWeek}, ${months[dt.month - 1]} ${dt.day}, ${dt.year} at ${hour12}:${minute} ${ampm}`;
}


/***/ },

/***/ "./src/state/events.ts"
/*!*****************************!*\
  !*** ./src/state/events.ts ***!
  \*****************************/
(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   createEvent: () => (/* binding */ createEvent),
/* harmony export */   filterEventsByTensionLevel: () => (/* binding */ filterEventsByTensionLevel),
/* harmony export */   filterEventsByTensionType: () => (/* binding */ filterEventsByTensionType),
/* harmony export */   formatEvent: () => (/* binding */ formatEvent),
/* harmony export */   formatEventTimestamp: () => (/* binding */ formatEventTimestamp),
/* harmony export */   formatEventsForInjection: () => (/* binding */ formatEventsForInjection),
/* harmony export */   getAbsentWitnesses: () => (/* binding */ getAbsentWitnesses),
/* harmony export */   getAllWitnesses: () => (/* binding */ getAllWitnesses),
/* harmony export */   getEventsForPair: () => (/* binding */ getEventsForPair),
/* harmony export */   getRelationshipEvents: () => (/* binding */ getRelationshipEvents)
/* harmony export */ });
// ============================================
// Event Utility Functions
// ============================================
/**
 * Create a TimestampedEvent from parameters.
 */
function createEvent(params) {
    const locationStr = typeof params.location === 'string'
        ? params.location
        : `${params.location.area} - ${params.location.place}`;
    return {
        timestamp: params.timestamp,
        summary: params.summary,
        eventTypes: params.eventTypes ?? ['conversation'],
        tensionType: params.tensionType,
        tensionLevel: params.tensionLevel,
        witnesses: params.witnesses,
        location: locationStr,
        relationshipSignal: params.relationshipSignal,
    };
}
// ============================================
// Formatting
// ============================================
/**
 * Format events for injection into prompts.
 * @param events Array of events to format
 * @param limit Maximum number of events to include (most recent)
 * @param presentCharacters Characters currently present (for witness absence notes)
 */
function formatEventsForInjection(events, limit, presentCharacters) {
    if (events.length === 0) {
        return 'No recent events.';
    }
    const toFormat = limit ? events.slice(-limit) : events;
    const presentSet = presentCharacters
        ? new Set(presentCharacters.map(c => c.toLowerCase()))
        : null;
    return toFormat
        .map((event, _index) => {
        const lines = [];
        // Event header with timestamp
        lines.push(`[${formatEventTimestamp(event.timestamp)}]`);
        // Summary
        lines.push(event.summary);
        // Tension info
        lines.push(`Tension: ${event.tensionLevel} ${event.tensionType}`);
        // Witnesses with absence notes
        if (event.witnesses.length > 0) {
            const witnessNotes = [];
            for (const witness of event.witnesses) {
                if (presentSet && !presentSet.has(witness.toLowerCase())) {
                    witnessNotes.push(`${witness} (not present)`);
                }
                else {
                    witnessNotes.push(witness);
                }
            }
            lines.push(`Witnesses: ${witnessNotes.join(', ')}`);
        }
        // Location
        lines.push(`Location: ${event.location}`);
        return lines.join('\n');
    })
        .join('\n\n');
}
/**
 * Format an event timestamp for display (compact format).
 */
function formatEventTimestamp(dt) {
    const hour12 = dt.hour % 12 || 12;
    const ampm = dt.hour < 12 ? 'AM' : 'PM';
    const minute = dt.minute.toString().padStart(2, '0');
    // Shorter day names
    const dayAbbrev = {
        Monday: 'Mon',
        Tuesday: 'Tue',
        Wednesday: 'Wed',
        Thursday: 'Thu',
        Friday: 'Fri',
        Saturday: 'Sat',
        Sunday: 'Sun',
    };
    const day = dayAbbrev[dt.dayOfWeek] || dt.dayOfWeek.slice(0, 3);
    return `${day} ${hour12}:${minute} ${ampm}`;
}
/**
 * Format a single event for display.
 */
function formatEvent(event) {
    return `[${formatEventTimestamp(event.timestamp)}] ${event.summary} (${event.tensionLevel} ${event.tensionType})`;
}
// ============================================
// Event Analysis
// ============================================
/**
 * Get witnesses who are not currently present (for dramatic irony).
 */
function getAbsentWitnesses(event, presentCharacters) {
    const presentSet = new Set(presentCharacters.map(c => c.toLowerCase()));
    return event.witnesses.filter(w => !presentSet.has(w.toLowerCase()));
}
/**
 * Get all unique witnesses across multiple events.
 */
function getAllWitnesses(events) {
    const witnesses = new Set();
    for (const event of events) {
        for (const witness of event.witnesses) {
            witnesses.add(witness);
        }
    }
    return Array.from(witnesses);
}
/**
 * Filter events by tension type.
 */
function filterEventsByTensionType(events, types) {
    const typeSet = new Set(types);
    return events.filter(e => typeSet.has(e.tensionType));
}
/**
 * Filter events by tension level (at or above).
 */
function filterEventsByTensionLevel(events, minLevel) {
    const levels = [
        'relaxed',
        'aware',
        'guarded',
        'tense',
        'charged',
        'volatile',
        'explosive',
    ];
    const minIndex = levels.indexOf(minLevel);
    return events.filter(e => levels.indexOf(e.tensionLevel) >= minIndex);
}
/**
 * Get events with relationship signals.
 */
function getRelationshipEvents(events) {
    return events.filter(e => e.relationshipSignal !== undefined);
}
/**
 * Find events involving a specific character pair.
 */
function getEventsForPair(events, char1, char2) {
    const pair = [char1.toLowerCase(), char2.toLowerCase()].sort();
    return events.filter(e => {
        if (!e.relationshipSignal)
            return false;
        const signalPair = e.relationshipSignal.pair.map(p => p.toLowerCase()).sort();
        return signalPair[0] === pair[0] && signalPair[1] === pair[1];
    });
}


/***/ },

/***/ "./src/state/narrativeState.ts"
/*!*************************************!*\
  !*** ./src/state/narrativeState.ts ***!
  \*************************************/
(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   NARRATIVE_STATE_VERSION: () => (/* reexport safe */ _types_state__WEBPACK_IMPORTED_MODULE_1__.NARRATIVE_STATE_VERSION),
/* harmony export */   addChapter: () => (/* binding */ addChapter),
/* harmony export */   getNarrativeState: () => (/* binding */ getNarrativeState),
/* harmony export */   getOrInitializeNarrativeState: () => (/* binding */ getOrInitializeNarrativeState),
/* harmony export */   getRelationship: () => (/* binding */ getRelationship),
/* harmony export */   initializeNarrativeState: () => (/* binding */ initializeNarrativeState),
/* harmony export */   migrateFromLegacyState: () => (/* binding */ migrateFromLegacyState),
/* harmony export */   saveNarrativeState: () => (/* binding */ saveNarrativeState),
/* harmony export */   setNarrativeState: () => (/* binding */ setNarrativeState),
/* harmony export */   updateRelationship: () => (/* binding */ updateRelationship)
/* harmony export */ });
/* harmony import */ var _constants__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../constants */ "./src/constants.ts");
/* harmony import */ var _types_state__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../types/state */ "./src/types/state.ts");
// ============================================
// Chat-Level Narrative State Management
// ============================================


// Re-export the version constant

// ============================================
// Storage Keys
// ============================================
const NARRATIVE_KEY = 'narrative';
// ============================================
// Public API
// ============================================
/**
 * Get the narrative state from the chat.
 * Returns null if no narrative state exists.
 */
function getNarrativeState() {
    const context = SillyTavern.getContext();
    const chat = context.chat;
    if (!chat || chat.length === 0) {
        return null;
    }
    // Narrative state is stored in the first message
    const firstMessage = chat[0];
    const storage = firstMessage.extra?.[_constants__WEBPACK_IMPORTED_MODULE_0__.EXTENSION_KEY];
    if (!storage || !storage[NARRATIVE_KEY]) {
        return null;
    }
    return storage[NARRATIVE_KEY];
}
/**
 * Set the narrative state for the chat.
 * Creates the storage structure if it doesn't exist.
 */
function setNarrativeState(state) {
    const context = SillyTavern.getContext();
    const chat = context.chat;
    if (!chat || chat.length === 0) {
        console.warn('[BlazeTracker] Cannot set narrative state: no chat messages');
        return;
    }
    const firstMessage = chat[0];
    if (!firstMessage.extra) {
        firstMessage.extra = {};
    }
    if (!firstMessage.extra[_constants__WEBPACK_IMPORTED_MODULE_0__.EXTENSION_KEY]) {
        firstMessage.extra[_constants__WEBPACK_IMPORTED_MODULE_0__.EXTENSION_KEY] = {};
    }
    firstMessage.extra[_constants__WEBPACK_IMPORTED_MODULE_0__.EXTENSION_KEY][NARRATIVE_KEY] = state;
}
/**
 * Initialize a new narrative state with default values.
 */
function initializeNarrativeState() {
    return {
        version: _types_state__WEBPACK_IMPORTED_MODULE_1__.NARRATIVE_STATE_VERSION,
        chapters: [],
        relationships: [],
        forecastCache: [],
        locationMappings: [],
    };
}
/**
 * Get or initialize the narrative state.
 * If no state exists, creates and saves a new one.
 * Also handles migrations from older versions.
 */
function getOrInitializeNarrativeState() {
    let state = getNarrativeState();
    if (!state) {
        state = initializeNarrativeState();
        setNarrativeState(state);
    }
    else {
        // Run migrations if needed
        const migrated = migrateNarrativeState(state);
        if (migrated) {
            setNarrativeState(state);
        }
    }
    return state;
}
/**
 * Save the narrative state and persist the chat.
 */
async function saveNarrativeState(state) {
    setNarrativeState(state);
    const context = SillyTavern.getContext();
    await context.saveChat();
}
// ============================================
// Migration
// ============================================
/**
 * Migrate narrative state from older versions to current.
 * Returns true if any migration was performed.
 */
function migrateNarrativeState(state) {
    let migrated = false;
    // Version 1 -> 2: Add versions array to relationships with initial version from current state
    if (!state.version || state.version < 2) {
        for (const rel of state.relationships) {
            if (!rel.versions) {
                // Create initial version from current relationship state
                // Use messageId 0 so it appears from the start of the chat
                rel.versions = [
                    {
                        messageId: 0,
                        status: rel.status,
                        aToB: {
                            feelings: [...rel.aToB.feelings],
                            secrets: [...rel.aToB.secrets],
                            wants: [...rel.aToB.wants],
                        },
                        bToA: {
                            feelings: [...rel.bToA.feelings],
                            secrets: [...rel.bToA.secrets],
                            wants: [...rel.bToA.wants],
                        },
                        milestones: [...rel.milestones],
                    },
                ];
            }
        }
        state.version = 2;
        migrated = true;
    }
    return migrated;
}
/**
 * Migrate from legacy state format (recentEvents in Scene) to new format.
 * This should be called when opening a chat that may have old state.
 */
function migrateFromLegacyState() {
    const context = SillyTavern.getContext();
    const chat = context.chat;
    // Start with empty narrative state
    const state = initializeNarrativeState();
    if (!chat || chat.length === 0) {
        return state;
    }
    // Collect all legacy recentEvents from messages
    const collectedEvents = [];
    for (const message of chat) {
        const storage = message.extra?.[_constants__WEBPACK_IMPORTED_MODULE_0__.EXTENSION_KEY];
        if (!storage)
            continue;
        // Check all swipes
        for (const swipeData of Object.values(storage)) {
            if (typeof swipeData === 'object' &&
                swipeData?.state?.scene?.recentEvents) {
                const events = swipeData.state.scene.recentEvents;
                if (Array.isArray(events)) {
                    for (const event of events) {
                        if (typeof event === 'string' &&
                            !collectedEvents.includes(event)) {
                            collectedEvents.push(event);
                        }
                    }
                }
            }
        }
    }
    // Note: We don't convert legacy string events to TimestampedEvents here
    // because we don't have the timestamp/tension/location info.
    // The legacy events are simply not migrated - new events will be extracted going forward.
    return state;
}
// ============================================
// Update Helpers
// ============================================
/**
 * Add a chapter to the narrative state.
 */
function addChapter(state, chapter) {
    state.chapters.push(chapter);
}
/**
 * Update or add a relationship in the narrative state.
 */
function updateRelationship(state, relationship) {
    const key = relationship.pair.join('|');
    const existingIndex = state.relationships.findIndex(r => r.pair.join('|') === key);
    if (existingIndex >= 0) {
        state.relationships[existingIndex] = relationship;
    }
    else {
        state.relationships.push(relationship);
    }
}
/**
 * Get a relationship by character pair.
 */
function getRelationship(state, char1, char2) {
    const pair = [char1, char2].sort();
    const key = pair.join('|');
    return state.relationships.find(r => r.pair.join('|') === key) ?? null;
}


/***/ },

/***/ "./src/state/relationships.ts"
/*!************************************!*\
  !*** ./src/state/relationships.ts ***!
  \************************************/
(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   addMilestone: () => (/* binding */ addMilestone),
/* harmony export */   addRelationshipVersion: () => (/* binding */ addRelationshipVersion),
/* harmony export */   clearAllMilestonesForMessage: () => (/* binding */ clearAllMilestonesForMessage),
/* harmony export */   clearAllMilestonesSince: () => (/* binding */ clearAllMilestonesSince),
/* harmony export */   clearMilestonesForMessage: () => (/* binding */ clearMilestonesForMessage),
/* harmony export */   clearMilestonesSince: () => (/* binding */ clearMilestonesSince),
/* harmony export */   compareNarrativeDateTime: () => (/* binding */ compareNarrativeDateTime),
/* harmony export */   createEmptyAttitude: () => (/* binding */ createEmptyAttitude),
/* harmony export */   createRelationship: () => (/* binding */ createRelationship),
/* harmony export */   findUnestablishedPairs: () => (/* binding */ findUnestablishedPairs),
/* harmony export */   formatRelationship: () => (/* binding */ formatRelationship),
/* harmony export */   formatRelationshipsForPrompt: () => (/* binding */ formatRelationshipsForPrompt),
/* harmony export */   getAttitudeDirection: () => (/* binding */ getAttitudeDirection),
/* harmony export */   getLatestVersionMessageId: () => (/* binding */ getLatestVersionMessageId),
/* harmony export */   getRelationshipAtMessage: () => (/* binding */ getRelationshipAtMessage),
/* harmony export */   getRelationshipsAtMessage: () => (/* binding */ getRelationshipsAtMessage),
/* harmony export */   hasMilestone: () => (/* binding */ hasMilestone),
/* harmony export */   isDateTimeOnOrAfter: () => (/* binding */ isDateTimeOnOrAfter),
/* harmony export */   narrativeDateTimeToNumber: () => (/* binding */ narrativeDateTimeToNumber),
/* harmony export */   pairKey: () => (/* binding */ pairKey),
/* harmony export */   popVersionForMessage: () => (/* binding */ popVersionForMessage),
/* harmony export */   sortPair: () => (/* binding */ sortPair),
/* harmony export */   updateAttitude: () => (/* binding */ updateAttitude)
/* harmony export */ });
// ============================================
// Relationship Utility Functions
// ============================================
// ============================================
// Pair Management
// ============================================
/**
 * Sort a pair of character names alphabetically.
 * Returns a tuple with the names in alphabetical order.
 */
function sortPair(char1, char2) {
    return char1.localeCompare(char2) <= 0 ? [char1, char2] : [char2, char1];
}
/**
 * Generate a deterministic key for a character pair.
 * The key is the same regardless of argument order.
 */
function pairKey(char1, char2) {
    const [a, b] = sortPair(char1, char2);
    return `${a}|${b}`;
}
/**
 * Check if a relationship has a specific milestone type.
 */
function hasMilestone(relationship, type) {
    return relationship.milestones.some(m => m.type === type);
}
/**
 * Find all character pairs that don't have an established relationship.
 * Returns pairs as sorted tuples.
 */
function findUnestablishedPairs(characters, relationships) {
    if (characters.length < 2) {
        return [];
    }
    const existingKeys = new Set(relationships.map(r => pairKey(r.pair[0], r.pair[1])));
    const unestablished = [];
    for (let i = 0; i < characters.length; i++) {
        for (let j = i + 1; j < characters.length; j++) {
            const key = pairKey(characters[i], characters[j]);
            if (!existingKeys.has(key)) {
                unestablished.push(sortPair(characters[i], characters[j]));
            }
        }
    }
    return unestablished;
}
// ============================================
// Formatting
// ============================================
/**
 * Format relationships for inclusion in prompts.
 * @param relationships All relationships
 * @param presentCharacters Characters currently in the scene (filters to relevant relationships)
 * @param includeSecrets Whether to include secret knowledge (for dramatic irony)
 */
function formatRelationshipsForPrompt(relationships, presentCharacters, includeSecrets = true) {
    if (relationships.length === 0) {
        return 'No established relationships.';
    }
    // Filter to relationships involving present characters if specified
    let relevantRelationships = relationships;
    if (presentCharacters && presentCharacters.length > 0) {
        const presentSet = new Set(presentCharacters.map(c => c.toLowerCase()));
        relevantRelationships = relationships.filter(r => presentSet.has(r.pair[0].toLowerCase()) ||
            presentSet.has(r.pair[1].toLowerCase()));
    }
    if (relevantRelationships.length === 0) {
        return 'No established relationships between present characters.';
    }
    return relevantRelationships.map(r => formatRelationship(r, includeSecrets)).join('\n\n');
}
/**
 * Format a single relationship for display.
 */
function formatRelationship(relationship, includeSecrets = true) {
    const [charA, charB] = relationship.pair;
    const lines = [];
    lines.push(`## ${charA} & ${charB} (${relationship.status})`);
    // A's feelings toward B
    lines.push(`${charA} â†’ ${charB}:`);
    lines.push(`  Feelings: ${relationship.aToB.feelings.join(', ') || 'neutral'}`);
    if (relationship.aToB.wants.length > 0) {
        lines.push(`  Wants: ${relationship.aToB.wants.join(', ')}`);
    }
    if (includeSecrets && relationship.aToB.secrets.length > 0) {
        lines.push(`  Secrets (${charB} doesn't know): ${relationship.aToB.secrets.join(', ')}`);
    }
    // B's feelings toward A
    lines.push(`${charB} â†’ ${charA}:`);
    lines.push(`  Feelings: ${relationship.bToA.feelings.join(', ') || 'neutral'}`);
    if (relationship.bToA.wants.length > 0) {
        lines.push(`  Wants: ${relationship.bToA.wants.join(', ')}`);
    }
    if (includeSecrets && relationship.bToA.secrets.length > 0) {
        lines.push(`  Secrets (${charA} doesn't know): ${relationship.bToA.secrets.join(', ')}`);
    }
    // Milestones
    if (relationship.milestones.length > 0) {
        lines.push(`Milestones: ${relationship.milestones.map(m => m.type.replace(/_/g, ' ')).join(', ')}`);
    }
    return lines.join('\n');
}
// ============================================
// Creation Helpers
// ============================================
/**
 * Create an empty relationship attitude.
 */
function createEmptyAttitude() {
    return {
        feelings: [],
        secrets: [],
        wants: [],
    };
}
/**
 * Create a new relationship between two characters.
 */
function createRelationship(char1, char2, status = 'strangers', messageId) {
    const pair = sortPair(char1, char2);
    const aToB = createEmptyAttitude();
    const bToA = createEmptyAttitude();
    const relationship = {
        pair,
        status,
        aToB,
        bToA,
        milestones: [],
        history: [],
        versions: [],
    };
    // If messageId provided, create the initial version
    if (messageId !== undefined) {
        addRelationshipVersion(relationship, messageId);
    }
    return relationship;
}
/**
 * Add a milestone to a relationship (avoids duplicates).
 */
function addMilestone(relationship, milestone) {
    // Check if we already have this milestone type
    if (!hasMilestone(relationship, milestone.type)) {
        relationship.milestones.push(milestone);
    }
}
/**
 * Get the attitude direction for a character in a relationship.
 * Returns 'aToB' if the character is the first in the pair, 'bToA' otherwise.
 */
function getAttitudeDirection(relationship, fromCharacter) {
    return relationship.pair[0].toLowerCase() === fromCharacter.toLowerCase() ? 'aToB' : 'bToA';
}
/**
 * Update a specific character's attitude in a relationship.
 */
function updateAttitude(relationship, fromCharacter, updates) {
    const direction = getAttitudeDirection(relationship, fromCharacter);
    const attitude = relationship[direction];
    if (updates.feelings !== undefined) {
        attitude.feelings = updates.feelings;
    }
    if (updates.secrets !== undefined) {
        attitude.secrets = updates.secrets;
    }
    if (updates.wants !== undefined) {
        attitude.wants = updates.wants;
    }
}
// ============================================
// Time Comparison
// ============================================
/**
 * Convert NarrativeDateTime to a comparable number (timestamp-like).
 * Returns a number that can be compared with > < >= <= operators.
 */
function narrativeDateTimeToNumber(dt) {
    // YYYYMMDDHHMMSS format as a number for easy comparison
    return (dt.year * 10000000000 +
        dt.month * 100000000 +
        dt.day * 1000000 +
        dt.hour * 10000 +
        dt.minute * 100 +
        dt.second);
}
/**
 * Compare two NarrativeDateTime values.
 * Returns:
 *   - negative if a < b
 *   - 0 if a === b
 *   - positive if a > b
 */
function compareNarrativeDateTime(a, b) {
    return narrativeDateTimeToNumber(a) - narrativeDateTimeToNumber(b);
}
/**
 * Check if a NarrativeDateTime is >= a reference time.
 */
function isDateTimeOnOrAfter(dt, reference) {
    return compareNarrativeDateTime(dt, reference) >= 0;
}
// ============================================
// Milestone Cleanup
// ============================================
/**
 * Remove milestones from a relationship that occurred on or after a given time.
 * Returns the number of milestones removed.
 */
function clearMilestonesSince(relationship, sinceTime) {
    const originalCount = relationship.milestones.length;
    relationship.milestones = relationship.milestones.filter(m => !isDateTimeOnOrAfter(m.timestamp, sinceTime));
    return originalCount - relationship.milestones.length;
}
/**
 * Remove milestones from all relationships that occurred on or after a given time.
 * Returns the total number of milestones removed.
 */
function clearAllMilestonesSince(relationships, sinceTime) {
    let totalRemoved = 0;
    for (const rel of relationships) {
        totalRemoved += clearMilestonesSince(rel, sinceTime);
    }
    return totalRemoved;
}
/**
 * Remove milestones from a relationship that were created by a specific message.
 * Returns the number of milestones removed.
 */
function clearMilestonesForMessage(relationship, messageId) {
    const originalCount = relationship.milestones.length;
    relationship.milestones = relationship.milestones.filter(m => m.messageId !== messageId);
    return originalCount - relationship.milestones.length;
}
/**
 * Remove milestones from all relationships that were created by a specific message.
 * Returns the total number of milestones removed.
 */
function clearAllMilestonesForMessage(relationships, messageId) {
    let totalRemoved = 0;
    for (const rel of relationships) {
        totalRemoved += clearMilestonesForMessage(rel, messageId);
    }
    return totalRemoved;
}
// ============================================
// Version Management
// ============================================
/**
 * Add a new version snapshot to a relationship.
 * Call this when the relationship status changes.
 */
function addRelationshipVersion(relationship, messageId) {
    // Initialize versions array if it doesn't exist (legacy relationships)
    if (!relationship.versions) {
        relationship.versions = [];
    }
    const version = {
        messageId,
        status: relationship.status,
        aToB: {
            feelings: [...relationship.aToB.feelings],
            secrets: [...relationship.aToB.secrets],
            wants: [...relationship.aToB.wants],
        },
        bToA: {
            feelings: [...relationship.bToA.feelings],
            secrets: [...relationship.bToA.secrets],
            wants: [...relationship.bToA.wants],
        },
        milestones: [...relationship.milestones],
    };
    relationship.versions.push(version);
}
/**
 * Remove the latest version if it matches the given messageId.
 * Call this before re-extracting or on swipe to rollback.
 * Returns true if a version was removed.
 */
function popVersionForMessage(relationship, messageId) {
    if (!relationship.versions || relationship.versions.length === 0) {
        return false;
    }
    const lastVersion = relationship.versions[relationship.versions.length - 1];
    if (lastVersion.messageId === messageId) {
        relationship.versions.pop();
        // Restore state from the new last version (if any)
        if (relationship.versions.length > 0) {
            const previousVersion = relationship.versions[relationship.versions.length - 1];
            relationship.status = previousVersion.status;
            relationship.aToB = {
                feelings: [...previousVersion.aToB.feelings],
                secrets: [...previousVersion.aToB.secrets],
                wants: [...previousVersion.aToB.wants],
            };
            relationship.bToA = {
                feelings: [...previousVersion.bToA.feelings],
                secrets: [...previousVersion.bToA.secrets],
                wants: [...previousVersion.bToA.wants],
            };
            relationship.milestones = [...previousVersion.milestones];
        }
        return true;
    }
    return false;
}
/**
 * Get the latest version's messageId for context window calculation.
 * Returns undefined if no versions exist.
 */
function getLatestVersionMessageId(relationship) {
    if (!relationship.versions || relationship.versions.length === 0) {
        return undefined;
    }
    return relationship.versions[relationship.versions.length - 1].messageId;
}
/**
 * Get the relationship state as it was at or before a given messageId.
 * Returns the version data, or undefined if no version exists before that message.
 */
function getRelationshipAtMessage(relationship, messageId) {
    // Handle legacy relationships without versions array
    if (!relationship.versions || relationship.versions.length === 0) {
        return undefined;
    }
    // Find the latest version with messageId <= the given messageId
    for (let i = relationship.versions.length - 1; i >= 0; i--) {
        if (relationship.versions[i].messageId <= messageId) {
            return relationship.versions[i];
        }
    }
    return undefined;
}
/**
 * Get all relationships with their state as of a specific messageId.
 * Returns relationships with status/attitudes from the appropriate version.
 * Relationships without a version at or before the messageId are filtered out.
 */
function getRelationshipsAtMessage(relationships, messageId) {
    const result = [];
    for (const rel of relationships) {
        const version = getRelationshipAtMessage(rel, messageId);
        if (version) {
            // Return a relationship with the versioned state
            result.push({
                ...rel,
                status: version.status,
                aToB: version.aToB,
                bToA: version.bToA,
                milestones: version.milestones,
            });
        }
        // No version found - skip this relationship
    }
    return result;
}


/***/ },

/***/ "./src/types/state.ts"
/*!****************************!*\
  !*** ./src/types/state.ts ***!
  \****************************/
(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   EVENT_TYPES: () => (/* binding */ EVENT_TYPES),
/* harmony export */   EVENT_TYPE_GROUPS: () => (/* binding */ EVENT_TYPE_GROUPS),
/* harmony export */   MILESTONE_TYPES: () => (/* binding */ MILESTONE_TYPES),
/* harmony export */   NARRATIVE_STATE_VERSION: () => (/* binding */ NARRATIVE_STATE_VERSION),
/* harmony export */   RELATIONSHIP_STATUSES: () => (/* binding */ RELATIONSHIP_STATUSES),
/* harmony export */   TENSION_LEVELS: () => (/* binding */ TENSION_LEVELS),
/* harmony export */   TENSION_TYPES: () => (/* binding */ TENSION_TYPES)
/* harmony export */ });
// ============================================
// Runtime State Types
// ============================================
const EVENT_TYPES = [
    'conversation',
    'confession',
    'argument',
    'negotiation',
    'discovery',
    'secret_shared',
    'secret_revealed',
    'emotional',
    'supportive',
    'rejection',
    'comfort',
    'apology',
    'forgiveness',
    'laugh',
    'gift',
    'compliment',
    'tease',
    'flirt',
    'date',
    'i_love_you',
    'sleepover',
    'shared_meal',
    'shared_activity',
    'intimate_touch',
    'intimate_kiss',
    'intimate_embrace',
    'intimate_heated',
    'intimate_foreplay',
    'intimate_oral',
    'intimate_manual',
    'intimate_penetrative',
    'intimate_climax',
    'action',
    'combat',
    'danger',
    'decision',
    'promise',
    'betrayal',
    'lied',
    'exclusivity',
    'marriage',
    'pregnancy',
    'childbirth',
    'social',
    'achievement',
];
/**
 * Event type groups for UI display.
 */
const EVENT_TYPE_GROUPS = {
    conversation: ['conversation', 'confession', 'argument', 'negotiation'],
    discovery: ['discovery', 'secret_shared', 'secret_revealed'],
    emotional: ['emotional', 'supportive', 'rejection', 'comfort', 'apology', 'forgiveness'],
    bonding: [
        'laugh',
        'gift',
        'compliment',
        'tease',
        'flirt',
        'date',
        'i_love_you',
        'sleepover',
        'shared_meal',
        'shared_activity',
    ],
    intimacy_romantic: [
        'intimate_touch',
        'intimate_kiss',
        'intimate_embrace',
        'intimate_heated',
    ],
    intimacy_sexual: [
        'intimate_foreplay',
        'intimate_oral',
        'intimate_manual',
        'intimate_penetrative',
        'intimate_climax',
    ],
    action: ['action', 'combat', 'danger'],
    commitment: ['decision', 'promise', 'betrayal', 'lied'],
    life_events: ['exclusivity', 'marriage', 'pregnancy', 'childbirth'],
    social: ['social', 'achievement'],
};
// ============================================
// Constants
// ============================================
const NARRATIVE_STATE_VERSION = 2;
const TENSION_LEVELS = [
    'relaxed',
    'aware',
    'guarded',
    'tense',
    'charged',
    'volatile',
    'explosive',
];
const TENSION_TYPES = [
    'confrontation',
    'intimate',
    'vulnerable',
    'celebratory',
    'negotiation',
    'suspense',
    'conversation',
];
const RELATIONSHIP_STATUSES = [
    'strangers',
    'acquaintances',
    'friendly',
    'close',
    'intimate',
    'strained',
    'hostile',
    'complicated',
];
const MILESTONE_TYPES = [
    // Relationship firsts
    'first_meeting',
    'first_conflict',
    'first_alliance',
    // Emotional
    'confession',
    'emotional_intimacy',
    // Bonding
    'first_laugh',
    'first_gift',
    'first_date',
    'first_i_love_you',
    'first_sleepover',
    'first_shared_meal',
    // Physical intimacy (granular)
    'first_touch',
    'first_kiss',
    'first_embrace',
    'first_heated',
    // Sexual milestones (atomic)
    'first_foreplay',
    'first_oral',
    'first_manual',
    'first_penetrative',
    'first_climax',
    // Life commitment
    'promised_exclusivity',
    'marriage',
    'pregnancy',
    'had_child',
    // Trust & commitment
    'promise_made',
    'promise_broken',
    'betrayal',
    'reconciliation',
    'sacrifice',
    // Secrets
    'secret_shared',
    'secret_revealed',
    // Conflicts
    'major_argument',
    'major_reconciliation',
];


/***/ },

/***/ "./src/ui/components/ChapterHistory.tsx"
/*!**********************************************!*\
  !*** ./src/ui/components/ChapterHistory.tsx ***!
  \**********************************************/
(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   ChapterHistory: () => (/* binding */ ChapterHistory)
/* harmony export */ });
/* harmony import */ var react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react/jsx-runtime */ "./node_modules/react/jsx-runtime.js");
/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! react */ "./node_modules/react/index.js");
/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_1__);
/* harmony import */ var _EventList__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./EventList */ "./src/ui/components/EventList.tsx");

// ============================================
// Chapter History Component
// ============================================


// ============================================
// Helpers
// ============================================
function formatChapterTime(dt) {
    const hour12 = dt.hour % 12 || 12;
    const ampm = dt.hour < 12 ? 'AM' : 'PM';
    const minute = dt.minute.toString().padStart(2, '0');
    const dayAbbrev = {
        Monday: 'Mon',
        Tuesday: 'Tue',
        Wednesday: 'Wed',
        Thursday: 'Thu',
        Friday: 'Fri',
        Saturday: 'Sat',
        Sunday: 'Sun',
    };
    const day = dayAbbrev[dt.dayOfWeek] || dt.dayOfWeek.slice(0, 3);
    return `${day} ${hour12}:${minute} ${ampm}`;
}
function formatTimeRange(start, end) {
    const startStr = formatChapterTime(start);
    const endStr = formatChapterTime(end);
    // If same day, simplify
    if (start.dayOfWeek === end.dayOfWeek) {
        const startTime = `${start.hour % 12 || 12}:${start.minute.toString().padStart(2, '0')} ${start.hour < 12 ? 'AM' : 'PM'}`;
        const endTime = `${end.hour % 12 || 12}:${end.minute.toString().padStart(2, '0')} ${end.hour < 12 ? 'AM' : 'PM'}`;
        const dayAbbrev = {
            Monday: 'Mon',
            Tuesday: 'Tue',
            Wednesday: 'Wed',
            Thursday: 'Thu',
            Friday: 'Fri',
            Saturday: 'Sat',
            Sunday: 'Sun',
        };
        const day = dayAbbrev[start.dayOfWeek] || start.dayOfWeek.slice(0, 3);
        return `${day} ${startTime} - ${endTime}`;
    }
    return `${startStr} - ${endStr}`;
}
// ============================================
// Components
// ============================================
function ChapterCard({ chapter, isExpanded, onToggle, editMode, onUpdateChapter, onDeleteChapter, onUpdateEvent, onDeleteEvent, }) {
    const [editingTitle, setEditingTitle] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)(chapter.title);
    const [editingSummary, setEditingSummary] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)(chapter.summary);
    const hasOutcomes = chapter.outcomes &&
        (chapter.outcomes.relationshipChanges.length > 0 ||
            chapter.outcomes.secretsRevealed.length > 0);
    const handleTitleChange = (e) => {
        setEditingTitle(e.target.value);
    };
    const handleTitleBlur = () => {
        if (onUpdateChapter && editingTitle !== chapter.title) {
            onUpdateChapter({ ...chapter, title: editingTitle });
        }
    };
    const handleSummaryChange = (e) => {
        setEditingSummary(e.target.value);
    };
    const handleSummaryBlur = () => {
        if (onUpdateChapter && editingSummary !== chapter.summary) {
            onUpdateChapter({ ...chapter, summary: editingSummary });
        }
    };
    return ((0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxs)("div", { className: `bt-chapter-card ${isExpanded ? 'bt-expanded' : ''}`, children: [(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxs)("div", { className: "bt-chapter-header", onClick: editMode ? undefined : onToggle, children: [(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxs)("div", { className: "bt-chapter-number", children: [(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)("i", { className: "fa-solid fa-bookmark" }), (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxs)("span", { children: ["Chapter ", chapter.index + 1] })] }), editMode ? ((0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)("input", { type: "text", className: "bt-chapter-title-input", value: editingTitle, onChange: handleTitleChange, onBlur: handleTitleBlur, onClick: e => e.stopPropagation() })) : ((0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)("div", { className: "bt-chapter-title", children: chapter.title })), (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)("div", { className: "bt-chapter-time", children: formatTimeRange(chapter.timeRange.start, chapter.timeRange.end) }), editMode && ((0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)("button", { type: "button", className: "bt-delete-btn-small", onClick: e => {
                            e.stopPropagation();
                            onDeleteChapter?.();
                        }, title: "Delete chapter", children: (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)("i", { className: "fa-solid fa-trash" }) })), (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)("i", { className: `fa-solid ${isExpanded ? 'fa-chevron-up' : 'fa-chevron-down'} bt-expand-icon`, onClick: editMode ? onToggle : undefined })] }), isExpanded && ((0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxs)("div", { className: "bt-chapter-details", children: [(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxs)("div", { className: "bt-chapter-summary", children: [(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxs)("div", { className: "bt-section-header", children: [(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)("i", { className: "fa-solid fa-align-left" }), ' ', "Summary"] }), editMode ? ((0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)("textarea", { className: "bt-chapter-summary-input", value: editingSummary, onChange: handleSummaryChange, onBlur: handleSummaryBlur, rows: 3 })) : ((0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)("p", { children: chapter.summary }))] }), chapter.primaryLocation && ((0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxs)("div", { className: "bt-chapter-location", children: [(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxs)("div", { className: "bt-section-header", children: [(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)("i", { className: "fa-solid fa-location-dot" }), ' ', "Location"] }), (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)("p", { children: chapter.primaryLocation })] })), hasOutcomes && chapter.outcomes && ((0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxs)("div", { className: "bt-chapter-outcomes", children: [(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxs)("div", { className: "bt-section-header", children: [(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)("i", { className: "fa-solid fa-flag-checkered" }), ' ', "Outcomes"] }), chapter.outcomes.relationshipChanges
                                .length > 0 && ((0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxs)("div", { className: "bt-outcome-group", children: [(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)("span", { className: "bt-outcome-label", children: "Relationship Changes:" }), (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)("ul", { children: chapter.outcomes.relationshipChanges.map((change, i) => ((0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)("li", { children: change }, i))) })] })), chapter.outcomes.secretsRevealed.length >
                                0 && ((0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxs)("div", { className: "bt-outcome-group", children: [(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)("span", { className: "bt-outcome-label", children: "Secrets Revealed:" }), (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)("ul", { children: chapter.outcomes.secretsRevealed.map((secret, i) => ((0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)("li", { children: secret }, i))) })] }))] })), chapter.events.length > 0 && ((0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxs)("div", { className: "bt-chapter-events", children: [(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxs)("div", { className: "bt-section-header", children: [(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)("i", { className: "fa-solid fa-list" }), ' ', "Events (", chapter.events.length, ")"] }), editMode ? ((0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(_EventList__WEBPACK_IMPORTED_MODULE_2__.EventList, { events: chapter.events, editMode: true, onUpdate: onUpdateEvent, onDelete: onDeleteEvent })) : ((0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)("ul", { className: "bt-events-list", children: chapter.events.map((event, i) => ((0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxs)("li", { className: "bt-archived-event", children: [(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)("span", { className: "bt-event-time", children: formatChapterTime(event.timestamp) }), (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)("span", { className: "bt-event-summary", children: event.summary }), (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxs)("span", { className: "bt-event-tension", children: ["(", event.tensionLevel, ' ', event.tensionType, ")"] })] }, i))) }))] }))] }))] }));
}
function ChapterHistory({ chapters, editMode, onUpdate }) {
    const [expandedIds, setExpandedIds] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)(new Set());
    const toggleExpanded = (index) => {
        setExpandedIds(prev => {
            const next = new Set(prev);
            if (next.has(index)) {
                next.delete(index);
            }
            else {
                next.add(index);
            }
            return next;
        });
    };
    const expandAll = () => {
        setExpandedIds(new Set(chapters.map(c => c.index)));
    };
    const collapseAll = () => {
        setExpandedIds(new Set());
    };
    const handleUpdateChapter = (chapterIndex, updatedChapter) => {
        if (onUpdate) {
            const newChapters = chapters.map(ch => ch.index === chapterIndex ? updatedChapter : ch);
            onUpdate(newChapters);
        }
    };
    const handleDeleteChapter = (chapterIndex) => {
        if (onUpdate) {
            const newChapters = chapters.filter(ch => ch.index !== chapterIndex);
            // Re-index remaining chapters
            const reindexedChapters = newChapters.map((ch, idx) => ({
                ...ch,
                index: idx,
            }));
            onUpdate(reindexedChapters);
        }
    };
    const handleUpdateEvent = (chapterIndex, eventIndex, event) => {
        if (onUpdate) {
            const newChapters = chapters.map(ch => {
                if (ch.index === chapterIndex) {
                    const newEvents = [...ch.events];
                    newEvents[eventIndex] = event;
                    return { ...ch, events: newEvents };
                }
                return ch;
            });
            onUpdate(newChapters);
        }
    };
    const handleDeleteEvent = (chapterIndex, eventIndex) => {
        if (onUpdate) {
            const newChapters = chapters.map(ch => {
                if (ch.index === chapterIndex) {
                    const newEvents = ch.events.filter((_, i) => i !== eventIndex);
                    return { ...ch, events: newEvents };
                }
                return ch;
            });
            onUpdate(newChapters);
        }
    };
    if (chapters.length === 0) {
        return ((0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)("div", { className: "bt-chapter-history bt-empty", children: (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)("p", { children: "No chapters recorded yet." }) }));
    }
    // Show chapters in reverse order (most recent first)
    const sortedChapters = [...chapters].sort((a, b) => b.index - a.index);
    return ((0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxs)("div", { className: "bt-chapter-history", children: [chapters.length > 1 && ((0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxs)("div", { className: "bt-chapter-controls", children: [(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxs)("button", { className: "bt-btn bt-btn-small", onClick: expandAll, children: [(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)("i", { className: "fa-solid fa-angles-down" }), " Expand All"] }), (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxs)("button", { className: "bt-btn bt-btn-small", onClick: collapseAll, children: [(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)("i", { className: "fa-solid fa-angles-up" }), " Collapse All"] }), (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxs)("span", { className: "bt-chapter-count", children: [chapters.length, " chapter", chapters.length !== 1 ? 's' : ''] })] })), (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)("div", { className: "bt-chapter-list", children: sortedChapters.map(chapter => ((0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(ChapterCard, { chapter: chapter, isExpanded: expandedIds.has(chapter.index), onToggle: () => toggleExpanded(chapter.index), editMode: editMode, onUpdateChapter: ch => handleUpdateChapter(chapter.index, ch), onDeleteChapter: () => handleDeleteChapter(chapter.index), onUpdateEvent: (evtIdx, evt) => handleUpdateEvent(chapter.index, evtIdx, evt), onDeleteEvent: evtIdx => handleDeleteEvent(chapter.index, evtIdx) }, chapter.index))) })] }));
}


/***/ },

/***/ "./src/ui/components/EventEditor.tsx"
/*!*******************************************!*\
  !*** ./src/ui/components/EventEditor.tsx ***!
  \*******************************************/
(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   EventEditor: () => (/* binding */ EventEditor)
/* harmony export */ });
/* harmony import */ var react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react/jsx-runtime */ "./node_modules/react/jsx-runtime.js");
/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! react */ "./node_modules/react/index.js");
/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_1__);
/* harmony import */ var _types_state__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../types/state */ "./src/types/state.ts");
/* harmony import */ var _form_TagInput__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./form/TagInput */ "./src/ui/components/form/TagInput.tsx");

// ============================================
// Event Editor Component
// ============================================



// ============================================
// Component
// ============================================
function EventEditor({ event, onSave, onCancel }) {
    const [summary, setSummary] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)(event.summary);
    const [eventTypes, setEventTypes] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)(event.eventTypes || ['conversation']);
    const [tensionLevel, setTensionLevel] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)(event.tensionLevel);
    const [tensionType, setTensionType] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)(event.tensionType);
    const [witnesses, setWitnesses] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)(event.witnesses || []);
    // Relationship signal state
    const [hasPair, setHasPair] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)(!!event.relationshipSignal?.pair);
    const [pairChar1, setPairChar1] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)(event.relationshipSignal?.pair?.[0] || '');
    const [pairChar2, setPairChar2] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)(event.relationshipSignal?.pair?.[1] || '');
    const [milestones, setMilestones] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)(event.relationshipSignal?.milestones || []);
    // New milestone form state
    const [newMilestoneType, setNewMilestoneType] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)('first_meeting');
    const [newMilestoneDesc, setNewMilestoneDesc] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)('');
    const handleSave = () => {
        const updatedEvent = {
            ...event,
            summary,
            eventTypes,
            tensionLevel,
            tensionType,
            witnesses,
        };
        // Update relationship signal
        if (hasPair && pairChar1 && pairChar2) {
            const sortedPair = [pairChar1, pairChar2].sort();
            updatedEvent.relationshipSignal = {
                pair: sortedPair,
                milestones: milestones.length > 0 ? milestones : undefined,
            };
        }
        else {
            updatedEvent.relationshipSignal = undefined;
        }
        onSave(updatedEvent);
    };
    const handleAddMilestone = () => {
        if (newMilestoneType) {
            const newMilestone = {
                type: newMilestoneType,
                description: newMilestoneDesc,
                timestamp: event.timestamp,
                location: event.location,
                messageId: event.messageId,
            };
            setMilestones([...milestones, newMilestone]);
            setNewMilestoneType('first_meeting');
            setNewMilestoneDesc('');
        }
    };
    const handleRemoveMilestone = (index) => {
        setMilestones(milestones.filter((_, i) => i !== index));
    };
    const handleToggleEventType = (type) => {
        if (eventTypes.includes(type)) {
            // Don't allow removing the last event type
            if (eventTypes.length > 1) {
                setEventTypes(eventTypes.filter(t => t !== type));
            }
        }
        else {
            setEventTypes([...eventTypes, type]);
        }
    };
    return ((0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxs)("div", { className: "bt-event-editor", children: [(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxs)("div", { className: "bt-editor-field", children: [(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)("label", { htmlFor: "event-summary", children: "Summary" }), (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)("textarea", { id: "event-summary", value: summary, onChange: e => setSummary(e.target.value), rows: 2, placeholder: "Event summary..." })] }), (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxs)("div", { className: "bt-editor-field", children: [(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)("label", { children: "Event Types" }), (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)("div", { className: "bt-event-type-grid", children: _types_state__WEBPACK_IMPORTED_MODULE_2__.EVENT_TYPES.map(type => ((0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxs)("label", { className: "bt-event-type-option", children: [(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)("input", { type: "checkbox", checked: eventTypes.includes(type), onChange: () => handleToggleEventType(type) }), (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)("span", { children: type.replace(/_/g, ' ') })] }, type))) })] }), (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxs)("div", { className: "bt-editor-row", children: [(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxs)("div", { className: "bt-editor-field", children: [(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)("label", { htmlFor: "tension-level", children: "Tension Level" }), (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)("select", { id: "tension-level", value: tensionLevel, onChange: e => setTensionLevel(e.target.value), children: _types_state__WEBPACK_IMPORTED_MODULE_2__.TENSION_LEVELS.map(level => ((0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)("option", { value: level, children: level }, level))) })] }), (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxs)("div", { className: "bt-editor-field", children: [(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)("label", { htmlFor: "tension-type", children: "Tension Type" }), (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)("select", { id: "tension-type", value: tensionType, onChange: e => setTensionType(e.target.value), children: _types_state__WEBPACK_IMPORTED_MODULE_2__.TENSION_TYPES.map(type => ((0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)("option", { value: type, children: type }, type))) })] })] }), (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxs)("div", { className: "bt-editor-field", children: [(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)("label", { children: "Witnesses" }), (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(_form_TagInput__WEBPACK_IMPORTED_MODULE_3__.TagInput, { tags: witnesses, onChange: setWitnesses, placeholder: "Add witness..." })] }), (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxs)("div", { className: "bt-editor-section", children: [(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxs)("label", { className: "bt-section-toggle", children: [(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)("input", { type: "checkbox", checked: hasPair, onChange: e => setHasPair(e.target.checked) }), (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)("span", { children: "Relationship Signal" })] }), hasPair && ((0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxs)("div", { className: "bt-relationship-signal-editor", children: [(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxs)("div", { className: "bt-editor-row", children: [(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxs)("div", { className: "bt-editor-field", children: [(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)("label", { htmlFor: "pair-char1", children: "Character 1" }), (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)("input", { id: "pair-char1", type: "text", value: pairChar1, onChange: e => setPairChar1(e.target
                                                    .value), placeholder: "Name..." })] }), (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)("span", { className: "bt-pair-separator", children: "&" }), (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxs)("div", { className: "bt-editor-field", children: [(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)("label", { htmlFor: "pair-char2", children: "Character 2" }), (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)("input", { id: "pair-char2", type: "text", value: pairChar2, onChange: e => setPairChar2(e.target
                                                    .value), placeholder: "Name..." })] })] }), (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxs)("div", { className: "bt-milestones-editor", children: [(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)("label", { children: "Milestones" }), milestones.length > 0 && ((0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)("ul", { className: "bt-milestones-list-edit", children: milestones.map((m, i) => ((0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxs)("li", { children: [(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)("span", { className: "bt-milestone-type", children: m.type.replace(/_/g, ' ') }), m.description && ((0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)("span", { className: "bt-milestone-desc", children: m.description })), (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)("button", { type: "button", className: "bt-delete-btn-small", onClick: () => handleRemoveMilestone(i), title: "Remove milestone", children: (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)("i", { className: "fa-solid fa-times" }) })] }, i))) })), (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxs)("div", { className: "bt-add-milestone", children: [(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)("select", { value: newMilestoneType, onChange: e => setNewMilestoneType(e.target
                                                    .value), children: _types_state__WEBPACK_IMPORTED_MODULE_2__.MILESTONE_TYPES.map(type => ((0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)("option", { value: type, children: type.replace(/_/g, ' ') }, type))) }), (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)("input", { type: "text", value: newMilestoneDesc, onChange: e => setNewMilestoneDesc(e.target
                                                    .value), placeholder: "Description (optional)..." }), (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)("button", { type: "button", className: "bt-btn bt-btn-small", onClick: handleAddMilestone, children: (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)("i", { className: "fa-solid fa-plus" }) })] })] })] }))] }), (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxs)("div", { className: "bt-editor-actions", children: [(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)("button", { type: "button", className: "bt-btn bt-btn-secondary", onClick: onCancel, children: "Cancel" }), (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)("button", { type: "button", className: "bt-btn bt-btn-primary", onClick: handleSave, children: "Save" })] })] }));
}


/***/ },

/***/ "./src/ui/components/EventList.tsx"
/*!*****************************************!*\
  !*** ./src/ui/components/EventList.tsx ***!
  \*****************************************/
(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   EventList: () => (/* binding */ EventList)
/* harmony export */ });
/* harmony import */ var react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react/jsx-runtime */ "./node_modules/react/jsx-runtime.js");
/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! react */ "./node_modules/react/index.js");
/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_1__);
/* harmony import */ var _icons__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../icons */ "./src/ui/icons.ts");
/* harmony import */ var _EventEditor__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./EventEditor */ "./src/ui/components/EventEditor.tsx");

// ============================================
// Event List Component
// ============================================



// ============================================
// Helpers
// ============================================
function formatEventTime(dt) {
    const hour12 = dt.hour % 12 || 12;
    const ampm = dt.hour < 12 ? 'AM' : 'PM';
    const minute = dt.minute.toString().padStart(2, '0');
    return `${dt.dayOfWeek} ${hour12}:${minute} ${ampm}`;
}
function getAbsentWitnesses(witnesses, presentCharacters) {
    const presentSet = new Set(presentCharacters.map(c => c.toLowerCase()));
    return witnesses.filter(w => !presentSet.has(w.toLowerCase()));
}
/**
 * Sort event types by salience (priority) order.
 */
function sortByPriority(types) {
    return [...types].sort((a, b) => {
        const aIndex = _icons__WEBPACK_IMPORTED_MODULE_2__.EVENT_TYPE_PRIORITY.indexOf(a);
        const bIndex = _icons__WEBPACK_IMPORTED_MODULE_2__.EVENT_TYPE_PRIORITY.indexOf(b);
        // Types not in priority list go to the end
        const aPos = aIndex === -1 ? _icons__WEBPACK_IMPORTED_MODULE_2__.EVENT_TYPE_PRIORITY.length : aIndex;
        const bPos = bIndex === -1 ? _icons__WEBPACK_IMPORTED_MODULE_2__.EVENT_TYPE_PRIORITY.length : bIndex;
        return aPos - bPos;
    });
}
// ============================================
// Components
// ============================================
function EventItem({ event, index: _index, presentCharacters, opacity = 1, editMode, onEdit, onDelete, }) {
    const levelIconClass = (0,_icons__WEBPACK_IMPORTED_MODULE_2__.getTensionLevelIcon)(event.tensionLevel);
    const levelColor = (0,_icons__WEBPACK_IMPORTED_MODULE_2__.getTensionColor)(event.tensionLevel);
    const typeIconClass = (0,_icons__WEBPACK_IMPORTED_MODULE_2__.getTensionIcon)(event.tensionType);
    const typeColor = (0,_icons__WEBPACK_IMPORTED_MODULE_2__.getTensionTypeColor)(event.tensionType);
    const milestones = event.relationshipSignal?.milestones ?? [];
    // Get event types sorted by salience
    const eventTypes = event.eventTypes?.length
        ? sortByPriority(event.eventTypes)
        : ['conversation'];
    // Calculate absent witnesses for dramatic irony notes
    const absentWitnesses = presentCharacters
        ? getAbsentWitnesses(event.witnesses, presentCharacters)
        : [];
    // Format tooltips
    const levelTooltip = `Level: ${event.tensionLevel}`;
    const typeTooltip = `Type: ${event.tensionType}`;
    return ((0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxs)("div", { className: "bt-event-item", style: {
            borderLeftColor: levelColor,
            '--bt-event-opacity': opacity,
        }, children: [(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxs)("div", { className: "bt-event-header", children: [(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)("span", { className: "bt-event-time", children: formatEventTime(event.timestamp) }), (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxs)("div", { className: "bt-event-header-right", children: [(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)("span", { className: "bt-event-types", children: eventTypes.map((type, idx) => ((0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)("i", { className: (0,_icons__WEBPACK_IMPORTED_MODULE_2__.getEventTypeIcon)(type), style: {
                                        color: (0,_icons__WEBPACK_IMPORTED_MODULE_2__.getEventTypeColor)(type),
                                    }, title: type.replace(/_/g, ' ') }, idx))) }), editMode && ((0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxs)("div", { className: "bt-event-actions", children: [(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)("button", { type: "button", className: "bt-edit-btn-small", onClick: onEdit, title: "Edit event", children: (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)("i", { className: "fa-solid fa-pen" }) }), (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)("button", { type: "button", className: "bt-delete-btn-small", onClick: onDelete, title: "Delete event", children: (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)("i", { className: "fa-solid fa-trash" }) })] }))] })] }), milestones.length > 0 && ((0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)("div", { className: "bt-event-milestones", children: milestones.map((m, idx) => ((0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxs)("span", { className: "bt-milestone-item", children: [(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)("i", { className: "fa-solid fa-star" }), (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)("span", { className: "bt-milestone-type", children: m.type.replace(/_/g, ' ') }), m.description && ((0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)("span", { className: "bt-milestone-desc", children: m.description }))] }, idx))) })), (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)("div", { className: "bt-event-summary", children: event.summary }), (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxs)("div", { className: "bt-event-footer", children: [(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxs)("div", { className: "bt-event-people", children: [event.witnesses.length > 0 && ((0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxs)("div", { className: "bt-event-witnesses", children: [(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)("span", { className: "bt-witnesses-label", children: "Witnesses:" }), event.witnesses.map((w, i) => ((0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)("span", { className: "bt-witness", children: w }, i)))] })), absentWitnesses.length > 0 && ((0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxs)("div", { className: "bt-event-absent", children: [(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)("span", { className: "bt-absent-label", children: "Not present:" }), absentWitnesses.map((w, i) => ((0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)("span", { className: "bt-absent-witness", children: w }, i)))] }))] }), (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxs)("div", { className: "bt-event-tension", children: [(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)("i", { className: typeIconClass, style: { color: typeColor }, title: typeTooltip }), (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)("i", { className: levelIconClass, style: { color: levelColor }, title: levelTooltip })] })] })] }));
}
function EventList({ events, presentCharacters, maxEvents, editMode, onUpdate, onDelete, }) {
    const [editingIndex, setEditingIndex] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)(null);
    // Get the most recent events (from the end of the array)
    const recentEvents = maxEvents ? events.slice(-maxEvents) : events;
    // Reverse to show newest first
    const displayEvents = [...recentEvents].reverse();
    // Calculate the original index from display index
    const getOriginalIndex = (displayIndex) => {
        // displayEvents is reversed, so we need to map back
        const recentIndex = displayEvents.length - 1 - displayIndex;
        // Then add the offset from slice
        const startOffset = events.length - recentEvents.length;
        return startOffset + recentIndex;
    };
    const handleEdit = (displayIndex) => {
        setEditingIndex(getOriginalIndex(displayIndex));
    };
    const handleDelete = (displayIndex) => {
        if (onDelete) {
            onDelete(getOriginalIndex(displayIndex));
        }
    };
    const handleSaveEdit = (event) => {
        if (onUpdate && editingIndex !== null) {
            onUpdate(editingIndex, event);
            setEditingIndex(null);
        }
    };
    const handleCancelEdit = () => {
        setEditingIndex(null);
    };
    if (displayEvents.length === 0) {
        return ((0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)("div", { className: "bt-event-list bt-empty", children: (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)("p", { children: "No events recorded yet." }) }));
    }
    // Find the event being edited (if any)
    const eventBeingEdited = editingIndex !== null ? events[editingIndex] : null;
    return ((0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxs)("div", { className: "bt-event-list", children: [editingIndex !== null && eventBeingEdited && ((0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)("div", { className: "bt-event-editor-container", children: (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(_EventEditor__WEBPACK_IMPORTED_MODULE_3__.EventEditor, { event: eventBeingEdited, onSave: handleSaveEdit, onCancel: handleCancelEdit }) })), displayEvents.map((event, displayIndex) => {
                const originalIndex = getOriginalIndex(displayIndex);
                // Skip showing the item being edited
                if (originalIndex === editingIndex) {
                    return null;
                }
                // Decrease opacity for older events: 100%, 75%, 50%, 40% (min)
                const opacity = Math.max(0.4, 1 - displayIndex * 0.25);
                return ((0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(EventItem, { event: event, index: originalIndex, presentCharacters: presentCharacters, opacity: editMode ? 1 : opacity, editMode: editMode, onEdit: () => handleEdit(displayIndex), onDelete: () => handleDelete(displayIndex) }, originalIndex));
            })] }));
}


/***/ },

/***/ "./src/ui/components/NarrativeModal.tsx"
/*!**********************************************!*\
  !*** ./src/ui/components/NarrativeModal.tsx ***!
  \**********************************************/
(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   NarrativeModal: () => (/* binding */ NarrativeModal)
/* harmony export */ });
/* harmony import */ var react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react/jsx-runtime */ "./node_modules/react/jsx-runtime.js");
/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! react */ "./node_modules/react/index.js");
/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_1__);
/* harmony import */ var react_dom__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! react-dom */ "./node_modules/react-dom/index.js");
/* harmony import */ var _ChapterHistory__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./ChapterHistory */ "./src/ui/components/ChapterHistory.tsx");
/* harmony import */ var _TensionGraph__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./TensionGraph */ "./src/ui/components/TensionGraph.tsx");
/* harmony import */ var _EventList__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./EventList */ "./src/ui/components/EventList.tsx");
/* harmony import */ var _tabs_RelationshipsTab__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ../tabs/RelationshipsTab */ "./src/ui/tabs/RelationshipsTab.tsx");

// ============================================
// Narrative Modal Component
// ============================================






// ============================================
// Component
// ============================================
function NarrativeModal({ narrativeState, currentEvents = [], presentCharacters, onClose, onSave, initialTab = 'chapters', }) {
    const [activeTab, setActiveTab] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)(initialTab);
    const [editMode, setEditMode] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)(false);
    const [saving, setSaving] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)(false);
    // Working copies for edit mode
    const [editChapters, setEditChapters] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)([]);
    const [editRelationships, setEditRelationships] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)([]);
    const [editCurrentEvents, setEditCurrentEvents] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)([]);
    // Track deleted events for syncing back to messages
    const [deletedEvents, setDeletedEvents] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)([]);
    // Initialize edit state when entering edit mode
    const enterEditMode = (0,react__WEBPACK_IMPORTED_MODULE_1__.useCallback)(() => {
        setEditChapters(JSON.parse(JSON.stringify(narrativeState.chapters)));
        setEditRelationships(JSON.parse(JSON.stringify(narrativeState.relationships)));
        setEditCurrentEvents(JSON.parse(JSON.stringify(currentEvents)));
        setDeletedEvents([]);
        setEditMode(true);
    }, [narrativeState, currentEvents]);
    const cancelEditMode = (0,react__WEBPACK_IMPORTED_MODULE_1__.useCallback)(() => {
        setEditMode(false);
        setEditChapters([]);
        setEditRelationships([]);
        setEditCurrentEvents([]);
        setDeletedEvents([]);
    }, []);
    const handleSave = (0,react__WEBPACK_IMPORTED_MODULE_1__.useCallback)(async () => {
        if (!onSave)
            return;
        setSaving(true);
        try {
            const updatedState = {
                ...narrativeState,
                chapters: editChapters,
                relationships: editRelationships,
            };
            await onSave(updatedState, deletedEvents, editCurrentEvents);
            setEditMode(false);
        }
        finally {
            setSaving(false);
        }
    }, [
        onSave,
        narrativeState,
        editChapters,
        editRelationships,
        editCurrentEvents,
        deletedEvents,
    ]);
    // Handle chapter updates
    const handleChaptersUpdate = (0,react__WEBPACK_IMPORTED_MODULE_1__.useCallback)((chapters) => {
        // Track deleted events from chapters
        const newChapterEventIds = new Set(chapters.flatMap(ch => ch.events.map(e => `${e.messageId}-${e.summary}`)));
        const oldEvents = editChapters.flatMap(ch => ch.events);
        for (const event of oldEvents) {
            if (!newChapterEventIds.has(`${event.messageId}-${event.summary}`)) {
                if (event.messageId !== undefined) {
                    setDeletedEvents(prev => [
                        ...prev,
                        {
                            messageId: event.messageId,
                            summary: event.summary,
                        },
                    ]);
                }
            }
        }
        setEditChapters(chapters);
    }, [editChapters]);
    // Handle current events updates
    const handleCurrentEventUpdate = (0,react__WEBPACK_IMPORTED_MODULE_1__.useCallback)((index, event) => {
        const newEvents = [...editCurrentEvents];
        newEvents[index] = event;
        setEditCurrentEvents(newEvents);
    }, [editCurrentEvents]);
    const handleCurrentEventDelete = (0,react__WEBPACK_IMPORTED_MODULE_1__.useCallback)((index) => {
        const event = editCurrentEvents[index];
        if (event.messageId !== undefined) {
            setDeletedEvents(prev => [
                ...prev,
                { messageId: event.messageId, summary: event.summary },
            ]);
        }
        setEditCurrentEvents(editCurrentEvents.filter((_, i) => i !== index));
    }, [editCurrentEvents]);
    // Close on escape key (only if not in edit mode)
    (0,react__WEBPACK_IMPORTED_MODULE_1__.useEffect)(() => {
        const handleKeyDown = (e) => {
            if (e.key === 'Escape' && !editMode) {
                onClose();
            }
        };
        window.addEventListener('keydown', handleKeyDown);
        return () => window.removeEventListener('keydown', handleKeyDown);
    }, [onClose, editMode]);
    // Prevent scrolling of body while modal is open
    (0,react__WEBPACK_IMPORTED_MODULE_1__.useEffect)(() => {
        document.body.style.overflow = 'hidden';
        return () => {
            document.body.style.overflow = '';
        };
    }, []);
    // Use edit state or original state based on mode
    const displayChapters = editMode ? editChapters : narrativeState.chapters;
    const displayRelationships = editMode ? editRelationships : narrativeState.relationships;
    const displayCurrentEvents = editMode ? editCurrentEvents : currentEvents;
    // Get all events from all chapters
    const allChapterEvents = displayChapters.flatMap(ch => ch.events);
    // All events for tension graph (including current)
    const allEvents = [...allChapterEvents, ...displayCurrentEvents];
    // Render to body via portal to avoid container positioning issues
    return (0,react_dom__WEBPACK_IMPORTED_MODULE_2__.createPortal)((0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)("div", { className: "bt-modal-overlay", onClick: e => {
            if (e.target === e.currentTarget && !editMode)
                onClose();
        }, children: (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxs)("div", { className: "bt-modal-container bt-narrative-modal", children: [(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxs)("div", { className: "bt-modal-header", children: [(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)("h2", { children: editMode
                                ? 'Editing Narrative'
                                : 'Narrative Overview' }), (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxs)("div", { className: "bt-modal-header-actions", children: [editMode ? ((0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxs)(react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.Fragment, { children: [(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)("button", { className: "bt-btn bt-btn-secondary", onClick: cancelEditMode, disabled: saving, children: "Cancel" }), (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)("button", { className: "bt-btn bt-btn-primary", onClick: handleSave, disabled: saving, children: saving ? ((0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxs)(react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.Fragment, { children: [(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)("i", { className: "fa-solid fa-spinner fa-spin" }), "Saving..."] })) : ((0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxs)(react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.Fragment, { children: [(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)("i", { className: "fa-solid fa-check" }), "Save"] })) })] })) : (onSave && ((0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxs)("button", { className: "bt-btn bt-btn-secondary", onClick: enterEditMode, title: "Enable editing of narrative state", children: [(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)("i", { className: "fa-solid fa-pen" }), "Enable Editing"] }))), (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)("button", { className: "bt-modal-close", onClick: onClose, disabled: editMode, children: (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)("i", { className: "fa-solid fa-xmark" }) })] })] }), (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxs)("div", { className: "bt-modal-tabs", children: [(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxs)("button", { className: `bt-tab ${activeTab === 'events' ? 'bt-tab-active' : ''}`, onClick: () => setActiveTab('events'), children: [(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)("i", { className: "fa-solid fa-bolt" }), (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxs)("span", { children: ["Events (", displayCurrentEvents.length, ")"] })] }), (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxs)("button", { className: `bt-tab ${activeTab === 'chapters' ? 'bt-tab-active' : ''}`, onClick: () => setActiveTab('chapters'), children: [(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)("i", { className: "fa-solid fa-book" }), (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxs)("span", { children: ["Chapters (", displayChapters.length, ")"] })] }), (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxs)("button", { className: `bt-tab ${activeTab === 'relationships' ? 'bt-tab-active' : ''}`, onClick: () => setActiveTab('relationships'), children: [(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)("i", { className: "fa-solid fa-heart" }), (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxs)("span", { children: ["Relationships (", displayRelationships.length, ")"] })] })] }), (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxs)("div", { className: "bt-modal-content", children: [activeTab === 'events' && ((0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)("div", { className: "bt-events-tab-content", children: displayCurrentEvents.length > 0 ? ((0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(_EventList__WEBPACK_IMPORTED_MODULE_5__.EventList, { events: displayCurrentEvents, presentCharacters: presentCharacters, editMode: editMode, onUpdate: handleCurrentEventUpdate, onDelete: handleCurrentEventDelete })) : ((0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)("p", { className: "bt-empty-message", children: "No events in the current chapter yet." })) })), activeTab === 'chapters' && ((0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxs)("div", { className: "bt-chapters-tab-content", children: [allEvents.length > 0 && !editMode && ((0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxs)("div", { className: "bt-tension-graph-section", children: [(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxs)("h3", { children: [(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)("i", { className: "fa-solid fa-chart-line" }), "Tension Over Time"] }), (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(_TensionGraph__WEBPACK_IMPORTED_MODULE_4__.TensionGraph, { events: allEvents })] })), (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(_ChapterHistory__WEBPACK_IMPORTED_MODULE_3__.ChapterHistory, { chapters: displayChapters, editMode: editMode, onUpdate: handleChaptersUpdate })] })), activeTab === 'relationships' && ((0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(_tabs_RelationshipsTab__WEBPACK_IMPORTED_MODULE_6__.RelationshipsTab, { relationships: displayRelationships, presentCharacters: presentCharacters, editMode: editMode, onUpdate: setEditRelationships }))] })] }) }), document.body);
}


/***/ },

/***/ "./src/ui/components/TensionGraph.tsx"
/*!********************************************!*\
  !*** ./src/ui/components/TensionGraph.tsx ***!
  \********************************************/
(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   TensionGraph: () => (/* binding */ TensionGraph)
/* harmony export */ });
/* harmony import */ var react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react/jsx-runtime */ "./node_modules/react/jsx-runtime.js");
/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! react */ "./node_modules/react/index.js");
/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_1__);
/* harmony import */ var react_dom__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! react-dom */ "./node_modules/react-dom/index.js");
/* harmony import */ var _icons__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../icons */ "./src/ui/icons.ts");

// ============================================
// Tension Graph Component
// ============================================



// ============================================
// Constants
// ============================================
const PADDING = { top: 25, right: 20, bottom: 30, left: 50 };
const TENSION_LEVELS = [
    'relaxed',
    'aware',
    'guarded',
    'tense',
    'charged',
    'volatile',
    'explosive',
];
// ============================================
// Helpers
// ============================================
/**
 * Calculate the time span in minutes between first and last event.
 */
function getTimeSpanMinutes(events) {
    if (events.length < 2)
        return 0;
    const first = events[0].timestamp;
    const last = events[events.length - 1].timestamp;
    // Convert to minutes since midnight for comparison
    const firstMinutes = first.hour * 60 + first.minute;
    const lastMinutes = last.hour * 60 + last.minute;
    // Handle day boundaries (simple approach - assume same day or next day)
    let diff = lastMinutes - firstMinutes;
    if (diff < 0)
        diff += 24 * 60; // Crossed midnight
    return diff;
}
/**
 * Format time based on span - show minutes if the span is short.
 */
function formatTimeForSpan(event, spanMinutes) {
    const dt = event.timestamp;
    const hour12 = dt.hour % 12 || 12;
    const ampm = dt.hour < 12 ? 'a' : 'p';
    const minute = dt.minute.toString().padStart(2, '0');
    // If span is less than 2 hours, show minutes
    if (spanMinutes < 120) {
        return `${hour12}:${minute}${ampm}`;
    }
    // If span is less than 6 hours, show minutes on the hour boundaries
    if (spanMinutes < 360) {
        return dt.minute === 0 ? `${hour12}${ampm}` : `${hour12}:${minute}${ampm}`;
    }
    // Otherwise just show hour
    return `${hour12}${ampm}`;
}
// ============================================
// Component
// ============================================
function TensionGraph({ events, width: propWidth, height: propHeight }) {
    const containerRef = (0,react__WEBPACK_IMPORTED_MODULE_1__.useRef)(null);
    const [dimensions, setDimensions] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)({
        width: propWidth ?? 400,
        height: propHeight ?? 250,
    });
    const [tooltip, setTooltip] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)({
        visible: false,
        x: 0,
        y: 0,
        event: null,
    });
    // Use ResizeObserver to track container size when no fixed dimensions provided
    (0,react__WEBPACK_IMPORTED_MODULE_1__.useEffect)(() => {
        if (propWidth && propHeight) {
            setDimensions({ width: propWidth, height: propHeight });
            return;
        }
        const container = containerRef.current;
        if (!container)
            return;
        const observer = new ResizeObserver(entries => {
            for (const entry of entries) {
                const { width, height } = entry.contentRect;
                if (width > 0 && height > 0) {
                    setDimensions({
                        width: propWidth ?? width,
                        height: propHeight ?? Math.max(250, height),
                    });
                }
            }
        });
        observer.observe(container);
        return () => observer.disconnect();
    }, [propWidth, propHeight]);
    const width = dimensions.width;
    const height = dimensions.height;
    // Calculate dimensions
    const graphWidth = width - PADDING.left - PADDING.right;
    const graphHeight = height - PADDING.top - PADDING.bottom;
    // Calculate time span for smart formatting
    const timeSpanMinutes = (0,react__WEBPACK_IMPORTED_MODULE_1__.useMemo)(() => getTimeSpanMinutes(events), [events]);
    // Generate points for the line
    const points = (0,react__WEBPACK_IMPORTED_MODULE_1__.useMemo)(() => {
        if (events.length === 0)
            return [];
        return events.map((event, index) => {
            const x = PADDING.left +
                (index / Math.max(events.length - 1, 1)) * graphWidth;
            const tensionValue = (0,_icons__WEBPACK_IMPORTED_MODULE_3__.getTensionValue)(event.tensionLevel);
            const y = PADDING.top + graphHeight - ((tensionValue - 1) / 6) * graphHeight;
            return { x, y, event };
        });
    }, [events, graphWidth, graphHeight]);
    // Generate path for the line
    const linePath = (0,react__WEBPACK_IMPORTED_MODULE_1__.useMemo)(() => {
        if (points.length === 0)
            return '';
        if (points.length === 1)
            return '';
        return points
            .map((point, i) => {
            return `${i === 0 ? 'M' : 'L'} ${point.x} ${point.y}`;
        })
            .join(' ');
    }, [points]);
    // Handle mouse events - use viewport coordinates for portal positioning
    const handlePointEnter = (point, e) => {
        setTooltip({
            visible: true,
            x: e.clientX,
            y: e.clientY - 10,
            event: point.event,
        });
    };
    const handlePointLeave = () => {
        setTooltip(prev => ({ ...prev, visible: false }));
    };
    if (events.length === 0) {
        return ((0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)("div", { className: "bt-tension-graph bt-empty", ref: containerRef, children: (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)("p", { children: "No events to graph." }) }));
    }
    return ((0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxs)("div", { className: "bt-tension-graph", ref: containerRef, children: [(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxs)("svg", { width: width, height: height, className: "bt-tension-svg", children: [TENSION_LEVELS.map((level, i) => {
                        const y = PADDING.top + graphHeight - (i / 6) * graphHeight;
                        const iconClass = (0,_icons__WEBPACK_IMPORTED_MODULE_3__.getTensionLevelIcon)(level);
                        const color = (0,_icons__WEBPACK_IMPORTED_MODULE_3__.getTensionColor)(level);
                        return ((0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxs)("g", { children: [(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)("line", { x1: PADDING.left - 5, y1: y, x2: PADDING.left, y2: y, stroke: "#666", strokeWidth: 1 }), (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)("foreignObject", { x: PADDING.left - 40, y: y - 10, width: 35, height: 20, children: (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)("i", { className: iconClass, style: {
                                            color,
                                            fontSize: '14px',
                                            display: 'block',
                                        }, title: level }) }), (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)("line", { x1: PADDING.left, y1: y, x2: width - PADDING.right, y2: y, stroke: "#333", strokeWidth: 1, strokeDasharray: "2,2" })] }, level));
                    }), (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)("line", { x1: PADDING.left, y1: height - PADDING.bottom, x2: width - PADDING.right, y2: height - PADDING.bottom, stroke: "#666", strokeWidth: 1 }), (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)("line", { x1: PADDING.left, y1: PADDING.top, x2: PADDING.left, y2: height - PADDING.bottom, stroke: "#666", strokeWidth: 1 }), linePath && ((0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)("path", { d: linePath, fill: "none", stroke: "#888", strokeWidth: 2, strokeLinejoin: "round", strokeLinecap: "round" })), points.map((point, i) => ((0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)("circle", { cx: point.x, cy: point.y, r: 6, fill: (0,_icons__WEBPACK_IMPORTED_MODULE_3__.getTensionColor)(point.event.tensionLevel), stroke: "#fff", strokeWidth: 2, className: "bt-graph-point", onMouseEnter: e => handlePointEnter(point, e), onMouseLeave: handlePointLeave }, i))), events.length > 0 && ((0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxs)(react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.Fragment, { children: [(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)("text", { x: PADDING.left, y: height - PADDING.bottom + 15, textAnchor: "start", className: "bt-graph-label", fontSize: 10, fill: "#999", children: formatTimeForSpan(events[0], timeSpanMinutes) }), events.length > 2 && ((0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)("text", { x: PADDING.left + graphWidth / 2, y: height - PADDING.bottom + 15, textAnchor: "middle", className: "bt-graph-label", fontSize: 10, fill: "#999", children: formatTimeForSpan(events[Math.floor(events.length /
                                    2)], timeSpanMinutes) })), events.length > 1 && ((0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)("text", { x: width - PADDING.right, y: height - PADDING.bottom + 15, textAnchor: "end", className: "bt-graph-label", fontSize: 10, fill: "#999", children: formatTimeForSpan(events[events.length - 1], timeSpanMinutes) }))] }))] }), tooltip.visible &&
                tooltip.event &&
                (0,react_dom__WEBPACK_IMPORTED_MODULE_2__.createPortal)((0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxs)("div", { className: "bt-graph-tooltip", style: {
                        position: 'fixed',
                        left: tooltip.x,
                        top: tooltip.y,
                        transform: 'translate(-50%, -100%)',
                    }, children: [(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxs)("div", { className: "bt-tooltip-level", style: {
                                color: (0,_icons__WEBPACK_IMPORTED_MODULE_3__.getTensionColor)(tooltip.event.tensionLevel),
                            }, children: [tooltip.event.tensionLevel, ' ', tooltip.event.tensionType] }), (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)("div", { className: "bt-tooltip-summary", children: tooltip.event.summary })] }), document.body)] }));
}


/***/ },

/***/ "./src/ui/components/display/CharacterCard.tsx"
/*!*****************************************************!*\
  !*** ./src/ui/components/display/CharacterCard.tsx ***!
  \*****************************************************/
(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   CharacterCard: () => (/* binding */ CharacterCard)
/* harmony export */ });
/* harmony import */ var react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react/jsx-runtime */ "./node_modules/react/jsx-runtime.js");
/* harmony import */ var _formatters__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../formatters */ "./src/ui/formatters.ts");


const STATUS_COLORS = {
    strangers: '#6b7280',
    acquaintances: '#3b82f6',
    friendly: '#22c55e',
    close: '#f59e0b',
    intimate: '#ec4899',
    strained: '#f97316',
    hostile: '#ef4444',
    complicated: '#8b5cf6',
};
function CharacterCard({ character, relationships }) {
    const mood = character.mood?.join(', ') || 'unknown';
    // Filter relationships to those involving this character
    const charRelationships = relationships?.filter(r => r.pair[0] === character.name || r.pair[1] === character.name) ?? [];
    return ((0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxs)("div", { className: "bt-character", children: [(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxs)("div", { className: "bt-char-header", children: [(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)("strong", { children: character.name }), (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)("span", { className: "bt-char-mood", children: mood })] }), (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxs)("div", { className: "bt-char-position", children: [(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)("i", { className: "fa-solid fa-location-crosshairs", title: "Position" }), (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)("span", { children: character.position })] }), (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxs)("div", { className: "bt-char-details", children: [character.activity && ((0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxs)("div", { className: "bt-char-row bt-char-activity", children: [(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)("i", { className: "fa-solid fa-person-walking", title: "Activity" }), (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)("span", { children: character.activity })] })), character.physicalState && character.physicalState.length > 0 && ((0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxs)("div", { className: "bt-char-row bt-char-physical", children: [(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)("i", { className: "fa-solid fa-heart-pulse", title: "Physical state" }), (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)("span", { children: character.physicalState.join(', ') })] })), character.outfit && ((0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxs)("div", { className: "bt-char-row bt-char-outfit", children: [(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)("i", { className: "fa-solid fa-shirt", title: "Outfit" }), (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)("span", { children: (0,_formatters__WEBPACK_IMPORTED_MODULE_1__.formatOutfit)(character.outfit) })] })), charRelationships.length > 0 && ((0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxs)("div", { className: "bt-char-relationships", children: [(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)("i", { className: "fa-solid fa-heart", title: "Relationships" }), (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)("div", { className: "bt-relationship-badges", children: charRelationships.map(rel => {
                                    const otherChar = rel.pair[0] ===
                                        character.name
                                        ? rel.pair[1]
                                        : rel.pair[0];
                                    const attitude = rel.pair[0] ===
                                        character.name
                                        ? rel.aToB
                                        : rel.bToA;
                                    const feelings = attitude.feelings
                                        .slice(0, 2)
                                        .join(', ');
                                    return ((0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxs)("span", { className: "bt-relationship-badge", style: {
                                            borderColor: STATUS_COLORS[rel
                                                .status],
                                        }, title: `${rel.status}${feelings ? `: ${feelings}` : ''}`, children: [(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)("span", { className: "bt-rel-name", children: otherChar }), (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)("span", { className: "bt-rel-status", style: {
                                                    color: STATUS_COLORS[rel
                                                        .status],
                                                }, children: rel.status })] }, otherChar));
                                }) })] }))] })] }));
}


/***/ },

/***/ "./src/ui/components/display/ClimateDisplay.tsx"
/*!******************************************************!*\
  !*** ./src/ui/components/display/ClimateDisplay.tsx ***!
  \******************************************************/
(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   ClimateDisplay: () => (/* binding */ ClimateDisplay)
/* harmony export */ });
/* harmony import */ var react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react/jsx-runtime */ "./node_modules/react/jsx-runtime.js");
/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! react */ "./node_modules/react/index.js");
/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_1__);
/* harmony import */ var react_dom__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! react-dom */ "./node_modules/react-dom/index.js");
/* harmony import */ var _ui_icons__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! @/ui/icons */ "./src/ui/icons.ts");
/* harmony import */ var _utils_temperatures__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! @/utils/temperatures */ "./src/utils/temperatures.ts");
/* harmony import */ var _weather__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! @/weather */ "./src/weather/index.ts");

// ============================================
// Climate Display Component
// ============================================





// ============================================
// Constants
// ============================================
const DAYLIGHT_ICONS = {
    dawn: 'fa-sun-haze',
    day: 'fa-sun',
    dusk: 'fa-sunset',
    night: 'fa-moon',
};
const DAYLIGHT_LABELS = {
    dawn: 'Dawn',
    day: 'Daytime',
    dusk: 'Dusk',
    night: 'Nighttime',
};
const BUILDING_TYPE_LABELS = {
    modern: 'Climate controlled',
    heated: 'Heated building',
    unheated: 'Unheated structure',
    underground: 'Underground',
    tent: 'Tent/minimal shelter',
    vehicle: 'Vehicle',
};
// ============================================
// Helpers
// ============================================
function getWindDescription(speed) {
    if (speed < 1)
        return 'Calm';
    if (speed < 8)
        return 'Light breeze';
    if (speed < 13)
        return 'Gentle breeze';
    if (speed < 19)
        return 'Moderate breeze';
    if (speed < 25)
        return 'Fresh breeze';
    if (speed < 32)
        return 'Strong breeze';
    if (speed < 39)
        return 'High wind';
    if (speed < 47)
        return 'Gale';
    if (speed < 55)
        return 'Strong gale';
    return 'Storm force';
}
function getHumidityDescription(humidity) {
    if (humidity < 30)
        return 'Very dry';
    if (humidity < 45)
        return 'Dry';
    if (humidity < 65)
        return 'Comfortable';
    if (humidity < 80)
        return 'Humid';
    return 'Very humid';
}
function getUVDescription(uv) {
    if (uv < 3)
        return 'Low';
    if (uv < 6)
        return 'Moderate';
    if (uv < 8)
        return 'High';
    if (uv < 11)
        return 'Very high';
    return 'Extreme';
}
// ============================================
// Component
// ============================================
function ClimateDisplay({ climate, temperatureUnit }) {
    const [tooltip, setTooltip] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)({
        visible: false,
        x: 0,
        y: 0,
    });
    const isLegacy = (0,_weather__WEBPACK_IMPORTED_MODULE_5__.isLegacyClimate)(climate);
    const procedural = isLegacy ? null : climate;
    // Get condition icon
    const conditionIcon = isLegacy
        ? (0,_ui_icons__WEBPACK_IMPORTED_MODULE_3__.getWeatherIcon)(climate.weather)
        : (0,_ui_icons__WEBPACK_IMPORTED_MODULE_3__.getConditionIcon)(climate.conditionType);
    // Get temperature to display
    const displayTemp = climate.temperature;
    // Check if indoors
    const isIndoors = procedural?.isIndoors ?? false;
    // Check if feels like is significantly different (>5Â°F difference)
    const feelsLikeDiff = procedural
        ? Math.abs(procedural.feelsLike - procedural.outdoorTemperature)
        : 0;
    const showFeelsLike = !isIndoors && feelsLikeDiff > 5;
    // Handle mouse events
    const handleMouseEnter = (e) => {
        setTooltip({
            visible: true,
            x: e.clientX,
            y: e.clientY - 10,
        });
    };
    const handleMouseMove = (e) => {
        setTooltip(prev => ({
            ...prev,
            x: e.clientX,
            y: e.clientY - 10,
        }));
    };
    const handleMouseLeave = () => {
        setTooltip(prev => ({ ...prev, visible: false }));
    };
    return ((0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxs)(react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.Fragment, { children: [(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxs)("span", { className: "bt-climate", onMouseEnter: handleMouseEnter, onMouseMove: handleMouseMove, onMouseLeave: handleMouseLeave, children: [(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)("i", { className: `fa-solid ${conditionIcon}` }), displayTemp !== undefined && ((0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)("span", { className: "bt-climate-temp", children: (0,_utils_temperatures__WEBPACK_IMPORTED_MODULE_4__.formatTemperature)(displayTemp, temperatureUnit) })), isIndoors && ((0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)("i", { className: "fa-solid fa-house bt-climate-indoor", title: "Indoors" })), showFeelsLike && procedural && ((0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxs)("span", { className: "bt-climate-feels", children: [(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)("i", { className: "fa-solid fa-temperature-half" }), (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)("span", { className: "bt-feels-value", children: (0,_utils_temperatures__WEBPACK_IMPORTED_MODULE_4__.formatTemperature)(procedural.feelsLike, temperatureUnit) })] })), procedural && procedural.windSpeed >= 15 && !isIndoors && ((0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)("i", { className: "fa-solid fa-wind bt-climate-wind", title: `${Math.round(procedural.windSpeed)} mph ${procedural.windDirection}` })), procedural && procedural.humidity >= 75 && !isIndoors && ((0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)("i", { className: "fa-solid fa-droplet bt-climate-humidity", title: `${Math.round(procedural.humidity)}% humidity` }))] }), tooltip.visible &&
                procedural &&
                (0,react_dom__WEBPACK_IMPORTED_MODULE_2__.createPortal)((0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxs)("div", { className: "bt-climate-tooltip", style: {
                        position: 'fixed',
                        left: tooltip.x,
                        top: tooltip.y,
                        transform: 'translate(-50%, -100%)',
                    }, children: [(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxs)("div", { className: "bt-climate-tooltip-row bt-climate-conditions", children: [(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)("i", { className: `fa-solid ${conditionIcon}` }), (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)("span", { children: procedural.conditions })] }), (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxs)("div", { className: "bt-climate-tooltip-row", children: [(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)("i", { className: `fa-solid ${DAYLIGHT_ICONS[procedural.daylight]}` }), (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)("span", { children: DAYLIGHT_LABELS[procedural.daylight] })] }), (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxs)("div", { className: "bt-climate-tooltip-section", children: [isIndoors &&
                                    procedural.indoorTemperature !==
                                        undefined && ((0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxs)("div", { className: "bt-climate-tooltip-row", children: [(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)("i", { className: "fa-solid fa-house" }), (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxs)("span", { children: ["Indoor:", ' ', (0,_utils_temperatures__WEBPACK_IMPORTED_MODULE_4__.formatTemperature)(procedural.indoorTemperature, temperatureUnit), procedural.buildingType && ((0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxs)("span", { className: "bt-climate-building", children: [' ', "(", BUILDING_TYPE_LABELS[procedural
                                                            .buildingType], ")"] }))] })] })), (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxs)("div", { className: "bt-climate-tooltip-row", children: [(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)("i", { className: "fa-solid fa-tree" }), (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxs)("span", { children: ["Outdoor:", ' ', (0,_utils_temperatures__WEBPACK_IMPORTED_MODULE_4__.formatTemperature)(procedural.outdoorTemperature, temperatureUnit)] })] }), feelsLikeDiff > 2 && ((0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxs)("div", { className: "bt-climate-tooltip-row", children: [(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)("i", { className: "fa-solid fa-temperature-half" }), (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxs)("span", { children: ["Feels like:", ' ', (0,_utils_temperatures__WEBPACK_IMPORTED_MODULE_4__.formatTemperature)(procedural.feelsLike, temperatureUnit)] })] }))] }), (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxs)("div", { className: "bt-climate-tooltip-section", children: [(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxs)("div", { className: "bt-climate-tooltip-row", children: [(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)("i", { className: "fa-solid fa-droplet" }), (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxs)("span", { children: [Math.round(procedural.humidity), "% humidity (", getHumidityDescription(procedural.humidity), ")"] })] }), (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxs)("div", { className: "bt-climate-tooltip-row", children: [(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)("i", { className: "fa-solid fa-wind" }), (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxs)("span", { children: [getWindDescription(procedural.windSpeed), procedural.windSpeed >=
                                                    5 && ((0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxs)(react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.Fragment, { children: [' ', "(", Math.round(procedural.windSpeed), ' ', "mph", ' ', procedural.windDirection, ")"] }))] })] }), procedural.daylight === 'day' &&
                                    procedural.uvIndex > 0 && ((0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxs)("div", { className: "bt-climate-tooltip-row", children: [(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)("i", { className: "fa-solid fa-sun" }), (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxs)("span", { children: ["UV Index:", ' ', procedural.uvIndex, ' ', "(", getUVDescription(procedural.uvIndex), ")"] })] }))] })] }), document.body)] }));
}


/***/ },

/***/ "./src/ui/components/display/LoadingIndicator.tsx"
/*!********************************************************!*\
  !*** ./src/ui/components/display/LoadingIndicator.tsx ***!
  \********************************************************/
(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   LoadingIndicator: () => (/* binding */ LoadingIndicator)
/* harmony export */ });
/* harmony import */ var react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react/jsx-runtime */ "./node_modules/react/jsx-runtime.js");

function LoadingIndicator({ stepLabel }) {
    return ((0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)("div", { className: "bt-state-container bt-extracting", children: (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxs)("div", { className: "bt-loading-indicator", children: [(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)("i", { className: "fa-solid fa-fire fa-beat-fade" }), (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)("span", { children: stepLabel })] }) }));
}


/***/ },

/***/ "./src/ui/components/display/SceneDisplay.tsx"
/*!****************************************************!*\
  !*** ./src/ui/components/display/SceneDisplay.tsx ***!
  \****************************************************/
(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   SceneDisplay: () => (/* binding */ SceneDisplay)
/* harmony export */ });
/* harmony import */ var react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react/jsx-runtime */ "./node_modules/react/jsx-runtime.js");
/* harmony import */ var _icons__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../icons */ "./src/ui/icons.ts");


function SceneDisplay({ scene, onMoreInfoClick }) {
    const { tension } = scene;
    const typeColor = (0,_icons__WEBPACK_IMPORTED_MODULE_1__.getTensionTypeColor)(tension.type);
    const levelColor = (0,_icons__WEBPACK_IMPORTED_MODULE_1__.getTensionColor)(tension.level);
    // Direction colors
    const directionColors = {
        escalating: '#ef4444', // red
        stable: '#6b7280', // gray
        decreasing: '#22c55e', // green
    };
    const directionColor = directionColors[tension.direction] || '#6b7280';
    return ((0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxs)("div", { className: "bt-scene", children: [(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxs)("div", { className: "bt-scene-header", children: [(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)("span", { className: "bt-scene-topic", children: scene.topic }), (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)("span", { className: "bt-scene-tone", children: scene.tone }), onMoreInfoClick && ((0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)("button", { className: "bt-more-info-btn", onClick: onMoreInfoClick, title: "View narrative overview", children: (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)("i", { className: "fa-solid fa-book-open" }) }))] }), (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxs)("div", { className: "bt-scene-tension", children: [(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxs)("span", { className: "bt-tension-type", title: tension.type, children: [(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)("i", { className: `fa-solid ${_icons__WEBPACK_IMPORTED_MODULE_1__.TENSION_TYPE_ICONS[tension.type]}`, style: { color: typeColor } }), tension.type] }), (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxs)("span", { className: "bt-tension-level", title: tension.level, children: [(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)("i", { className: `fa-solid ${_icons__WEBPACK_IMPORTED_MODULE_1__.TENSION_LEVEL_ICONS[tension.level]}`, style: { color: levelColor } }), tension.level] }), (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxs)("span", { className: "bt-tension-direction", title: tension.direction, children: [(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)("i", { className: `fa-solid ${_icons__WEBPACK_IMPORTED_MODULE_1__.TENSION_DIRECTION_ICONS[tension.direction]}`, style: { color: directionColor } }), tension.direction] })] })] }));
}


/***/ },

/***/ "./src/ui/components/display/index.ts"
/*!********************************************!*\
  !*** ./src/ui/components/display/index.ts ***!
  \********************************************/
(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   CharacterCard: () => (/* reexport safe */ _CharacterCard__WEBPACK_IMPORTED_MODULE_1__.CharacterCard),
/* harmony export */   ClimateDisplay: () => (/* reexport safe */ _ClimateDisplay__WEBPACK_IMPORTED_MODULE_3__.ClimateDisplay),
/* harmony export */   LoadingIndicator: () => (/* reexport safe */ _LoadingIndicator__WEBPACK_IMPORTED_MODULE_2__.LoadingIndicator),
/* harmony export */   SceneDisplay: () => (/* reexport safe */ _SceneDisplay__WEBPACK_IMPORTED_MODULE_0__.SceneDisplay)
/* harmony export */ });
/* harmony import */ var _SceneDisplay__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./SceneDisplay */ "./src/ui/components/display/SceneDisplay.tsx");
/* harmony import */ var _CharacterCard__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./CharacterCard */ "./src/ui/components/display/CharacterCard.tsx");
/* harmony import */ var _LoadingIndicator__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./LoadingIndicator */ "./src/ui/components/display/LoadingIndicator.tsx");
/* harmony import */ var _ClimateDisplay__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./ClimateDisplay */ "./src/ui/components/display/ClimateDisplay.tsx");






/***/ },

/***/ "./src/ui/components/form/CheckboxField.tsx"
/*!**************************************************!*\
  !*** ./src/ui/components/form/CheckboxField.tsx ***!
  \**************************************************/
(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   CheckboxField: () => (/* binding */ CheckboxField)
/* harmony export */ });
/* harmony import */ var react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react/jsx-runtime */ "./node_modules/react/jsx-runtime.js");

function CheckboxField({ id, label, description, checked, onChange }) {
    return ((0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxs)("div", { className: "flex-container flexFlowColumn", children: [(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxs)("label", { className: "checkbox_label", children: [(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)("input", { type: "checkbox", id: id, checked: checked, onChange: e => onChange(e.target.checked) }), (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)("span", { children: label })] }), (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)("small", { children: description })] }));
}


/***/ },

/***/ "./src/ui/components/form/NumberField.tsx"
/*!************************************************!*\
  !*** ./src/ui/components/form/NumberField.tsx ***!
  \************************************************/
(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   NumberField: () => (/* binding */ NumberField)
/* harmony export */ });
/* harmony import */ var react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react/jsx-runtime */ "./node_modules/react/jsx-runtime.js");

function NumberField({ id, label, description, value, min, max, step, onChange, }) {
    return ((0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxs)("div", { className: "flex-container flexFlowColumn", children: [(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)("label", { htmlFor: id, children: label }), (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)("small", { children: description }), (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)("input", { type: "number", id: id, className: "text_pole", min: min, max: max, step: step, value: value, onChange: e => onChange(parseInt(e.target.value) || min) })] }));
}


/***/ },

/***/ "./src/ui/components/form/OutfitEditor.tsx"
/*!*************************************************!*\
  !*** ./src/ui/components/form/OutfitEditor.tsx ***!
  \*************************************************/
(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   OutfitEditor: () => (/* binding */ OutfitEditor)
/* harmony export */ });
/* harmony import */ var react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react/jsx-runtime */ "./node_modules/react/jsx-runtime.js");
/* harmony import */ var _constants__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../constants */ "./src/ui/constants.ts");


/** Outfit editor with nullable slots */
function OutfitEditor({ outfit, onChange }) {
    const update = (slot, value) => {
        onChange({ ...outfit, [slot]: value || null });
    };
    return ((0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)("div", { className: "bt-outfit-grid", children: _constants__WEBPACK_IMPORTED_MODULE_1__.OUTFIT_SLOTS.map(slot => ((0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxs)("div", { className: "bt-outfit-slot", children: [(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)("label", { children: slot }), (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxs)("div", { className: "bt-outfit-row", children: [(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)("input", { type: "text", value: outfit[slot] || '', onChange: e => update(slot, e.target.value), placeholder: "None" }), outfit[slot] && ((0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)("button", { type: "button", onClick: () => update(slot, null), className: "bt-x", children: "\u00D7" }))] })] }, slot))) }));
}


/***/ },

/***/ "./src/ui/components/form/SelectField.tsx"
/*!************************************************!*\
  !*** ./src/ui/components/form/SelectField.tsx ***!
  \************************************************/
(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   SelectField: () => (/* binding */ SelectField)
/* harmony export */ });
/* harmony import */ var react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react/jsx-runtime */ "./node_modules/react/jsx-runtime.js");

function SelectField({ id, label, description, value, options, onChange, }) {
    return ((0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxs)("div", { className: "flex-container flexFlowColumn", children: [(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)("label", { htmlFor: id, children: label }), (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)("small", { children: description }), (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)("select", { id: id, className: "text_pole", value: value, onChange: e => onChange(e.target.value), children: options.map(opt => ((0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)("option", { value: opt.value, children: opt.label }, opt.value))) })] }));
}


/***/ },

/***/ "./src/ui/components/form/TagInput.tsx"
/*!*********************************************!*\
  !*** ./src/ui/components/form/TagInput.tsx ***!
  \*********************************************/
(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   TagInput: () => (/* binding */ TagInput)
/* harmony export */ });
/* harmony import */ var react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react/jsx-runtime */ "./node_modules/react/jsx-runtime.js");
/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! react */ "./node_modules/react/index.js");
/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_1__);


/** Tag input for arrays of strings (mood, physicalState, etc.) */
function TagInput({ tags, onChange, placeholder = 'Add...' }) {
    const [input, setInput] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)('');
    const addTag = () => {
        const trimmed = input.trim();
        if (trimmed && !tags.includes(trimmed)) {
            onChange([...tags, trimmed]);
            setInput('');
        }
    };
    const removeTag = (tag) => {
        onChange(tags.filter(t => t !== tag));
    };
    return ((0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxs)("div", { className: "bt-tag-input", children: [(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)("div", { className: "bt-tags", children: tags.map(tag => ((0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxs)("span", { className: "bt-tag", children: [tag, (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)("button", { type: "button", onClick: () => removeTag(tag), className: "bt-tag-x", children: "\u00D7" })] }, tag))) }), (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxs)("div", { className: "bt-tag-add", children: [(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)("input", { type: "text", value: input, onChange: e => setInput(e.target.value), onKeyDown: e => e.key === 'Enter' && (e.preventDefault(), addTag()), placeholder: placeholder }), (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)("button", { type: "button", onClick: addTag, children: "+" })] })] }));
}


/***/ },

/***/ "./src/ui/components/form/index.ts"
/*!*****************************************!*\
  !*** ./src/ui/components/form/index.ts ***!
  \*****************************************/
(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   CheckboxField: () => (/* reexport safe */ _CheckboxField__WEBPACK_IMPORTED_MODULE_2__.CheckboxField),
/* harmony export */   NumberField: () => (/* reexport safe */ _NumberField__WEBPACK_IMPORTED_MODULE_1__.NumberField),
/* harmony export */   OutfitEditor: () => (/* reexport safe */ _OutfitEditor__WEBPACK_IMPORTED_MODULE_4__.OutfitEditor),
/* harmony export */   SelectField: () => (/* reexport safe */ _SelectField__WEBPACK_IMPORTED_MODULE_0__.SelectField),
/* harmony export */   TagInput: () => (/* reexport safe */ _TagInput__WEBPACK_IMPORTED_MODULE_3__.TagInput)
/* harmony export */ });
/* harmony import */ var _SelectField__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./SelectField */ "./src/ui/components/form/SelectField.tsx");
/* harmony import */ var _NumberField__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./NumberField */ "./src/ui/components/form/NumberField.tsx");
/* harmony import */ var _CheckboxField__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./CheckboxField */ "./src/ui/components/form/CheckboxField.tsx");
/* harmony import */ var _TagInput__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./TagInput */ "./src/ui/components/form/TagInput.tsx");
/* harmony import */ var _OutfitEditor__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./OutfitEditor */ "./src/ui/components/form/OutfitEditor.tsx");







/***/ },

/***/ "./src/ui/constants.ts"
/*!*****************************!*\
  !*** ./src/ui/constants.ts ***!
  \*****************************/
(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   BUILDING_TYPES: () => (/* binding */ BUILDING_TYPES),
/* harmony export */   BUILDING_TYPE_LABELS: () => (/* binding */ BUILDING_TYPE_LABELS),
/* harmony export */   DAYS_OF_WEEK: () => (/* binding */ DAYS_OF_WEEK),
/* harmony export */   MONTH_NAMES: () => (/* binding */ MONTH_NAMES),
/* harmony export */   OUTFIT_SLOTS: () => (/* binding */ OUTFIT_SLOTS),
/* harmony export */   TENSION_DIRECTIONS: () => (/* binding */ TENSION_DIRECTIONS),
/* harmony export */   TENSION_LEVELS: () => (/* binding */ TENSION_LEVELS),
/* harmony export */   TENSION_TYPES: () => (/* binding */ TENSION_TYPES),
/* harmony export */   WEATHER_CONDITIONS: () => (/* binding */ WEATHER_CONDITIONS),
/* harmony export */   WEATHER_CONDITION_LABELS: () => (/* binding */ WEATHER_CONDITION_LABELS),
/* harmony export */   WEATHER_OPTIONS: () => (/* binding */ WEATHER_OPTIONS)
/* harmony export */ });
// ============================================
// Shared UI Constants
// ============================================
/**
 * Month names for display.
 */
const MONTH_NAMES = [
    'January',
    'February',
    'March',
    'April',
    'May',
    'June',
    'July',
    'August',
    'September',
    'October',
    'November',
    'December',
];
/**
 * Days of the week.
 */
const DAYS_OF_WEEK = [
    'Sunday',
    'Monday',
    'Tuesday',
    'Wednesday',
    'Thursday',
    'Friday',
    'Saturday',
];
/**
 * Valid weather options (legacy).
 */
const WEATHER_OPTIONS = [
    'sunny',
    'cloudy',
    'rainy',
    'snowy',
    'windy',
    'thunderstorm',
];
/**
 * Weather condition options (procedural system).
 */
const WEATHER_CONDITIONS = [
    'clear',
    'sunny',
    'partly_cloudy',
    'overcast',
    'foggy',
    'drizzle',
    'rain',
    'heavy_rain',
    'thunderstorm',
    'sleet',
    'snow',
    'heavy_snow',
    'blizzard',
    'windy',
    'hot',
    'cold',
    'humid',
];
/**
 * Weather condition display names.
 */
const WEATHER_CONDITION_LABELS = {
    clear: 'Clear',
    sunny: 'Sunny',
    partly_cloudy: 'Partly Cloudy',
    overcast: 'Overcast',
    foggy: 'Foggy',
    drizzle: 'Drizzle',
    rain: 'Rain',
    heavy_rain: 'Heavy Rain',
    thunderstorm: 'Thunderstorm',
    sleet: 'Sleet',
    snow: 'Snow',
    heavy_snow: 'Heavy Snow',
    blizzard: 'Blizzard',
    windy: 'Windy',
    hot: 'Hot',
    cold: 'Cold',
    humid: 'Humid',
};
/**
 * Building types for indoor temperature.
 */
const BUILDING_TYPES = [
    'modern',
    'heated',
    'unheated',
    'underground',
    'tent',
    'vehicle',
];
/**
 * Building type display names.
 */
const BUILDING_TYPE_LABELS = {
    modern: 'Modern (HVAC)',
    heated: 'Heated (Fireplace)',
    unheated: 'Unheated (Barn/Warehouse)',
    underground: 'Underground (Cave/Basement)',
    tent: 'Tent',
    vehicle: 'Vehicle',
};
/**
 * Tension levels in ascending order.
 */
const TENSION_LEVELS = [
    'relaxed',
    'aware',
    'guarded',
    'tense',
    'charged',
    'volatile',
    'explosive',
];
/**
 * Tension types.
 */
const TENSION_TYPES = [
    'confrontation',
    'intimate',
    'vulnerable',
    'celebratory',
    'negotiation',
    'suspense',
    'conversation',
];
/**
 * Tension directions.
 */
const TENSION_DIRECTIONS = [
    'escalating',
    'stable',
    'decreasing',
];
/**
 * Outfit slots in order.
 */
const OUTFIT_SLOTS = [
    'head',
    'neck',
    'jacket',
    'back',
    'torso',
    'legs',
    'underwear',
    'socks',
    'footwear',
];


/***/ },

/***/ "./src/ui/formatters.ts"
/*!******************************!*\
  !*** ./src/ui/formatters.ts ***!
  \******************************/
(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   capitalize: () => (/* binding */ capitalize),
/* harmony export */   formatLocation: () => (/* binding */ formatLocation),
/* harmony export */   formatOutfit: () => (/* binding */ formatOutfit),
/* harmony export */   formatTime: () => (/* binding */ formatTime)
/* harmony export */ });
/* harmony import */ var _constants__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./constants */ "./src/ui/constants.ts");
/* harmony import */ var _utils_timeFormat__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../utils/timeFormat */ "./src/utils/timeFormat.ts");
// ============================================
// Shared UI Formatters
// ============================================


/**
 * Format a narrative datetime for display.
 */
function formatTime(time, timeFormat = '24h') {
    const month = _constants__WEBPACK_IMPORTED_MODULE_0__.MONTH_NAMES[time.month - 1];
    // "Mon, Jan 15 2024, 14:30"
    return `${time.dayOfWeek.slice(0, 3)}, ${month} ${time.day} ${time.year}, ${(0,_utils_timeFormat__WEBPACK_IMPORTED_MODULE_1__.applyTimeFormat)(time.hour, time.minute, timeFormat)}`;
}
/**
 * Format a location for display.
 */
function formatLocation(location) {
    const parts = [location.position, location.place, location.area];
    return parts.filter(Boolean).join(' \u00B7 ');
}
/**
 * Format an outfit for display.
 */
function formatOutfit(outfit) {
    const outfitParts = [
        outfit.torso || 'topless',
        outfit.legs || 'bottomless',
        outfit.underwear || 'no underwear',
        outfit.head || null,
        outfit.neck || null,
        outfit.jacket || null,
        outfit.back || null,
        outfit.footwear || null,
    ];
    return outfitParts.filter((v) => v !== null).join(', ');
}
/**
 * Capitalize the first letter of a string.
 */
function capitalize(str) {
    if (!str)
        return str;
    return str.charAt(0).toUpperCase() + str.slice(1);
}


/***/ },

/***/ "./src/ui/icons.ts"
/*!*************************!*\
  !*** ./src/ui/icons.ts ***!
  \*************************/
(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   CONDITION_ICONS: () => (/* binding */ CONDITION_ICONS),
/* harmony export */   EVENT_TYPE_COLORS: () => (/* binding */ EVENT_TYPE_COLORS),
/* harmony export */   EVENT_TYPE_ICONS: () => (/* binding */ EVENT_TYPE_ICONS),
/* harmony export */   EVENT_TYPE_PRIORITY: () => (/* binding */ EVENT_TYPE_PRIORITY),
/* harmony export */   TENSION_DIRECTION_ICONS: () => (/* binding */ TENSION_DIRECTION_ICONS),
/* harmony export */   TENSION_LEVEL_COLORS: () => (/* binding */ TENSION_LEVEL_COLORS),
/* harmony export */   TENSION_LEVEL_ICONS: () => (/* binding */ TENSION_LEVEL_ICONS),
/* harmony export */   TENSION_LEVEL_VALUES: () => (/* binding */ TENSION_LEVEL_VALUES),
/* harmony export */   TENSION_TYPE_COLORS: () => (/* binding */ TENSION_TYPE_COLORS),
/* harmony export */   TENSION_TYPE_ICONS: () => (/* binding */ TENSION_TYPE_ICONS),
/* harmony export */   WEATHER_ICONS: () => (/* binding */ WEATHER_ICONS),
/* harmony export */   getConditionIcon: () => (/* binding */ getConditionIcon),
/* harmony export */   getEventTypeColor: () => (/* binding */ getEventTypeColor),
/* harmony export */   getEventTypeIcon: () => (/* binding */ getEventTypeIcon),
/* harmony export */   getPrimaryEventType: () => (/* binding */ getPrimaryEventType),
/* harmony export */   getTensionColor: () => (/* binding */ getTensionColor),
/* harmony export */   getTensionIcon: () => (/* binding */ getTensionIcon),
/* harmony export */   getTensionLevelIcon: () => (/* binding */ getTensionLevelIcon),
/* harmony export */   getTensionTypeColor: () => (/* binding */ getTensionTypeColor),
/* harmony export */   getTensionValue: () => (/* binding */ getTensionValue),
/* harmony export */   getWeatherIcon: () => (/* binding */ getWeatherIcon)
/* harmony export */ });
// ============================================
// UI Icons and Colors for BlazeTracker
// ============================================
/**
 * Font Awesome icons for tension types.
 */
const TENSION_TYPE_ICONS = {
    conversation: 'fa-comments',
    confrontation: 'fa-burst',
    intimate: 'fa-heart',
    suspense: 'fa-clock',
    vulnerable: 'fa-shield-halved',
    celebratory: 'fa-champagne-glasses',
    negotiation: 'fa-handshake',
};
/**
 * Font Awesome icons for tension levels.
 */
const TENSION_LEVEL_ICONS = {
    relaxed: 'fa-mug-hot',
    aware: 'fa-eye',
    guarded: 'fa-shield-halved',
    tense: 'fa-face-grimace',
    charged: 'fa-bolt',
    volatile: 'fa-fire',
    explosive: 'fa-explosion',
};
/**
 * Font Awesome icons for tension directions.
 */
const TENSION_DIRECTION_ICONS = {
    escalating: 'fa-arrow-trend-up',
    stable: 'fa-grip-lines',
    decreasing: 'fa-arrow-trend-down',
};
/**
 * Font Awesome icons for weather types.
 */
const WEATHER_ICONS = {
    sunny: 'fa-sun',
    cloudy: 'fa-cloud',
    snowy: 'fa-snowflake',
    rainy: 'fa-cloud-rain',
    windy: 'fa-wind',
    thunderstorm: 'fa-cloud-bolt',
};
/**
 * Get the weather icon for a weather type.
 */
function getWeatherIcon(weather) {
    return WEATHER_ICONS[weather] ?? 'fa-question';
}
/**
 * Font Awesome icons for procedural weather conditions.
 */
const CONDITION_ICONS = {
    clear: 'fa-moon',
    sunny: 'fa-sun',
    partly_cloudy: 'fa-cloud-sun',
    overcast: 'fa-cloud',
    foggy: 'fa-smog',
    drizzle: 'fa-cloud-rain',
    rain: 'fa-cloud-showers-heavy',
    heavy_rain: 'fa-cloud-showers-water',
    thunderstorm: 'fa-cloud-bolt',
    sleet: 'fa-cloud-meatball',
    snow: 'fa-snowflake',
    heavy_snow: 'fa-snowflake',
    blizzard: 'fa-icicles',
    windy: 'fa-wind',
    hot: 'fa-temperature-high',
    cold: 'fa-temperature-low',
    humid: 'fa-droplet',
};
/**
 * Get the icon for a procedural weather condition.
 */
function getConditionIcon(condition) {
    return CONDITION_ICONS[condition] ?? 'fa-question';
}
/**
 * Colors for tension types.
 */
const TENSION_TYPE_COLORS = {
    conversation: '#6b7280', // gray-500
    confrontation: '#ef4444', // red-500
    intimate: '#ec4899', // pink-500
    suspense: '#8b5cf6', // violet-500
    vulnerable: '#06b6d4', // cyan-500
    celebratory: '#eab308', // yellow-500
    negotiation: '#f97316', // orange-500
};
/**
 * Colors for tension levels.
 */
const TENSION_LEVEL_COLORS = {
    relaxed: '#6b7280', // gray-500
    aware: '#3b82f6', // blue-500
    guarded: '#22c55e', // green-500
    tense: '#f59e0b', // amber-500
    charged: '#f97316', // orange-500
    volatile: '#ef4444', // red-500
    explosive: '#dc2626', // red-600
};
/**
 * Get the icon class for a tension type.
 */
function getTensionIcon(type) {
    return `fa-solid ${TENSION_TYPE_ICONS[type] || 'fa-circle'}`;
}
/**
 * Get the icon class for a tension level.
 */
function getTensionLevelIcon(level) {
    return `fa-solid ${TENSION_LEVEL_ICONS[level] || 'fa-circle'}`;
}
/**
 * Get the color for a tension type.
 */
function getTensionTypeColor(type) {
    return TENSION_TYPE_COLORS[type] || '#6b7280';
}
/**
 * Get the color for a tension level.
 */
function getTensionColor(level) {
    return TENSION_LEVEL_COLORS[level] || '#6b7280';
}
/**
 * Numeric value for tension level (for graphing).
 */
const TENSION_LEVEL_VALUES = {
    relaxed: 1,
    aware: 2,
    guarded: 3,
    tense: 4,
    charged: 5,
    volatile: 6,
    explosive: 7,
};
/**
 * Get numeric value for a tension level.
 */
function getTensionValue(level) {
    return TENSION_LEVEL_VALUES[level] || 1;
}
// ============================================
// Event Type Icons and Colors
// ============================================
/**
 * Font Awesome icons for event types.
 */
const EVENT_TYPE_ICONS = {
    // Conversation
    conversation: 'fa-comments',
    confession: 'fa-heart-circle-exclamation',
    argument: 'fa-comment-slash',
    negotiation: 'fa-handshake',
    // Discovery
    discovery: 'fa-lightbulb',
    secret_shared: 'fa-user-secret',
    secret_revealed: 'fa-mask',
    // Emotional
    emotional: 'fa-face-smile-beam',
    supportive: 'fa-hand-holding-heart',
    rejection: 'fa-hand',
    comfort: 'fa-hands-holding',
    apology: 'fa-hands-praying',
    forgiveness: 'fa-dove',
    // Bonding
    laugh: 'fa-face-laugh-beam',
    gift: 'fa-gift',
    compliment: 'fa-face-grin-stars',
    tease: 'fa-face-grin-tongue',
    flirt: 'fa-face-grin-wink',
    date: 'fa-champagne-glasses',
    i_love_you: 'fa-heart-circle-check',
    sleepover: 'fa-bed',
    shared_meal: 'fa-utensils',
    shared_activity: 'fa-gamepad',
    // Romantic Intimacy
    intimate_touch: 'fa-hand-holding-hand',
    intimate_kiss: 'fa-face-kiss-wink-heart',
    intimate_embrace: 'fa-people-pulling',
    intimate_heated: 'fa-fire',
    // Sexual Activity
    intimate_foreplay: 'fa-fire-flame-curved',
    intimate_oral: 'fa-face-kiss-beam',
    intimate_manual: 'fa-hand-sparkles',
    intimate_penetrative: 'fa-heart',
    intimate_climax: 'fa-star',
    // Action
    action: 'fa-person-running',
    combat: 'fa-hand-fist',
    danger: 'fa-skull',
    // Commitment
    decision: 'fa-scale-balanced',
    promise: 'fa-handshake-angle',
    betrayal: 'fa-face-angry',
    lied: 'fa-face-grimace',
    // Life Events
    exclusivity: 'fa-lock',
    marriage: 'fa-ring',
    pregnancy: 'fa-baby',
    childbirth: 'fa-baby-carriage',
    // Social
    social: 'fa-users',
    achievement: 'fa-trophy',
};
/**
 * Colors for event types.
 */
const EVENT_TYPE_COLORS = {
    // Conversation - grays/blues
    conversation: '#6b7280',
    confession: '#ec4899',
    argument: '#ef4444',
    negotiation: '#f59e0b',
    // Discovery - yellows
    discovery: '#eab308',
    secret_shared: '#8b5cf6',
    secret_revealed: '#a855f7',
    // Emotional - cyans
    emotional: '#06b6d4',
    supportive: '#22d3ee',
    rejection: '#f43f5e',
    comfort: '#14b8a6', // teal-500
    apology: '#a78bfa', // violet-400
    forgiveness: '#34d399', // emerald-400
    // Bonding - warm greens and oranges
    laugh: '#facc15', // yellow-400
    gift: '#f472b6', // pink-400
    compliment: '#fbbf24', // amber-400
    tease: '#fb923c', // orange-400
    flirt: '#f87171', // red-400
    date: '#a78bfa', // violet-400
    i_love_you: '#f43f5e', // rose-500
    sleepover: '#818cf8', // indigo-400
    shared_meal: '#4ade80', // green-400
    shared_activity: '#60a5fa', // blue-400
    // Romantic Intimacy - pinks
    intimate_touch: '#fda4af',
    intimate_kiss: '#fb7185',
    intimate_embrace: '#f472b6',
    intimate_heated: '#ec4899',
    // Sexual Activity - deeper pinks/magentas
    intimate_foreplay: '#db2777',
    intimate_oral: '#be185d',
    intimate_manual: '#9d174d',
    intimate_penetrative: '#831843',
    intimate_climax: '#701a75',
    // Action - blues/reds
    action: '#3b82f6',
    combat: '#dc2626',
    danger: '#991b1b',
    // Commitment - purples/oranges
    decision: '#8b5cf6',
    promise: '#22c55e',
    betrayal: '#b91c1c',
    lied: '#f97316', // orange-500
    // Life Events - golds/teals
    exclusivity: '#0d9488', // teal-600
    marriage: '#d97706', // amber-600
    pregnancy: '#ec4899', // pink-500
    childbirth: '#8b5cf6', // violet-500
    // Social - greens
    social: '#22c55e',
    achievement: '#f59e0b',
};
/**
 * Priority order for selecting "primary" icon when multiple types.
 * Higher priority items appear first.
 */
const EVENT_TYPE_PRIORITY = [
    // Life events take highest priority (rare, significant)
    'childbirth',
    'marriage',
    'pregnancy',
    'exclusivity',
    // Sexual activity takes visual priority (highest intensity first)
    'intimate_climax',
    'intimate_penetrative',
    'intimate_oral',
    'intimate_manual',
    'intimate_foreplay',
    // Then romantic intimacy
    'intimate_heated',
    'intimate_kiss',
    'intimate_embrace',
    'intimate_touch',
    // Then high-drama events
    'combat',
    'danger',
    'betrayal',
    'confession',
    'argument',
    // Then emotional/discovery
    'emotional',
    'comfort',
    'apology',
    'forgiveness',
    'secret_revealed',
    'secret_shared',
    'discovery',
    // Then decisions
    'decision',
    'promise',
    'rejection',
    // Then bonding/social
    'i_love_you',
    'date',
    'sleepover',
    'gift',
    'laugh',
    'compliment',
    'flirt',
    'tease',
    'shared_meal',
    'shared_activity',
    // Then social/support
    'supportive',
    'achievement',
    'social',
    'negotiation',
    // Default
    'conversation',
    'action',
];
/**
 * Get the primary event type from an array of types based on priority.
 */
function getPrimaryEventType(types) {
    for (const priority of EVENT_TYPE_PRIORITY) {
        if (types.includes(priority))
            return priority;
    }
    return types[0] || 'conversation';
}
/**
 * Get the icon class for an event type.
 */
function getEventTypeIcon(type) {
    return `fa-solid ${EVENT_TYPE_ICONS[type] || 'fa-circle'}`;
}
/**
 * Get the color for an event type.
 */
function getEventTypeColor(type) {
    return EVENT_TYPE_COLORS[type] || '#6b7280';
}


/***/ },

/***/ "./src/ui/settings.css"
/*!*****************************!*\
  !*** ./src/ui/settings.css ***!
  \*****************************/
(module, __unused_webpack_exports, __webpack_require__) {

module.exports = __webpack_require__.p + "4202f158bef5f780a78c.css";

/***/ },

/***/ "./src/ui/settingsUI.tsx"
/*!*******************************!*\
  !*** ./src/ui/settingsUI.tsx ***!
  \*******************************/
(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   initSettingsUI: () => (/* binding */ initSettingsUI),
/* harmony export */   unmountSettingsUI: () => (/* binding */ unmountSettingsUI)
/* harmony export */ });
/* harmony import */ var react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react/jsx-runtime */ "./node_modules/react/jsx-runtime.js");
/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! react */ "./node_modules/react/index.js");
/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_1__);
/* harmony import */ var react_dom_client__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! react-dom/client */ "./node_modules/react-dom/client.js");
/* harmony import */ var _settings__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../settings */ "./src/settings.ts");
/* harmony import */ var _stateDisplay__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./stateDisplay */ "./src/ui/stateDisplay.tsx");
/* harmony import */ var _extractors_prompts__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../extractors/prompts */ "./src/extractors/prompts.ts");
/* harmony import */ var _components_form__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./components/form */ "./src/ui/components/form/index.ts");







function PromptEditor({ definition, customPrompts, customTemperatures, onSave, onSaveTemperature, }) {
    const [isEditing, setIsEditing] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)(false);
    const [editValue, setEditValue] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)('');
    const [editTemperature, setEditTemperature] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)(definition.defaultTemperature);
    // Defensive: customTemperatures may be undefined for existing users
    const temps = customTemperatures ?? {};
    const isPromptCustomized = !!customPrompts[definition.key];
    const isTemperatureCustomized = definition.key in temps;
    const currentTemperature = temps[definition.key] ?? definition.defaultTemperature;
    const handleEdit = () => {
        setEditValue(customPrompts[definition.key] || definition.default);
        setEditTemperature(currentTemperature);
        setIsEditing(true);
    };
    const handleSave = () => {
        // If unchanged from default, remove customization
        if (editValue.trim() === definition.default.trim()) {
            onSave(definition.key, null);
        }
        else {
            onSave(definition.key, editValue);
        }
        // Same for temperature
        if (editTemperature === definition.defaultTemperature) {
            onSaveTemperature(definition.key, null);
        }
        else {
            onSaveTemperature(definition.key, editTemperature);
        }
        setIsEditing(false);
    };
    const handleReset = () => {
        onSave(definition.key, null);
        onSaveTemperature(definition.key, null);
        setIsEditing(false);
    };
    const handleCancel = () => {
        setIsEditing(false);
    };
    const handleTemperatureInput = (value) => {
        const num = parseFloat(value);
        if (!isNaN(num)) {
            setEditTemperature(Math.max(0, Math.min(2, num)));
        }
    };
    if (isEditing) {
        return ((0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxs)("div", { className: "bt-prompt-editor", children: [(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxs)("div", { className: "bt-prompt-editor-header", children: [(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)("strong", { children: definition.name }), (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)("span", { className: "bt-prompt-description", children: definition.description })] }), (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)("div", { className: "bt-temperature-control", children: (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxs)("label", { className: "bt-temperature-label", children: [(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)("span", { children: "Temperature:" }), (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)("input", { type: "range", className: "bt-temperature-slider", min: "0", max: "2", step: "0.05", value: editTemperature, onChange: e => setEditTemperature(parseFloat(e.target.value)) }), (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)("input", { type: "number", className: "bt-temperature-input", min: "0", max: "2", step: "0.05", value: editTemperature, onChange: e => handleTemperatureInput(e.target.value) }), (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxs)("span", { className: "bt-temperature-default", children: ["(default: ", definition.defaultTemperature, ")"] })] }) }), (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxs)("div", { className: "bt-prompt-placeholders", children: [(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)("strong", { children: "Available placeholders:" }), (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)("ul", { children: definition.placeholders.map(p => ((0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxs)("li", { children: [(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)("code", { children: p.name }), " \u2014", ' ', p.description] }, p.name))) })] }), (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)("textarea", { className: "text_pole bt-prompt-textarea", value: editValue, onChange: e => setEditValue(e.target.value), rows: 15 }), (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxs)("div", { className: "bt-prompt-actions", children: [(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxs)("button", { className: "menu_button", onClick: handleSave, children: [(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)("i", { className: "fa-solid fa-check" }), " Save"] }), (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxs)("button", { className: "menu_button", onClick: handleReset, children: [(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)("i", { className: "fa-solid fa-rotate-left" }), " Reset to Default"] }), (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxs)("button", { className: "menu_button", onClick: handleCancel, children: [(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)("i", { className: "fa-solid fa-xmark" }), " Cancel"] })] })] }));
    }
    return ((0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxs)("div", { className: "bt-prompt-item", onClick: handleEdit, children: [(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxs)("div", { className: "bt-prompt-item-header", children: [(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)("span", { className: "bt-prompt-name", children: definition.name }), (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxs)("div", { className: "bt-prompt-badges", children: [isTemperatureCustomized && ((0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxs)("span", { className: "bt-prompt-temperature-badge", title: `Custom temperature: ${currentTemperature}`, children: [(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)("i", { className: "fa-solid fa-temperature-half" }), ' ', currentTemperature] })), isPromptCustomized && ((0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)("span", { className: "bt-prompt-customized", title: "Custom prompt", children: (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)("i", { className: "fa-solid fa-pen" }) }))] })] }), (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)("small", { className: "bt-prompt-description", children: definition.description })] }));
}
function PromptsSection({ customPrompts, customTemperatures, onUpdatePrompt, onUpdateTemperature, }) {
    const [isExpanded, setIsExpanded] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)(false);
    const definitions = (0,_extractors_prompts__WEBPACK_IMPORTED_MODULE_5__.getAllPromptDefinitions)();
    return ((0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxs)("div", { className: "bt-prompts-section", children: [(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxs)("div", { className: "bt-prompts-header", onClick: () => setIsExpanded(!isExpanded), children: [(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxs)("span", { children: [(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)("i", { className: `fa-solid ${isExpanded ? 'fa-chevron-down' : 'fa-chevron-right'}` }), ' ', "Custom Prompts"] }), (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)("small", { children: "Click to customize extraction prompts" })] }), isExpanded && ((0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)("div", { className: "bt-prompts-list", children: definitions.map(def => ((0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(PromptEditor, { definition: def, customPrompts: customPrompts, customTemperatures: customTemperatures, onSave: onUpdatePrompt, onSaveTemperature: onUpdateTemperature }, def.key))) }))] }));
}
function ExtractionTogglesSection({ settings, onToggle, onNumericChange, }) {
    return ((0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxs)("div", { className: "bt-extraction-toggles", children: [(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxs)("div", { className: "bt-section-header", children: [(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)("strong", { children: "Extraction Types" }), (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)("small", { children: "Enable or disable specific extraction modules" })] }), (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(_components_form__WEBPACK_IMPORTED_MODULE_6__.CheckboxField, { id: "blazetracker-tracktime", label: "Time Tracking", description: "Extract and track narrative date/time", checked: settings.trackTime, onChange: checked => onToggle('trackTime', checked) }), settings.trackTime && ((0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)("div", { className: "bt-nested-setting", children: (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(_components_form__WEBPACK_IMPORTED_MODULE_6__.NumberField, { id: "blazetracker-leapthreshold", label: "Leap Threshold (minutes)", description: "Cap consecutive time jumps to prevent 'double sleep' issues", value: settings.leapThresholdMinutes, min: 5, max: 1440, step: 5, onChange: v => onNumericChange('leapThresholdMinutes', v) }) })), (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(_components_form__WEBPACK_IMPORTED_MODULE_6__.CheckboxField, { id: "blazetracker-tracklocation", label: "Location Tracking", description: "Extract area, place, position, and nearby props", checked: settings.trackLocation, onChange: checked => onToggle('trackLocation', checked) }), (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(_components_form__WEBPACK_IMPORTED_MODULE_6__.CheckboxField, { id: "blazetracker-trackclimate", label: "Climate Tracking", description: "Extract weather and temperature conditions", checked: settings.trackClimate, onChange: checked => onToggle('trackClimate', checked) }), settings.trackClimate && ((0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxs)("div", { className: "bt-nested-setting", children: [(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(_components_form__WEBPACK_IMPORTED_MODULE_6__.CheckboxField, { id: "blazetracker-proceduralweather", label: "Procedural Weather", description: "Use procedural forecast generation instead of LLM extraction", checked: settings.useProceduralWeather, onChange: checked => onToggle('useProceduralWeather', checked) }), settings.useProceduralWeather && ((0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)("div", { className: "bt-nested-setting", children: (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(_components_form__WEBPACK_IMPORTED_MODULE_6__.CheckboxField, { id: "blazetracker-weathertransitions", label: "Weather Transitions", description: "Inject transition notes when weather changes significantly", checked: settings.injectWeatherTransitions, onChange: checked => onToggle('injectWeatherTransitions', checked) }) }))] })), (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(_components_form__WEBPACK_IMPORTED_MODULE_6__.CheckboxField, { id: "blazetracker-trackcharacters", label: "Character Tracking", description: "Extract character positions, moods, outfits, and dispositions", checked: settings.trackCharacters, onChange: checked => onToggle('trackCharacters', checked) }), (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(_components_form__WEBPACK_IMPORTED_MODULE_6__.CheckboxField, { id: "blazetracker-trackscene", label: "Scene Tracking", description: "Extract scene topic, tone, tension, and recent events", checked: settings.trackScene, onChange: checked => onToggle('trackScene', checked) })] }));
}
// ============================================
// Main Settings Panel Component
// ============================================
function SettingsPanel() {
    const [settings, setSettings] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)(_settings__WEBPACK_IMPORTED_MODULE_3__.getSettings);
    const [profiles, setProfiles] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)([]);
    // Load connection profiles
    (0,react__WEBPACK_IMPORTED_MODULE_1__.useEffect)(() => {
        const context = SillyTavern.getContext();
        const connectionManager = context.extensionSettings?.connectionManager;
        setProfiles(connectionManager?.profiles || []);
    }, []);
    const handleUpdate = (0,react__WEBPACK_IMPORTED_MODULE_1__.useCallback)((key, value) => {
        (0,_settings__WEBPACK_IMPORTED_MODULE_3__.updateSetting)(key, value);
        setSettings(prev => ({ ...prev, [key]: value }));
    }, []);
    const handlePositionChange = (0,react__WEBPACK_IMPORTED_MODULE_1__.useCallback)((value) => {
        handleUpdate('displayPosition', value);
        document.querySelectorAll('.bt-state-root').forEach(el => el.remove());
        setTimeout(() => (0,_stateDisplay__WEBPACK_IMPORTED_MODULE_4__.renderAllStates)(), 200);
    }, [handleUpdate]);
    // Handler for boolean extraction toggles
    const handleExtractionToggle = (0,react__WEBPACK_IMPORTED_MODULE_1__.useCallback)((key, value) => {
        handleUpdate(key, value);
        setTimeout(() => (0,_stateDisplay__WEBPACK_IMPORTED_MODULE_4__.renderAllStates)(), 100);
    }, [handleUpdate]);
    // Handler for numeric extraction settings
    const handleExtractionNumericChange = (0,react__WEBPACK_IMPORTED_MODULE_1__.useCallback)((key, value) => {
        handleUpdate(key, value);
    }, [handleUpdate]);
    const handleTempUnitChange = (0,react__WEBPACK_IMPORTED_MODULE_1__.useCallback)((value) => {
        handleUpdate('temperatureUnit', value);
        setTimeout(() => (0,_stateDisplay__WEBPACK_IMPORTED_MODULE_4__.renderAllStates)(), 100);
    }, [handleUpdate]);
    const handleTimeFormatChange = (0,react__WEBPACK_IMPORTED_MODULE_1__.useCallback)((value) => {
        handleUpdate('timeFormat', value);
        setTimeout(() => (0,_stateDisplay__WEBPACK_IMPORTED_MODULE_4__.renderAllStates)(), 100);
    }, [handleUpdate]);
    const handlePromptUpdate = (0,react__WEBPACK_IMPORTED_MODULE_1__.useCallback)((key, value) => {
        const newCustomPrompts = { ...(settings.customPrompts ?? {}) };
        if (value === null) {
            delete newCustomPrompts[key];
        }
        else {
            newCustomPrompts[key] = value;
        }
        handleUpdate('customPrompts', newCustomPrompts);
    }, [settings.customPrompts, handleUpdate]);
    const handleTemperatureUpdate = (0,react__WEBPACK_IMPORTED_MODULE_1__.useCallback)((key, value) => {
        const newCustomTemperatures = { ...(settings.customTemperatures ?? {}) };
        if (value === null) {
            delete newCustomTemperatures[key];
        }
        else {
            newCustomTemperatures[key] = value;
        }
        handleUpdate('customTemperatures', newCustomTemperatures);
    }, [settings.customTemperatures, handleUpdate]);
    return ((0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxs)("div", { className: "blazetracker-settings-content", children: [(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxs)("div", { className: "flex-container flexFlowColumn", children: [(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)("label", { htmlFor: "blazetracker-profile", children: "Connection Profile" }), (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)("small", { children: "Select which API connection to use for state extraction" }), (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxs)("select", { id: "blazetracker-profile", className: "text_pole", value: settings.profileId, onChange: e => handleUpdate('profileId', e.target.value), children: [(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)("option", { value: "", children: "-- Select a profile --" }), profiles.map(profile => ((0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)("option", { value: profile.id, children: profile.name || profile.id }, profile.id)))] })] }), (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)("hr", {}), (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(_components_form__WEBPACK_IMPORTED_MODULE_6__.SelectField, { id: "blazetracker-automode", label: "Auto Mode", description: "When to automatically extract state", value: settings.autoMode, options: [
                    { value: 'none', label: 'None (manual only)' },
                    { value: 'responses', label: 'AI responses only' },
                    { value: 'inputs', label: 'User messages only' },
                    { value: 'both', label: 'Both' },
                ], onChange: v => handleUpdate('autoMode', v) }), (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)("hr", {}), (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(_components_form__WEBPACK_IMPORTED_MODULE_6__.NumberField, { id: "blazetracker-lastx", label: "Max Messages to Include", description: "Max. number of recent messages to send for extraction context", value: settings.lastXMessages, min: 1, max: 50, step: 1, onChange: v => handleUpdate('lastXMessages', v) }), (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)("hr", {}), (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(_components_form__WEBPACK_IMPORTED_MODULE_6__.NumberField, { id: "blazetracker-maxtokens", label: "Max Response Tokens", description: "Maximum tokens for extraction response", value: settings.maxResponseTokens, min: 500, max: 8000, step: 100, onChange: v => handleUpdate('maxResponseTokens', v) }), (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)("hr", {}), (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(_components_form__WEBPACK_IMPORTED_MODULE_6__.SelectField, { id: "blazetracker-position", label: "State Display Position", description: "Show state block above or below the message", value: settings.displayPosition, options: [
                    { value: 'below', label: 'Below message' },
                    { value: 'above', label: 'Above message' },
                ], onChange: handlePositionChange }), (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)("hr", {}), (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(ExtractionTogglesSection, { settings: settings, onToggle: handleExtractionToggle, onNumericChange: handleExtractionNumericChange }), (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)("hr", {}), (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(_components_form__WEBPACK_IMPORTED_MODULE_6__.SelectField, { id: "blazetracker-tempunit", label: "Temperature Unit", description: "Display temperatures in Fahrenheit or Celsius", value: settings.temperatureUnit, options: [
                    { value: 'fahrenheit', label: 'Fahrenheit (Â°F)' },
                    { value: 'celsius', label: 'Celsius (Â°C)' },
                ], onChange: handleTempUnitChange }), (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(_components_form__WEBPACK_IMPORTED_MODULE_6__.SelectField, { id: "blazetracker-timeformat", label: "Time Format", description: "Display time in 12-hour or 24-hour format", value: settings.timeFormat, options: [
                    { value: '24h', label: '24-hour (14:30)' },
                    { value: '12h', label: '12-hour (2:30 PM)' },
                ], onChange: handleTimeFormatChange }), (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)("hr", {}), (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(PromptsSection, { customPrompts: settings.customPrompts, customTemperatures: settings.customTemperatures, onUpdatePrompt: handlePromptUpdate, onUpdateTemperature: handleTemperatureUpdate })] }));
}
// ============================================
// Initialization
// ============================================
let settingsRoot = null;
function injectSettingsStyles() {
    if (document.getElementById('blazetracker-settings-styles'))
        return;
    const link = document.createElement('link');
    link.id = 'blazetracker-settings-styles';
    link.rel = 'stylesheet';
    link.href = new URL(/* asset import */ __webpack_require__(/*! ./settings.css */ "./src/ui/settings.css"), __webpack_require__.b).href;
    document.head.appendChild(link);
}
async function initSettingsUI() {
    const settingsContainer = document.getElementById('extensions_settings');
    if (!settingsContainer) {
        console.error('[BlazeTracker] Extension settings container not found.');
        return;
    }
    // Inject styles
    injectSettingsStyles();
    // Initialize settings
    await _settings__WEBPACK_IMPORTED_MODULE_3__.settingsManager.initializeSettings();
    // Create wrapper with drawer structure
    const panel = document.createElement('div');
    panel.id = 'blazetracker-settings';
    panel.className = 'extension_container';
    panel.innerHTML = `
    <div class="inline-drawer">
      <div class="inline-drawer-toggle inline-drawer-header">
        <b>ðŸ”¥ BlazeTracker</b>
        <div class="inline-drawer-icon fa-solid fa-circle-chevron-down down"></div>
      </div>
      <div class="inline-drawer-content">
        <div id="blazetracker-settings-root"></div>
      </div>
    </div>
  `;
    settingsContainer.appendChild(panel);
    // Mount React component
    const root = document.getElementById('blazetracker-settings-root');
    if (root) {
        settingsRoot = react_dom_client__WEBPACK_IMPORTED_MODULE_2__.createRoot(root);
        settingsRoot.render((0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(SettingsPanel, {}));
    }
}
function unmountSettingsUI() {
    if (settingsRoot) {
        settingsRoot.unmount();
        settingsRoot = null;
    }
}


/***/ },

/***/ "./src/ui/stateDisplay.css"
/*!*********************************!*\
  !*** ./src/ui/stateDisplay.css ***!
  \*********************************/
(module, __unused_webpack_exports, __webpack_require__) {

module.exports = __webpack_require__.p + "170df1f11bc13c62df91.css";

/***/ },

/***/ "./src/ui/stateDisplay.tsx"
/*!*********************************!*\
  !*** ./src/ui/stateDisplay.tsx ***!
  \*********************************/
(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   clearLoadingState: () => (/* binding */ clearLoadingState),
/* harmony export */   doExtractState: () => (/* binding */ doExtractState),
/* harmony export */   extractionInProgress: () => (/* binding */ extractionInProgress),
/* harmony export */   initStateDisplay: () => (/* binding */ initStateDisplay),
/* harmony export */   injectStyles: () => (/* binding */ injectStyles),
/* harmony export */   isManualExtractionInProgress: () => (/* binding */ isManualExtractionInProgress),
/* harmony export */   renderAllStates: () => (/* binding */ renderAllStates),
/* harmony export */   renderMessageState: () => (/* binding */ renderMessageState),
/* harmony export */   setManualExtractionInProgress: () => (/* binding */ setManualExtractionInProgress),
/* harmony export */   unmountAllRoots: () => (/* binding */ unmountAllRoots),
/* harmony export */   unmountMessageState: () => (/* binding */ unmountMessageState)
/* harmony export */ });
/* harmony import */ var react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react/jsx-runtime */ "./node_modules/react/jsx-runtime.js");
/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! react */ "./node_modules/react/index.js");
/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_1__);
/* harmony import */ var react_dom_client__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! react-dom/client */ "./node_modules/react-dom/client.js");
/* harmony import */ var sillytavern_utils_lib_config__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! sillytavern-utils-lib/config */ "./node_modules/sillytavern-utils-lib/dist/config.js");
/* harmony import */ var _extractors_extractState__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../extractors/extractState */ "./src/extractors/extractState.ts");
/* harmony import */ var _extractors_extractionProgress__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../extractors/extractionProgress */ "./src/extractors/extractionProgress.ts");
/* harmony import */ var _utils_messageState__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ../utils/messageState */ "./src/utils/messageState.ts");
/* harmony import */ var _stateEditor__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./stateEditor */ "./src/ui/stateEditor.tsx");
/* harmony import */ var _injectors_injectState__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ../injectors/injectState */ "./src/injectors/injectState.ts");
/* harmony import */ var _settings__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ../settings */ "./src/settings.ts");
/* harmony import */ var _extractors_extractTime__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! ../extractors/extractTime */ "./src/extractors/extractTime.ts");
/* harmony import */ var _constants__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(/*! ../constants */ "./src/constants.ts");
/* harmony import */ var _formatters__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__(/*! ./formatters */ "./src/ui/formatters.ts");
/* harmony import */ var _components_display__WEBPACK_IMPORTED_MODULE_13__ = __webpack_require__(/*! ./components/display */ "./src/ui/components/display/index.ts");
/* harmony import */ var _components_EventList__WEBPACK_IMPORTED_MODULE_14__ = __webpack_require__(/*! ./components/EventList */ "./src/ui/components/EventList.tsx");
/* harmony import */ var _components_NarrativeModal__WEBPACK_IMPORTED_MODULE_15__ = __webpack_require__(/*! ./components/NarrativeModal */ "./src/ui/components/NarrativeModal.tsx");
/* harmony import */ var _state_narrativeState__WEBPACK_IMPORTED_MODULE_16__ = __webpack_require__(/*! ../state/narrativeState */ "./src/state/narrativeState.ts");
/* harmony import */ var _state_relationships__WEBPACK_IMPORTED_MODULE_17__ = __webpack_require__(/*! ../state/relationships */ "./src/state/relationships.ts");


















// Track React roots so we can unmount/update them
const roots = new Map();
// Track ongoing extractions - exported so index.ts can check
const extractionInProgress = new Set();
// Track manual extraction in progress (prevents auto-extraction during manual)
let manualExtractionInProgress = false;
// Track current extraction step for UI updates
let currentExtractionStep = 'idle';
let currentExtractionMessageId = null;
/**
 * Check if a manual extraction is currently in progress.
 */
function isManualExtractionInProgress() {
    return manualExtractionInProgress;
}
/**
 * Set the manual extraction flag.
 */
function setManualExtractionInProgress(value) {
    manualExtractionInProgress = value;
}
function StateDisplay({ stateData, narrativeState, messageId, isExtracting, extractionStep, }) {
    const [showModal, setShowModal] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)(false);
    const handleOpenModal = (0,react__WEBPACK_IMPORTED_MODULE_1__.useCallback)(() => {
        setShowModal(true);
    }, []);
    const handleCloseModal = (0,react__WEBPACK_IMPORTED_MODULE_1__.useCallback)(() => {
        setShowModal(false);
    }, []);
    // Handle saving narrative state from the modal
    const handleNarrativeSave = (0,react__WEBPACK_IMPORTED_MODULE_1__.useCallback)(async (updatedState, deletedEvents, updatedCurrentEvents) => {
        const context = SillyTavern.getContext();
        // Save the narrative state
        await (0,_state_narrativeState__WEBPACK_IMPORTED_MODULE_16__.saveNarrativeState)(updatedState);
        // Sync deleted events: remove from affected messages' currentEvents
        if (deletedEvents.length > 0 || updatedCurrentEvents) {
            // Group deletions by messageId
            const deletionsByMessage = new Map();
            for (const del of deletedEvents) {
                if (!deletionsByMessage.has(del.messageId)) {
                    deletionsByMessage.set(del.messageId, new Set());
                }
                deletionsByMessage.get(del.messageId).add(del.summary);
            }
            // Update each affected message
            for (const [messageId, deletedSummaries] of deletionsByMessage) {
                const message = context.chat[messageId];
                if (!message)
                    continue;
                const msgStateData = (0,_utils_messageState__WEBPACK_IMPORTED_MODULE_6__.getMessageState)(message);
                if (!msgStateData?.state.currentEvents)
                    continue;
                // Filter out deleted events
                msgStateData.state.currentEvents =
                    msgStateData.state.currentEvents.filter(event => !deletedSummaries.has(event.summary));
                (0,_utils_messageState__WEBPACK_IMPORTED_MODULE_6__.setMessageState)(message, msgStateData);
            }
            // If we have updated current events, update the most recent message
            if (updatedCurrentEvents && context.chat.length > 0) {
                // Find the most recent message that has state
                for (let i = context.chat.length - 1; i >= 0; i--) {
                    const message = context.chat[i];
                    const msgStateData = (0,_utils_messageState__WEBPACK_IMPORTED_MODULE_6__.getMessageState)(message);
                    if (msgStateData?.state) {
                        msgStateData.state.currentEvents =
                            updatedCurrentEvents;
                        (0,_utils_messageState__WEBPACK_IMPORTED_MODULE_6__.setMessageState)(message, msgStateData);
                        break;
                    }
                }
            }
            await context.saveChat();
        }
        // Re-render all states to reflect the changes
        renderAllStates();
    }, []);
    // Show loading state while extracting
    if (isExtracting) {
        const stepLabel = extractionStep ? (0,_extractors_extractionProgress__WEBPACK_IMPORTED_MODULE_5__.getStepLabel)(extractionStep) : 'Extracting...';
        return (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(_components_display__WEBPACK_IMPORTED_MODULE_13__.LoadingIndicator, { stepLabel: stepLabel });
    }
    if (!stateData) {
        return null;
    }
    const { state } = stateData;
    const settings = (0,_settings__WEBPACK_IMPORTED_MODULE_9__.getSettings)();
    // Determine what to show based on settings AND data availability
    const showTime = settings.trackTime !== false && state.time;
    const showLocation = settings.trackLocation !== false && state.location;
    const showClimate = settings.trackClimate !== false && state.climate;
    const showScene = settings.trackScene !== false && state.scene;
    const showCharacters = settings.trackCharacters !== false &&
        state.characters &&
        state.characters.length > 0;
    // If nothing to show, render nothing
    const hasAnythingToShow = showTime || showLocation || showClimate || showScene || showCharacters;
    if (!hasAnythingToShow) {
        return null;
    }
    // Calculate details summary
    const characterCount = state.characters?.length ?? 0;
    const propsCount = state.location?.props?.length ?? 0;
    const showDetails = (showCharacters && characterCount > 0) || (showLocation && propsCount > 0);
    // Get relationships for character cards, versioned to this message's time
    const allRelationships = narrativeState?.relationships ?? [];
    const relationships = (0,_state_relationships__WEBPACK_IMPORTED_MODULE_17__.getRelationshipsAtMessage)(allRelationships, messageId);
    // Get current events for display
    const currentEvents = state.currentEvents ?? [];
    const showEvents = currentEvents.length > 0;
    // Get present character names for context
    const presentCharacters = state.characters?.map(c => c.name) ?? [];
    // Check if narrative modal should be available (has chapters or relationships)
    const hasNarrativeContent = narrativeState &&
        (narrativeState.chapters.length > 0 || narrativeState.relationships.length > 0);
    return ((0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxs)("div", { className: "bt-state-container", children: [(showTime || showClimate || showLocation) && ((0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxs)("div", { className: "bt-state-summary", children: [showTime && state.time && ((0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxs)("span", { className: "bt-time", children: [(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)("i", { className: "fa-regular fa-clock" }), ' ', (0,_formatters__WEBPACK_IMPORTED_MODULE_12__.formatTime)(state.time, settings.timeFormat)] })), showClimate && state.climate && ((0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(_components_display__WEBPACK_IMPORTED_MODULE_13__.ClimateDisplay, { climate: state.climate, temperatureUnit: settings.temperatureUnit })), showLocation && state.location && ((0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxs)("span", { className: "bt-location", children: [(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)("i", { className: "fa-solid fa-location-dot" }), ' ', (0,_formatters__WEBPACK_IMPORTED_MODULE_12__.formatLocation)(state.location)] }))] })), showScene && state.scene ? ((0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(_components_display__WEBPACK_IMPORTED_MODULE_13__.SceneDisplay, { scene: state.scene, onMoreInfoClick: hasNarrativeContent ? handleOpenModal : undefined })) : showScene && !state.scene ? ((0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxs)("div", { className: "bt-scene-pending", children: [(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)("i", { className: "fa-solid fa-hourglass-half" }), (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)("span", { children: "Scene analysis will happen after first character response" })] })) : null, state.chapterEnded ? ((0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)("div", { className: "bt-current-events", children: (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxs)("div", { className: "bt-chapter-ended", children: [(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxs)("div", { className: "bt-chapter-ended-header", children: [(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)("i", { className: "fa-solid fa-book" }), (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxs)("span", { className: "bt-chapter-ended-title", children: ["Chapter ", state.chapterEnded.index + 1, ":", ' ', state.chapterEnded.title] }), (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxs)("span", { className: "bt-chapter-ended-badge", children: [state.chapterEnded.reason ===
                                            'location_change' &&
                                            'Location changed', state.chapterEnded.reason ===
                                            'time_jump' && 'Time skip', state.chapterEnded.reason === 'both' &&
                                            'Location + Time', state.chapterEnded.reason === 'manual' &&
                                            'Manual'] })] }), (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)("div", { className: "bt-chapter-ended-summary", children: state.chapterEnded.summary }), (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)("div", { className: "bt-chapter-ended-stats", children: (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxs)("span", { children: [state.chapterEnded.eventCount, " events archived"] }) })] }) })) : showEvents ? ((0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxs)("div", { className: "bt-current-events", children: [(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(_components_EventList__WEBPACK_IMPORTED_MODULE_14__.EventList, { events: currentEvents.slice(-3), presentCharacters: presentCharacters, maxEvents: 3 }), currentEvents.length > 3 && hasNarrativeContent && ((0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxs)("button", { className: "bt-view-all-events", onClick: handleOpenModal, children: ["View all ", currentEvents.length, " events..."] }))] })) : null, showDetails && ((0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxs)("details", { className: "bt-state-details", children: [(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxs)("summary", { children: ["Details", showCharacters &&
                                characterCount > 0 &&
                                ` (${characterCount} characters`, showLocation &&
                                propsCount > 0 &&
                                `${showCharacters && characterCount > 0 ? ', ' : ' ('}${propsCount} props`, (showCharacters && characterCount > 0) ||
                                (showLocation && propsCount > 0)
                                ? ')'
                                : ''] }), showLocation &&
                        state.location &&
                        state.location.props &&
                        state.location.props.length > 0 && ((0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxs)("div", { className: "bt-props-section", children: [(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)("span", { className: "bt-props-header", children: "Props" }), (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)("div", { className: "bt-props", children: (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)("ul", { children: state.location.props.map((prop, idx) => ((0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)("li", { children: prop }, idx))) }) })] })), showCharacters &&
                        state.characters &&
                        state.characters.length > 0 && ((0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)("div", { className: "bt-characters", children: state.characters.map((char, idx) => ((0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(_components_display__WEBPACK_IMPORTED_MODULE_13__.CharacterCard, { character: char, relationships: relationships }, `${char.name}-${idx}`))) }))] })), showModal && narrativeState && ((0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(_components_NarrativeModal__WEBPACK_IMPORTED_MODULE_15__.NarrativeModal, { narrativeState: narrativeState, currentEvents: currentEvents, presentCharacters: presentCharacters, onClose: handleCloseModal, onSave: handleNarrativeSave, initialTab: currentEvents.length > 3 ? 'events' : 'chapters' }))] }));
}
// --- State Extraction ---
function getPreviousState(context, beforeMessageId) {
    for (let i = beforeMessageId - 1; i >= 0; i--) {
        const prev = context.chat[i];
        const trackerData = (0,_utils_messageState__WEBPACK_IMPORTED_MODULE_6__.getMessageState)(prev);
        if (trackerData?.state) {
            return trackerData.state;
        }
    }
    return null;
}
async function doExtractState(messageId, options = {}) {
    if (extractionInProgress.has(messageId)) {
        return null;
    }
    // Set manual extraction flag if this is a manual trigger
    if (options.isManual) {
        setManualExtractionInProgress(true);
    }
    const context = SillyTavern.getContext();
    const message = context.chat[messageId];
    if (!message) {
        console.warn(`[${_constants__WEBPACK_IMPORTED_MODULE_11__.EXTENSION_NAME}] Message not found:`, messageId);
        return null;
    }
    // Mark extraction in progress and track which message
    extractionInProgress.add(messageId);
    currentExtractionMessageId = messageId;
    // Try to show loading state (synchronous - DOM should be ready since we're called from
    // USER_MESSAGE_RENDERED or GENERATION_ENDED, not during streaming)
    const messageElement = document.querySelector(`[mesid="${messageId}"]`);
    const mesBlock = messageElement?.querySelector('.mes_block');
    if (messageElement && mesBlock) {
        updateMenuButtonState(messageId, true);
        renderMessageStateInternal(messageId, messageElement, null, true, currentExtractionStep);
    }
    const previousState = getPreviousState(context, messageId);
    // Clear milestones created by this message before re-extraction
    // This applies to all triggers: swiping, editing, fire button, slash commands
    const narrativeState = (0,_state_narrativeState__WEBPACK_IMPORTED_MODULE_16__.getNarrativeState)();
    if (narrativeState && narrativeState.relationships.length > 0) {
        const removed = (0,_state_relationships__WEBPACK_IMPORTED_MODULE_17__.clearAllMilestonesForMessage)(narrativeState.relationships, messageId);
        if (removed > 0) {
            await (0,_state_narrativeState__WEBPACK_IMPORTED_MODULE_16__.saveNarrativeState)(narrativeState);
        }
    }
    try {
        const { state } = await (0,_extractors_extractState__WEBPACK_IMPORTED_MODULE_4__.extractState)(context, messageId, previousState);
        const stateData = {
            state,
            extractedAt: new Date().toISOString(),
        };
        if (!message.extra) {
            message.extra = {};
        }
        (0,_utils_messageState__WEBPACK_IMPORTED_MODULE_6__.setMessageState)(message, stateData);
        await context.saveChat();
        // Update subsequent messages if this isn't the last message (re-extraction case)
        if (messageId < context.chat.length - 1) {
            // Find the event that was extracted for this specific messageId
            const newEvent = state.currentEvents?.find(e => e.messageId === messageId);
            // Update subsequent messages' events
            (0,_extractors_extractState__WEBPACK_IMPORTED_MODULE_4__.updateSubsequentMessagesEvents)(context, messageId, newEvent);
            // Save again to persist the updated subsequent messages
            await context.saveChat();
        }
        // Render the extracted state
        if (messageElement) {
            renderMessageStateInternal(messageId, messageElement, stateData, false);
        }
        return stateData;
    }
    catch (e) {
        if (e.name === 'AbortError') {
            (0,sillytavern_utils_lib_config__WEBPACK_IMPORTED_MODULE_3__.st_echo)?.('warning', 'ðŸ”¥ Extraction aborted');
        }
        else {
            console.warn(`[${_constants__WEBPACK_IMPORTED_MODULE_11__.EXTENSION_NAME}] Extraction failed:`, e);
            (0,sillytavern_utils_lib_config__WEBPACK_IMPORTED_MODULE_3__.st_echo)?.('error', `ðŸ”¥ Extraction failed: ${e.message}`);
        }
        // Clear loading state on error
        if (messageElement) {
            renderMessageStateInternal(messageId, messageElement, null, false);
        }
        return null;
    }
    finally {
        extractionInProgress.delete(messageId);
        if (currentExtractionMessageId === messageId) {
            currentExtractionMessageId = null;
        }
        // Clear manual extraction flag if we set it
        if (options.isManual) {
            setManualExtractionInProgress(false);
        }
        updateMenuButtonState(messageId, false);
    }
}
// --- Menu Button ---
function updateMenuButtonState(messageId, isLoading) {
    const messageElement = document.querySelector(`[mesid="${messageId}"]`);
    const btn = messageElement?.querySelector('.bt-extract-btn');
    if (btn) {
        btn.classList.toggle('bt-loading', isLoading);
        const icon = btn.querySelector('i');
        if (icon) {
            icon.className = isLoading
                ? 'fa-solid fa-spinner fa-spin'
                : 'fa-solid fa-fire';
        }
    }
}
function addMenuButton(messageId, messageElement) {
    const extraButtons = messageElement.querySelector('.extraMesButtons');
    if (!extraButtons)
        return;
    if (!extraButtons.querySelector('.bt-extract-btn')) {
        const extractBtn = document.createElement('div');
        extractBtn.className = 'bt-extract-btn mes_button';
        extractBtn.title = 'Extract scene state (BlazeTracker)';
        extractBtn.innerHTML = '<i class="fa-solid fa-fire"></i>';
        extractBtn.addEventListener('click', async (e) => {
            e.preventDefault();
            e.stopPropagation();
            await doExtractState(messageId, { isManual: true });
        });
        extraButtons.insertBefore(extractBtn, extraButtons.firstChild);
    }
    if (!extraButtons.querySelector('.bt-edit-btn')) {
        const editBtn = document.createElement('div');
        editBtn.className = 'bt-edit-btn mes_button';
        editBtn.title = 'Edit scene state (BlazeTracker)';
        editBtn.innerHTML = '<i class="fa-solid fa-pen"></i>';
        editBtn.addEventListener('click', async (e) => {
            e.preventDefault();
            e.stopPropagation();
            await editMessageState(messageId);
        });
        const extractBtn = extraButtons.querySelector('.bt-extract-btn');
        if (extractBtn) {
            extractBtn.after(editBtn);
        }
        else {
            extraButtons.insertBefore(editBtn, extraButtons.firstChild);
        }
    }
}
// --- Internal render function (when we already have the element) ---
function renderMessageStateInternal(messageId, messageElement, stateData, isExtracting, extractionStep) {
    addMenuButton(messageId, messageElement);
    const settings = (0,_settings__WEBPACK_IMPORTED_MODULE_9__.getSettings)();
    const isAbove = settings.displayPosition === 'above';
    let needsNewRoot = false;
    let container = messageElement.querySelector('.bt-state-root');
    if (!container) {
        container = document.createElement('div');
        container.className = 'bt-state-root';
        needsNewRoot = true;
    }
    // Update position class
    container.classList.toggle('bt-above', isAbove);
    // Insert in correct position
    const mesBlock = messageElement.querySelector('.mes_block');
    const mesText = mesBlock?.querySelector('.mes_text');
    if (needsNewRoot && mesBlock) {
        if (isAbove && mesText) {
            mesBlock.insertBefore(container, mesText);
        }
        else {
            mesBlock.appendChild(container);
        }
    }
    let root = roots.get(messageId);
    if (needsNewRoot && root) {
        root.unmount();
        root = undefined;
    }
    if (!root) {
        root = react_dom_client__WEBPACK_IMPORTED_MODULE_2__.createRoot(container);
        roots.set(messageId, root);
    }
    // Get narrative state from message 0
    const narrativeState = (0,_state_narrativeState__WEBPACK_IMPORTED_MODULE_16__.getNarrativeState)();
    root.render((0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(StateDisplay, { stateData: stateData, narrativeState: narrativeState, messageId: messageId, isExtracting: isExtracting, extractionStep: extractionStep }));
    // If this is the most recent message, scroll to the end.
    const context = SillyTavern.getContext();
    if (messageId === context.chat.length - 1) {
        setTimeout(() => {
            messageElement.scrollIntoView({ behavior: 'smooth', block: 'nearest' });
        }, 50);
    }
}
// --- Public API ---
function renderMessageState(messageId, stateData, isExtracting = false) {
    // Don't render if extraction is in progress (unless we're explicitly setting isExtracting)
    if (extractionInProgress.has(messageId) && !isExtracting) {
        return;
    }
    const context = SillyTavern.getContext();
    const message = context.chat[messageId];
    const messageElement = document.querySelector(`[mesid="${messageId}"]`);
    if (!messageElement)
        return;
    const currentStateData = stateData !== undefined
        ? stateData
        : ((0,_utils_messageState__WEBPACK_IMPORTED_MODULE_6__.getMessageState)(message) ?? null);
    renderMessageStateInternal(messageId, messageElement, currentStateData, isExtracting);
}
/** Clear loading state (used when extraction is handled elsewhere) */
function clearLoadingState(messageId) {
    extractionInProgress.delete(messageId);
    renderMessageState(messageId);
}
function unmountMessageState(messageId) {
    const root = roots.get(messageId);
    if (root) {
        root.unmount();
        roots.delete(messageId);
    }
}
/**
 * Unmount all React roots and clear DOM containers.
 * Use this before bulk operations like bt-extract-all.
 */
function unmountAllRoots() {
    // Remove all DOM containers
    document.querySelectorAll('.bt-state-root').forEach(el => el.remove());
    // Unmount all React roots
    for (const [_messageId, root] of roots) {
        root.unmount();
    }
    roots.clear();
}
function renderAllStates() {
    const context = SillyTavern.getContext();
    // Reset time tracker first
    (0,_extractors_extractTime__WEBPACK_IMPORTED_MODULE_10__.resetTimeTracker)();
    // Find most recent message with state and initialize time tracker
    for (let i = context.chat.length - 1; i >= 0; i--) {
        const msg = context.chat[i];
        const stored = (0,_utils_messageState__WEBPACK_IMPORTED_MODULE_6__.getMessageState)(msg);
        if (stored?.state?.time) {
            (0,_extractors_extractTime__WEBPACK_IMPORTED_MODULE_10__.setTimeTrackerState)(stored.state.time);
            break;
        }
    }
    // Unmount all roots and clear DOM containers
    unmountAllRoots();
    // Re-render all messages
    for (let i = 0; i < context.chat.length; i++) {
        renderMessageState(i);
    }
}
async function editMessageState(messageId) {
    const context = SillyTavern.getContext();
    const message = context.chat[messageId];
    if (!message) {
        (0,sillytavern_utils_lib_config__WEBPACK_IMPORTED_MODULE_3__.st_echo)?.('error', 'Message not found');
        return;
    }
    const currentStateData = (0,_utils_messageState__WEBPACK_IMPORTED_MODULE_6__.getMessageState)(message);
    const currentState = currentStateData?.state || null;
    const _saved = await (0,_stateEditor__WEBPACK_IMPORTED_MODULE_7__.openStateEditor)(currentState, async (newState) => {
        const stateData = {
            state: newState,
            extractedAt: new Date().toISOString(),
        };
        (0,_utils_messageState__WEBPACK_IMPORTED_MODULE_6__.setMessageState)(message, stateData);
        await context.saveChat();
        renderMessageState(messageId, stateData);
        (0,_injectors_injectState__WEBPACK_IMPORTED_MODULE_8__.updateInjectionFromChat)();
        (0,sillytavern_utils_lib_config__WEBPACK_IMPORTED_MODULE_3__.st_echo)?.('success', 'ðŸ”¥ State updated');
    });
}
function initStateDisplay() {
    const context = SillyTavern.getContext();
    // Wire up extraction progress updates
    (0,_extractors_extractionProgress__WEBPACK_IMPORTED_MODULE_5__.onExtractionProgress)((progress) => {
        currentExtractionStep = progress.step;
        // Re-render the extracting message to show updated step
        if (currentExtractionMessageId !== null &&
            extractionInProgress.has(currentExtractionMessageId)) {
            const messageElement = document.querySelector(`[mesid="${currentExtractionMessageId}"]`);
            if (messageElement) {
                renderMessageStateInternal(currentExtractionMessageId, messageElement, null, true, progress.step);
            }
        }
    });
    // Only handle chat change for initial render - let index.ts handle message events
    context.eventSource.on(context.event_types.CHAT_CHANGED, (() => {
        (0,_extractors_extractTime__WEBPACK_IMPORTED_MODULE_10__.resetTimeTracker)();
        setTimeout(renderAllStates, 100);
    }));
}
function injectStyles() {
    if (document.getElementById('blazetracker-styles'))
        return;
    const link = document.createElement('link');
    link.id = 'blazetracker-styles';
    link.rel = 'stylesheet';
    link.href = new URL(/* asset import */ __webpack_require__(/*! ./stateDisplay.css */ "./src/ui/stateDisplay.css"), __webpack_require__.b).href;
    document.head.appendChild(link);
}


/***/ },

/***/ "./src/ui/stateEditor.css"
/*!********************************!*\
  !*** ./src/ui/stateEditor.css ***!
  \********************************/
(module, __unused_webpack_exports, __webpack_require__) {

module.exports = __webpack_require__.p + "b1ef1f178d9815513791.css";

/***/ },

/***/ "./src/ui/stateEditor.tsx"
/*!********************************!*\
  !*** ./src/ui/stateEditor.tsx ***!
  \********************************/
(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   StateEditor: () => (/* binding */ StateEditor),
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__),
/* harmony export */   openStateEditor: () => (/* binding */ openStateEditor)
/* harmony export */ });
/* harmony import */ var react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react/jsx-runtime */ "./node_modules/react/jsx-runtime.js");
/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! react */ "./node_modules/react/index.js");
/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_1__);
/* harmony import */ var react_dom_client__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! react-dom/client */ "./node_modules/react-dom/client.js");
/* harmony import */ var _utils_temperatures__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../utils/temperatures */ "./src/utils/temperatures.ts");
/* harmony import */ var _settings__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../settings */ "./src/settings.ts");
/* harmony import */ var _constants__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./constants */ "./src/ui/constants.ts");
/* harmony import */ var _components_form__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./components/form */ "./src/ui/components/form/index.ts");
/* harmony import */ var _weather__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ../weather */ "./src/weather/index.ts");

/**
 * BlazeTracker State Editor
 *
 * A form-based editor for TrackedState with validation against the schema.
 * Uses ST's popup system to display.
 *
 * Only shows sections for fields that exist in the state.
 * Preserves optionality - undefined fields stays undefined.
 */







// --- Helper Functions ---
function getDaysInMonth(year, month) {
    // Day 0 of next month = last day of this month
    return new Date(year, month, 0).getDate();
}
function getDayOfWeek(year, month, day) {
    const date = new Date(year, month - 1, day);
    return _constants__WEBPACK_IMPORTED_MODULE_5__.DAYS_OF_WEEK[date.getDay()];
}
function createEmptyCharacter() {
    return {
        name: '',
        position: '',
        activity: '',
        // Note: goals removed in v1.0.0, now tracked in CharacterArc
        mood: [],
        physicalState: [],
        outfit: {
            head: null,
            neck: null,
            jacket: null,
            back: null,
            torso: null,
            legs: null,
            socks: null,
            underwear: null,
            footwear: null,
        },
        // Note: dispositions removed in v1.0.0, now tracked in Relationship
    };
}
function createEmptyTime() {
    const now = new Date();
    return {
        year: now.getFullYear(),
        month: now.getMonth() + 1,
        day: now.getDate(),
        hour: 12,
        minute: 0,
        second: 0,
        dayOfWeek: _constants__WEBPACK_IMPORTED_MODULE_5__.DAYS_OF_WEEK[now.getDay()],
    };
}
function createEmptyLocation() {
    return {
        area: '',
        place: '',
        position: '',
        props: [],
    };
}
function createEmptyClimate() {
    return {
        weather: 'sunny',
        temperature: 70,
    };
}
function createEmptyScene() {
    return {
        topic: '',
        tone: '',
        tension: {
            level: 'relaxed',
            direction: 'stable',
            type: 'conversation',
        },
        // Note: recentEvents removed in v1.0.0, replaced by currentEvents on TrackedState
    };
}
function cloneState(state) {
    return JSON.parse(JSON.stringify(state));
}
// --- Validation ---
function validateState(state) {
    const errors = {};
    // Scene (only validate if present)
    if (state.scene) {
        if (!state.scene.topic?.trim()) {
            errors['scene.topic'] = 'Topic is required';
        }
        if (!state.scene.tone?.trim()) {
            errors['scene.tone'] = 'Tone is required';
        }
    }
    // Time (only validate if present)
    if (state.time) {
        if (state.time.year < 1 || state.time.year > 9999) {
            errors['time.year'] = 'Year must be 1-9999';
        }
        if (state.time.month < 1 || state.time.month > 12) {
            errors['time.month'] = 'Month must be 1-12';
        }
        const maxDay = getDaysInMonth(state.time.year, state.time.month);
        if (state.time.day < 1 || state.time.day > maxDay) {
            errors['time.day'] = `Day must be 1-${maxDay}`;
        }
        if (state.time.hour < 0 || state.time.hour > 23) {
            errors['time.hour'] = 'Hour must be 0-23';
        }
        if (state.time.minute < 0 || state.time.minute > 59) {
            errors['time.minute'] = 'Minute must be 0-59';
        }
    }
    // Location (only validate if present)
    if (state.location) {
        if (!state.location.area?.trim()) {
            errors['location.area'] = 'Area is required';
        }
        if (!state.location.place?.trim()) {
            errors['location.place'] = 'Place is required';
        }
        if (!state.location.position?.trim()) {
            errors['location.position'] = 'Position is required';
        }
        if (!state.location.props?.length) {
            errors['location.props'] = 'Props is required';
        }
    }
    // Climate (only validate if present)
    if (state.climate) {
        if ((0,_weather__WEBPACK_IMPORTED_MODULE_7__.isLegacyClimate)(state.climate)) {
            if (!_constants__WEBPACK_IMPORTED_MODULE_5__.WEATHER_OPTIONS.includes(state.climate.weather)) {
                errors['climate.weather'] = 'Invalid weather';
            }
        }
        else {
            if (!_constants__WEBPACK_IMPORTED_MODULE_5__.WEATHER_CONDITIONS.includes(state.climate.conditionType)) {
                errors['climate.conditionType'] = 'Invalid condition type';
            }
        }
    }
    // Characters (only validate if present)
    if (state.characters) {
        state.characters.forEach((char, idx) => {
            if (!char.name?.trim()) {
                errors[`char.${idx}.name`] = 'Name required';
            }
            if (!char.position?.trim()) {
                errors[`char.${idx}.position`] = 'Position required';
            }
        });
    }
    return errors;
}
// --- Sub-Components ---
/** Character editor */
function CharacterEditor({ character, index, onChange, onRemove, otherNames: _otherNames, errors, }) {
    const update = (field, value) => {
        onChange({ ...character, [field]: value });
    };
    return ((0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)("div", { className: "bt-char-editor", children: (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxs)("details", { children: [(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxs)("summary", { children: [(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)("span", { className: "bt-char-name", children: character.name || `Character ${index + 1}` }), (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)("button", { type: "button", onClick: e => {
                                e.preventDefault();
                                onRemove();
                            }, className: "bt-x", children: "\u00D7" })] }), (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxs)("div", { className: "bt-char-fields", children: [(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxs)("div", { className: "bt-row-2", children: [(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxs)("div", { className: "bt-field", children: [(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)("label", { children: "Name *" }), (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)("input", { type: "text", value: character.name, onChange: e => update('name', e.target.value), className: errors[`char.${index}.name`]
                                                ? 'bt-err'
                                                : '' })] }), (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxs)("div", { className: "bt-field", children: [(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)("label", { children: "Activity" }), (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)("input", { type: "text", value: character.activity || '', onChange: e => update('activity', e.target.value ||
                                                undefined) })] })] }), (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxs)("div", { className: "bt-field", children: [(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)("label", { children: "Position *" }), (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)("input", { type: "text", value: character.position, onChange: e => update('position', e.target.value), className: errors[`char.${index}.position`]
                                        ? 'bt-err'
                                        : '' })] }), (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxs)("div", { className: "bt-field", children: [(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)("label", { children: "Mood" }), (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(_components_form__WEBPACK_IMPORTED_MODULE_6__.TagInput, { tags: character.mood || [], onChange: t => update('mood', t), placeholder: "anxious, hopeful..." })] }), (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxs)("div", { className: "bt-field", children: [(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)("label", { children: "Physical State" }), (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(_components_form__WEBPACK_IMPORTED_MODULE_6__.TagInput, { tags: character.physicalState || [], onChange: t => update('physicalState', t), placeholder: "tired, injured..." })] }), (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxs)("div", { className: "bt-field", children: [(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)("label", { children: "Outfit" }), (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(_components_form__WEBPACK_IMPORTED_MODULE_6__.OutfitEditor, { outfit: character.outfit, onChange: o => update('outfit', o) })] })] })] }) }));
}
// --- Main Component ---
function StateEditor({ initialState, onSave, onCancel }) {
    const settings = (0,_settings__WEBPACK_IMPORTED_MODULE_4__.getSettings)();
    const tempUnit = settings.temperatureUnit ?? 'fahrenheit';
    // Clone the state to avoid mutating the original
    // Keep undefined fields as undefined
    const [state, setState] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)(() => initialState ? cloneState(initialState) : {});
    const [errors, setErrors] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)({});
    const [tab, setTab] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)('scene');
    // Check what sections exist
    const hasTime = state.time !== undefined;
    const hasLocation = state.location !== undefined;
    const hasClimate = state.climate !== undefined;
    const hasScene = state.scene !== undefined;
    const hasCharacters = state.characters !== undefined;
    // Check if there's anything to show on the scene tab
    const hasSceneTabContent = hasTime || hasLocation || hasClimate || hasScene;
    // Ensure we're on a valid tab
    (0,react__WEBPACK_IMPORTED_MODULE_1__.useEffect)(() => {
        if (tab === 'scene' && !hasSceneTabContent && hasCharacters) {
            setTab('chars');
        }
        else if (tab === 'chars' && !hasCharacters && hasSceneTabContent) {
            setTab('scene');
        }
    }, [tab, hasSceneTabContent, hasCharacters]);
    // Scene context
    const updateScene = (field, value) => {
        setState(s => {
            if (!s.scene)
                return s;
            return {
                ...s,
                scene: { ...s.scene, [field]: value },
            };
        });
    };
    const updateTension = (field, value) => {
        setState(s => {
            if (!s.scene)
                return s;
            return {
                ...s,
                scene: {
                    ...s.scene,
                    tension: {
                        ...s.scene.tension,
                        [field]: value,
                    },
                },
            };
        });
    };
    // Time - with automatic dayOfWeek calculation
    const updateTime = (field, value) => {
        setState(s => {
            if (!s.time)
                return s;
            const newTime = { ...s.time, [field]: value };
            // Recalculate dayOfWeek if date components change
            if (field === 'year' || field === 'month' || field === 'day') {
                // Clamp day to valid range for the month
                const maxDay = getDaysInMonth(newTime.year, newTime.month);
                if (newTime.day > maxDay) {
                    newTime.day = maxDay;
                }
                newTime.dayOfWeek = getDayOfWeek(newTime.year, newTime.month, newTime.day);
            }
            return { ...s, time: newTime };
        });
    };
    // Location
    const updateLocation = (field, value) => {
        setState(s => {
            if (!s.location)
                return s;
            return { ...s, location: { ...s.location, [field]: value } };
        });
    };
    // Climate (handles both legacy Climate and ProceduralClimate)
    const updateClimate = (field, value) => {
        setState(s => {
            if (!s.climate)
                return s;
            return {
                ...s,
                climate: { ...s.climate, [field]: value },
            };
        });
    };
    // Characters
    const updateChar = (idx, char) => {
        setState(s => {
            if (!s.characters)
                return s;
            return {
                ...s,
                characters: s.characters.map((c, i) => (i === idx ? char : c)),
            };
        });
    };
    const addChar = () => {
        setState(s => {
            if (!s.characters)
                return s;
            return { ...s, characters: [...s.characters, createEmptyCharacter()] };
        });
    };
    const removeChar = (idx) => {
        setState(s => {
            if (!s.characters)
                return s;
            return { ...s, characters: s.characters.filter((_, i) => i !== idx) };
        });
    };
    const getOtherNames = (excludeIdx) => (state.characters || [])
        .filter((_, i) => i !== excludeIdx)
        .map(c => c.name)
        .filter(Boolean);
    // Add missing sections
    const addTime = () => setState(s => ({ ...s, time: createEmptyTime() }));
    const addLocation = () => setState(s => ({ ...s, location: createEmptyLocation() }));
    const addClimate = () => setState(s => ({ ...s, climate: createEmptyClimate() }));
    const addScene = () => setState(s => ({ ...s, scene: createEmptyScene() }));
    const addCharacters = () => setState(s => ({ ...s, characters: [] }));
    // Remove sections (switch tabs if needed)
    const removeTime = () => {
        setState(s => {
            const { time: _time, ...rest } = s;
            return rest;
        });
    };
    const removeLocation = () => {
        setState(s => {
            const { location: _location, ...rest } = s;
            return rest;
        });
    };
    const removeClimate = () => {
        setState(s => {
            const { climate: _climate, ...rest } = s;
            return rest;
        });
    };
    const removeScene = () => {
        setState(s => {
            const { scene: _scene, ...rest } = s;
            return rest;
        });
    };
    const removeCharacters = () => {
        setState(s => {
            const { characters: _characters, ...rest } = s;
            return rest;
        });
        // Switch to scene tab since characters tab will be gone
        setTab('scene');
    };
    // Save
    const handleSave = () => {
        const errs = validateState(state);
        setErrors(errs);
        if (Object.keys(errs).length === 0) {
            onSave(state);
        }
    };
    const hasErrors = Object.keys(errors).length > 0;
    // Calculate max days for current month (only if time exists)
    const maxDaysInMonth = hasTime && state.time ? getDaysInMonth(state.time.year, state.time.month) : 31;
    // Check what sections are missing (for add buttons)
    const missingSections = {
        time: !hasTime,
        location: !hasLocation,
        climate: !hasClimate,
        scene: !hasScene,
        characters: !hasCharacters,
    };
    const hasMissingSections = Object.values(missingSections).some(v => v);
    // Component for adding missing sections
    const AddSectionButtons = () => {
        if (!hasMissingSections)
            return null;
        return ((0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxs)("div", { className: "bt-add-sections", children: [(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)("span", { className: "bt-add-sections-label", children: "Add section:" }), missingSections.scene && ((0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxs)("button", { type: "button", onClick: addScene, className: "bt-btn-small", children: [(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)("i", { className: "fa-solid fa-clapperboard" }), " Scene"] })), missingSections.time && ((0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxs)("button", { type: "button", onClick: addTime, className: "bt-btn-small", children: [(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)("i", { className: "fa-regular fa-clock" }), " Time"] })), missingSections.location && ((0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxs)("button", { type: "button", onClick: addLocation, className: "bt-btn-small", children: [(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)("i", { className: "fa-solid fa-map-marker-alt" }), ' ', "Location"] })), missingSections.climate && ((0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxs)("button", { type: "button", onClick: addClimate, className: "bt-btn-small", children: [(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)("i", { className: "fa-solid fa-cloud-sun" }), " Climate"] })), missingSections.characters && ((0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxs)("button", { type: "button", onClick: addCharacters, className: "bt-btn-small", children: [(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)("i", { className: "fa-solid fa-users" }), " Characters"] }))] }));
    };
    // If nothing to edit at all, show add buttons
    if (!hasSceneTabContent && !hasCharacters) {
        return ((0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxs)("div", { className: "bt-editor", children: [(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxs)("div", { className: "bt-empty-state", children: [(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)("i", { className: "fa-solid fa-info-circle" }), (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)("p", { children: "No state data to edit." }), (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)("p", { children: "Run extraction to populate, or add sections manually:" }), (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(AddSectionButtons, {})] }), (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)("div", { className: "bt-actions", children: (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)("button", { type: "button", onClick: onCancel, className: "bt-btn", children: "Close" }) })] }));
    }
    return ((0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxs)("div", { className: "bt-editor", children: [(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxs)("div", { className: "bt-tabs", children: [hasSceneTabContent && ((0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxs)("button", { type: "button", className: `bt-tab ${tab === 'scene' ? 'active' : ''}`, onClick: () => setTab('scene'), children: [(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)("i", { className: "fa-solid fa-location-dot" }), " Scene"] })), hasCharacters && ((0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxs)("button", { type: "button", className: `bt-tab ${tab === 'chars' ? 'active' : ''}`, onClick: () => setTab('chars'), children: [(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)("i", { className: "fa-solid fa-users" }), " Characters (", state.characters?.length || 0, ")"] }))] }), tab === 'scene' && hasSceneTabContent && ((0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxs)("div", { className: "bt-panel", children: [hasScene && state.scene && ((0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxs)("fieldset", { className: "bt-section", children: [(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxs)("legend", { children: [(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)("i", { className: "fa-solid fa-clapperboard" }), ' ', "Context", (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)("button", { type: "button", className: "bt-section-remove", onClick: removeScene, title: "Remove section", children: (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)("i", { className: "fa-solid fa-trash" }) })] }), (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxs)("div", { className: "bt-row-2", children: [(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxs)("div", { className: "bt-field", children: [(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)("label", { children: "Topic *" }), (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)("input", { type: "text", value: state.scene
                                                    .topic, onChange: e => updateScene('topic', e
                                                    .target
                                                    .value), placeholder: "What's the scene about?", className: errors['scene.topic']
                                                    ? 'bt-err'
                                                    : '' })] }), (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxs)("div", { className: "bt-field", children: [(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)("label", { children: "Tone *" }), (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)("input", { type: "text", value: state.scene
                                                    .tone, onChange: e => updateScene('tone', e
                                                    .target
                                                    .value), placeholder: "Emotional atmosphere...", className: errors['scene.tone']
                                                    ? 'bt-err'
                                                    : '' })] })] }), (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxs)("div", { className: "bt-row-3", children: [(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxs)("div", { className: "bt-field", children: [(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)("label", { children: "Tension Level" }), (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)("select", { value: state.scene
                                                    .tension
                                                    .level, onChange: e => updateTension('level', e
                                                    .target
                                                    .value), children: _constants__WEBPACK_IMPORTED_MODULE_5__.TENSION_LEVELS.map(l => ((0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)("option", { value: l, children: l
                                                        .charAt(0)
                                                        .toUpperCase() +
                                                        l.slice(1) }, l))) })] }), (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxs)("div", { className: "bt-field", children: [(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)("label", { children: "Direction" }), (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)("select", { value: state.scene
                                                    .tension
                                                    .direction, onChange: e => updateTension('direction', e
                                                    .target
                                                    .value), children: _constants__WEBPACK_IMPORTED_MODULE_5__.TENSION_DIRECTIONS.map(d => ((0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)("option", { value: d, children: d
                                                        .charAt(0)
                                                        .toUpperCase() +
                                                        d.slice(1) }, d))) })] }), (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxs)("div", { className: "bt-field", children: [(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)("label", { children: "Type" }), (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)("select", { value: state.scene
                                                    .tension
                                                    .type, onChange: e => updateTension('type', e
                                                    .target
                                                    .value), children: _constants__WEBPACK_IMPORTED_MODULE_5__.TENSION_TYPES.map(t => ((0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)("option", { value: t, children: t
                                                        .charAt(0)
                                                        .toUpperCase() +
                                                        t.slice(1) }, t))) })] })] })] })), hasTime && state.time && ((0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxs)("fieldset", { className: "bt-section", children: [(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxs)("legend", { children: [(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)("i", { className: "fa-regular fa-clock" }), ' ', "Time", (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)("button", { type: "button", className: "bt-section-remove", onClick: removeTime, title: "Remove section", children: (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)("i", { className: "fa-solid fa-trash" }) })] }), (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxs)("div", { className: "bt-row-3", children: [(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxs)("div", { className: "bt-field", children: [(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)("label", { children: "Year" }), (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)("input", { type: "number", min: 1, max: 9999, value: state.time
                                                    .year, onChange: e => updateTime('year', parseInt(e
                                                    .target
                                                    .value) ||
                                                    2024), className: errors['time.year']
                                                    ? 'bt-err'
                                                    : '' })] }), (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxs)("div", { className: "bt-field", children: [(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)("label", { children: "Month" }), (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)("select", { value: state.time
                                                    .month, onChange: e => updateTime('month', parseInt(e
                                                    .target
                                                    .value)), className: errors['time.month']
                                                    ? 'bt-err'
                                                    : '', children: _constants__WEBPACK_IMPORTED_MODULE_5__.MONTH_NAMES.map((name, idx) => ((0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)("option", { value: idx +
                                                        1, children: name }, idx))) })] }), (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxs)("div", { className: "bt-field", children: [(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)("label", { children: "Day" }), (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)("input", { type: "number", min: 1, max: maxDaysInMonth, value: state.time
                                                    .day, onChange: e => updateTime('day', parseInt(e
                                                    .target
                                                    .value) ||
                                                    1), className: errors['time.day']
                                                    ? 'bt-err'
                                                    : '' })] })] }), (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxs)("div", { className: "bt-row-3", children: [(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxs)("div", { className: "bt-field", children: [(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)("label", { children: "Hour (0-23)" }), (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)("input", { type: "number", min: 0, max: 23, value: state.time
                                                    .hour, onChange: e => updateTime('hour', parseInt(e
                                                    .target
                                                    .value) ||
                                                    0), className: errors['time.hour']
                                                    ? 'bt-err'
                                                    : '' })] }), (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxs)("div", { className: "bt-field", children: [(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)("label", { children: "Minute" }), (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)("input", { type: "number", min: 0, max: 59, value: state.time
                                                    .minute, onChange: e => updateTime('minute', parseInt(e
                                                    .target
                                                    .value) ||
                                                    0), className: errors['time.minute']
                                                    ? 'bt-err'
                                                    : '' })] }), (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxs)("div", { className: "bt-field", children: [(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)("label", { children: "Day of Week" }), (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)("input", { type: "text", value: state.time
                                                    .dayOfWeek, disabled: true, style: {
                                                    opacity: 0.7,
                                                    cursor: 'not-allowed',
                                                } })] })] })] })), hasLocation && state.location && ((0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxs)("fieldset", { className: "bt-section", children: [(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxs)("legend", { children: [(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)("i", { className: "fa-solid fa-map-marker-alt" }), ' ', "Location", (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)("button", { type: "button", className: "bt-section-remove", onClick: removeLocation, title: "Remove section", children: (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)("i", { className: "fa-solid fa-trash" }) })] }), (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxs)("div", { className: "bt-field", children: [(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)("label", { children: "Area *" }), (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)("input", { type: "text", value: state.location.area, onChange: e => updateLocation('area', e.target
                                            .value), placeholder: "City, district, region...", className: errors['location.area']
                                            ? 'bt-err'
                                            : '' })] }), (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxs)("div", { className: "bt-field", children: [(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)("label", { children: "Place *" }), (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)("input", { type: "text", value: state.location.place, onChange: e => updateLocation('place', e.target
                                            .value), placeholder: "Building, establishment, room...", className: errors['location.place']
                                            ? 'bt-err'
                                            : '' })] }), (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxs)("div", { className: "bt-field", children: [(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)("label", { children: "Position *" }), (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)("input", { type: "text", value: state.location
                                            .position, onChange: e => updateLocation('position', e.target
                                            .value), placeholder: "Position within the place...", className: errors['location.position']
                                            ? 'bt-err'
                                            : '' })] }), (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxs)("div", { className: "bt-field", children: [(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)("label", { children: "Props" }), (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(_components_form__WEBPACK_IMPORTED_MODULE_6__.TagInput, { tags: state.location
                                            .props || [], onChange: t => updateLocation('props', t), placeholder: "Add props..." })] })] })), hasClimate && state.climate && ((0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxs)("fieldset", { className: "bt-section", children: [(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxs)("legend", { children: [(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)("i", { className: "fa-solid fa-cloud-sun" }), ' ', "Climate", (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)("button", { type: "button", className: "bt-section-remove", onClick: removeClimate, title: "Remove section", children: (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)("i", { className: "fa-solid fa-trash" }) })] }), (0,_weather__WEBPACK_IMPORTED_MODULE_7__.isLegacyClimate)(state.climate) ? (
                            /* Legacy Climate Editor */
                            (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxs)("div", { className: "bt-row-2", children: [(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxs)("div", { className: "bt-field", children: [(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)("label", { children: "Weather" }), (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)("select", { value: state
                                                    .climate
                                                    .weather, onChange: e => updateClimate('weather', e
                                                    .target
                                                    .value), children: _constants__WEBPACK_IMPORTED_MODULE_5__.WEATHER_OPTIONS.map(w => ((0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)("option", { value: w, children: w
                                                        .charAt(0)
                                                        .toUpperCase() +
                                                        w.slice(1) }, w))) })] }), (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxs)("div", { className: "bt-field", children: [(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxs)("label", { children: ["Temperature (", tempUnit ===
                                                        'celsius'
                                                        ? 'Â°C'
                                                        : 'Â°F', ")"] }), (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)("input", { type: "number", value: (0,_utils_temperatures__WEBPACK_IMPORTED_MODULE_3__.toDisplayTemp)(state
                                                    .climate
                                                    .temperature, tempUnit), onChange: e => updateClimate('temperature', (0,_utils_temperatures__WEBPACK_IMPORTED_MODULE_3__.toStorageTemp)(parseInt(e
                                                    .target
                                                    .value) ||
                                                    0, tempUnit)) })] })] })) : (
                            /* Procedural Climate Editor */
                            (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxs)(react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.Fragment, { children: [(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxs)("div", { className: "bt-row-2", children: [(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxs)("div", { className: "bt-field", children: [(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)("label", { children: "Condition" }), (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)("select", { value: state
                                                            .climate
                                                            .conditionType, onChange: e => updateClimate('conditionType', e
                                                            .target
                                                            .value), children: _constants__WEBPACK_IMPORTED_MODULE_5__.WEATHER_CONDITIONS.map(c => ((0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)("option", { value: c, children: _constants__WEBPACK_IMPORTED_MODULE_5__.WEATHER_CONDITION_LABELS[c] }, c))) })] }), (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxs)("div", { className: "bt-field", children: [(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxs)("label", { children: ["Temperature (", tempUnit ===
                                                                'celsius'
                                                                ? 'Â°C'
                                                                : 'Â°F', ")"] }), (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)("input", { type: "number", value: (0,_utils_temperatures__WEBPACK_IMPORTED_MODULE_3__.toDisplayTemp)(state
                                                            .climate
                                                            .temperature, tempUnit), onChange: e => updateClimate('temperature', (0,_utils_temperatures__WEBPACK_IMPORTED_MODULE_3__.toStorageTemp)(parseInt(e
                                                            .target
                                                            .value) ||
                                                            0, tempUnit)) })] })] }), (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxs)("div", { className: "bt-row-2", children: [(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxs)("div", { className: "bt-field", children: [(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)("label", { children: "Humidity (%)" }), (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)("input", { type: "number", min: "0", max: "100", value: state
                                                            .climate
                                                            .humidity, onChange: e => updateClimate('humidity', parseInt(e
                                                            .target
                                                            .value) ||
                                                            0) })] }), (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxs)("div", { className: "bt-field", children: [(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)("label", { children: "Wind Speed (mph)" }), (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)("input", { type: "number", min: "0", value: state
                                                            .climate
                                                            .windSpeed, onChange: e => updateClimate('windSpeed', parseInt(e
                                                            .target
                                                            .value) ||
                                                            0) })] })] }), (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxs)("div", { className: "bt-row-2", children: [(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxs)("div", { className: "bt-field", children: [(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)("label", { children: "Cloud Cover (%)" }), (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)("input", { type: "number", min: "0", max: "100", value: state
                                                            .climate
                                                            .cloudCover, onChange: e => updateClimate('cloudCover', parseInt(e
                                                            .target
                                                            .value) ||
                                                            0) })] }), (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxs)("div", { className: "bt-field", children: [(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)("label", { children: "Indoors" }), (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxs)("select", { value: state
                                                            .climate
                                                            .isIndoors
                                                            ? 'yes'
                                                            : 'no', onChange: e => updateClimate('isIndoors', e
                                                            .target
                                                            .value ===
                                                            'yes'), children: [(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)("option", { value: "no", children: "No (Outdoors)" }), (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)("option", { value: "yes", children: "Yes (Indoors)" })] })] })] }), state.climate
                                        .isIndoors && ((0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxs)("div", { className: "bt-row-2", children: [(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxs)("div", { className: "bt-field", children: [(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)("label", { children: "Building Type" }), (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)("select", { value: state
                                                            .climate
                                                            .buildingType ??
                                                            'modern', onChange: e => updateClimate('buildingType', e
                                                            .target
                                                            .value), children: _constants__WEBPACK_IMPORTED_MODULE_5__.BUILDING_TYPES.map(b => ((0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)("option", { value: b, children: _constants__WEBPACK_IMPORTED_MODULE_5__.BUILDING_TYPE_LABELS[b] }, b))) })] }), (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxs)("div", { className: "bt-field", children: [(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxs)("label", { children: ["Indoor Temp (", tempUnit ===
                                                                'celsius'
                                                                ? 'Â°C'
                                                                : 'Â°F', ")"] }), (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)("input", { type: "number", value: (0,_utils_temperatures__WEBPACK_IMPORTED_MODULE_3__.toDisplayTemp)(state
                                                            .climate
                                                            .indoorTemperature ??
                                                            state
                                                                .climate
                                                                .temperature, tempUnit), onChange: e => updateClimate('indoorTemperature', (0,_utils_temperatures__WEBPACK_IMPORTED_MODULE_3__.toStorageTemp)(parseInt(e
                                                            .target
                                                            .value) ||
                                                            0, tempUnit)) })] })] }))] }))] })), (missingSections.scene ||
                        missingSections.time ||
                        missingSections.location ||
                        missingSections.climate) && ((0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxs)("div", { className: "bt-add-sections", children: [(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)("span", { className: "bt-add-sections-label", children: "Add:" }), missingSections.scene && ((0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxs)("button", { type: "button", onClick: addScene, className: "bt-btn-small", children: [(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)("i", { className: "fa-solid fa-clapperboard" }), ' ', "Scene"] })), missingSections.time && ((0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxs)("button", { type: "button", onClick: addTime, className: "bt-btn-small", children: [(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)("i", { className: "fa-regular fa-clock" }), ' ', "Time"] })), missingSections.location && ((0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxs)("button", { type: "button", onClick: addLocation, className: "bt-btn-small", children: [(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)("i", { className: "fa-solid fa-map-marker-alt" }), ' ', "Location"] })), missingSections.climate && ((0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxs)("button", { type: "button", onClick: addClimate, className: "bt-btn-small", children: [(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)("i", { className: "fa-solid fa-cloud-sun" }), ' ', "Climate"] }))] }))] })), tab === 'chars' && hasCharacters && state.characters && ((0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxs)("div", { className: "bt-panel", children: [(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxs)("div", { className: "bt-section-header", children: [(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)("span", { children: "Characters" }), (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxs)("button", { type: "button", className: "bt-section-remove", onClick: removeCharacters, title: "Remove all characters", children: [(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)("i", { className: "fa-solid fa-trash" }), " Remove Section"] })] }), (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)("div", { className: "bt-chars-list", children: state.characters.map((char, idx) => ((0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(CharacterEditor, { character: char, index: idx, onChange: c => updateChar(idx, c), onRemove: () => removeChar(idx), otherNames: getOtherNames(idx), errors: errors }, idx))) }), (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxs)("button", { type: "button", onClick: addChar, className: "bt-add-char", children: [(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)("i", { className: "fa-solid fa-plus" }), " Add Character"] })] })), tab === 'scene' && missingSections.characters && ((0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxs)("div", { className: "bt-add-sections", style: {
                    marginTop: '1rem',
                    borderTop: '1px solid var(--SmartThemeBorderColor)',
                    paddingTop: '1rem',
                }, children: [(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)("span", { className: "bt-add-sections-label", children: "Add:" }), (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxs)("button", { type: "button", onClick: () => {
                            addCharacters();
                            setTab('chars');
                        }, className: "bt-btn-small", children: [(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)("i", { className: "fa-solid fa-users" }), " Characters"] })] })), hasErrors && ((0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxs)("div", { className: "bt-errors", children: [(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)("i", { className: "fa-solid fa-exclamation-triangle" }), "Fix highlighted errors before saving."] })), (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxs)("div", { className: "bt-actions", children: [(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)("button", { type: "button", onClick: onCancel, className: "bt-btn", children: "Cancel" }), (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxs)("button", { type: "button", onClick: handleSave, className: "bt-btn bt-btn-primary", children: [(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)("i", { className: "fa-solid fa-save" }), " Save"] })] })] }));
}
// --- Integration with SillyTavern Popup ---
/**
 * Opens the state editor in a popup dialog.
 * Returns true if saved, false if cancelled.
 */
async function openStateEditor(currentState, onSave) {
    // Load CSS if not already loaded
    const cssUrl = new URL(/* asset import */ __webpack_require__(/*! ./stateEditor.css */ "./src/ui/stateEditor.css"), __webpack_require__.b).href;
    if (!document.querySelector(`link[href="${cssUrl}"]`)) {
        const link = document.createElement('link');
        link.rel = 'stylesheet';
        link.href = cssUrl;
        document.head.appendChild(link);
    }
    const context = SillyTavern.getContext();
    return new Promise(resolve => {
        // Create container
        const container = document.createElement('div');
        container.id = 'bt-editor-root';
        let savedState = null;
        const handleSave = (state) => {
            savedState = state;
            // Close popup by clicking OK
            document.querySelector('.popup-button-ok')?.click();
        };
        const handleCancel = () => {
            document.querySelector('.popup-button-cancel')?.click();
        };
        // Use imported ReactDOM, not window.ReactDOM
        const root = react_dom_client__WEBPACK_IMPORTED_MODULE_2__.createRoot(container);
        root.render((0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(StateEditor, { initialState: currentState, onSave: handleSave, onCancel: handleCancel }));
        // Show popup
        context.callGenericPopup(container, context.POPUP_TYPE.CONFIRM, null, {
            wide: true,
            large: true,
            okButton: '', // Hidden
            cancelButton: 'Close',
        }).then(async () => {
            root.unmount();
            if (savedState) {
                await onSave(savedState);
                resolve(true);
            }
            else {
                resolve(false);
            }
        });
        // Hide default OK button
        requestAnimationFrame(() => {
            const okBtn = document.querySelector('.popup-button-ok');
            if (okBtn)
                okBtn.style.display = 'none';
        });
    });
}
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (StateEditor);


/***/ },

/***/ "./src/ui/tabs/RelationshipsTab.tsx"
/*!******************************************!*\
  !*** ./src/ui/tabs/RelationshipsTab.tsx ***!
  \******************************************/
(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   RelationshipsTab: () => (/* binding */ RelationshipsTab)
/* harmony export */ });
/* harmony import */ var react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react/jsx-runtime */ "./node_modules/react/jsx-runtime.js");
/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! react */ "./node_modules/react/index.js");
/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_1__);
/* harmony import */ var _types_state__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../types/state */ "./src/types/state.ts");
/* harmony import */ var _components_form_TagInput__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../components/form/TagInput */ "./src/ui/components/form/TagInput.tsx");

// ============================================
// Relationships Tab Component
// ============================================



// ============================================
// Helpers
// ============================================
function formatMilestoneDate(dt) {
    if (!dt)
        return '';
    const months = [
        'Jan',
        'Feb',
        'Mar',
        'Apr',
        'May',
        'Jun',
        'Jul',
        'Aug',
        'Sep',
        'Oct',
        'Nov',
        'Dec',
    ];
    const month = months[dt.month - 1] || 'Jan';
    return `${month} ${dt.day}, ${dt.year}`;
}
// ============================================
// Constants
// ============================================
const STATUS_COLORS = {
    strangers: '#6b7280',
    acquaintances: '#3b82f6',
    friendly: '#22c55e',
    close: '#f59e0b',
    intimate: '#ec4899',
    strained: '#f97316',
    hostile: '#ef4444',
    complicated: '#8b5cf6',
};
const STATUS_ICONS = {
    strangers: 'fa-user-secret',
    acquaintances: 'fa-handshake',
    friendly: 'fa-users',
    close: 'fa-user-group',
    intimate: 'fa-heart',
    strained: 'fa-face-frown',
    hostile: 'fa-skull',
    complicated: 'fa-question',
};
// ============================================
// Components
// ============================================
function RelationshipCard({ relationship, isExpanded, onToggle, editMode, isEditing, onStartEdit, onUpdateRelationship, onDeleteRelationship, }) {
    const [char1, char2] = relationship.pair;
    const statusColor = STATUS_COLORS[relationship.status] || '#6b7280';
    const statusIcon = STATUS_ICONS[relationship.status] || 'fa-circle';
    const handleStatusChange = (newStatus) => {
        onUpdateRelationship?.({ ...relationship, status: newStatus });
    };
    const handleAToBChange = (field, values) => {
        onUpdateRelationship?.({
            ...relationship,
            aToB: { ...relationship.aToB, [field]: values },
        });
    };
    const handleBToAChange = (field, values) => {
        onUpdateRelationship?.({
            ...relationship,
            bToA: { ...relationship.bToA, [field]: values },
        });
    };
    const handleDeleteMilestone = (index) => {
        const newMilestones = relationship.milestones.filter((_, i) => i !== index);
        onUpdateRelationship?.({ ...relationship, milestones: newMilestones });
    };
    return ((0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxs)("div", { className: `bt-relationship-card ${isExpanded ? 'bt-expanded' : ''} ${isEditing ? 'bt-editing' : ''}`, children: [(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxs)("div", { className: "bt-relationship-header", onClick: isEditing ? undefined : onToggle, children: [(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxs)("div", { className: "bt-relationship-pair", children: [(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)("span", { className: "bt-char-name", children: char1 }), (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)("i", { className: `fa-solid ${statusIcon}`, style: { color: statusColor } }), (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)("span", { className: "bt-char-name", children: char2 })] }), isEditing ? ((0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)("select", { className: "bt-status-select", value: relationship.status, onChange: e => handleStatusChange(e.target
                            .value), onClick: e => e.stopPropagation(), children: _types_state__WEBPACK_IMPORTED_MODULE_2__.RELATIONSHIP_STATUSES.map(status => ((0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)("option", { value: status, children: status }, status))) })) : ((0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)("div", { className: "bt-relationship-status", style: { color: statusColor }, children: relationship.status })), editMode && !isEditing && ((0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxs)("div", { className: "bt-relationship-actions", children: [(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)("button", { type: "button", className: "bt-edit-btn-small", onClick: e => {
                                    e.stopPropagation();
                                    onStartEdit?.();
                                }, title: "Edit relationship", children: (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)("i", { className: "fa-solid fa-pen" }) }), (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)("button", { type: "button", className: "bt-delete-btn-small", onClick: e => {
                                    e.stopPropagation();
                                    onDeleteRelationship?.();
                                }, title: "Delete relationship", children: (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)("i", { className: "fa-solid fa-trash" }) })] })), isEditing && ((0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)("button", { type: "button", className: "bt-delete-btn-small", onClick: e => {
                            e.stopPropagation();
                            onDeleteRelationship?.();
                        }, title: "Delete relationship", children: (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)("i", { className: "fa-solid fa-trash" }) })), (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)("i", { className: `fa-solid ${isExpanded ? 'fa-chevron-up' : 'fa-chevron-down'} bt-expand-icon`, onClick: isEditing ? onToggle : undefined })] }), isExpanded && ((0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxs)("div", { className: "bt-relationship-details", children: [(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxs)("div", { className: "bt-attitude-section", children: [(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxs)("div", { className: "bt-attitude-header", children: [char1, " \u2192 ", char2] }), (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)("div", { className: "bt-attitude-content", children: isEditing ? ((0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxs)(react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.Fragment, { children: [(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxs)("div", { className: "bt-attitude-row-edit", children: [(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)("span", { className: "bt-label", children: "Feels:" }), (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(_components_form_TagInput__WEBPACK_IMPORTED_MODULE_3__.TagInput, { tags: relationship
                                                        .aToB
                                                        .feelings, onChange: v => handleAToBChange('feelings', v), placeholder: "Add feeling..." })] }), (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxs)("div", { className: "bt-attitude-row-edit", children: [(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)("span", { className: "bt-label", children: "Wants:" }), (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(_components_form_TagInput__WEBPACK_IMPORTED_MODULE_3__.TagInput, { tags: relationship
                                                        .aToB
                                                        .wants, onChange: v => handleAToBChange('wants', v), placeholder: "Add want..." })] }), (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxs)("div", { className: "bt-attitude-row-edit", children: [(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)("span", { className: "bt-label", children: "Secrets:" }), (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(_components_form_TagInput__WEBPACK_IMPORTED_MODULE_3__.TagInput, { tags: relationship
                                                        .aToB
                                                        .secrets, onChange: v => handleAToBChange('secrets', v), placeholder: "Add secret..." })] })] })) : ((0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxs)(react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.Fragment, { children: [relationship.aToB.feelings
                                            .length > 0 && ((0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxs)("div", { className: "bt-attitude-row", children: [(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)("span", { className: "bt-label", children: "Feels:" }), (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)("span", { className: "bt-value", children: relationship.aToB.feelings.join(', ') })] })), relationship.aToB.wants
                                            .length > 0 && ((0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxs)("div", { className: "bt-attitude-row", children: [(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)("span", { className: "bt-label", children: "Wants:" }), (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)("span", { className: "bt-value", children: relationship.aToB.wants.join(', ') })] })), relationship.aToB.secrets
                                            .length > 0 && ((0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxs)("div", { className: "bt-attitude-row", children: [(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)("span", { className: "bt-label", children: "Secrets:" }), (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)("span", { className: "bt-value", children: relationship.aToB.secrets.join(', ') })] }))] })) })] }), (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxs)("div", { className: "bt-attitude-section", children: [(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxs)("div", { className: "bt-attitude-header", children: [char2, " \u2192 ", char1] }), (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)("div", { className: "bt-attitude-content", children: isEditing ? ((0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxs)(react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.Fragment, { children: [(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxs)("div", { className: "bt-attitude-row-edit", children: [(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)("span", { className: "bt-label", children: "Feels:" }), (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(_components_form_TagInput__WEBPACK_IMPORTED_MODULE_3__.TagInput, { tags: relationship
                                                        .bToA
                                                        .feelings, onChange: v => handleBToAChange('feelings', v), placeholder: "Add feeling..." })] }), (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxs)("div", { className: "bt-attitude-row-edit", children: [(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)("span", { className: "bt-label", children: "Wants:" }), (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(_components_form_TagInput__WEBPACK_IMPORTED_MODULE_3__.TagInput, { tags: relationship
                                                        .bToA
                                                        .wants, onChange: v => handleBToAChange('wants', v), placeholder: "Add want..." })] }), (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxs)("div", { className: "bt-attitude-row-edit", children: [(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)("span", { className: "bt-label", children: "Secrets:" }), (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(_components_form_TagInput__WEBPACK_IMPORTED_MODULE_3__.TagInput, { tags: relationship
                                                        .bToA
                                                        .secrets, onChange: v => handleBToAChange('secrets', v), placeholder: "Add secret..." })] })] })) : ((0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxs)(react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.Fragment, { children: [relationship.bToA.feelings
                                            .length > 0 && ((0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxs)("div", { className: "bt-attitude-row", children: [(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)("span", { className: "bt-label", children: "Feels:" }), (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)("span", { className: "bt-value", children: relationship.bToA.feelings.join(', ') })] })), relationship.bToA.wants
                                            .length > 0 && ((0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxs)("div", { className: "bt-attitude-row", children: [(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)("span", { className: "bt-label", children: "Wants:" }), (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)("span", { className: "bt-value", children: relationship.bToA.wants.join(', ') })] })), relationship.bToA.secrets
                                            .length > 0 && ((0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxs)("div", { className: "bt-attitude-row", children: [(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)("span", { className: "bt-label", children: "Secrets:" }), (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)("span", { className: "bt-value", children: relationship.bToA.secrets.join(', ') })] }))] })) })] }), (relationship.milestones.length > 0 || isEditing) && ((0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxs)("div", { className: "bt-milestones-section", children: [(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxs)("div", { className: "bt-milestones-header", children: [(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)("i", { className: "fa-solid fa-star" }), ' ', "Milestones"] }), relationship.milestones.length > 0 ? ((0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)("ul", { className: "bt-milestones-list", children: relationship.milestones.map((milestone, i) => {
                                    const dateStr = formatMilestoneDate(milestone.timestamp);
                                    return ((0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxs)("li", { children: [(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)("span", { className: "bt-milestone-type", children: milestone.type.replace(/_/g, ' ') }), dateStr && ((0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxs)("span", { className: "bt-milestone-date", children: [' ', "(", dateStr, ")"] })), milestone.description && ((0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxs)("span", { className: "bt-milestone-desc", children: [' ', "-", ' ', milestone.description] })), isEditing && ((0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)("button", { type: "button", className: "bt-delete-btn-small bt-inline", onClick: () => handleDeleteMilestone(i), title: "Delete milestone", children: (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)("i", { className: "fa-solid fa-times" }) }))] }, i));
                                }) })) : ((0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)("p", { className: "bt-empty-message", children: "No milestones yet." }))] })), relationship.history.length > 0 && ((0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxs)("div", { className: "bt-history-section", children: [(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxs)("div", { className: "bt-history-header", children: [(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)("i", { className: "fa-solid fa-clock-rotate-left" }), ' ', "History"] }), (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)("ul", { className: "bt-history-list", children: relationship.history.map((snapshot, i) => ((0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxs)("li", { children: [(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxs)("span", { className: "bt-history-chapter", children: ["Ch.", ' ', snapshot.chapterIndex +
                                                    1, ":"] }), (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)("span", { className: "bt-history-status", children: snapshot.status }), snapshot.summary && ((0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxs)("span", { className: "bt-history-summary", children: [' ', "-", ' ', snapshot.summary] }))] }, i))) })] }))] }))] }));
}
function RelationshipsTab({ relationships, presentCharacters, editMode, onUpdate, }) {
    const [expandedIds, setExpandedIds] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)(new Set());
    const [filterCharacter, setFilterCharacter] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)('');
    const [editingPairKey, setEditingPairKey] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)(null);
    // Get unique characters for filter dropdown
    const allCharacters = (0,react__WEBPACK_IMPORTED_MODULE_1__.useMemo)(() => {
        const chars = new Set();
        for (const rel of relationships) {
            chars.add(rel.pair[0]);
            chars.add(rel.pair[1]);
        }
        return Array.from(chars).sort();
    }, [relationships]);
    // Filter relationships
    const filteredRelationships = (0,react__WEBPACK_IMPORTED_MODULE_1__.useMemo)(() => {
        if (!filterCharacter)
            return relationships;
        return relationships.filter(rel => rel.pair[0].toLowerCase() === filterCharacter.toLowerCase() ||
            rel.pair[1].toLowerCase() === filterCharacter.toLowerCase());
    }, [relationships, filterCharacter]);
    // Sort: present characters first, then by status
    const sortedRelationships = (0,react__WEBPACK_IMPORTED_MODULE_1__.useMemo)(() => {
        const presentSet = presentCharacters
            ? new Set(presentCharacters.map(c => c.toLowerCase()))
            : null;
        const statusOrder = [
            'intimate',
            'close',
            'friendly',
            'acquaintances',
            'strangers',
            'strained',
            'hostile',
            'complicated',
        ];
        return [...filteredRelationships].sort((a, b) => {
            // Present characters first
            if (presentSet) {
                const aPresent = a.pair.some(p => presentSet.has(p.toLowerCase()));
                const bPresent = b.pair.some(p => presentSet.has(p.toLowerCase()));
                if (aPresent && !bPresent)
                    return -1;
                if (!aPresent && bPresent)
                    return 1;
            }
            // Then by status (closer = higher)
            const aStatus = statusOrder.indexOf(a.status);
            const bStatus = statusOrder.indexOf(b.status);
            return aStatus - bStatus;
        });
    }, [filteredRelationships, presentCharacters]);
    const toggleExpanded = (pairKey) => {
        setExpandedIds(prev => {
            const next = new Set(prev);
            if (next.has(pairKey)) {
                next.delete(pairKey);
            }
            else {
                next.add(pairKey);
            }
            return next;
        });
    };
    const getPairKey = (rel) => rel.pair.join('|');
    const handleStartEdit = (pairKey) => {
        // Expand the card when starting to edit
        setExpandedIds(prev => {
            const next = new Set(prev);
            next.add(pairKey);
            return next;
        });
        setEditingPairKey(pairKey);
    };
    const handleUpdateRelationship = (pairKey, updated) => {
        if (onUpdate) {
            const newRelationships = relationships.map(rel => getPairKey(rel) === pairKey ? updated : rel);
            onUpdate(newRelationships);
        }
    };
    const handleDeleteRelationship = (pairKey) => {
        if (onUpdate) {
            const newRelationships = relationships.filter(rel => getPairKey(rel) !== pairKey);
            onUpdate(newRelationships);
            // Clear editing if we deleted the one being edited
            if (editingPairKey === pairKey) {
                setEditingPairKey(null);
            }
        }
    };
    // Clear editing state when leaving edit mode
    react__WEBPACK_IMPORTED_MODULE_1___default().useEffect(() => {
        if (!editMode) {
            setEditingPairKey(null);
        }
    }, [editMode]);
    if (relationships.length === 0) {
        return ((0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)("div", { className: "bt-relationships-tab bt-empty", children: (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)("p", { children: "No relationships established yet." }) }));
    }
    return ((0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxs)("div", { className: "bt-relationships-tab", children: [allCharacters.length > 2 && ((0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxs)("div", { className: "bt-filter-bar", children: [(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)("label", { htmlFor: "bt-char-filter", children: "Filter by character:" }), (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxs)("select", { id: "bt-char-filter", value: filterCharacter, onChange: e => setFilterCharacter(e.target.value), children: [(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)("option", { value: "", children: "All" }), allCharacters.map(char => ((0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)("option", { value: char, children: char }, char)))] })] })), (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)("div", { className: "bt-relationship-list", children: sortedRelationships.map(rel => {
                    const pairKey = getPairKey(rel);
                    return ((0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(RelationshipCard, { relationship: rel, isExpanded: expandedIds.has(pairKey), onToggle: () => toggleExpanded(pairKey), editMode: editMode, isEditing: editingPairKey === pairKey, onStartEdit: () => handleStartEdit(pairKey), onUpdateRelationship: updated => handleUpdateRelationship(pairKey, updated), onDeleteRelationship: () => handleDeleteRelationship(pairKey) }, pairKey));
                }) }), filteredRelationships.length === 0 && filterCharacter && ((0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxs)("p", { className: "bt-no-results", children: ["No relationships found for ", filterCharacter, "."] }))] }));
}


/***/ },

/***/ "./src/utils/clothingMatch.ts"
/*!************************************!*\
  !*** ./src/utils/clothingMatch.ts ***!
  \************************************/
(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   CHAR_PREFIX_PATTERNS: () => (/* binding */ CHAR_PREFIX_PATTERNS),
/* harmony export */   CHAR_SUFFIX_PATTERNS: () => (/* binding */ CHAR_SUFFIX_PATTERNS),
/* harmony export */   CLOTHING_KEYWORDS: () => (/* binding */ CLOTHING_KEYWORDS),
/* harmony export */   COLOR_KEYWORDS: () => (/* binding */ COLOR_KEYWORDS),
/* harmony export */   buildItemSearchTerms: () => (/* binding */ buildItemSearchTerms),
/* harmony export */   extractClothingType: () => (/* binding */ extractClothingType),
/* harmony export */   extractColors: () => (/* binding */ extractColors),
/* harmony export */   extractPropCore: () => (/* binding */ extractPropCore),
/* harmony export */   propAlreadyExists: () => (/* binding */ propAlreadyExists),
/* harmony export */   propMatchesItem: () => (/* binding */ propMatchesItem)
/* harmony export */ });
/**
 * Utility functions for matching clothing items in props.
 * Used to detect duplicate items when moving removed clothing to location props.
 */
// ============================================
// Constants
// ============================================
/**
 * Common clothing type keywords to extract for fuzzy matching.
 * Order matters - more specific terms should come first.
 */
const CLOTHING_KEYWORDS = [
    // Footwear
    'sneakers',
    'trainers',
    'boots',
    'heels',
    'sandals',
    'loafers',
    'flats',
    'shoes',
    'slippers',
    // Legwear
    'stockings',
    'tights',
    'thigh-highs',
    'knee-highs',
    'socks',
    'jeans',
    'trousers',
    'pants',
    'shorts',
    'skirt',
    'leggings',
    'sweatpants',
    // Underwear
    'panties',
    'knickers',
    'thong',
    'boxers',
    'briefs',
    'underwear',
    'sports bra',
    'bralette',
    'bra',
    // Tops
    'blouse',
    't-shirt',
    'tshirt',
    'shirt',
    'top',
    'tank top',
    'vest',
    'camisole',
    'sweater',
    'jumper',
    'hoodie',
    'cardigan',
    'pullover',
    // Outerwear
    'jacket',
    'coat',
    'blazer',
    'parka',
    'windbreaker',
    // Dresses
    'dress',
    'gown',
    'sundress',
    // Headwear
    'hat',
    'cap',
    'beanie',
    'hood',
];
/**
 * Common color words to extract from item descriptions.
 */
const COLOR_KEYWORDS = [
    'black',
    'white',
    'red',
    'blue',
    'green',
    'yellow',
    'purple',
    'pink',
    'orange',
    'brown',
    'grey',
    'gray',
    'navy',
    'cream',
    'beige',
    'tan',
    'maroon',
    'burgundy',
    'teal',
    'cyan',
    'silver',
    'gold',
    'dark',
    'light',
    'pale',
    'bright',
    'pastel',
];
/**
 * Patterns for PREFIX [item] - character name before the item.
 */
const CHAR_PREFIX_PATTERNS = [
    (char) => `${char}'s `,
    (char) => `${char}s `, // Without apostrophe
];
/**
 * Patterns for [item] SUFFIX - character name after the item.
 */
const CHAR_SUFFIX_PATTERNS = [
    (char) => ` belonging to ${char}`,
    (char) => ` ${char} removed`,
    (char) => ` ${char} took off`,
    (char) => ` ${char} dropped`,
    (char) => ` ${char} discarded`,
    (char) => ` from ${char}`,
    (char) => ` (${char}'s)`,
];
// ============================================
// Extraction Functions
// ============================================
/**
 * Extract the core clothing type from a descriptive item name.
 * e.g., "dark blue Levi's jeans" -> "jeans"
 */
function extractClothingType(itemName) {
    const lower = itemName.toLowerCase();
    for (const keyword of CLOTHING_KEYWORDS) {
        if (lower.includes(keyword)) {
            return keyword;
        }
    }
    return null;
}
/**
 * Extract color(s) from an item description.
 * e.g., "dark blue Levi's jeans" -> ["dark", "blue"]
 */
function extractColors(itemName) {
    const lower = itemName.toLowerCase();
    const colors = [];
    for (const color of COLOR_KEYWORDS) {
        if (lower.includes(color)) {
            colors.push(color);
        }
    }
    return colors;
}
/**
 * Build search terms for an item. Returns variations we should look for.
 * e.g., "White Nike sneakers" ->
 *   ["white nike sneakers", "sneakers", "white sneakers"]
 */
function buildItemSearchTerms(itemName) {
    const terms = [];
    const lower = itemName.toLowerCase();
    // Full item name
    terms.push(lower);
    // Just the clothing type
    const clothingType = extractClothingType(itemName);
    if (clothingType) {
        terms.push(clothingType);
        // Color + type combinations
        const colors = extractColors(itemName);
        for (const color of colors) {
            terms.push(`${color} ${clothingType}`);
        }
    }
    else {
        // No known clothing type - add individual words as fallback
        // This helps match "onesie" when item is "pink onesie"
        const words = lower
            .split(/\s+/)
            .filter(w => w.length > 2 &&
            !COLOR_KEYWORDS.includes(w) &&
            !['the', 'and', 'with'].includes(w));
        terms.push(...words);
    }
    return [...new Set(terms)]; // Dedupe
}
/**
 * Strip a prop string down to its core item description.
 * Removes character prefixes, state suffixes like "(removed)", location info.
 */
function extractPropCore(prop, charName) {
    const charLower = charName.toLowerCase();
    let propCore = prop.toLowerCase();
    // Remove character prefix
    for (const prefixFn of CHAR_PREFIX_PATTERNS) {
        const prefix = prefixFn(charLower);
        if (propCore.startsWith(prefix)) {
            propCore = propCore.slice(prefix.length);
            break;
        }
    }
    // Strip common suffixes like "on the floor", "(removed)" etc.
    propCore = propCore
        .replace(/\s*\(.*\)\s*$/, '')
        .replace(/\s+on the (?:floor|ground|bed|chair|table|sofa|couch).*$/, '')
        .replace(/\s+(?:removed|discarded|dropped|tossed|thrown).*$/, '')
        .replace(/\s+belonging to \w+.*$/, '')
        .replace(/\s+from \w+.*$/, '')
        .trim();
    return propCore;
}
// ============================================
// Matching Functions
// ============================================
/**
 * Check if a prop matches an item for a given character.
 * Uses PREFIX [item] SUFFIX pattern matching.
 */
function propMatchesItem(prop, itemSearchTerms, charName, fullItemName) {
    const propLower = prop.toLowerCase();
    const charLower = charName.toLowerCase();
    const itemLower = fullItemName.toLowerCase();
    // Strategy 1: Check if prop contains any search term AND the character name
    const hasCharName = propLower.includes(charLower);
    for (const term of itemSearchTerms) {
        // Direct match on full prop
        if (propLower === term)
            return true;
        // Prop contains the search term
        if (propLower.includes(term)) {
            // If char name is also present, definitely a match
            if (hasCharName)
                return true;
            // If no possessive marker at all, it's probably a generic prop that matches
            // e.g., "sneakers on the floor" matches anyone's sneakers
            if (!propLower.includes("'s") && !propLower.includes('belonging to')) {
                return true;
            }
        }
    }
    // Strategy 2: Check PREFIX patterns - "Elena's [term]"
    for (const prefixFn of CHAR_PREFIX_PATTERNS) {
        const prefix = prefixFn(charLower);
        if (propLower.startsWith(prefix)) {
            // Check if any search term appears after the prefix
            const afterPrefix = propLower.slice(prefix.length);
            for (const term of itemSearchTerms) {
                if (afterPrefix.includes(term) ||
                    term.includes(afterPrefix.split(' ')[0])) {
                    return true;
                }
            }
            // Fallback: check if the afterPrefix is substring of item or vice versa
            if (afterPrefix.length > 2 &&
                (itemLower.includes(afterPrefix) || afterPrefix.includes(itemLower))) {
                return true;
            }
        }
    }
    // Strategy 3: Check SUFFIX patterns - "[term] belonging to Elena"
    for (const suffixFn of CHAR_SUFFIX_PATTERNS) {
        const suffix = suffixFn(charLower);
        if (propLower.includes(suffix)) {
            for (const term of itemSearchTerms) {
                if (propLower.includes(term)) {
                    return true;
                }
            }
        }
    }
    // Strategy 4: Substring fallback for unknown item types
    // If prop (without char prefix) is substring of item or vice versa
    // e.g., prop "onesie" matches item "pink onesie"
    const propCore = extractPropCore(prop, charName);
    if (propCore.length > 2) {
        if (itemLower.includes(propCore) || propCore.includes(itemLower)) {
            // But make sure it's not a different character's item
            if (hasCharName || !propLower.includes("'s")) {
                return true;
            }
        }
    }
    return false;
}
/**
 * Check if a prop already exists in the set using multiple matching strategies.
 */
function propAlreadyExists(itemName, charName, existingProps) {
    const searchTerms = buildItemSearchTerms(itemName);
    for (const prop of existingProps) {
        if (propMatchesItem(prop, searchTerms, charName, itemName)) {
            return true;
        }
    }
    return false;
}


/***/ },

/***/ "./src/utils/generator.ts"
/*!********************************!*\
  !*** ./src/utils/generator.ts ***!
  \********************************/
(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   buildExtractionMessages: () => (/* binding */ buildExtractionMessages),
/* harmony export */   makeGeneratorRequest: () => (/* binding */ makeGeneratorRequest)
/* harmony export */ });
/* harmony import */ var sillytavern_utils_lib__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! sillytavern-utils-lib */ "./node_modules/sillytavern-utils-lib/dist/index.js");

const generator = new sillytavern_utils_lib__WEBPACK_IMPORTED_MODULE_0__.Generator();
/**
 * Make a request to the LLM via SillyTavern's Generator.
 * Centralized to avoid duplication across extractors.
 */
function makeGeneratorRequest(messages, options) {
    const { profileId, maxTokens, temperature = 0.5, abortSignal } = options;
    return new Promise((resolve, reject) => {
        if (abortSignal?.aborted) {
            return reject(new DOMException('Aborted', 'AbortError'));
        }
        const abortController = new AbortController();
        if (abortSignal) {
            abortSignal.addEventListener('abort', () => abortController.abort());
        }
        generator.generateRequest({
            profileId,
            prompt: messages,
            maxTokens,
            custom: { signal: abortController.signal },
            overridePayload: {
                temperature,
            },
        }, {
            abortController,
            onFinish: (_requestId, data, error) => {
                if (error) {
                    return reject(error);
                }
                if (!data) {
                    return reject(new DOMException('Request aborted', 'AbortError'));
                }
                const content = data.content;
                if (typeof content === 'string') {
                    resolve(content);
                }
                else {
                    resolve(JSON.stringify(content));
                }
            },
        });
    });
}
/**
 * Build a standard message array for extraction prompts.
 */
function buildExtractionMessages(systemPrompt, userPrompt) {
    return [
        { role: 'system', content: systemPrompt },
        { role: 'user', content: userPrompt },
    ];
}


/***/ },

/***/ "./src/utils/json.ts"
/*!***************************!*\
  !*** ./src/utils/json.ts ***!
  \***************************/
(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   asBoolean: () => (/* binding */ asBoolean),
/* harmony export */   asNumber: () => (/* binding */ asNumber),
/* harmony export */   asString: () => (/* binding */ asString),
/* harmony export */   asStringArray: () => (/* binding */ asStringArray),
/* harmony export */   asStringOrNull: () => (/* binding */ asStringOrNull),
/* harmony export */   isObject: () => (/* binding */ isObject),
/* harmony export */   parseJsonResponse: () => (/* binding */ parseJsonResponse)
/* harmony export */ });
// ============================================
// JSON Repair Functions
// ============================================
/**
 * Common thinking block close tags from various models.
 */
const THINKING_CLOSERS = [
    '</think>',
    '</thinking>',
    '</thought>',
    '</reasoning>',
    '</reason>',
    '</reflection>',
    '[/THINK]',
    '[/THINKING]',
    '[/THOUGHT]',
    '[/REASONING]',
    '[/REASON]',
    '[/REFLECTION]',
];
/**
 * Strip content before thinking block closers and trim to JSON boundaries.
 */
function preprocessJsonResponse(input) {
    let result = input;
    // Strip everything up to and including thinking close tags
    for (const closer of THINKING_CLOSERS) {
        const idx = result.toLowerCase().indexOf(closer.toLowerCase());
        if (idx !== -1) {
            result = result.slice(idx + closer.length);
        }
    }
    // Find the first { or [ and last } or ]
    const firstBrace = result.indexOf('{');
    const firstBracket = result.indexOf('[');
    const lastBrace = result.lastIndexOf('}');
    const lastBracket = result.lastIndexOf(']');
    // Determine start position (first { or [)
    let start = -1;
    if (firstBrace !== -1 && firstBracket !== -1) {
        start = Math.min(firstBrace, firstBracket);
    }
    else if (firstBrace !== -1) {
        start = firstBrace;
    }
    else if (firstBracket !== -1) {
        start = firstBracket;
    }
    // Determine end position (last } or ])
    let end = -1;
    if (lastBrace !== -1 && lastBracket !== -1) {
        end = Math.max(lastBrace, lastBracket);
    }
    else if (lastBrace !== -1) {
        end = lastBrace;
    }
    else if (lastBracket !== -1) {
        end = lastBracket;
    }
    // Extract JSON portion if valid boundaries found
    if (start !== -1 && end !== -1 && end > start) {
        result = result.slice(start, end + 1);
    }
    return result.trim();
}
/**
 * Fix directional/smart quotes to straight quotes.
 * " " â€ž â†’ "
 * ' ' â€š â†’ '
 */
function repairSmartQuotes(jsonStr) {
    return jsonStr
        .replace(/[\u201C\u201D\u201E\u201F\u2033\u2036]/g, '"')
        .replace(/[\u2018\u2019\u201A\u201B\u2032\u2035]/g, "'");
}
/**
 * Fix single-quoted strings to double-quoted.
 * Uses a state machine approach for reliability.
 */
function repairSingleQuotes(jsonStr) {
    const result = [];
    let i = 0;
    let inDoubleQuote = false;
    let inSingleQuote = false;
    while (i < jsonStr.length) {
        const char = jsonStr[i];
        const prevChar = i > 0 ? jsonStr[i - 1] : '';
        if (char === '"' && prevChar !== '\\') {
            if (!inSingleQuote) {
                inDoubleQuote = !inDoubleQuote;
            }
            result.push(char);
        }
        else if (char === "'" && prevChar !== '\\') {
            if (!inDoubleQuote) {
                // Convert single quote to double quote
                result.push('"');
                inSingleQuote = !inSingleQuote;
            }
            else {
                // Inside double-quoted string, keep as-is
                result.push(char);
            }
        }
        else {
            result.push(char);
        }
        i++;
    }
    return result.join('');
}
/**
 * Fix unquoted keys in JSON strings.
 * Converts: { footwear: null } -> { "footwear": null }
 */
function repairUnquotedKeys(jsonStr) {
    return jsonStr.replace(/([{,]\s*)([a-zA-Z_][a-zA-Z0-9_]*)(\s*:)/g, '$1"$2"$3');
}
/**
 * Fix unquoted keys with trailing apostrophe typo.
 * mood': â†’ mood:
 * Must run before repairUnquotedKeys and repairSingleQuotes.
 */
function repairUnquotedKeyApostropheTypo(jsonStr) {
    // Match: after { or , (with any whitespace including newlines),
    // an identifier followed by apostrophe, then colon
    return jsonStr.replace(/([{,][\s]*)([a-zA-Z_][a-zA-Z0-9_]*)'([\s]*:)/g, '$1$2$3');
}
/**
 * Fix double-quoted keys with trailing apostrophe typo before colon.
 * "mood': â†’ "mood":
 */
function repairKeyApostropheTypo(jsonStr) {
    return jsonStr.replace(/"([^"]+)'(\s*:)/g, '"$1"$2');
}
/**
 * Fix the bizarre '. pattern that appears in some malformed output.
 * jacket'.null â†’ jacket: null
 */
function repairDotApostropheTypo(jsonStr) {
    return jsonStr.replace(/'\.(\s*)/g, ': ');
}
/**
 * Fix unquoted string values (risky but sometimes necessary).
 * Only attempts to fix values that look like unquoted strings.
 */
function repairUnquotedValues(jsonStr) {
    return jsonStr.replace(/:\s*([a-zA-Z][^,}\]\n]*?)(\s*[,}\]])/g, (match, value, ending) => {
        const trimmed = value.trim();
        // Don't quote JSON literals
        if (['null', 'true', 'false'].includes(trimmed)) {
            return `: ${trimmed}${ending}`;
        }
        // Don't quote if already quoted
        if (/^["'].*["']$/.test(trimmed)) {
            return match;
        }
        // Don't quote numbers
        if (/^-?\d+\.?\d*$/.test(trimmed)) {
            return `: ${trimmed}${ending}`;
        }
        // Quote the unquoted string value
        const escaped = trimmed.replace(/"/g, '\\"');
        return `: "${escaped}"${ending}`;
    });
}
/**
 * Apply all repair functions to a JSON string.
 * Order matters - some repairs depend on others running first.
 */
function repairJson(jsonStr) {
    let repaired = jsonStr;
    // Phase 1: Normalize smart quote characters to straight quotes
    repaired = repairSmartQuotes(repaired);
    // Phase 2: Fix apostrophe typos BEFORE single quote conversion
    // (otherwise the state machine thinks stray apostrophes are string delimiters)
    repaired = repairUnquotedKeyApostropheTypo(repaired);
    repaired = repairKeyApostropheTypo(repaired);
    repaired = repairDotApostropheTypo(repaired);
    // Phase 3: Convert single quotes to double quotes
    repaired = repairSingleQuotes(repaired);
    // Phase 4: Fix unquoted keys
    repaired = repairUnquotedKeys(repaired);
    // Phase 5: Fix unquoted values (riskiest, run last)
    repaired = repairUnquotedValues(repaired);
    return repaired;
}
// ============================================
// Main Parser
// ============================================
/**
 * Parse a JSON response from an LLM, handling markdown code blocks
 * and extracting the JSON object or array.
 */
function parseJsonResponse(response, options = {}) {
    const { shape = 'auto', moduleName = 'BlazeTracker' } = options;
    let jsonStr = response.trim();
    // Strip markdown code blocks
    const jsonMatch = jsonStr.match(/```(?:json)?\s*([\s\S]*?)```/);
    if (jsonMatch) {
        jsonStr = jsonMatch[1].trim();
    }
    // Preprocess: strip thinking blocks and extract JSON boundaries
    jsonStr = preprocessJsonResponse(jsonStr);
    // Extract based on expected shape
    if (shape === 'array') {
        const arrayMatch = jsonStr.match(/\[[\s\S]*\]/);
        if (arrayMatch) {
            jsonStr = arrayMatch[0];
        }
    }
    else if (shape === 'object') {
        const objectMatch = jsonStr.match(/\{[\s\S]*\}/);
        if (objectMatch) {
            jsonStr = objectMatch[0];
        }
    }
    else {
        // Auto: try object first, then array
        const objectMatch = jsonStr.match(/\{[\s\S]*\}/);
        const arrayMatch = jsonStr.match(/\[[\s\S]*\]/);
        if (objectMatch && arrayMatch) {
            // Use whichever comes first in the string
            jsonStr =
                jsonStr.indexOf('{') < jsonStr.indexOf('[')
                    ? objectMatch[0]
                    : arrayMatch[0];
        }
        else if (objectMatch) {
            jsonStr = objectMatch[0];
        }
        else if (arrayMatch) {
            jsonStr = arrayMatch[0];
        }
    }
    // Try parsing as-is first
    try {
        return JSON.parse(jsonStr);
    }
    catch {
        // Try with repairs
        const repaired = repairJson(jsonStr);
        try {
            return JSON.parse(repaired);
        }
        catch (e) {
            console.error(`[${moduleName}] Failed to parse response:`, e);
            console.error(`[${moduleName}] Original:`, jsonStr);
            console.error(`[${moduleName}] After repair:`, repaired);
            throw new Error(`Failed to parse ${moduleName} response as JSON`);
        }
    }
}
/**
 * Safely extract a string from an unknown value.
 */
function asString(value, fallback) {
    return typeof value === 'string' ? value : fallback;
}
/**
 * Safely extract a string or null from an unknown value.
 */
function asStringOrNull(value) {
    return typeof value === 'string' ? value : null;
}
/**
 * Safely extract a number from an unknown value.
 */
function asNumber(value, fallback) {
    return typeof value === 'number' ? value : fallback;
}
/**
 * Safely extract a boolean from an unknown value.
 */
function asBoolean(value, fallback) {
    return typeof value === 'boolean' ? value : fallback;
}
/**
 * Safely extract an array of strings from an unknown value.
 */
function asStringArray(value, maxItems) {
    if (!Array.isArray(value)) {
        return [];
    }
    const filtered = value.filter((v) => typeof v === 'string');
    return maxItems ? filtered.slice(0, maxItems) : filtered;
}
/**
 * Check if value is a non-null object.
 */
function isObject(value) {
    return typeof value === 'object' && value !== null && !Array.isArray(value);
}


/***/ },

/***/ "./src/utils/messageState.ts"
/*!***********************************!*\
  !*** ./src/utils/messageState.ts ***!
  \***********************************/
(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   getMessageState: () => (/* binding */ getMessageState),
/* harmony export */   setMessageState: () => (/* binding */ setMessageState)
/* harmony export */ });
/* harmony import */ var _constants__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../constants */ "./src/constants.ts");

function getMessageState(message) {
    const swipeId = message.swipe_id ?? 0;
    const storage = message.extra?.[_constants__WEBPACK_IMPORTED_MODULE_0__.EXTENSION_KEY];
    return storage?.[swipeId] ?? null;
}
function setMessageState(message, stateData) {
    const swipeId = message.swipe_id ?? 0;
    if (!message.extra)
        message.extra = {};
    if (!message.extra[_constants__WEBPACK_IMPORTED_MODULE_0__.EXTENSION_KEY])
        message.extra[_constants__WEBPACK_IMPORTED_MODULE_0__.EXTENSION_KEY] = {};
    message.extra[_constants__WEBPACK_IMPORTED_MODULE_0__.EXTENSION_KEY][swipeId] = stateData;
}


/***/ },

/***/ "./src/utils/temperatures.ts"
/*!***********************************!*\
  !*** ./src/utils/temperatures.ts ***!
  \***********************************/
(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   celsiusToFahrenheit: () => (/* binding */ celsiusToFahrenheit),
/* harmony export */   fahrenheitToCelsius: () => (/* binding */ fahrenheitToCelsius),
/* harmony export */   formatTemperature: () => (/* binding */ formatTemperature),
/* harmony export */   toDisplayTemp: () => (/* binding */ toDisplayTemp),
/* harmony export */   toStorageTemp: () => (/* binding */ toStorageTemp)
/* harmony export */ });
function fahrenheitToCelsius(fahrenheit) {
    return Math.round(((fahrenheit - 32) * 5) / 9);
}
function celsiusToFahrenheit(celsius) {
    return Math.round((celsius * 9) / 5 + 32);
}
/**
 * Convert from storage (Fahrenheit) to display unit
 */
function toDisplayTemp(fahrenheit, unit) {
    return unit === 'celsius' ? fahrenheitToCelsius(fahrenheit) : fahrenheit;
}
/**
 * Convert from display unit to storage (Fahrenheit)
 */
function toStorageTemp(display, unit) {
    return unit === 'celsius' ? celsiusToFahrenheit(display) : display;
}
/**
 * Format temperature for display with unit symbol
 */
function formatTemperature(fahrenheit, unit) {
    if (unit === 'celsius') {
        return `${fahrenheitToCelsius(fahrenheit)}Â°C`;
    }
    return `${fahrenheit}Â°F`;
}


/***/ },

/***/ "./src/utils/tension.ts"
/*!******************************!*\
  !*** ./src/utils/tension.ts ***!
  \******************************/
(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   calculateTensionDirection: () => (/* binding */ calculateTensionDirection)
/* harmony export */ });
const TENSION_LEVEL_ORDER = [
    'relaxed',
    'aware',
    'guarded',
    'tense',
    'charged',
    'volatile',
    'explosive',
];
function calculateTensionDirection(currentLevel, previousLevel) {
    if (!previousLevel)
        return 'stable';
    const currentIndex = TENSION_LEVEL_ORDER.indexOf(currentLevel);
    const previousIndex = TENSION_LEVEL_ORDER.indexOf(previousLevel);
    if (currentIndex > previousIndex)
        return 'escalating';
    if (currentIndex < previousIndex)
        return 'decreasing';
    return 'stable';
}


/***/ },

/***/ "./src/utils/timeFormat.ts"
/*!*********************************!*\
  !*** ./src/utils/timeFormat.ts ***!
  \*********************************/
(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   applyTimeFormat: () => (/* binding */ applyTimeFormat)
/* harmony export */ });
function applyTimeFormat(hour, minute, format) {
    const mm = String(minute).padStart(2, '0');
    if (format === '12h') {
        const h = hour % 12 || 12;
        const ampm = hour < 12 ? 'AM' : 'PM';
        return `${h}:${mm} ${ampm}`;
    }
    return `${String(hour).padStart(2, '0')}:${mm}`;
}


/***/ },

/***/ "./src/weather/climateApi.ts"
/*!***********************************!*\
  !*** ./src/weather/climateApi.ts ***!
  \***********************************/
(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   clearCaches: () => (/* binding */ clearCaches),
/* harmony export */   fetchClimateNormals: () => (/* binding */ fetchClimateNormals),
/* harmony export */   geocodeLocation: () => (/* binding */ geocodeLocation)
/* harmony export */ });
/* harmony import */ var _fallbackProfiles__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./fallbackProfiles */ "./src/weather/fallbackProfiles.ts");
/**
 * Climate API Client
 *
 * Fetches historical climate data from Open-Meteo API.
 * Converts metric units to imperial (Fahrenheit, mph, inches).
 */

// ============================================
// Constants
// ============================================
const OPEN_METEO_ARCHIVE_URL = 'https://archive-api.open-meteo.com/v1/archive';
const NOMINATIM_URL = 'https://nominatim.openstreetmap.org/search';
const USER_AGENT = 'BlazeTracker/1.0 (SillyTavern Extension)';
// Cache for API responses
const climateCache = new Map();
const geocodeCache = new Map();
// ============================================
// Unit Conversion
// ============================================
function celsiusToFahrenheit(c) {
    return (c * 9) / 5 + 32;
}
function kmhToMph(kmh) {
    return kmh * 0.621371;
}
function mmToInches(mm) {
    return mm * 0.0393701;
}
// ============================================
// Geocoding
// ============================================
/**
 * Geocode a place name to coordinates using Nominatim
 */
async function geocodeLocation(placeName) {
    const cacheKey = placeName.toLowerCase().trim();
    if (geocodeCache.has(cacheKey)) {
        return geocodeCache.get(cacheKey);
    }
    try {
        const params = new URLSearchParams({
            q: placeName,
            format: 'json',
            limit: '1',
        });
        const response = await fetch(`${NOMINATIM_URL}?${params}`, {
            headers: {
                'User-Agent': USER_AGENT,
            },
        });
        if (!response.ok) {
            console.warn(`[BlazeTracker] Geocoding failed for "${placeName}": ${response.status}`);
            geocodeCache.set(cacheKey, null);
            return null;
        }
        const data = await response.json();
        if (!Array.isArray(data) || data.length === 0) {
            console.warn(`[BlazeTracker] No geocoding results for "${placeName}"`);
            geocodeCache.set(cacheKey, null);
            return null;
        }
        const result = {
            latitude: parseFloat(data[0].lat),
            longitude: parseFloat(data[0].lon),
        };
        geocodeCache.set(cacheKey, result);
        return result;
    }
    catch (error) {
        console.error(`[BlazeTracker] Geocoding error for "${placeName}":`, error);
        geocodeCache.set(cacheKey, null);
        return null;
    }
}
// ============================================
// Climate Data Fetching
// ============================================
/**
 * Fetch historical climate data from Open-Meteo
 * Returns averages for the specified month based on historical data
 */
async function fetchClimateNormals(latitude, longitude, month, fallbackClimateType) {
    const cacheKey = `${latitude.toFixed(2)},${longitude.toFixed(2)},${month}`;
    if (climateCache.has(cacheKey)) {
        return climateCache.get(cacheKey);
    }
    try {
        // Query last 10 years of data for this month
        const currentYear = new Date().getFullYear();
        const years = [];
        for (let y = currentYear - 10; y < currentYear; y++) {
            years.push(y);
        }
        // Build date ranges for the target month across all years
        const allData = await Promise.all(years.map(year => fetchMonthData(latitude, longitude, year, month)));
        // Filter out failed fetches
        const validData = allData.filter(d => d !== null);
        if (validData.length === 0) {
            console.warn(`[BlazeTracker] No climate data available, using fallback`);
            return getFallbackNormals(latitude, longitude, month, fallbackClimateType);
        }
        // Calculate averages
        const normals = calculateNormals(validData, latitude, longitude, month);
        climateCache.set(cacheKey, normals);
        return normals;
    }
    catch (error) {
        console.error(`[BlazeTracker] Climate API error:`, error);
        return getFallbackNormals(latitude, longitude, month, fallbackClimateType);
    }
}
/**
 * Fetch data for a single month in a single year
 */
async function fetchMonthData(latitude, longitude, year, month) {
    try {
        // Calculate date range for the month
        const startDate = `${year}-${String(month).padStart(2, '0')}-01`;
        const lastDay = new Date(year, month, 0).getDate();
        const endDate = `${year}-${String(month).padStart(2, '0')}-${String(lastDay).padStart(2, '0')}`;
        const params = new URLSearchParams({
            latitude: latitude.toString(),
            longitude: longitude.toString(),
            start_date: startDate,
            end_date: endDate,
            daily: [
                'temperature_2m_max',
                'temperature_2m_min',
                'precipitation_sum',
                'relative_humidity_2m_mean',
                'windspeed_10m_max',
                'cloudcover_mean',
            ].join(','),
            timezone: 'auto',
        });
        const response = await fetch(`${OPEN_METEO_ARCHIVE_URL}?${params}`);
        if (!response.ok) {
            return null;
        }
        const data = await response.json();
        if (!data.daily) {
            return null;
        }
        return {
            highs: data.daily.temperature_2m_max || [],
            lows: data.daily.temperature_2m_min || [],
            precip: data.daily.precipitation_sum || [],
            humidity: data.daily.relative_humidity_2m_mean || [],
            windSpeed: data.daily.windspeed_10m_max || [],
            cloudCover: data.daily.cloudcover_mean || [],
        };
    }
    catch {
        return null;
    }
}
/**
 * Calculate climate normals from historical data
 */
function calculateNormals(data, latitude, longitude, month) {
    // Flatten all data points
    const allHighs = data.flatMap(d => d.highs).filter(v => v !== null);
    const allLows = data.flatMap(d => d.lows).filter(v => v !== null);
    const allPrecip = data.flatMap(d => d.precip).filter(v => v !== null);
    const allHumidity = data.flatMap(d => d.humidity).filter(v => v !== null);
    const allWind = data.flatMap(d => d.windSpeed).filter(v => v !== null);
    const allClouds = data.flatMap(d => d.cloudCover).filter(v => v !== null);
    const avg = (arr) => arr.length > 0 ? arr.reduce((a, b) => a + b, 0) / arr.length : 0;
    const stdDev = (arr) => {
        if (arr.length === 0)
            return 0;
        const mean = avg(arr);
        const squareDiffs = arr.map(v => Math.pow(v - mean, 2));
        return Math.sqrt(avg(squareDiffs));
    };
    // Count precip days (>1mm = >0.04 inches)
    const precipDays = allPrecip.filter(p => p > 1).length / data.length;
    // Calculate sun times based on latitude and month
    const sunTimes = calculateSunTimes(latitude, month);
    // Estimate condition probabilities from cloud cover and precip
    const avgCloudCover = avg(allClouds);
    const precipProb = precipDays / 30;
    const conditionProbabilities = {
        clear: Math.max(0, (100 - avgCloudCover) / 100 - precipProb) * 0.5,
        partlyCloudy: Math.min(0.3, avgCloudCover / 200),
        overcast: Math.min(0.3, avgCloudCover / 150),
        rain: precipProb * (avg(allLows) > 32 ? 1 : 0.3),
        snow: precipProb * (avg(allLows) <= 32 ? 1 : 0),
    };
    // Normalize probabilities
    const total = Object.values(conditionProbabilities).reduce((a, b) => a + b, 0);
    if (total > 0) {
        Object.keys(conditionProbabilities).forEach(k => {
            conditionProbabilities[k] /= total;
        });
    }
    return {
        latitude,
        longitude,
        month,
        avgHigh: celsiusToFahrenheit(avg(allHighs)),
        avgLow: celsiusToFahrenheit(avg(allLows)),
        avgPrecipitation: mmToInches(avg(allPrecip)),
        avgPrecipDays: Math.round(precipDays),
        avgHumidity: avg(allHumidity),
        avgWindSpeed: kmhToMph(avg(allWind)),
        avgCloudCover: avg(allClouds),
        avgSunriseHour: sunTimes.sunrise,
        avgSunsetHour: sunTimes.sunset,
        tempStdDev: celsiusToFahrenheit(stdDev(allHighs)) - 32, // Convert std dev
        conditionProbabilities,
    };
}
/**
 * Calculate approximate sunrise/sunset times based on latitude and month
 */
function calculateSunTimes(latitude, month) {
    // Simplified calculation based on latitude and time of year
    // June 21 = summer solstice (longest day in northern hemisphere)
    // December 21 = winter solstice (shortest day)
    const dayOfYear = (month - 1) * 30 + 15; // Approximate mid-month
    const summerSolstice = 172; // ~June 21
    // Calculate day length variation based on latitude
    // At equator, day length is ~12 hours year-round
    // At 60Â° latitude, variation is ~6 hours
    const latitudeRadians = (Math.abs(latitude) * Math.PI) / 180;
    const maxVariation = Math.min(6, Math.tan(latitudeRadians) * 3);
    // Sinusoidal variation through the year
    const variation = Math.cos(((dayOfYear - summerSolstice) * 2 * Math.PI) / 365) * maxVariation;
    // Apply hemisphere correction
    const hemisphereCorrection = latitude >= 0 ? 1 : -1;
    const dayLengthHours = 12 + variation * hemisphereCorrection;
    // Calculate sunrise/sunset from day length
    const sunrise = 12 - dayLengthHours / 2;
    const sunset = 12 + dayLengthHours / 2;
    return {
        sunrise: Math.max(4, Math.min(9, sunrise)),
        sunset: Math.max(17, Math.min(21, sunset)),
    };
}
/**
 * Get fallback normals when API fails
 */
function getFallbackNormals(latitude, longitude, month, fallbackClimateType) {
    // Infer climate type from latitude if not provided
    let climateType = fallbackClimateType;
    if (!climateType) {
        const absLat = Math.abs(latitude);
        if (absLat > 60)
            climateType = 'arctic';
        else if (absLat < 25)
            climateType = 'tropical';
        else if (absLat > 45)
            climateType = 'continental';
        else
            climateType = 'temperate';
    }
    const normals = (0,_fallbackProfiles__WEBPACK_IMPORTED_MODULE_0__.getClimateNormalsFromFallback)(climateType, month);
    // Override with actual coordinates
    return {
        ...normals,
        latitude,
        longitude,
    };
}
/**
 * Clear all caches (for testing)
 */
function clearCaches() {
    climateCache.clear();
    geocodeCache.clear();
}


/***/ },

/***/ "./src/weather/fallbackProfiles.ts"
/*!*****************************************!*\
  !*** ./src/weather/fallbackProfiles.ts ***!
  \*****************************************/
(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   FALLBACK_PROFILES: () => (/* binding */ FALLBACK_PROFILES),
/* harmony export */   getClimateNormalsFromFallback: () => (/* binding */ getClimateNormalsFromFallback),
/* harmony export */   getFallbackProfile: () => (/* binding */ getFallbackProfile),
/* harmony export */   inferBaseClimateType: () => (/* binding */ inferBaseClimateType)
/* harmony export */ });
/**
 * Fallback Climate Profiles
 *
 * Hardcoded climate data for when API/geocoding fails.
 * All temperatures in Fahrenheit.
 */
// ============================================
// Profiles
// ============================================
const FALLBACK_PROFILES = {
    temperate: {
        type: 'temperate',
        monthlyHighs: [40, 43, 52, 62, 72, 80, 85, 83, 76, 64, 52, 43],
        monthlyLows: [25, 27, 34, 43, 53, 62, 67, 65, 57, 46, 36, 28],
        monthlyPrecipDays: [10, 9, 11, 11, 12, 10, 9, 9, 8, 8, 9, 10],
        monthlyHumidity: [70, 68, 62, 58, 62, 65, 68, 70, 72, 70, 72, 72],
        tempStdDev: 8,
        precipPersistence: 0.6,
        conditionWeights: {
            winter: { clear: 0.3, overcast: 0.35, snow: 0.2, rain: 0.15 },
            spring: { clear: 0.35, partly_cloudy: 0.3, rain: 0.25, overcast: 0.1 },
            summer: { sunny: 0.45, partly_cloudy: 0.3, thunderstorm: 0.15, clear: 0.1 },
            fall: { clear: 0.35, overcast: 0.3, rain: 0.2, partly_cloudy: 0.15 },
        },
    },
    desert: {
        type: 'desert',
        monthlyHighs: [67, 72, 80, 89, 99, 109, 111, 109, 103, 91, 77, 67],
        monthlyLows: [45, 49, 55, 63, 72, 81, 87, 85, 78, 65, 53, 45],
        monthlyPrecipDays: [3, 3, 2, 1, 1, 0, 2, 3, 2, 2, 2, 3],
        monthlyHumidity: [35, 30, 25, 18, 15, 12, 25, 30, 28, 25, 30, 38],
        tempStdDev: 6,
        precipPersistence: 0.3,
        conditionWeights: {
            winter: { sunny: 0.6, clear: 0.3, partly_cloudy: 0.1 },
            spring: { sunny: 0.7, clear: 0.2, windy: 0.1 },
            summer: { hot: 0.5, sunny: 0.3, thunderstorm: 0.15, clear: 0.05 },
            fall: { sunny: 0.6, clear: 0.3, partly_cloudy: 0.1 },
        },
    },
    arctic: {
        type: 'arctic',
        monthlyHighs: [5, 8, 18, 32, 45, 55, 60, 57, 47, 32, 18, 8],
        monthlyLows: [-12, -10, 0, 18, 32, 42, 47, 45, 36, 22, 8, -5],
        monthlyPrecipDays: [8, 7, 7, 6, 7, 8, 10, 11, 10, 10, 9, 8],
        monthlyHumidity: [75, 73, 70, 68, 70, 75, 80, 82, 80, 78, 76, 75],
        tempStdDev: 10,
        precipPersistence: 0.7,
        conditionWeights: {
            winter: { snow: 0.4, overcast: 0.3, cold: 0.2, clear: 0.1 },
            spring: { overcast: 0.3, snow: 0.3, partly_cloudy: 0.25, clear: 0.15 },
            summer: { partly_cloudy: 0.35, overcast: 0.3, rain: 0.2, clear: 0.15 },
            fall: { overcast: 0.35, snow: 0.25, cold: 0.2, partly_cloudy: 0.2 },
        },
    },
    tropical: {
        type: 'tropical',
        monthlyHighs: [87, 88, 89, 90, 90, 89, 88, 88, 88, 88, 87, 87],
        monthlyLows: [73, 73, 74, 75, 76, 76, 75, 75, 75, 75, 74, 73],
        monthlyPrecipDays: [8, 6, 7, 10, 15, 18, 20, 19, 17, 15, 12, 9],
        monthlyHumidity: [78, 75, 74, 76, 82, 85, 86, 86, 85, 84, 82, 80],
        tempStdDev: 3,
        precipPersistence: 0.7,
        conditionWeights: {
            winter: { sunny: 0.4, partly_cloudy: 0.35, rain: 0.2, humid: 0.05 },
            spring: { partly_cloudy: 0.35, rain: 0.3, thunderstorm: 0.2, humid: 0.15 },
            summer: { rain: 0.35, thunderstorm: 0.25, humid: 0.25, overcast: 0.15 },
            fall: { partly_cloudy: 0.3, rain: 0.3, humid: 0.2, thunderstorm: 0.2 },
        },
    },
    mediterranean: {
        type: 'mediterranean',
        monthlyHighs: [55, 58, 63, 70, 78, 87, 93, 93, 86, 75, 63, 55],
        monthlyLows: [40, 42, 45, 50, 57, 64, 70, 70, 64, 55, 47, 41],
        monthlyPrecipDays: [9, 8, 7, 5, 2, 1, 0, 1, 2, 5, 7, 9],
        monthlyHumidity: [72, 68, 62, 55, 48, 42, 38, 40, 48, 58, 68, 73],
        tempStdDev: 5,
        precipPersistence: 0.5,
        conditionWeights: {
            winter: { rain: 0.35, overcast: 0.3, partly_cloudy: 0.2, clear: 0.15 },
            spring: { sunny: 0.4, partly_cloudy: 0.35, clear: 0.15, rain: 0.1 },
            summer: { sunny: 0.6, hot: 0.25, clear: 0.1, partly_cloudy: 0.05 },
            fall: { partly_cloudy: 0.35, sunny: 0.3, rain: 0.2, overcast: 0.15 },
        },
    },
    continental: {
        type: 'continental',
        monthlyHighs: [32, 37, 48, 62, 73, 82, 87, 85, 76, 63, 48, 35],
        monthlyLows: [17, 21, 30, 40, 51, 61, 66, 64, 55, 43, 32, 22],
        monthlyPrecipDays: [9, 8, 10, 11, 12, 10, 9, 9, 8, 8, 9, 9],
        monthlyHumidity: [72, 70, 65, 58, 60, 62, 65, 68, 70, 68, 72, 74],
        tempStdDev: 12,
        precipPersistence: 0.55,
        conditionWeights: {
            winter: { snow: 0.35, overcast: 0.3, cold: 0.2, clear: 0.15 },
            spring: { partly_cloudy: 0.3, rain: 0.3, clear: 0.25, thunderstorm: 0.15 },
            summer: { sunny: 0.35, hot: 0.25, thunderstorm: 0.25, partly_cloudy: 0.15 },
            fall: { clear: 0.35, overcast: 0.3, rain: 0.2, partly_cloudy: 0.15 },
        },
    },
    oceanic: {
        type: 'oceanic',
        monthlyHighs: [47, 49, 53, 58, 64, 69, 73, 73, 68, 59, 52, 47],
        monthlyLows: [38, 38, 41, 44, 50, 55, 59, 59, 55, 48, 43, 39],
        monthlyPrecipDays: [15, 12, 13, 11, 10, 9, 8, 9, 10, 13, 14, 15],
        monthlyHumidity: [85, 82, 78, 75, 76, 78, 80, 82, 83, 85, 86, 86],
        tempStdDev: 4,
        precipPersistence: 0.65,
        conditionWeights: {
            winter: { overcast: 0.4, rain: 0.35, drizzle: 0.15, foggy: 0.1 },
            spring: { partly_cloudy: 0.35, rain: 0.3, overcast: 0.2, drizzle: 0.15 },
            summer: { partly_cloudy: 0.4, overcast: 0.25, rain: 0.2, sunny: 0.15 },
            fall: { overcast: 0.35, rain: 0.35, drizzle: 0.15, foggy: 0.15 },
        },
    },
};
// ============================================
// Helpers
// ============================================
/**
 * Get season from month (Northern Hemisphere)
 */
function getSeason(month) {
    if (month >= 3 && month <= 5)
        return 'spring';
    if (month >= 6 && month <= 8)
        return 'summer';
    if (month >= 9 && month <= 11)
        return 'fall';
    return 'winter';
}
/**
 * Get approximate sunrise/sunset for a month
 * Returns hours (e.g., 6.5 = 6:30 AM)
 */
function getApproxSunTimes(month, baseClimate) {
    // Base times vary by latitude approximation
    const latitudeEffect = {
        arctic: 3, // Extreme variation
        continental: 1.5,
        temperate: 1,
        oceanic: 0.8,
        mediterranean: 0.7,
        desert: 0.5,
        tropical: 0.3, // Minimal variation
    };
    const effect = latitudeEffect[baseClimate];
    // June = longest day (month 6), December = shortest (month 12)
    // Sinusoidal variation
    const dayOfYear = (month - 1) * 30 + 15; // Approximate
    const summerSolstice = 172; // ~June 21
    const variation = Math.cos(((dayOfYear - summerSolstice) * 2 * Math.PI) / 365);
    // Base: 6 AM sunrise, 6 PM sunset (equinox)
    const sunrise = 6 - variation * effect;
    const sunset = 18 + variation * effect;
    return { sunrise, sunset };
}
/**
 * Convert a fallback profile to ClimateNormals for a given month
 */
function getClimateNormalsFromFallback(baseClimate, month) {
    const profile = FALLBACK_PROFILES[baseClimate];
    const monthIndex = month - 1;
    const season = getSeason(month);
    const { sunrise, sunset } = getApproxSunTimes(month, baseClimate);
    // Calculate condition probabilities from weights
    const weights = profile.conditionWeights[season];
    const totalWeight = Object.values(weights).reduce((a, b) => a + b, 0);
    // Map to standard condition probabilities
    const conditionProbabilities = {
        clear: ((weights.clear || 0) + (weights.sunny || 0)) / totalWeight || 0.2,
        partlyCloudy: (weights.partly_cloudy || 0) / totalWeight || 0.2,
        overcast: (weights.overcast || 0) / totalWeight || 0.2,
        rain: ((weights.rain || 0) +
            (weights.drizzle || 0) +
            (weights.thunderstorm || 0)) /
            totalWeight || 0.2,
        snow: (weights.snow || 0) / totalWeight || 0,
    };
    // Estimate precipitation (inches/day based on precip days)
    const avgPrecipitation = (profile.monthlyPrecipDays[monthIndex] / 30) * 0.15; // ~0.15" per rainy day
    return {
        latitude: 0, // Unknown for fallback
        longitude: 0,
        month,
        avgHigh: profile.monthlyHighs[monthIndex],
        avgLow: profile.monthlyLows[monthIndex],
        avgPrecipitation,
        avgPrecipDays: profile.monthlyPrecipDays[monthIndex],
        avgHumidity: profile.monthlyHumidity[monthIndex],
        avgWindSpeed: 8, // Default moderate wind
        avgCloudCover: 50, // Default moderate clouds
        avgSunriseHour: sunrise,
        avgSunsetHour: sunset,
        tempStdDev: profile.tempStdDev,
        conditionProbabilities,
    };
}
/**
 * Get a fallback profile by type
 */
function getFallbackProfile(type) {
    return FALLBACK_PROFILES[type];
}
/**
 * Determine most likely base climate type from temperature and conditions
 */
function inferBaseClimateType(avgTemp, humidity, condition) {
    const conditionLower = condition.toLowerCase();
    // Check for obvious conditions
    if (conditionLower.includes('snow') || conditionLower.includes('blizzard')) {
        return avgTemp < 20 ? 'arctic' : 'continental';
    }
    if (conditionLower.includes('hot') || avgTemp > 95) {
        return humidity < 40 ? 'desert' : 'tropical';
    }
    // Temperature-based heuristics
    if (avgTemp < 32)
        return 'arctic';
    if (avgTemp > 85 && humidity > 70)
        return 'tropical';
    if (avgTemp > 85 && humidity < 40)
        return 'desert';
    if (humidity > 75)
        return 'oceanic';
    // Default to temperate
    return 'temperate';
}


/***/ },

/***/ "./src/weather/forecastCache.ts"
/*!**************************************!*\
  !*** ./src/weather/forecastCache.ts ***!
  \**************************************/
(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   cacheForecast: () => (/* binding */ cacheForecast),
/* harmony export */   cleanupCache: () => (/* binding */ cleanupCache),
/* harmony export */   forecastCoversRange: () => (/* binding */ forecastCoversRange),
/* harmony export */   getCacheStats: () => (/* binding */ getCacheStats),
/* harmony export */   getCachedForecast: () => (/* binding */ getCachedForecast),
/* harmony export */   getDaysRemaining: () => (/* binding */ getDaysRemaining),
/* harmony export */   getLocationId: () => (/* binding */ getLocationId),
/* harmony export */   removeCacheEntry: () => (/* binding */ removeCacheEntry),
/* harmony export */   shouldRegenerateForecast: () => (/* binding */ shouldRegenerateForecast),
/* harmony export */   touchCacheEntry: () => (/* binding */ touchCacheEntry)
/* harmony export */ });
/**
 * Forecast Cache
 *
 * Manages per-location forecast storage and retrieval.
 */
// ============================================
// Location ID
// ============================================
/**
 * Generate consistent location ID from area name
 */
function getLocationId(area) {
    return area.toLowerCase().trim().replace(/\s+/g, '-');
}
// ============================================
// Date Utilities
// ============================================
/**
 * Parse a YYYY-MM-DD date string
 */
function parseDate(dateStr) {
    const [year, month, day] = dateStr.split('-').map(Number);
    return new Date(year, month - 1, day);
}
/**
 * Convert NarrativeDateTime to Date
 */
function toDate(dt) {
    return new Date(dt.year, dt.month - 1, dt.day);
}
/**
 * Add days to a date
 */
function addDays(date, days) {
    const result = new Date(date);
    result.setDate(result.getDate() + days);
    return result;
}
// ============================================
// Cache Operations
// ============================================
/**
 * Get a cached forecast for an area
 * Returns null if not found or expired
 */
function getCachedForecast(cache, area, currentDate) {
    const locationId = getLocationId(area);
    const entry = cache.find(e => getLocationId(e.areaName) === locationId);
    if (!entry) {
        return null;
    }
    // Check if forecast covers current date
    const forecastStart = parseDate(entry.forecast.startDate);
    const forecastEnd = addDays(forecastStart, entry.forecast.days.length);
    const current = toDate(currentDate);
    if (current < forecastStart || current >= forecastEnd) {
        return null; // Forecast doesn't cover this date
    }
    return entry.forecast;
}
/**
 * Add or update a forecast in the cache
 */
function cacheForecast(cache, area, forecast) {
    const locationId = getLocationId(area);
    // Remove existing entry for this location
    const filtered = cache.filter(e => getLocationId(e.areaName) !== locationId);
    // Add new entry
    return [
        ...filtered,
        {
            areaName: area,
            forecast,
            lastAccessedDate: new Date().toISOString(),
        },
    ];
}
/**
 * Update the last accessed date for a cache entry
 */
function touchCacheEntry(cache, area) {
    const locationId = getLocationId(area);
    return cache.map(entry => {
        if (getLocationId(entry.areaName) === locationId) {
            return {
                ...entry,
                lastAccessedDate: new Date().toISOString(),
            };
        }
        return entry;
    });
}
/**
 * Remove a specific location from the cache
 */
function removeCacheEntry(cache, area) {
    const locationId = getLocationId(area);
    return cache.filter(e => getLocationId(e.areaName) !== locationId);
}
/**
 * Clean up old cache entries
 */
function cleanupCache(cache, maxAgeMs = 30 * 24 * 60 * 60 * 1000) {
    const cutoff = Date.now() - maxAgeMs;
    return cache.filter(entry => {
        const lastAccessed = new Date(entry.lastAccessedDate).getTime();
        return lastAccessed > cutoff;
    });
}
/**
 * Get cache statistics
 */
function getCacheStats(cache) {
    if (cache.length === 0) {
        return {
            entryCount: 0,
            totalDays: 0,
            oldestAccess: null,
            newestAccess: null,
        };
    }
    const accessDates = cache
        .map(e => new Date(e.lastAccessedDate).getTime())
        .sort((a, b) => a - b);
    return {
        entryCount: cache.length,
        totalDays: cache.reduce((sum, e) => sum + e.forecast.days.length, 0),
        oldestAccess: new Date(accessDates[0]).toISOString(),
        newestAccess: new Date(accessDates[accessDates.length - 1]).toISOString(),
    };
}
// ============================================
// Forecast Querying
// ============================================
/**
 * Check if a forecast covers a date range
 */
function forecastCoversRange(forecast, startDate, endDate) {
    const forecastStart = parseDate(forecast.startDate);
    const forecastEnd = addDays(forecastStart, forecast.days.length);
    const rangeStart = toDate(startDate);
    const rangeEnd = toDate(endDate);
    return rangeStart >= forecastStart && rangeEnd < forecastEnd;
}
/**
 * Get the number of days remaining in a forecast from a given date
 */
function getDaysRemaining(forecast, currentDate) {
    const forecastStart = parseDate(forecast.startDate);
    const forecastEnd = addDays(forecastStart, forecast.days.length);
    const current = toDate(currentDate);
    if (current >= forecastEnd) {
        return 0;
    }
    const diffMs = forecastEnd.getTime() - current.getTime();
    return Math.ceil(diffMs / (1000 * 60 * 60 * 24));
}
/**
 * Determine if a forecast should be regenerated
 * (less than 3 days remaining or doesn't cover current date)
 */
function shouldRegenerateForecast(forecast, currentDate, minDaysRemaining = 3) {
    if (!forecast) {
        return true;
    }
    const daysRemaining = getDaysRemaining(forecast, currentDate);
    return daysRemaining < minDaysRemaining;
}


/***/ },

/***/ "./src/weather/forecastGenerator.ts"
/*!******************************************!*\
  !*** ./src/weather/forecastGenerator.ts ***!
  \******************************************/
(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   generateForecast: () => (/* binding */ generateForecast),
/* harmony export */   getDayIndex: () => (/* binding */ getDayIndex),
/* harmony export */   lookupDay: () => (/* binding */ lookupDay),
/* harmony export */   lookupWeather: () => (/* binding */ lookupWeather)
/* harmony export */ });
/* harmony import */ var seedrandom__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! seedrandom */ "./node_modules/seedrandom/index.js");
/* harmony import */ var seedrandom__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(seedrandom__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var _weatherDeriver__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./weatherDeriver */ "./src/weather/weatherDeriver.ts");
/**
 * Forecast Generator
 *
 * Generates a 4-week weather forecast with realistic day-to-day variation
 * using autocorrelated temperature generation and Markov chain precipitation.
 */


// ============================================
// Random Utilities
// ============================================
/**
 * Box-Muller transform for Gaussian random numbers
 */
function gaussianRandom(rng) {
    let u = 0, v = 0;
    while (u === 0)
        u = rng(); // Avoid 0
    while (v === 0)
        v = rng();
    return Math.sqrt(-2.0 * Math.log(u)) * Math.cos(2.0 * Math.PI * v);
}
/**
 * Clamp a value between min and max
 */
function clamp(value, min, max) {
    return Math.max(min, Math.min(max, value));
}
// ============================================
// Date Utilities
// ============================================
/**
 * Format date as YYYY-MM-DD
 */
function formatDate(year, month, day) {
    return `${year}-${String(month).padStart(2, '0')}-${String(day).padStart(2, '0')}`;
}
/**
 * Add days to a date
 */
function addDays(year, month, day, daysToAdd) {
    const date = new Date(year, month - 1, day + daysToAdd);
    return {
        year: date.getFullYear(),
        month: date.getMonth() + 1,
        day: date.getDate(),
    };
}
// ============================================
// Temperature Generation
// ============================================
/**
 * Generate daily high/low temperatures using AR(1) process
 * This creates realistic day-to-day correlation
 */
function generateDailyTemps(normals, state, dayIndex, initialAnchor) {
    const phi = 0.75; // Autocorrelation coefficient
    const mean = (normals.avgHigh + normals.avgLow) / 2;
    const range = normals.avgHigh - normals.avgLow;
    let todayMean;
    // For day 0 with initial anchor, use the anchor
    if (dayIndex === 0 && initialAnchor) {
        todayMean = initialAnchor.temperature;
    }
    // For days 1-2 with anchor, blend toward normals
    else if (dayIndex <= 2 && initialAnchor) {
        const blendFactor = dayIndex / 3;
        const noise = gaussianRandom(state.rng) *
            normals.tempStdDev *
            Math.sqrt(1 - phi * phi) *
            blendFactor;
        todayMean =
            state.prevDayMeanTemp * (1 - blendFactor) +
                (mean + phi * (state.prevDayMeanTemp - mean) + noise) * blendFactor;
    }
    // Normal AR(1) process
    else {
        const noise = gaussianRandom(state.rng) * normals.tempStdDev * Math.sqrt(1 - phi * phi);
        todayMean = mean + phi * (state.prevDayMeanTemp - mean) + noise;
    }
    // Calculate high and low from mean
    const high = todayMean + range / 2;
    const low = todayMean - range / 2;
    return {
        high: Math.round(high),
        low: Math.round(low),
        meanTemp: todayMean,
    };
}
/**
 * Generate hourly temperatures using sinusoidal interpolation
 */
function generateHourlyTemp(hour, high, low, sunrise, sunset) {
    // Temperature minimum occurs near sunrise
    // Temperature maximum occurs ~2-3 hours after solar noon
    const solarNoon = (sunrise + sunset) / 2;
    const peakHour = solarNoon + 2;
    // Use sinusoidal model
    // Minimum at sunrise, maximum at peak hour
    const range = high - low;
    if (hour < sunrise) {
        // Pre-dawn: gradually cooling toward minimum
        const nightLength = 24 - sunset + sunrise;
        const hoursFromSunset = hour + (24 - sunset);
        const progress = hoursFromSunset / nightLength;
        return low + range * 0.3 * (1 - progress);
    }
    else if (hour < peakHour) {
        // Morning: warming toward peak
        const morningLength = peakHour - sunrise;
        const progress = (hour - sunrise) / morningLength;
        // Sinusoidal ease-in
        const factor = Math.sin((progress * Math.PI) / 2);
        return low + range * factor;
    }
    else if (hour < sunset) {
        // Afternoon: cooling from peak
        const afternoonLength = sunset - peakHour;
        const progress = (hour - peakHour) / afternoonLength;
        // Sinusoidal ease-out
        const factor = Math.cos((progress * Math.PI) / 2);
        return low + range * factor;
    }
    else {
        // Evening: continued cooling
        const eveningLength = 24 - sunset + sunrise;
        const progress = (hour - sunset) / eveningLength;
        return low + range * 0.3 * (1 - progress);
    }
}
// ============================================
// Precipitation Generation
// ============================================
/**
 * Determine if it's raining today using Markov chain
 */
function willRainToday(normals, state) {
    const baseProbability = normals.avgPrecipDays / 30;
    // Persistence: if it rained yesterday, more likely today
    const persistence = 0.6;
    const probability = state.wasRaining
        ? baseProbability + (1 - baseProbability) * persistence
        : baseProbability * (1 - persistence * 0.5);
    return state.rng() < probability;
}
/**
 * Generate hourly precipitation amounts
 */
function generateHourlyPrecip(isRaining, normals, rng) {
    const hourly = new Array(24).fill(0);
    if (!isRaining)
        return hourly;
    // Determine rain pattern
    // 60% chance of sustained rain, 40% chance of scattered showers
    const sustained = rng() < 0.6;
    if (sustained) {
        // Pick a start hour and duration
        const startHour = Math.floor(rng() * 18); // Start between 0-17
        const duration = Math.floor(rng() * 8) + 4; // 4-12 hours
        for (let h = startHour; h < Math.min(startHour + duration, 24); h++) {
            // Base intensity with some variation
            const intensity = (0.05 + rng() * 0.15) * (normals.avgPrecipitation * 30);
            hourly[h] = Math.max(0.01, intensity);
        }
    }
    else {
        // Scattered showers - 2-4 short bursts
        const numBursts = Math.floor(rng() * 3) + 2;
        for (let i = 0; i < numBursts; i++) {
            const burstHour = Math.floor(rng() * 24);
            const burstDuration = Math.floor(rng() * 2) + 1;
            for (let h = burstHour; h < Math.min(burstHour + burstDuration, 24); h++) {
                const intensity = (0.02 + rng() * 0.1) * (normals.avgPrecipitation * 30);
                hourly[h] = Math.max(0.01, intensity);
            }
        }
    }
    return hourly;
}
// ============================================
// Cloud Cover Generation
// ============================================
/**
 * Generate hourly cloud cover
 */
function generateHourlyClouds(isRaining, precipHourly, normals, rng) {
    // Base cloud cover from normals
    const baseClouds = normals.avgCloudCover;
    return precipHourly.map((precip, hour) => {
        // If raining, clouds are high
        if (precip > 0.01) {
            return clamp(80 + rng() * 20, 70, 100);
        }
        // Otherwise, use base with variation
        const variation = (rng() - 0.5) * 30;
        let clouds = baseClouds + variation;
        // Morning tends to be clearer
        if (hour >= 6 && hour <= 10) {
            clouds -= 10;
        }
        // Afternoon buildup (especially in summer)
        if (hour >= 14 && hour <= 17) {
            clouds += 10;
        }
        return clamp(clouds, 0, 100);
    });
}
// ============================================
// Wind Generation
// ============================================
/**
 * Generate hourly wind speed and direction
 */
function generateHourlyWind(normals, rng) {
    const baseSpeed = normals.avgWindSpeed;
    const speed = [];
    const direction = [];
    // Pick a prevailing direction for the day
    const prevailingDir = rng() * 360;
    for (let h = 0; h < 24; h++) {
        // Wind is typically lighter at night, stronger in afternoon
        let timeMultiplier = 1;
        if (h >= 0 && h < 6)
            timeMultiplier = 0.6;
        else if (h >= 12 && h < 18)
            timeMultiplier = 1.3;
        // Random variation
        const variation = 0.7 + rng() * 0.6; // 0.7 to 1.3
        speed.push(Math.max(0, Math.round(baseSpeed * timeMultiplier * variation)));
        // Direction varies around prevailing
        const dirVariation = (rng() - 0.5) * 60; // Â±30 degrees
        direction.push((prevailingDir + dirVariation + 360) % 360);
    }
    return { speed, direction };
}
// ============================================
// Humidity Generation
// ============================================
/**
 * Generate hourly humidity
 */
function generateHourlyHumidity(hourlyTemp, precipHourly, high, low, normals, rng) {
    const baseHumidity = normals.avgHumidity;
    return hourlyTemp.map((temp, hour) => {
        let humidity = baseHumidity;
        // Humidity inversely related to temperature (warmer = drier)
        const tempRange = high - low;
        const tempPosition = tempRange > 0 ? (temp - low) / tempRange : 0.5;
        humidity -= tempPosition * 15; // Up to 15% drop at peak temp
        // Rain increases humidity
        if (precipHourly[hour] > 0.01) {
            humidity += 20;
        }
        // Early morning tends to be more humid
        if (hour >= 4 && hour <= 7) {
            humidity += 10;
        }
        // Random variation
        humidity += (rng() - 0.5) * 10;
        return clamp(Math.round(humidity), 20, 100);
    });
}
// ============================================
// UV Index Generation
// ============================================
/**
 * Generate hourly UV index
 */
function generateHourlyUV(hourlyTemp, hourlyClouds, sunrise, sunset, normals) {
    return hourlyTemp.map((_, hour) => {
        // No UV at night
        if (hour < sunrise || hour > sunset)
            return 0;
        // Peak UV at solar noon
        const solarNoon = (sunrise + sunset) / 2;
        const hoursFromNoon = Math.abs(hour - solarNoon);
        const dayLength = sunset - sunrise;
        // Base UV curve (peaks at 10-11 at solar noon in summer)
        const maxUV = 8 + (normals.avgHigh - 60) / 10; // Higher temp = higher max UV
        const timeFactor = Math.cos((hoursFromNoon / (dayLength / 2)) * Math.PI * 0.5);
        let uv = maxUV * Math.max(0, timeFactor);
        // Clouds reduce UV
        const cloudReduction = hourlyClouds[hour] / 100;
        uv *= 1 - cloudReduction * 0.7;
        return clamp(Math.round(uv), 0, 11);
    });
}
// ============================================
// Main Generator
// ============================================
/**
 * Generate a complete day forecast
 */
function generateDay(dateStr, normals, state, dayIndex, initialConditions) {
    // Generate daily temps
    const { high, low, meanTemp } = generateDailyTemps(normals, state, dayIndex, initialConditions);
    state.prevDayMeanTemp = meanTemp;
    // Determine precipitation
    const isRaining = willRainToday(normals, state);
    state.wasRaining = isRaining;
    // Generate hourly data
    const precipHourly = generateHourlyPrecip(isRaining, normals, state.rng);
    const cloudHourly = generateHourlyClouds(isRaining, precipHourly, normals, state.rng);
    const { speed: windSpeed, direction: windDir } = generateHourlyWind(normals, state.rng);
    const hourly = [];
    const conditions = [];
    for (let h = 0; h < 24; h++) {
        const temp = generateHourlyTemp(h, high, low, normals.avgSunriseHour, normals.avgSunsetHour);
        const humidity = generateHourlyHumidity([temp], [precipHourly[h]], high, low, normals, state.rng)[0];
        const hourData = {
            hour: h,
            temperature: Math.round(temp),
            feelsLike: (0,_weatherDeriver__WEBPACK_IMPORTED_MODULE_1__.calculateFeelsLike)(temp, humidity, windSpeed[h]),
            humidity,
            precipitation: Math.round(precipHourly[h] * 100) / 100,
            precipProbability: precipHourly[h] > 0.01
                ? 80 + state.rng() * 20
                : 10 + state.rng() * 20,
            cloudCover: Math.round(cloudHourly[h]),
            windSpeed: windSpeed[h],
            windDirection: Math.round(windDir[h]),
            uvIndex: 0, // Will be set below
        };
        // Derive condition
        const condition = (0,_weatherDeriver__WEBPACK_IMPORTED_MODULE_1__.deriveCondition)(hourData);
        conditions.push(condition);
        hourly.push(hourData);
    }
    // Generate UV after we have all hourly data
    const uvIndex = generateHourlyUV(hourly.map(h => h.temperature), hourly.map(h => h.cloudCover), normals.avgSunriseHour, normals.avgSunsetHour, normals);
    // Apply UV to hourly data
    hourly.forEach((h, i) => {
        h.uvIndex = uvIndex[i];
    });
    // Determine dominant condition for the day
    const dominantCondition = (0,_weatherDeriver__WEBPACK_IMPORTED_MODULE_1__.getDominantCondition)(conditions, normals.avgSunriseHour, normals.avgSunsetHour);
    return {
        date: dateStr,
        high,
        low,
        sunrise: Math.round(normals.avgSunriseHour * 10) / 10,
        sunset: Math.round(normals.avgSunsetHour * 10) / 10,
        hourly,
        dominantCondition,
    };
}
/**
 * Generate a complete forecast
 */
function generateForecast(params) {
    const { climateNormals, startDate, initialConditions, seed, days = 28 } = params;
    // Create seeded RNG
    const rng = seedrandom__WEBPACK_IMPORTED_MODULE_0___default()(seed);
    // Initialize state
    const initialMean = initialConditions
        ? initialConditions.temperature
        : (climateNormals.avgHigh + climateNormals.avgLow) / 2;
    const state = {
        prevDayMeanTemp: initialMean,
        wasRaining: false,
        rng,
    };
    // Generate each day
    const forecastDays = [];
    for (let i = 0; i < days; i++) {
        const { year, month, day } = addDays(startDate.year, startDate.month, startDate.day, i);
        const dateStr = formatDate(year, month, day);
        // Only use initial conditions for first 3 days (anchor period)
        const anchor = i < 3 ? initialConditions : null;
        forecastDays.push(generateDay(dateStr, climateNormals, state, i, anchor));
    }
    return {
        locationId: seed.split('-')[0] || 'unknown',
        startDate: formatDate(startDate.year, startDate.month, startDate.day),
        generatedFrom: initialConditions || undefined,
        days: forecastDays,
    };
}
/**
 * Look up weather for a specific date/time in a forecast
 */
function lookupWeather(forecast, date) {
    const dateStr = formatDate(date.year, date.month, date.day);
    const day = forecast.days.find(d => d.date === dateStr);
    if (!day)
        return null;
    const hour = clamp(date.hour, 0, 23);
    return day.hourly[hour];
}
/**
 * Get the day forecast for a specific date
 */
function lookupDay(forecast, date) {
    const dateStr = formatDate(date.year, date.month, date.day);
    return forecast.days.find(d => d.date === dateStr) || null;
}
/**
 * Calculate the day index for a date within a forecast
 */
function getDayIndex(forecastStartDate, currentDate) {
    const [startYear, startMonth, startDay] = forecastStartDate.split('-').map(Number);
    const start = new Date(startYear, startMonth - 1, startDay);
    const current = new Date(currentDate.year, currentDate.month - 1, currentDate.day);
    const diffTime = current.getTime() - start.getTime();
    const diffDays = Math.floor(diffTime / (1000 * 60 * 60 * 24));
    return diffDays;
}


/***/ },

/***/ "./src/weather/index.ts"
/*!******************************!*\
  !*** ./src/weather/index.ts ***!
  \******************************/
(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   cacheForecast: () => (/* reexport safe */ _forecastCache__WEBPACK_IMPORTED_MODULE_4__.cacheForecast),
/* harmony export */   extractProceduralClimate: () => (/* binding */ extractProceduralClimate),
/* harmony export */   getCachedForecast: () => (/* reexport safe */ _forecastCache__WEBPACK_IMPORTED_MODULE_4__.getCachedForecast),
/* harmony export */   getDayIndex: () => (/* reexport safe */ _forecastGenerator__WEBPACK_IMPORTED_MODULE_3__.getDayIndex),
/* harmony export */   isLegacyClimate: () => (/* binding */ isLegacyClimate),
/* harmony export */   mapLegacyWeather: () => (/* reexport safe */ _weatherDeriver__WEBPACK_IMPORTED_MODULE_5__.mapLegacyWeather),
/* harmony export */   toLegacyWeather: () => (/* reexport safe */ _weatherDeriver__WEBPACK_IMPORTED_MODULE_5__.toLegacyWeather),
/* harmony export */   tolegacyClimateFormat: () => (/* binding */ tolegacyClimateFormat)
/* harmony export */ });
/* harmony import */ var _locationMapper__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./locationMapper */ "./src/weather/locationMapper.ts");
/* harmony import */ var _climateApi__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./climateApi */ "./src/weather/climateApi.ts");
/* harmony import */ var _fallbackProfiles__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./fallbackProfiles */ "./src/weather/fallbackProfiles.ts");
/* harmony import */ var _forecastGenerator__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./forecastGenerator */ "./src/weather/forecastGenerator.ts");
/* harmony import */ var _forecastCache__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./forecastCache */ "./src/weather/forecastCache.ts");
/* harmony import */ var _weatherDeriver__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./weatherDeriver */ "./src/weather/weatherDeriver.ts");
/* harmony import */ var _indoorTemperature__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./indoorTemperature */ "./src/weather/indoorTemperature.ts");
/* harmony import */ var _weatherTransitions__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./weatherTransitions */ "./src/weather/weatherTransitions.ts");
/**
 * Weather System
 *
 * Main entry point for the procedural weather system.
 * Coordinates location mapping, forecast generation, and climate derivation.
 */








// Re-export utilities


// ============================================
// Legacy Climate Detection
// ============================================
/**
 * Check if a climate object is the legacy format
 */
function isLegacyClimate(climate) {
    return (climate !== null &&
        typeof climate === 'object' &&
        'weather' in climate &&
        'temperature' in climate &&
        !('conditionType' in climate));
}
/**
 * Main climate extraction function
 *
 * Flow:
 * 1. Check if we have a cached forecast for this location
 * 2. If not, map the location and generate a new forecast
 * 3. Look up weather for current date/time
 * 4. Calculate indoor/outdoor temperature
 * 5. Derive conditions and check for transitions
 */
async function extractProceduralClimate(params) {
    const { isInitial, currentTime, currentLocation, previousClimate, narrativeContext, abortSignal, } = params;
    let { forecastCache, locationMappings } = params;
    const area = currentLocation.area || 'Unknown';
    // Check for existing forecast
    let forecast = (0,_forecastCache__WEBPACK_IMPORTED_MODULE_4__.getCachedForecast)(forecastCache, area, currentTime);
    const needsNewForecast = (0,_forecastCache__WEBPACK_IMPORTED_MODULE_4__.shouldRegenerateForecast)(forecast, currentTime);
    // Handle initial extraction or missing forecast
    if (needsNewForecast || !forecast) {
        // Get initial conditions from previous climate (for anchoring)
        let initialConditions = null;
        if (isInitial && previousClimate) {
            if (isLegacyClimate(previousClimate)) {
                initialConditions = {
                    temperature: previousClimate.temperature,
                    condition: previousClimate.weather,
                };
            }
            else {
                initialConditions = {
                    temperature: previousClimate.temperature,
                    condition: previousClimate.conditionType,
                };
            }
        }
        // Map location to climate data source
        const mapping = await (0,_locationMapper__WEBPACK_IMPORTED_MODULE_0__.mapLocation)(area, narrativeContext || '', locationMappings, abortSignal);
        // Update location mappings cache
        locationMappings = (0,_locationMapper__WEBPACK_IMPORTED_MODULE_0__.addToCache)(locationMappings, mapping);
        // Fetch or generate climate normals
        let climateNormals;
        if (mapping.latitude !== undefined && mapping.longitude !== undefined) {
            climateNormals = await (0,_climateApi__WEBPACK_IMPORTED_MODULE_1__.fetchClimateNormals)(mapping.latitude, mapping.longitude, currentTime.month, mapping.baseClimateType);
        }
        else if (mapping.baseClimateType) {
            climateNormals = (0,_fallbackProfiles__WEBPACK_IMPORTED_MODULE_2__.getClimateNormalsFromFallback)(mapping.baseClimateType, currentTime.month);
        }
        else {
            // Ultimate fallback
            climateNormals = (0,_fallbackProfiles__WEBPACK_IMPORTED_MODULE_2__.getClimateNormalsFromFallback)('temperate', currentTime.month);
        }
        // Generate forecast
        const seed = `${area}-${currentTime.year}-${currentTime.month}-${currentTime.day}`;
        forecast = (0,_forecastGenerator__WEBPACK_IMPORTED_MODULE_3__.generateForecast)({
            climateNormals,
            startDate: currentTime,
            initialConditions,
            seed,
            days: 28,
        });
        // Update location info on forecast
        if (mapping.realWorldAnalog && mapping.latitude && mapping.longitude) {
            forecast.realWorldAnalog = {
                name: mapping.realWorldAnalog,
                latitude: mapping.latitude,
                longitude: mapping.longitude,
            };
        }
        if (mapping.baseClimateType) {
            forecast.baseClimateType = mapping.baseClimateType;
        }
        // Cache the forecast
        forecastCache = (0,_forecastCache__WEBPACK_IMPORTED_MODULE_4__.cacheForecast)(forecastCache, area, forecast);
    }
    // Look up current weather
    const hourlyWeather = (0,_forecastGenerator__WEBPACK_IMPORTED_MODULE_3__.lookupWeather)(forecast, currentTime);
    const dayForecast = (0,_forecastGenerator__WEBPACK_IMPORTED_MODULE_3__.lookupDay)(forecast, currentTime);
    if (!hourlyWeather || !dayForecast) {
        // This shouldn't happen if forecast generation is correct
        console.error('[BlazeTracker] Failed to look up weather for date');
        // Return a default climate
        return createDefaultResult(currentTime, currentLocation, forecastCache, locationMappings);
    }
    // Calculate indoor/outdoor temperature
    const tempResult = (0,_indoorTemperature__WEBPACK_IMPORTED_MODULE_6__.calculateEffectiveTemperature)(hourlyWeather.temperature, currentLocation, currentTime.hour);
    // Derive condition
    const conditionType = (0,_weatherDeriver__WEBPACK_IMPORTED_MODULE_5__.deriveCondition)(hourlyWeather);
    const conditions = (0,_weatherDeriver__WEBPACK_IMPORTED_MODULE_5__.describeCondition)(conditionType);
    // Build climate object
    const climate = {
        temperature: Math.round(tempResult.effectiveTemperature),
        outdoorTemperature: hourlyWeather.temperature,
        indoorTemperature: tempResult.indoorTemperature,
        feelsLike: (0,_weatherDeriver__WEBPACK_IMPORTED_MODULE_5__.calculateFeelsLike)(hourlyWeather.temperature, hourlyWeather.humidity, hourlyWeather.windSpeed),
        humidity: hourlyWeather.humidity,
        precipitation: hourlyWeather.precipitation,
        cloudCover: hourlyWeather.cloudCover,
        windSpeed: hourlyWeather.windSpeed,
        windDirection: (0,_weatherDeriver__WEBPACK_IMPORTED_MODULE_5__.getWindDirection)(hourlyWeather.windDirection),
        conditions,
        conditionType,
        uvIndex: hourlyWeather.uvIndex,
        daylight: (0,_weatherDeriver__WEBPACK_IMPORTED_MODULE_5__.getDaylightPhase)(currentTime.hour, dayForecast.sunrise, dayForecast.sunset),
        isIndoors: tempResult.isIndoors,
        buildingType: tempResult.buildingType,
    };
    // Check for weather transition
    let transition = null;
    if (previousClimate && !isInitial) {
        const prevProcedural = isLegacyClimate(previousClimate)
            ? convertLegacyClimate(previousClimate)
            : previousClimate;
        if ((0,_weatherTransitions__WEBPACK_IMPORTED_MODULE_7__.shouldMentionTransition)(prevProcedural, climate)) {
            transition = (0,_weatherTransitions__WEBPACK_IMPORTED_MODULE_7__.generateTransitionInjection)(prevProcedural, climate);
        }
    }
    return {
        climate,
        forecast,
        transition,
        forecastCache,
        locationMappings,
    };
}
/**
 * Convert legacy climate to procedural format (for comparison)
 */
function convertLegacyClimate(legacy) {
    const conditionType = (0,_weatherDeriver__WEBPACK_IMPORTED_MODULE_5__.mapLegacyWeather)(legacy.weather);
    return {
        temperature: legacy.temperature,
        outdoorTemperature: legacy.temperature,
        feelsLike: legacy.temperature,
        humidity: 50,
        precipitation: 0,
        cloudCover: 50,
        windSpeed: 5,
        windDirection: 'N',
        conditions: legacy.weather,
        conditionType,
        uvIndex: 5,
        daylight: 'day',
        isIndoors: false,
    };
}
/**
 * Create a default result when forecast lookup fails
 */
function createDefaultResult(currentTime, currentLocation, forecastCache, locationMappings) {
    const climate = {
        temperature: 70,
        outdoorTemperature: 70,
        feelsLike: 70,
        humidity: 50,
        precipitation: 0,
        cloudCover: 30,
        windSpeed: 5,
        windDirection: 'N',
        conditions: 'pleasant weather',
        conditionType: 'clear',
        uvIndex: 5,
        daylight: currentTime.hour >= 6 && currentTime.hour < 18 ? 'day' : 'night',
        isIndoors: false,
    };
    // Create a minimal forecast
    const forecast = {
        locationId: currentLocation.area || 'unknown',
        startDate: `${currentTime.year}-${String(currentTime.month).padStart(2, '0')}-${String(currentTime.day).padStart(2, '0')}`,
        days: [],
    };
    return {
        climate,
        forecast,
        transition: null,
        forecastCache,
        locationMappings,
    };
}
// ============================================
// Utility Functions
// ============================================
/**
 * Convert ProceduralClimate to legacy Climate format
 * Used for backward compatibility with existing code
 */
function tolegacyClimateFormat(climate) {
    return {
        weather: (0,_weatherDeriver__WEBPACK_IMPORTED_MODULE_5__.toLegacyWeather)(climate.conditionType),
        temperature: climate.temperature,
    };
}
/**
 * Get forecast day index for debugging
 */



/***/ },

/***/ "./src/weather/indoorTemperature.ts"
/*!******************************************!*\
  !*** ./src/weather/indoorTemperature.ts ***!
  \******************************************/
(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   calculateEffectiveTemperature: () => (/* binding */ calculateEffectiveTemperature),
/* harmony export */   calculateIndoorTemp: () => (/* binding */ calculateIndoorTemp),
/* harmony export */   inferBuildingType: () => (/* binding */ inferBuildingType),
/* harmony export */   isIndoors: () => (/* binding */ isIndoors)
/* harmony export */ });
/**
 * Indoor Temperature Calculator
 *
 * Calculates indoor temperatures based on building type and outdoor conditions.
 * All temperatures in Fahrenheit.
 */
/**
 * Calculate indoor temperature based on building type
 */
function calculateIndoorTemp(params) {
    const { outdoorTemp, buildingType, hour } = params;
    switch (buildingType) {
        case 'modern':
            // HVAC maintains 65-75Â°F
            // Slight variation based on outdoor (AC struggles in extreme heat)
            if (outdoorTemp > 95)
                return 75 + (outdoorTemp - 95) * 0.1;
            if (outdoorTemp < 14)
                return 65 - (14 - outdoorTemp) * 0.05;
            return 70;
        case 'heated': {
            // Fireplace/hearth - aims for ~65Â°F but influenced by outdoor
            // Warmer during "active" hours, cooler at night (fire dies down)
            const heatedTarget = hour >= 6 && hour <= 22 ? 65 : 57;
            const heatedDamping = 0.3; // 30% outdoor influence
            return heatedTarget + (outdoorTemp - heatedTarget) * heatedDamping;
        }
        case 'unheated': {
            // Barn, warehouse - minimal shelter
            // Slightly warmer than outdoor in cold, slightly cooler in heat
            const unheatedDamping = 0.7;
            const shelterEffect = outdoorTemp < 50 ? 5 : outdoorTemp > 77 ? -4 : 0;
            return (outdoorTemp * unheatedDamping +
                70 * (1 - unheatedDamping) +
                shelterEffect);
        }
        case 'underground':
            // Cave, basement - stable year-round
            // Typically average annual temperature of region (~55Â°F)
            return 55;
        case 'tent': {
            // Almost no shelter, slight greenhouse effect
            const tentEffect = hour >= 10 && hour <= 16 ? 9 : 2;
            return outdoorTemp + tentEffect;
        }
        case 'vehicle': {
            // Car/carriage - moderate shelter
            // Greenhouse effect when sunny during day
            const vehicleEffect = hour >= 10 && hour <= 16 ? 15 : 4;
            return outdoorTemp + vehicleEffect;
        }
        default:
            return outdoorTemp;
    }
}
// ============================================
// Building Type Detection
// ============================================
/**
 * Pattern definitions for building type detection
 */
const BUILDING_PATTERNS = [
    [
        'underground',
        /\b(cave|basement|cellar|mine|tunnel|bunker|crypt|catacomb|sewer|subway|metro|underground)\b/i,
    ],
    ['tent', /\b(tent|campsite|bivouac|yurt|pavilion|camping|campground)\b/i],
    [
        'vehicle',
        /\b(car|truck|van|bus|carriage|wagon|train|plane|aircraft|ship|boat|yacht|submarine|spaceship|shuttle)\b/i,
    ],
    [
        'unheated',
        /\b(barn|warehouse|shed|garage|stable|hangar|greenhouse|storage|attic|loft)\b/i,
    ],
    [
        'modern',
        /\b(office|apartment|hotel|hospital|mall|store|shop|restaurant|cafe|cafeteria|gym|school|university|library|museum|theater|cinema|supermarket|bank|clinic)\b/i,
    ],
    [
        'heated',
        /\b(house|home|cabin|cottage|inn|tavern|castle|manor|palace|mansion|villa|lodge|hut|shack|chapel|church|temple|shrine)\b/i,
    ],
];
/**
 * Infer building type from location description
 */
function inferBuildingType(location) {
    const place = location.place?.toLowerCase() || '';
    const area = location.area?.toLowerCase() || '';
    const position = location.position?.toLowerCase() || '';
    // Combine all location text for matching
    const fullText = `${area} ${place} ${position}`;
    for (const [type, pattern] of BUILDING_PATTERNS) {
        if (pattern.test(fullText)) {
            return type;
        }
    }
    return null; // Unknown - assume outdoor
}
// ============================================
// Indoor/Outdoor Detection
// ============================================
/**
 * Explicit outdoor indicators
 */
const OUTDOOR_PATTERNS = /\b(outside|outdoor|street|road|path|trail|garden|park|beach|field|forest|mountain|river|lake|ocean|sea|sky|rooftop|balcony|patio|deck|yard|lawn|meadow|desert|plains|valley|cliff|shore|woods|jungle|savanna|tundra|swamp|marsh|courtyard|plaza|square|alley|sidewalk|highway|bridge)\b/i;
/**
 * Explicit indoor indicators
 */
const INDOOR_PATTERNS = /\b(inside|indoor|room|hall|chamber|office|bedroom|kitchen|bathroom|lobby|corridor|basement|attic|closet|pantry|study|den|foyer|vestibule|anteroom|parlor|salon|lounge|ward|cell|vault|treasury|armory|throne room|great hall|dining room|living room|sitting room)\b/i;
/**
 * Determine if the current location is indoors
 */
function isIndoors(location) {
    const place = location.place?.toLowerCase() || '';
    const position = location.position?.toLowerCase() || '';
    const area = location.area?.toLowerCase() || '';
    // Check position first (most specific)
    if (OUTDOOR_PATTERNS.test(position)) {
        return false;
    }
    if (INDOOR_PATTERNS.test(position)) {
        return true;
    }
    // Check place
    if (OUTDOOR_PATTERNS.test(place)) {
        return false;
    }
    if (INDOOR_PATTERNS.test(place)) {
        return true;
    }
    // Check area
    if (OUTDOOR_PATTERNS.test(area)) {
        return false;
    }
    // If we can infer a building type, assume indoor
    const buildingType = inferBuildingType(location);
    if (buildingType && buildingType !== 'tent') {
        return true;
    }
    // Default to outdoor if uncertain
    return false;
}
/**
 * Determine indoor/outdoor status and calculate effective temperature
 */
function calculateEffectiveTemperature(outdoorTemp, location, hour) {
    const indoors = isIndoors(location);
    if (!indoors) {
        return {
            isIndoors: false,
            effectiveTemperature: outdoorTemp,
        };
    }
    const buildingType = inferBuildingType(location);
    if (!buildingType) {
        // Indoor but unknown building type - assume heated
        const indoorTemp = calculateIndoorTemp({
            outdoorTemp,
            buildingType: 'heated',
            hour,
        });
        return {
            isIndoors: true,
            buildingType: 'heated',
            indoorTemperature: indoorTemp,
            effectiveTemperature: indoorTemp,
        };
    }
    const indoorTemp = calculateIndoorTemp({
        outdoorTemp,
        buildingType,
        hour,
    });
    return {
        isIndoors: true,
        buildingType,
        indoorTemperature: indoorTemp,
        effectiveTemperature: indoorTemp,
    };
}


/***/ },

/***/ "./src/weather/locationMapper.ts"
/*!***************************************!*\
  !*** ./src/weather/locationMapper.ts ***!
  \***************************************/
(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   addToCache: () => (/* binding */ addToCache),
/* harmony export */   findInCache: () => (/* binding */ findInCache),
/* harmony export */   isLikelyRealLocation: () => (/* binding */ isLikelyRealLocation),
/* harmony export */   mapLocation: () => (/* binding */ mapLocation)
/* harmony export */ });
/* harmony import */ var _climateApi__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./climateApi */ "./src/weather/climateApi.ts");
/* harmony import */ var _settings__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../settings */ "./src/settings.ts");
/* harmony import */ var _utils_generator__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../utils/generator */ "./src/utils/generator.ts");
/* harmony import */ var _utils_json__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../utils/json */ "./src/utils/json.ts");
/**
 * Location Mapper
 *
 * Maps fictional/fantasy locations to real-world climate analogs
 * or base climate types.
 */




// ============================================
// Constants
// ============================================
const SYSTEM_PROMPT = 'You are a climate analysis assistant. Return only valid JSON.';
const LOCATION_ANALYSIS_PROMPT = `
Analyze this location for climate mapping.

Location: {{location}}
Context: {{context}}

Determine:
1. Is the LOCATION itself a real Earth location, or fictional/fantasy?
2. If fictional, what real-world city has the most similar climate?
3. If you cannot determine a good real-world equivalent, classify into a base climate type.

CRITICAL: You are classifying the LOCATION, not the characters or story.
- Fictional characters in a real location = isFantasy: FALSE (the location is still real)
- A real location in a fictional story = isFantasy: FALSE (the location is still real)
- Only fictional/fantasy LOCATIONS should be isFantasy: true

Base climate types (use ONLY if no good real-world match):
- temperate: Mild seasons, moderate precipitation (e.g., generic forests, villages)
- desert: Hot/dry, large day/night temperature swings
- arctic: Cold year-round, possible polar day/night cycles
- tropical: Hot/humid, consistent temperatures, possible monsoons
- mediterranean: Warm dry summers, mild wet winters
- continental: Hot summers, cold winters, variable weather
- oceanic: Mild temperatures, frequent rain, small variations

Examples:
- "London" â†’ isFantasy: false (real location)
- "London" (with Doctor Who) â†’ isFantasy: false (London is real regardless of fictional characters)
- "Tokyo" (in an anime) â†’ isFantasy: false (Tokyo is a real city)
- "New York" (with Spider-Man) â†’ isFantasy: false (New York is real)
- "Winterfell" â†’ isFantasy: true, realWorldAnalog: "Reykjavik, Iceland"
- "The Void Dimension" â†’ isFantasy: true, baseClimateType: "arctic" (no good match)
- "Generic fantasy tavern" â†’ isFantasy: true, baseClimateType: "temperate"
- "Tatooine" â†’ isFantasy: true, realWorldAnalog: "Phoenix, Arizona"
- "King's Landing" â†’ isFantasy: true, realWorldAnalog: "Dubrovnik, Croatia"
- "Gotham City" â†’ isFantasy: true, realWorldAnalog: "New York City, USA"

Output JSON:
{
  "isFantasy": true/false,
  "realWorldAnalog": "City, Country" or null,
  "baseClimateType": "temperate" or null,
  "reasoning": "Brief explanation"
}
`;
// Schema for validation (reserved for future use)
const _LOCATION_ANALYSIS_SCHEMA = {
    type: 'object',
    properties: {
        isFantasy: { type: 'boolean' },
        realWorldAnalog: { type: ['string', 'null'] },
        baseClimateType: {
            type: ['string', 'null'],
            enum: [
                'temperate',
                'desert',
                'arctic',
                'tropical',
                'mediterranean',
                'continental',
                'oceanic',
                null,
            ],
        },
        reasoning: { type: 'string' },
    },
    required: ['isFantasy', 'reasoning'],
};
/**
 * Try geocoding with progressively shorter location strings.
 * For "Industrial District, Huntsville, AL", tries:
 * 1. "Industrial District, Huntsville, AL"
 * 2. "Huntsville, AL"
 * 3. "AL"
 */
async function geocodeWithFallback(location) {
    // Split by comma and try progressively shorter versions
    const parts = location.split(',').map(p => p.trim());
    for (let i = 0; i < parts.length; i++) {
        const tryLocation = parts.slice(i).join(', ');
        const coords = await (0,_climateApi__WEBPACK_IMPORTED_MODULE_0__.geocodeLocation)(tryLocation);
        if (coords) {
            return {
                latitude: coords.latitude,
                longitude: coords.longitude,
                usedLocation: tryLocation,
            };
        }
    }
    return null;
}
// ============================================
// Main API
// ============================================
/**
 * Map a location to climate data source
 *
 * Flow:
 * 1. Check cache
 * 2. Ask LLM if fantasy or real
 * 3. If real, try geocoding
 * 4. If fantasy with analog, try geocoding analog
 * 5. If geocoding fails, fall back to base climate type
 */
async function mapLocation(location, context, cache, abortSignal) {
    // Check cache first
    const normalizedLocation = location.toLowerCase().trim();
    const cached = cache.find(m => m.fantasyLocation.toLowerCase().trim() === normalizedLocation);
    if (cached) {
        return cached;
    }
    // Ask LLM to analyze the location
    const analysis = await analyzeLocation(location, context, abortSignal);
    // Handle real locations
    if (!analysis.isFantasy) {
        const coords = await geocodeWithFallback(location);
        if (coords) {
            return {
                fantasyLocation: location,
                realWorldAnalog: coords.usedLocation,
                latitude: coords.latitude,
                longitude: coords.longitude,
                isFantasy: false,
                reasoning: analysis.reasoning,
            };
        }
        // Geocoding failed - treat as fantasy and re-analyze
        console.warn(`[BlazeTracker] Geocoding failed for "${location}", treating as fantasy`);
    }
    // Handle fantasy with real-world analog
    if (analysis.realWorldAnalog) {
        const coords = await (0,_climateApi__WEBPACK_IMPORTED_MODULE_0__.geocodeLocation)(analysis.realWorldAnalog);
        if (coords) {
            return {
                fantasyLocation: location,
                realWorldAnalog: analysis.realWorldAnalog,
                latitude: coords.latitude,
                longitude: coords.longitude,
                isFantasy: true,
                reasoning: analysis.reasoning,
            };
        }
        // Analog geocoding failed - fall through to base climate type
        console.warn(`[BlazeTracker] Geocoding failed for analog "${analysis.realWorldAnalog}"`);
    }
    // Fall back to base climate type
    const baseClimateType = analysis.baseClimateType || 'temperate';
    return {
        fantasyLocation: location,
        baseClimateType: baseClimateType,
        isFantasy: true,
        reasoning: analysis.reasoning || 'Using fallback climate type',
    };
}
/**
 * Quick check if a location is likely real (for optimization)
 */
async function isLikelyRealLocation(location) {
    // Simple heuristics for common real locations
    const realIndicators = [
        /^[A-Z][a-z]+,\s*[A-Z][a-z]+/, // "City, Country" format
        /\b(USA|UK|France|Germany|Japan|China|Australia|Canada)\b/i,
        /\b(New York|London|Paris|Tokyo|Sydney|Toronto)\b/i,
    ];
    const fantasyIndicators = [
        /\b(castle|kingdom|realm|dimension|void|magical|enchanted)\b/i,
        /\b(tavern|inn|guild|dungeon|forest|village)\b/i,
        /'s\s+(lair|tower|fortress|domain)/i,
    ];
    const locationLower = location.toLowerCase();
    // Check fantasy indicators first
    if (fantasyIndicators.some(r => r.test(locationLower))) {
        return false;
    }
    // Check real indicators
    if (realIndicators.some(r => r.test(location))) {
        return true;
    }
    // Uncertain - will need LLM analysis
    return false;
}
async function analyzeLocation(location, context, abortSignal) {
    const settings = (0,_settings__WEBPACK_IMPORTED_MODULE_1__.getSettings)();
    const prompt = LOCATION_ANALYSIS_PROMPT.replace('{{location}}', location).replace('{{context}}', context || 'No additional context');
    const messages = (0,_utils_generator__WEBPACK_IMPORTED_MODULE_2__.buildExtractionMessages)(SYSTEM_PROMPT, prompt);
    try {
        const response = await (0,_utils_generator__WEBPACK_IMPORTED_MODULE_2__.makeGeneratorRequest)(messages, {
            profileId: settings.profileId,
            maxTokens: 500,
            temperature: (0,_settings__WEBPACK_IMPORTED_MODULE_1__.getTemperature)('climate_initial'),
            abortSignal,
        });
        const parsed = (0,_utils_json__WEBPACK_IMPORTED_MODULE_3__.parseJsonResponse)(response, {
            shape: 'object',
            moduleName: 'BlazeTracker/LocationMapper',
        });
        return validateAnalysisResult(parsed);
    }
    catch (error) {
        console.error('[BlazeTracker] Location analysis failed:', error);
        // Return safe default
        return {
            isFantasy: true,
            realWorldAnalog: null,
            baseClimateType: 'temperate',
            reasoning: 'Analysis failed, using default',
        };
    }
}
function validateAnalysisResult(data) {
    if (typeof data !== 'object' || data === null) {
        throw new Error('Invalid location analysis result');
    }
    const obj = data;
    const validBaseTypes = [
        'temperate',
        'desert',
        'arctic',
        'tropical',
        'mediterranean',
        'continental',
        'oceanic',
    ];
    return {
        isFantasy: typeof obj.isFantasy === 'boolean' ? obj.isFantasy : true,
        realWorldAnalog: typeof obj.realWorldAnalog === 'string' ? obj.realWorldAnalog : null,
        baseClimateType: typeof obj.baseClimateType === 'string' &&
            validBaseTypes.includes(obj.baseClimateType)
            ? obj.baseClimateType
            : null,
        reasoning: typeof obj.reasoning === 'string' ? obj.reasoning : 'No reasoning provided',
    };
}
// ============================================
// Cache Management
// ============================================
/**
 * Add a mapping to the cache
 */
function addToCache(cache, mapping) {
    const normalizedLocation = mapping.fantasyLocation.toLowerCase().trim();
    // Remove existing entry if present
    const filtered = cache.filter(m => m.fantasyLocation.toLowerCase().trim() !== normalizedLocation);
    return [...filtered, mapping];
}
/**
 * Find a mapping in the cache
 */
function findInCache(cache, location) {
    const normalizedLocation = location.toLowerCase().trim();
    return cache.find(m => m.fantasyLocation.toLowerCase().trim() === normalizedLocation);
}


/***/ },

/***/ "./src/weather/weatherDeriver.ts"
/*!***************************************!*\
  !*** ./src/weather/weatherDeriver.ts ***!
  \***************************************/
(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   calculateFeelsLike: () => (/* binding */ calculateFeelsLike),
/* harmony export */   deriveCondition: () => (/* binding */ deriveCondition),
/* harmony export */   describeCondition: () => (/* binding */ describeCondition),
/* harmony export */   getDaylightPhase: () => (/* binding */ getDaylightPhase),
/* harmony export */   getDominantCondition: () => (/* binding */ getDominantCondition),
/* harmony export */   getWindDirection: () => (/* binding */ getWindDirection),
/* harmony export */   mapLegacyWeather: () => (/* binding */ mapLegacyWeather),
/* harmony export */   toLegacyWeather: () => (/* binding */ toLegacyWeather)
/* harmony export */ });
/**
 * Weather Deriver
 *
 * Derives human-readable weather conditions from meteorological metrics.
 * All temperatures in Fahrenheit, wind in mph, precipitation in inches.
 */
// ============================================
// Condition Derivation
// ============================================
/**
 * Derive weather condition from hourly metrics
 */
function deriveCondition(weather) {
    const { temperature, precipitation, humidity, windSpeed, cloudCover } = weather;
    // Precipitation takes priority (precipitation in inches)
    if (precipitation > 0.02) {
        // Snow vs rain (temperature in Â°F)
        if (temperature <= 32) {
            if (windSpeed > 25 && precipitation > 0.2)
                return 'blizzard';
            if (precipitation > 0.2)
                return 'heavy_snow';
            return 'snow';
        }
        if (temperature <= 35)
            return 'sleet';
        // Rain intensity
        if (precipitation > 0.4)
            return 'heavy_rain';
        if (precipitation > 0.2 && windSpeed > 20)
            return 'thunderstorm';
        if (precipitation > 0.08)
            return 'rain';
        return 'drizzle';
    }
    // Fog (high humidity, low wind, near dew point)
    if (humidity > 95 && windSpeed < 6 && cloudCover > 80) {
        return 'foggy';
    }
    // Wind (mph)
    if (windSpeed > 30)
        return 'windy';
    // Cloud cover
    if (cloudCover > 85)
        return 'overcast';
    if (cloudCover > 50)
        return 'partly_cloudy';
    // Temperature extremes (Â°F)
    if (temperature > 95)
        return 'hot';
    if (temperature < 14)
        return 'cold';
    // Humidity extreme
    if (humidity > 85 && temperature > 75)
        return 'humid';
    // Default clear conditions
    return cloudCover < 20 ? 'sunny' : 'clear';
}
// ============================================
// Condition Descriptions
// ============================================
const CONDITION_DESCRIPTIONS = {
    clear: ['clear skies', 'pleasant weather', 'calm conditions'],
    sunny: ['bright sunshine', 'sunny skies', 'brilliant sun'],
    partly_cloudy: ['scattered clouds', 'partly cloudy', 'intermittent sunshine'],
    overcast: ['gray skies', 'heavy cloud cover', 'overcast'],
    foggy: ['thick fog', 'misty conditions', 'fog rolling in'],
    drizzle: ['light drizzle', 'misting rain', 'gentle rain'],
    rain: ['steady rain', 'rainfall', 'rainy weather'],
    heavy_rain: ['heavy rain', 'downpour', 'torrential rain'],
    thunderstorm: ['thunderstorm', 'thunder and lightning', 'electrical storm'],
    sleet: ['freezing rain', 'sleet', 'icy precipitation'],
    snow: ['snowfall', 'snow flurries', 'snowing'],
    heavy_snow: ['heavy snowfall', 'blanketing snow', 'intense snow'],
    blizzard: ['blizzard conditions', 'whiteout', 'severe blizzard'],
    windy: ['strong winds', 'gusty conditions', 'blustery weather'],
    hot: ['scorching heat', 'oppressive heat', 'sweltering'],
    cold: ['bitter cold', 'freezing temperatures', 'frigid air'],
    humid: ['muggy conditions', 'humid air', 'sticky weather'],
};
/**
 * Get a human-readable description of the condition
 */
function describeCondition(condition, rng) {
    const options = CONDITION_DESCRIPTIONS[condition] || ['moderate weather'];
    const random = rng ? rng() : Math.random();
    return options[Math.floor(random * options.length)];
}
// ============================================
// Wind Direction
// ============================================
const WIND_DIRECTIONS = [
    'N',
    'NNE',
    'NE',
    'ENE',
    'E',
    'ESE',
    'SE',
    'SSE',
    'S',
    'SSW',
    'SW',
    'WSW',
    'W',
    'WNW',
    'NW',
    'NNW',
];
/**
 * Convert wind direction degrees to compass direction
 */
function getWindDirection(degrees) {
    const index = Math.round(degrees / 22.5) % 16;
    return WIND_DIRECTIONS[index];
}
// ============================================
// Daylight Phase
// ============================================
/**
 * Determine daylight phase based on current hour and sun times
 */
function getDaylightPhase(hour, sunrise, sunset) {
    // Dawn: 30 min before to 30 min after sunrise
    if (hour >= sunrise - 0.5 && hour < sunrise + 0.5)
        return 'dawn';
    // Day: after dawn until 30 min before sunset
    if (hour >= sunrise + 0.5 && hour < sunset - 0.5)
        return 'day';
    // Dusk: 30 min before to 30 min after sunset
    if (hour >= sunset - 0.5 && hour < sunset + 0.5)
        return 'dusk';
    // Night: everything else
    return 'night';
}
// ============================================
// Feels Like Temperature
// ============================================
/**
 * Calculate "feels like" temperature (wind chill / heat index)
 * Uses Fahrenheit
 */
function calculateFeelsLike(temperature, humidity, windSpeed) {
    // Wind chill (for cold temperatures)
    if (temperature <= 50 && windSpeed > 3) {
        // NWS Wind Chill formula
        const windChill = 35.74 +
            0.6215 * temperature -
            35.75 * Math.pow(windSpeed, 0.16) +
            0.4275 * temperature * Math.pow(windSpeed, 0.16);
        return Math.round(windChill);
    }
    // Heat index (for hot temperatures)
    if (temperature >= 80 && humidity >= 40) {
        // Simplified Rothfusz regression
        const hi = -42.379 +
            2.04901523 * temperature +
            10.14333127 * humidity -
            0.22475541 * temperature * humidity -
            0.00683783 * temperature * temperature -
            0.05481717 * humidity * humidity +
            0.00122874 * temperature * temperature * humidity +
            0.00085282 * temperature * humidity * humidity -
            0.00000199 * temperature * temperature * humidity * humidity;
        return Math.round(hi);
    }
    // No adjustment needed
    return Math.round(temperature);
}
// ============================================
// Dominant Condition for Day
// ============================================
/**
 * Determine the dominant weather condition for a day
 * based on hourly conditions (weighted toward daytime hours)
 */
function getDominantCondition(hourlyConditions, sunrise, sunset) {
    const counts = {};
    hourlyConditions.forEach((condition, hour) => {
        // Weight daytime hours more heavily
        const isDaytime = hour >= Math.floor(sunrise) && hour <= Math.ceil(sunset);
        const weight = isDaytime ? 2 : 1;
        counts[condition] = (counts[condition] || 0) + weight;
    });
    // Find condition with highest count
    let dominant = 'clear';
    let maxCount = 0;
    for (const [condition, count] of Object.entries(counts)) {
        if (count > maxCount) {
            maxCount = count;
            dominant = condition;
        }
    }
    return dominant;
}
// ============================================
// Legacy Condition Mapping
// ============================================
/**
 * Map legacy weather types to new WeatherCondition
 */
function mapLegacyWeather(legacyWeather) {
    const mapping = {
        sunny: 'sunny',
        cloudy: 'overcast',
        snowy: 'snow',
        rainy: 'rain',
        windy: 'windy',
        thunderstorm: 'thunderstorm',
    };
    return mapping[legacyWeather.toLowerCase()] || 'clear';
}
/**
 * Map new WeatherCondition back to legacy weather type (for display compatibility)
 */
function toLegacyWeather(condition) {
    switch (condition) {
        case 'sunny':
        case 'clear':
        case 'hot':
            return 'sunny';
        case 'partly_cloudy':
        case 'overcast':
        case 'foggy':
        case 'humid':
            return 'cloudy';
        case 'snow':
        case 'heavy_snow':
        case 'blizzard':
        case 'sleet':
        case 'cold':
            return 'snowy';
        case 'drizzle':
        case 'rain':
        case 'heavy_rain':
            return 'rainy';
        case 'windy':
            return 'windy';
        case 'thunderstorm':
            return 'thunderstorm';
        default:
            return 'sunny';
    }
}


/***/ },

/***/ "./src/weather/weatherTransitions.ts"
/*!*******************************************!*\
  !*** ./src/weather/weatherTransitions.ts ***!
  \*******************************************/
(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   generateTransitionInjection: () => (/* binding */ generateTransitionInjection),
/* harmony export */   getTransitionText: () => (/* binding */ getTransitionText),
/* harmony export */   shouldMentionTransition: () => (/* binding */ shouldMentionTransition)
/* harmony export */ });
/**
 * Weather Transitions
 *
 * Generates narrative text when weather changes significantly.
 */
const TRANSITIONS = [
    // Clear to precipitation
    {
        from: 'clear',
        to: 'overcast',
        templates: [
            'Clouds drift across the sky, dimming the light',
            'The sky grows gray as clouds gather overhead',
            'A blanket of clouds slowly obscures the sun',
        ],
    },
    {
        from: 'sunny',
        to: 'overcast',
        templates: [
            'The bright sunshine fades as clouds roll in',
            'Dark clouds begin to gather, blocking out the sun',
            'The sunny skies give way to gathering clouds',
        ],
    },
    {
        from: 'overcast',
        to: 'rain',
        templates: [
            'The first drops of rain begin to fall',
            'Rain starts to patter down from the gray sky',
            'The clouds finally release their burden as rain begins',
        ],
    },
    {
        from: 'clear',
        to: 'rain',
        templates: [
            'Dark clouds roll in quickly, and rain begins to fall',
            'The weather turns suddenly as rain sweeps across the area',
        ],
    },
    {
        from: 'partly_cloudy',
        to: 'rain',
        templates: [
            'The scattered clouds thicken and rain begins to fall',
            'What started as a few clouds has turned to steady rain',
        ],
    },
    {
        from: 'rain',
        to: 'heavy_rain',
        templates: [
            'The rain intensifies into a downpour',
            'The steady rain becomes a torrential downpour',
        ],
    },
    {
        from: 'rain',
        to: 'thunderstorm',
        templates: [
            'Thunder rumbles in the distance as the rain intensifies',
            'Lightning flashes across the sky as the storm picks up',
            'The rain turns to a full thunderstorm',
        ],
    },
    {
        from: 'rain',
        to: 'snow',
        templates: [
            'The rain turns to sleet, then thick snowflakes',
            'As the temperature drops, the rain becomes snow',
        ],
    },
    // Precipitation clearing
    {
        from: 'rain',
        to: 'clear',
        templates: [
            'The rain tapers off as patches of blue appear',
            'The clouds part and sunlight breaks through',
            'The storm passes, leaving fresh air in its wake',
        ],
    },
    {
        from: 'rain',
        to: 'partly_cloudy',
        templates: [
            'The rain stops, leaving behind scattered clouds',
            'The precipitation ends but clouds remain',
        ],
    },
    {
        from: 'heavy_rain',
        to: 'rain',
        templates: [
            'The downpour eases to a steady rain',
            'The torrential rain lessens somewhat',
        ],
    },
    {
        from: 'thunderstorm',
        to: 'rain',
        templates: [
            'The thunder fades into the distance, leaving just rain',
            'The storm passes but the rain continues',
        ],
    },
    {
        from: 'snow',
        to: 'clear',
        templates: [
            'The snowfall gradually stops, revealing clear skies',
            'The last snowflakes drift down as the clouds disperse',
        ],
    },
    {
        from: 'heavy_snow',
        to: 'snow',
        templates: [
            'The heavy snowfall eases to light flurries',
            'The blanketing snow becomes a gentler fall',
        ],
    },
    {
        from: 'blizzard',
        to: 'snow',
        templates: [
            'The blizzard conditions ease, though snow continues',
            'The whiteout conditions clear somewhat',
        ],
    },
    // Temperature-related
    {
        from: 'clear',
        to: 'hot',
        templates: [
            'The heat intensifies as the sun beats down',
            'A wave of oppressive heat settles in',
            'The temperature climbs to sweltering levels',
        ],
    },
    {
        from: 'hot',
        to: 'clear',
        templates: [
            'The oppressive heat begins to ease',
            'The temperature becomes more bearable',
        ],
    },
    {
        from: 'clear',
        to: 'cold',
        templates: [
            'A bitter chill settles over the area',
            'The temperature plummets as a cold front moves in',
            'An icy wind brings freezing temperatures',
        ],
    },
    {
        from: 'cold',
        to: 'clear',
        templates: [
            'The bitter cold begins to moderate',
            'The freezing temperatures ease somewhat',
        ],
    },
    // Fog
    {
        from: 'clear',
        to: 'foggy',
        templates: [
            'A thick fog rolls in, obscuring visibility',
            'Mist begins to gather, shrouding the surroundings',
        ],
    },
    {
        from: 'foggy',
        to: 'clear',
        templates: [
            'The fog begins to lift, revealing the surroundings',
            'The mist burns off as visibility improves',
        ],
    },
    // Wind
    {
        from: 'clear',
        to: 'windy',
        templates: [
            'Strong winds pick up, rustling through everything',
            'Gusts of wind begin to sweep across the area',
        ],
    },
    {
        from: 'windy',
        to: 'clear',
        templates: [
            'The strong winds die down to a gentle breeze',
            'The gusts subside and calm returns',
        ],
    },
];
// ============================================
// Transition Detection
// ============================================
/**
 * Determine if a weather transition is significant enough to mention
 */
function shouldMentionTransition(prevClimate, newClimate) {
    // Condition type changed
    if (prevClimate.conditionType !== newClimate.conditionType) {
        // Some transitions are minor (e.g., clear to sunny)
        const minorTransitions = [
            ['clear', 'sunny'],
            ['sunny', 'clear'],
            ['partly_cloudy', 'overcast'],
            ['overcast', 'partly_cloudy'],
        ];
        const isMinor = minorTransitions.some(([from, to]) => (prevClimate.conditionType === from &&
            newClimate.conditionType === to) ||
            (prevClimate.conditionType === to &&
                newClimate.conditionType === from));
        if (!isMinor) {
            return true;
        }
    }
    // Large temperature change (>10Â°F)
    if (Math.abs(prevClimate.temperature - newClimate.temperature) > 10) {
        return true;
    }
    // Precipitation started/stopped
    const wasRaining = prevClimate.precipitation > 0.02;
    const isRaining = newClimate.precipitation > 0.02;
    if (wasRaining !== isRaining) {
        return true;
    }
    // Significant wind change
    if (Math.abs(prevClimate.windSpeed - newClimate.windSpeed) > 15 &&
        (prevClimate.windSpeed > 20 || newClimate.windSpeed > 20)) {
        return true;
    }
    return false;
}
// ============================================
// Transition Text Generation
// ============================================
/**
 * Get transition text for a weather change
 */
function getTransitionText(from, to, tempChange) {
    // Find matching transition
    const transition = TRANSITIONS.find(t => t.from === from && t.to === to);
    if (transition) {
        const templates = transition.templates;
        return templates[Math.floor(Math.random() * templates.length)];
    }
    // Try reverse direction with modified text
    const reverseTransition = TRANSITIONS.find(t => t.from === to && t.to === from);
    if (reverseTransition) {
        // Use a generic transition for the reverse
        const conditions = formatCondition(to);
        return `The weather shifts to ${conditions}`;
    }
    // Generic fallback for unmapped transitions
    if (from !== to) {
        const fromStr = formatCondition(from);
        const toStr = formatCondition(to);
        return `The weather changes from ${fromStr} to ${toStr}`;
    }
    // Temperature-only change
    if (tempChange && Math.abs(tempChange) > 10) {
        if (tempChange > 0) {
            return 'The air grows noticeably warmer';
        }
        else {
            return 'A distinct chill creeps into the air';
        }
    }
    return null; // No significant change
}
/**
 * Format a condition for display
 */
function formatCondition(condition) {
    return condition.replace(/_/g, ' ');
}
// ============================================
// Full Transition Description
// ============================================
/**
 * Generate a complete transition description for injection
 */
function generateTransitionInjection(prevClimate, newClimate) {
    if (!shouldMentionTransition(prevClimate, newClimate)) {
        return null;
    }
    const tempChange = newClimate.temperature - prevClimate.temperature;
    const transitionText = getTransitionText(prevClimate.conditionType, newClimate.conditionType, tempChange);
    return transitionText;
}


/***/ },

/***/ "?d4c0"
/*!************************!*\
  !*** crypto (ignored) ***!
  \************************/
() {

/* (ignored) */

/***/ }

/******/ });
/************************************************************************/
/******/ // The module cache
/******/ var __webpack_module_cache__ = {};
/******/ 
/******/ // The require function
/******/ function __webpack_require__(moduleId) {
/******/ 	// Check if module is in cache
/******/ 	var cachedModule = __webpack_module_cache__[moduleId];
/******/ 	if (cachedModule !== undefined) {
/******/ 		return cachedModule.exports;
/******/ 	}
/******/ 	// Check if module exists (development only)
/******/ 	if (__webpack_modules__[moduleId] === undefined) {
/******/ 		var e = new Error("Cannot find module '" + moduleId + "'");
/******/ 		e.code = 'MODULE_NOT_FOUND';
/******/ 		throw e;
/******/ 	}
/******/ 	// Create a new module (and put it into the cache)
/******/ 	var module = __webpack_module_cache__[moduleId] = {
/******/ 		id: moduleId,
/******/ 		loaded: false,
/******/ 		exports: {}
/******/ 	};
/******/ 
/******/ 	// Execute the module function
/******/ 	__webpack_modules__[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/ 
/******/ 	// Flag the module as loaded
/******/ 	module.loaded = true;
/******/ 
/******/ 	// Return the exports of the module
/******/ 	return module.exports;
/******/ }
/******/ 
/******/ // expose the modules object (__webpack_modules__)
/******/ __webpack_require__.m = __webpack_modules__;
/******/ 
/************************************************************************/
/******/ /* webpack/runtime/amd define */
/******/ (() => {
/******/ 	__webpack_require__.amdD = function () {
/******/ 		throw new Error('define cannot be used indirect');
/******/ 	};
/******/ })();
/******/ 
/******/ /* webpack/runtime/amd options */
/******/ (() => {
/******/ 	__webpack_require__.amdO = {};
/******/ })();
/******/ 
/******/ /* webpack/runtime/compat get default export */
/******/ (() => {
/******/ 	// getDefaultExport function for compatibility with non-harmony modules
/******/ 	__webpack_require__.n = (module) => {
/******/ 		var getter = module && module.__esModule ?
/******/ 			() => (module['default']) :
/******/ 			() => (module);
/******/ 		__webpack_require__.d(getter, { a: getter });
/******/ 		return getter;
/******/ 	};
/******/ })();
/******/ 
/******/ /* webpack/runtime/define property getters */
/******/ (() => {
/******/ 	// define getter functions for harmony exports
/******/ 	__webpack_require__.d = (exports, definition) => {
/******/ 		for(var key in definition) {
/******/ 			if(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {
/******/ 				Object.defineProperty(exports, key, { enumerable: true, get: definition[key] });
/******/ 			}
/******/ 		}
/******/ 	};
/******/ })();
/******/ 
/******/ /* webpack/runtime/hasOwnProperty shorthand */
/******/ (() => {
/******/ 	__webpack_require__.o = (obj, prop) => (Object.prototype.hasOwnProperty.call(obj, prop))
/******/ })();
/******/ 
/******/ /* webpack/runtime/make namespace object */
/******/ (() => {
/******/ 	// define __esModule on exports
/******/ 	__webpack_require__.r = (exports) => {
/******/ 		if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 			Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 		}
/******/ 		Object.defineProperty(exports, '__esModule', { value: true });
/******/ 	};
/******/ })();
/******/ 
/******/ /* webpack/runtime/node module decorator */
/******/ (() => {
/******/ 	__webpack_require__.nmd = (module) => {
/******/ 		module.paths = [];
/******/ 		if (!module.children) module.children = [];
/******/ 		return module;
/******/ 	};
/******/ })();
/******/ 
/******/ /* webpack/runtime/publicPath */
/******/ (() => {
/******/ 	var scriptUrl;
/******/ 	if (typeof import.meta.url === "string") scriptUrl = import.meta.url
/******/ 	// When supporting browsers where an automatic publicPath is not supported you must specify an output.publicPath manually via configuration
/******/ 	// or pass an empty string ("") and set the __webpack_public_path__ variable from your code to use your own logic.
/******/ 	if (!scriptUrl) throw new Error("Automatic publicPath is not supported in this browser");
/******/ 	scriptUrl = scriptUrl.replace(/^blob:/, "").replace(/#.*$/, "").replace(/\?.*$/, "").replace(/\/[^\/]+$/, "/");
/******/ 	__webpack_require__.p = scriptUrl;
/******/ })();
/******/ 
/******/ /* webpack/runtime/import chunk loading */
/******/ (() => {
/******/ 	__webpack_require__.b = new URL("./", import.meta.url);
/******/ 	
/******/ 	// object to store loaded and loading chunks
/******/ 	// undefined = chunk not loaded, null = chunk preloaded/prefetched
/******/ 	// [resolve, Promise] = chunk loading, 0 = chunk loaded
/******/ 	var installedChunks = {
/******/ 		"main": 0
/******/ 	};
/******/ 	
/******/ 	// no install chunk
/******/ 	
/******/ 	// no chunk on demand loading
/******/ 	
/******/ 	// no prefetching
/******/ 	
/******/ 	// no preloaded
/******/ 	
/******/ 	// no external install chunk
/******/ 	
/******/ 	// no on chunks loaded
/******/ 	// no HMR
/******/ 	
/******/ 	// no HMR manifest
/******/ })();
/******/ 
/************************************************************************/
var __webpack_exports__ = {};
// This entry needs to be wrapped in an IIFE because it needs to be isolated against other modules in the chunk.
(() => {
/*!**********************!*\
  !*** ./src/index.ts ***!
  \**********************/
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _extractors_extractState__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./extractors/extractState */ "./src/extractors/extractState.ts");
/* harmony import */ var _ui_settingsUI__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./ui/settingsUI */ "./src/ui/settingsUI.tsx");
/* harmony import */ var _ui_stateDisplay__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./ui/stateDisplay */ "./src/ui/stateDisplay.tsx");
/* harmony import */ var _settings__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./settings */ "./src/settings.ts");
/* harmony import */ var _injectors_injectState__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./injectors/injectState */ "./src/injectors/injectState.ts");
/* harmony import */ var _constants__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./constants */ "./src/constants.ts");
/* harmony import */ var _utils_messageState__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./utils/messageState */ "./src/utils/messageState.ts");
/* harmony import */ var _migrations_migrateOldTime__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./migrations/migrateOldTime */ "./src/migrations/migrateOldTime.ts");
/* harmony import */ var _commands_slashCommands__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ./commands/slashCommands */ "./src/commands/slashCommands.ts");
/* harmony import */ var _state_narrativeState__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ./state/narrativeState */ "./src/state/narrativeState.ts");
/* harmony import */ var sillytavern_utils_lib_config__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! sillytavern-utils-lib/config */ "./node_modules/sillytavern-utils-lib/dist/config.js");











function log(..._args) {
    // Logging disabled for production
}
/**
 * Check if chat has legacy BlazeTracker data without narrative state.
 * This indicates the ancient format that needs full re-extraction.
 */
function hasLegacyDataWithoutNarrativeState(context) {
    // If there's already a narrative state, we're good
    const narrativeState = (0,_state_narrativeState__WEBPACK_IMPORTED_MODULE_9__.getNarrativeState)();
    if (narrativeState) {
        return false;
    }
    // Check if any messages have old BlazeTracker data
    for (const message of context.chat) {
        if (message.extra?.[_constants__WEBPACK_IMPORTED_MODULE_5__.EXTENSION_KEY]) {
            return true;
        }
    }
    return false;
}
/**
 * Show popup offering migration options when legacy data is detected.
 */
async function showLegacyDataPopup(context) {
    return new Promise(resolve => {
        const container = document.createElement('div');
        container.innerHTML = `
			<div style="padding: 10px;">
				<p style="margin-bottom: 15px;">
					<strong>ðŸ”¥ BlazeTracker: Outdated Data Detected</strong>
				</p>
				<p style="margin-bottom: 15px;">
					This chat has tracker data from an older version that is no longer compatible.
				</p>
				<div style="display: flex; flex-direction: column; gap: 10px;">
					<button id="bt-migrate-all" class="menu_button" style="padding: 10px; width: 100%;">
						<strong>Re-extract All State</strong> (slow, accurate)
						<br><small>Rebuild state for every message. Best for important chats.</small>
					</button>
					<button id="bt-migrate-recent" class="menu_button" style="padding: 10px; width: 100%;">
						<strong>Re-extract Recent State</strong> (fast)
						<br><small>Only extract the latest message. Good enough for most cases.</small>
					</button>
					<button id="bt-migrate-empty" class="menu_button" style="padding: 10px; width: 100%;">
						<strong>Initialize Empty State</strong>
						<br><small style="color: #f59e0b;">âš ï¸ Discards old data. State will build from new messages.</small>
					</button>
				</div>
			</div>
		`;
        // Show as TEXT popup (no buttons) - we provide our own
        context.callGenericPopup(container, context.POPUP_TYPE.TEXT, null, {
            wide: true,
        });
        // Wire up button handlers
        const handleMigrateAll = async () => {
            cleanup();
            log('User chose to re-extract all messages');
            (0,sillytavern_utils_lib_config__WEBPACK_IMPORTED_MODULE_10__.st_echo)?.('info', 'ðŸ”¥ Starting full re-extraction...');
            const state = (0,_state_narrativeState__WEBPACK_IMPORTED_MODULE_9__.initializeNarrativeState)();
            (0,_state_narrativeState__WEBPACK_IMPORTED_MODULE_9__.setNarrativeState)(state);
            clearAllPerMessageState(context);
            await context.saveChat();
            const { extracted, failed } = await (0,_commands_slashCommands__WEBPACK_IMPORTED_MODULE_8__.runExtractAll)();
            (0,sillytavern_utils_lib_config__WEBPACK_IMPORTED_MODULE_10__.st_echo)?.('success', `ðŸ”¥ Re-extraction complete: ${extracted} extracted, ${failed} failed`);
            resolve();
        };
        const handleMigrateRecent = async () => {
            cleanup();
            log('User chose to re-extract recent message only');
            (0,sillytavern_utils_lib_config__WEBPACK_IMPORTED_MODULE_10__.st_echo)?.('info', 'ðŸ”¥ Re-extracting recent state...');
            const state = (0,_state_narrativeState__WEBPACK_IMPORTED_MODULE_9__.initializeNarrativeState)();
            (0,_state_narrativeState__WEBPACK_IMPORTED_MODULE_9__.setNarrativeState)(state);
            clearAllPerMessageState(context);
            await context.saveChat();
            // Just extract the most recent message
            const lastMessageId = context.chat.length - 1;
            if (lastMessageId > 0) {
                await (0,_ui_stateDisplay__WEBPACK_IMPORTED_MODULE_2__.doExtractState)(lastMessageId);
            }
            (0,_ui_stateDisplay__WEBPACK_IMPORTED_MODULE_2__.renderAllStates)();
            (0,sillytavern_utils_lib_config__WEBPACK_IMPORTED_MODULE_10__.st_echo)?.('success', 'ðŸ”¥ Recent state extracted');
            resolve();
        };
        const handleMigrateEmpty = async () => {
            cleanup();
            log('User chose to initialize empty state');
            const state = (0,_state_narrativeState__WEBPACK_IMPORTED_MODULE_9__.initializeNarrativeState)();
            (0,_state_narrativeState__WEBPACK_IMPORTED_MODULE_9__.setNarrativeState)(state);
            // Don't clear per-message state - just let it be ignored
            await context.saveChat();
            (0,_ui_stateDisplay__WEBPACK_IMPORTED_MODULE_2__.renderAllStates)();
            (0,sillytavern_utils_lib_config__WEBPACK_IMPORTED_MODULE_10__.st_echo)?.('info', 'ðŸ”¥ Initialized with empty state');
            resolve();
        };
        const cleanup = () => {
            // Close the popup
            document.querySelector('.popup-button-ok')?.click();
        };
        // Add event listeners after a tick to ensure DOM is ready
        setTimeout(() => {
            document.getElementById('bt-migrate-all')?.addEventListener('click', handleMigrateAll);
            document.getElementById('bt-migrate-recent')?.addEventListener('click', handleMigrateRecent);
            document.getElementById('bt-migrate-empty')?.addEventListener('click', handleMigrateEmpty);
        }, 0);
    });
}
/**
 * Clear all per-message BlazeTracker state.
 */
function clearAllPerMessageState(context) {
    for (let i = 0; i < context.chat.length; i++) {
        const message = context.chat[i];
        if (message.extra && message.extra[_constants__WEBPACK_IMPORTED_MODULE_5__.EXTENSION_KEY]) {
            delete message.extra[_constants__WEBPACK_IMPORTED_MODULE_5__.EXTENSION_KEY];
        }
    }
}
async function init() {
    const context = SillyTavern.getContext();
    // Inject CSS first
    (0,_ui_stateDisplay__WEBPACK_IMPORTED_MODULE_2__.injectStyles)();
    // Initialize settings
    await _settings__WEBPACK_IMPORTED_MODULE_3__.settingsManager.initializeSettings();
    await (0,_ui_settingsUI__WEBPACK_IMPORTED_MODULE_1__.initSettingsUI)();
    // Initialize state display (handles chat change)
    (0,_ui_stateDisplay__WEBPACK_IMPORTED_MODULE_2__.initStateDisplay)();
    (0,_extractors_extractState__WEBPACK_IMPORTED_MODULE_0__.setupExtractionAbortHandler)();
    // Register slash commands
    (0,_commands_slashCommands__WEBPACK_IMPORTED_MODULE_8__.registerSlashCommands)();
    const settings = (0,_settings__WEBPACK_IMPORTED_MODULE_3__.getSettings)();
    const autoExtractResponses = settings.autoMode === 'responses' || settings.autoMode === 'both';
    const autoExtractInputs = settings.autoMode === 'inputs' || settings.autoMode === 'both';
    // Hook user messages
    context.eventSource.on(context.event_types.USER_MESSAGE_RENDERED, (async (messageId) => {
        if (autoExtractInputs) {
            log('Auto-extracting for user message:', messageId);
            await (0,_ui_stateDisplay__WEBPACK_IMPORTED_MODULE_2__.doExtractState)(messageId);
            (0,_injectors_injectState__WEBPACK_IMPORTED_MODULE_4__.updateInjectionFromChat)();
        }
        else {
            // Just render existing state (or nothing)
            setTimeout(() => (0,_ui_stateDisplay__WEBPACK_IMPORTED_MODULE_2__.renderMessageState)(messageId), 100);
        }
    }));
    // Re-extract on message edit
    context.eventSource.on(context.event_types.MESSAGE_EDITED, (async (messageId) => {
        const lastIndex = context.chat.length - 1;
        // Only re-extract if editing one of the last 2 messages
        if (messageId >= lastIndex - 1 && messageId !== 0) {
            if (autoExtractResponses || autoExtractInputs) {
                log('Re-extracting for edited message:', messageId);
                await (0,_ui_stateDisplay__WEBPACK_IMPORTED_MODULE_2__.doExtractState)(messageId);
            }
        }
    }));
    // Re-render all on generation end (to catch any we missed)
    if (autoExtractResponses) {
        // This ensures the message is fully rendered and DOM is stable
        context.eventSource.on(context.event_types.GENERATION_ENDED, (async (_messageId) => {
            // Yield to microtask queue - ensures any synchronous
            // GENERATION_STOPPED handlers complete first
            await Promise.resolve();
            // Skip extraction if the generation was aborted
            if ((0,_extractors_extractState__WEBPACK_IMPORTED_MODULE_0__.wasGenerationAborted)()) {
                log('Generation was aborted, skipping extraction');
                return;
            }
            // Skip if batch extraction is in progress (bt-extract-all)
            if ((0,_extractors_extractState__WEBPACK_IMPORTED_MODULE_0__.isBatchExtractionInProgress)()) {
                log('Batch extraction in progress, skipping auto-extraction');
                return;
            }
            // Skip if manual extraction is in progress (fire button, slash command)
            if ((0,_ui_stateDisplay__WEBPACK_IMPORTED_MODULE_2__.isManualExtractionInProgress)()) {
                log('Manual extraction in progress, skipping auto-extraction');
                return;
            }
            // messageId might not be passed, get the last message
            const stContext = SillyTavern.getContext();
            const lastMessageId = stContext.chat.length - 1;
            if (lastMessageId <= 0)
                return;
            const message = stContext.chat[lastMessageId];
            // Only extract for AI messages
            if (message.is_user)
                return;
            log('Auto-extracting for completed generation:', lastMessageId);
            await (0,_ui_stateDisplay__WEBPACK_IMPORTED_MODULE_2__.doExtractState)(lastMessageId);
        }));
    }
    // Update injection on chat change
    context.eventSource.on(context.event_types.CHAT_CHANGED, (async () => {
        const ctx = SillyTavern.getContext();
        const settings = (0,_settings__WEBPACK_IMPORTED_MODULE_3__.getSettings)();
        // Check for ancient legacy data that needs full re-extraction
        if (hasLegacyDataWithoutNarrativeState(ctx)) {
            log('Detected legacy BlazeTracker data without narrative state');
            // Show popup - don't await, let it run in background
            showLegacyDataPopup(ctx);
        }
        else {
            // Ensure narrative state is migrated to latest version
            (0,_state_narrativeState__WEBPACK_IMPORTED_MODULE_9__.getOrInitializeNarrativeState)();
        }
        // Run time format migration
        if (settings.profileId) {
            await (0,_migrations_migrateOldTime__WEBPACK_IMPORTED_MODULE_7__.migrateOldTimeFormats)(ctx, settings.profileId);
        }
        setTimeout(() => {
            (0,_ui_stateDisplay__WEBPACK_IMPORTED_MODULE_2__.renderAllStates)();
            (0,_injectors_injectState__WEBPACK_IMPORTED_MODULE_4__.updateInjectionFromChat)();
        }, 100);
    }));
    const handleSwipe = async (messageId) => {
        log('Swipe detected for message:', messageId);
        const stContext = SillyTavern.getContext();
        const message = stContext.chat[messageId];
        const existingState = (0,_utils_messageState__WEBPACK_IMPORTED_MODULE_6__.getMessageState)(message);
        if (existingState) {
            // This swipe already has state, render it
            log('State exists for this swipe');
            (0,_ui_stateDisplay__WEBPACK_IMPORTED_MODULE_2__.renderMessageState)(messageId, existingState);
        }
        else {
            // No state - either new generation in progress or old unextracted swipe
            // Don't auto-extract here - could be mid-generation with wrong content
            // GENERATION_ENDED will handle new generations
            // User can manually extract old swipes if needed
            (0,_ui_stateDisplay__WEBPACK_IMPORTED_MODULE_2__.renderMessageState)(messageId, null);
        }
        (0,_injectors_injectState__WEBPACK_IMPORTED_MODULE_4__.updateInjectionFromChat)();
    };
    // Try MESSAGE_SWIPED event
    if (context.event_types.MESSAGE_SWIPED) {
        context.eventSource.on(context.event_types.MESSAGE_SWIPED, (async (data) => {
            // Event data format varies: could be number, { message }, { messageId }, { id }
            const messageId = typeof data === 'number'
                ? data
                : (data?.message ?? data?.messageId ?? data?.id);
            if (typeof messageId === 'number') {
                // Small delay to let ST update the swipe data
                setTimeout(() => handleSwipe(messageId), 50);
            }
        }));
        log('MESSAGE_SWIPED handler registered');
    }
    // Try SWIPE_CHANGED event (alternate name)
    if (context.event_types.SWIPE_CHANGED) {
        context.eventSource.on(context.event_types.SWIPE_CHANGED, (async (data) => {
            const messageId = typeof data === 'number'
                ? data
                : (data?.message ?? data?.messageId ?? data?.id);
            if (typeof messageId === 'number') {
                setTimeout(() => handleSwipe(messageId), 50);
            }
        }));
        log('SWIPE_CHANGED handler registered');
    }
    log('Event hooks registered.');
}
// Wait for DOM/ST to be ready
if (document.readyState === 'loading') {
    document.addEventListener('DOMContentLoaded', init);
}
else {
    init();
}

})();


//# sourceMappingURL=index.js.map